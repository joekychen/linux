<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kvm › vmx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vmx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Kernel-based Virtual Machine driver for Linux</span>
<span class="cm"> *</span>
<span class="cm"> * This module enables machines with Intel VT-x extensions to run virtual</span>
<span class="cm"> * machines without emulation or binary translation.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Qumranet, Inc.</span>
<span class="cm"> * Copyright 2010 Red Hat, Inc. and/or its affiliates.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *   Avi Kivity   &lt;avi@qumranet.com&gt;</span>
<span class="cm"> *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This work is licensed under the terms of the GNU GPL, version 2.  See</span>
<span class="cm"> * the COPYING file in the top-level directory.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;irq.h&quot;</span>
<span class="cp">#include &quot;mmu.h&quot;</span>
<span class="cp">#include &quot;cpuid.h&quot;</span>

<span class="cp">#include &lt;linux/kvm_host.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace_event.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/tboot.h&gt;</span>
<span class="cp">#include &quot;kvm_cache_regs.h&quot;</span>
<span class="cp">#include &quot;x86.h&quot;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/vmx.h&gt;</span>
<span class="cp">#include &lt;asm/virtext.h&gt;</span>
<span class="cp">#include &lt;asm/mce.h&gt;</span>
<span class="cp">#include &lt;asm/i387.h&gt;</span>
<span class="cp">#include &lt;asm/xcr.h&gt;</span>
<span class="cp">#include &lt;asm/perf_event.h&gt;</span>

<span class="cp">#include &quot;trace.h&quot;</span>

<span class="cp">#define __ex(x) __kvm_handle_fault_on_reboot(x)</span>
<span class="cp">#define __ex_clear(x, reg) \</span>
<span class="cp">	____kvm_handle_fault_on_reboot(x, &quot;xor &quot; reg &quot; , &quot; reg)</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Qumranet&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">x86_cpu_id</span> <span class="n">vmx_cpu_id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">X86_FEATURE_MATCH</span><span class="p">(</span><span class="n">X86_FEATURE_VMX</span><span class="p">),</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">x86cpu</span><span class="p">,</span> <span class="n">vmx_cpu_id</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">enable_vpid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">vpid</span><span class="p">,</span> <span class="n">enable_vpid</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">flexpriority_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">flexpriority</span><span class="p">,</span> <span class="n">flexpriority_enabled</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">enable_ept</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">ept</span><span class="p">,</span> <span class="n">enable_ept</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">enable_unrestricted_guest</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">unrestricted_guest</span><span class="p">,</span>
			<span class="n">enable_unrestricted_guest</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">emulate_invalid_guest_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">emulate_invalid_guest_state</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">vmm_exclusive</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">vmm_exclusive</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">fasteoi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">fasteoi</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If nested=1, nested virtualization is supported, i.e., guests may use</span>
<span class="cm"> * VMX and be a hypervisor for its own guests. If nested=0, guests may not</span>
<span class="cm"> * use VMX instructions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">nested</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">nested</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="cp">#define KVM_GUEST_CR0_MASK_UNRESTRICTED_GUEST				\</span>
<span class="cp">	(X86_CR0_WP | X86_CR0_NE | X86_CR0_NW | X86_CR0_CD)</span>
<span class="cp">#define KVM_GUEST_CR0_MASK						\</span>
<span class="cp">	(KVM_GUEST_CR0_MASK_UNRESTRICTED_GUEST | X86_CR0_PG | X86_CR0_PE)</span>
<span class="cp">#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST				\</span>
<span class="cp">	(X86_CR0_WP | X86_CR0_NE)</span>
<span class="cp">#define KVM_VM_CR0_ALWAYS_ON						\</span>
<span class="cp">	(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | X86_CR0_PG | X86_CR0_PE)</span>
<span class="cp">#define KVM_CR4_GUEST_OWNED_BITS				      \</span>
<span class="cp">	(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR      \</span>
<span class="cp">	 | X86_CR4_OSXMMEXCPT)</span>

<span class="cp">#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)</span>
<span class="cp">#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)</span>

<span class="cp">#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))</span>

<span class="cm">/*</span>
<span class="cm"> * These 2 parameters are used to config the controls for Pause-Loop Exiting:</span>
<span class="cm"> * ple_gap:    upper bound on the amount of time between two successive</span>
<span class="cm"> *             executions of PAUSE in a loop. Also indicate if ple enabled.</span>
<span class="cm"> *             According to test, this time is usually smaller than 128 cycles.</span>
<span class="cm"> * ple_window: upper bound on the amount of time a guest is allowed to execute</span>
<span class="cm"> *             in a PAUSE loop. Tests indicate that most spinlocks are held for</span>
<span class="cm"> *             less than 2^12 cycles</span>
<span class="cm"> * Time is measured based on a counter that runs at the same rate as the TSC,</span>
<span class="cm"> * refer SDM volume 3b section 21.6.13 &amp; 22.1.3.</span>
<span class="cm"> */</span>
<span class="cp">#define KVM_VMX_DEFAULT_PLE_GAP    128</span>
<span class="cp">#define KVM_VMX_DEFAULT_PLE_WINDOW 4096</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ple_gap</span> <span class="o">=</span> <span class="n">KVM_VMX_DEFAULT_PLE_GAP</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ple_gap</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ple_window</span> <span class="o">=</span> <span class="n">KVM_VMX_DEFAULT_PLE_WINDOW</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ple_window</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="cp">#define NR_AUTOLOAD_MSRS 8</span>
<span class="cp">#define VMCS02_POOL_SIZE 1</span>

<span class="k">struct</span> <span class="n">vmcs</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">revision_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">abort</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Track a VMCS that may be loaded on a certain CPU. If it is (cpu!=-1), also</span>
<span class="cm"> * remember whether it was VMLAUNCHed, and maintain a linked list of all VMCSs</span>
<span class="cm"> * loaded on this CPU (so we can clear them if the CPU goes down).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">loaded_vmcs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="n">vmcs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">launched</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">loaded_vmcss_on_cpu_link</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">shared_msr_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct vmcs12 describes the state that our guest hypervisor (L1) keeps for a</span>
<span class="cm"> * single nested guest (L2), hence the name vmcs12. Any VMX implementation has</span>
<span class="cm"> * a VMCS structure, and vmcs12 is our emulated VMX&#39;s VMCS. This structure is</span>
<span class="cm"> * stored in guest memory specified by VMPTRLD, but is opaque to the guest,</span>
<span class="cm"> * which must access it using VMREAD/VMWRITE/VMCLEAR instructions.</span>
<span class="cm"> * More than one of these structures may exist, if L1 runs multiple L2 guests.</span>
<span class="cm"> * nested_vmx_run() will use the data here to build a vmcs02: a VMCS for the</span>
<span class="cm"> * underlying hardware which will be used to run L2.</span>
<span class="cm"> * This structure is packed to ensure that its layout is identical across</span>
<span class="cm"> * machines (necessary for live migration).</span>
<span class="cm"> * If there are changes in this struct, VMCS12_REVISION must be changed.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">u64</span> <span class="n">natural_width</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">__packed</span> <span class="n">vmcs12</span> <span class="p">{</span>
	<span class="cm">/* According to the Intel spec, a VMCS region must start with the</span>
<span class="cm">	 * following two fields. Then follow implementation-specific data.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">revision_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">abort</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">launch_state</span><span class="p">;</span> <span class="cm">/* set to 0 by VMCLEAR, to 1 by VMLAUNCH */</span>
	<span class="n">u32</span> <span class="n">padding</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span> <span class="cm">/* room for future expansion */</span>

	<span class="n">u64</span> <span class="n">io_bitmap_a</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">io_bitmap_b</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">msr_bitmap</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vm_exit_msr_store_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vm_exit_msr_load_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vm_entry_msr_load_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tsc_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">virtual_apic_page_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">apic_access_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ept_pointer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guest_physical_address</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vmcs_link_pointer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guest_ia32_debugctl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guest_ia32_pat</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guest_ia32_efer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guest_ia32_perf_global_ctrl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guest_pdptr0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guest_pdptr1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guest_pdptr2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">guest_pdptr3</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">host_ia32_pat</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">host_ia32_efer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">host_ia32_perf_global_ctrl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">padding64</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* room for future expansion */</span>
	<span class="cm">/*</span>
<span class="cm">	 * To allow migration of L1 (complete with its L2 guests) between</span>
<span class="cm">	 * machines of different natural widths (32 or 64 bit), we cannot have</span>
<span class="cm">	 * unsigned long fields with no explict size. We use u64 (aliased</span>
<span class="cm">	 * natural_width) instead. Luckily, x86 is little-endian.</span>
<span class="cm">	 */</span>
	<span class="n">natural_width</span> <span class="n">cr0_guest_host_mask</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">cr4_guest_host_mask</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">cr0_read_shadow</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">cr4_read_shadow</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">cr3_target_value0</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">cr3_target_value1</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">cr3_target_value2</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">cr3_target_value3</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">exit_qualification</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_linear_address</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_cr0</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_cr3</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_cr4</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_es_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_cs_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_ss_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_ds_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_fs_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_gs_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_ldtr_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_tr_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_gdtr_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_idtr_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_dr7</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_rsp</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_rip</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_rflags</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_pending_dbg_exceptions</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_sysenter_esp</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">guest_sysenter_eip</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_cr0</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_cr3</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_cr4</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_fs_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_gs_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_tr_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_gdtr_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_idtr_base</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_ia32_sysenter_esp</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_ia32_sysenter_eip</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_rsp</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">host_rip</span><span class="p">;</span>
	<span class="n">natural_width</span> <span class="n">paddingl</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* room for future expansion */</span>
	<span class="n">u32</span> <span class="n">pin_based_vm_exec_control</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exception_bitmap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page_fault_error_code_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page_fault_error_code_match</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cr3_target_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_exit_controls</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_exit_msr_store_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_exit_msr_load_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_entry_controls</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_entry_msr_load_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_entry_intr_info_field</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_entry_exception_error_code</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_entry_instruction_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tpr_threshold</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">secondary_vm_exec_control</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_instruction_error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_exit_reason</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_exit_intr_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_exit_intr_error_code</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idt_vectoring_info_field</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idt_vectoring_error_code</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vm_exit_instruction_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vmx_instruction_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_es_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_cs_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_ss_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_ds_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_fs_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_gs_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_ldtr_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_tr_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_gdtr_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_idtr_limit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_es_ar_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_cs_ar_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_ss_ar_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_ds_ar_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_fs_ar_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_gs_ar_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_ldtr_ar_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_tr_ar_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_interruptibility_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_activity_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">guest_sysenter_cs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">host_ia32_sysenter_cs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">padding32</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* room for future expansion */</span>
	<span class="n">u16</span> <span class="n">virtual_processor_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">guest_es_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">guest_cs_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">guest_ss_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">guest_ds_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">guest_fs_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">guest_gs_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">guest_ldtr_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">guest_tr_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">host_es_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">host_cs_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">host_ss_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">host_ds_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">host_fs_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">host_gs_selector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">host_tr_selector</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * VMCS12_REVISION is an arbitrary id that should be changed if the content or</span>
<span class="cm"> * layout of struct vmcs12 is changed. MSR_IA32_VMX_BASIC returns this id, and</span>
<span class="cm"> * VMPTRLD verifies that the VMCS region that L1 is loading contains this id.</span>
<span class="cm"> */</span>
<span class="cp">#define VMCS12_REVISION 0x11e57ed0</span>

<span class="cm">/*</span>
<span class="cm"> * VMCS12_SIZE is the number of bytes L1 should allocate for the VMXON region</span>
<span class="cm"> * and any VMCS region. Although only sizeof(struct vmcs12) are used by the</span>
<span class="cm"> * current implementation, 4K are reserved to avoid future complications.</span>
<span class="cm"> */</span>
<span class="cp">#define VMCS12_SIZE 0x1000</span>

<span class="cm">/* Used to remember the last vmcs02 used for some recently used vmcs12s */</span>
<span class="k">struct</span> <span class="n">vmcs02_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">gpa_t</span> <span class="n">vmptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loaded_vmcs</span> <span class="n">vmcs02</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The nested_vmx structure is part of vcpu_vmx, and holds information we need</span>
<span class="cm"> * for correct emulation of VMX (i.e., nested VMX) on this vcpu.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nested_vmx</span> <span class="p">{</span>
	<span class="cm">/* Has the level1 guest done vmxon? */</span>
	<span class="n">bool</span> <span class="n">vmxon</span><span class="p">;</span>

	<span class="cm">/* The guest-physical address of the current VMCS L1 keeps for L2 */</span>
	<span class="n">gpa_t</span> <span class="n">current_vmptr</span><span class="p">;</span>
	<span class="cm">/* The host-usable pointer to the above */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">current_vmcs12_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">current_vmcs12</span><span class="p">;</span>

	<span class="cm">/* vmcs02_list cache of VMCSs recently used to run L2 guests */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vmcs02_pool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vmcs02_num</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vmcs01_tsc_offset</span><span class="p">;</span>
	<span class="cm">/* L2 must run next, and mustn&#39;t decide to exit to L1. */</span>
	<span class="n">bool</span> <span class="n">nested_run_pending</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Guest pages referred to in vmcs02 with host-physical pointers, so</span>
<span class="cm">	 * we must keep them pinned while L2 runs.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">apic_access_page</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span>       <span class="n">vcpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>         <span class="n">host_rsp</span><span class="p">;</span>
	<span class="n">u8</span>                    <span class="n">fail</span><span class="p">;</span>
	<span class="n">u8</span>                    <span class="n">cpl</span><span class="p">;</span>
	<span class="n">bool</span>                  <span class="n">nmi_known_unmasked</span><span class="p">;</span>
	<span class="n">u32</span>                   <span class="n">exit_intr_info</span><span class="p">;</span>
	<span class="n">u32</span>                   <span class="n">idt_vectoring_info</span><span class="p">;</span>
	<span class="n">ulong</span>                 <span class="n">rflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shared_msr_entry</span> <span class="o">*</span><span class="n">guest_msrs</span><span class="p">;</span>
	<span class="kt">int</span>                   <span class="n">nmsrs</span><span class="p">;</span>
	<span class="kt">int</span>                   <span class="n">save_nmsrs</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">u64</span> 		      <span class="n">msr_host_kernel_gs_base</span><span class="p">;</span>
	<span class="n">u64</span> 		      <span class="n">msr_guest_kernel_gs_base</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * loaded_vmcs points to the VMCS currently used in this vcpu. For a</span>
<span class="cm">	 * non-nested (L1) guest, it always points to vmcs01. For a nested</span>
<span class="cm">	 * guest (L2), it points to a different VMCS.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">loaded_vmcs</span>    <span class="n">vmcs01</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loaded_vmcs</span>   <span class="o">*</span><span class="n">loaded_vmcs</span><span class="p">;</span>
	<span class="n">bool</span>                  <span class="n">__launched</span><span class="p">;</span> <span class="cm">/* temporary, used in vmx_vcpu_run */</span>
	<span class="k">struct</span> <span class="n">msr_autoload</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">nr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vmx_msr_entry</span> <span class="n">guest</span><span class="p">[</span><span class="n">NR_AUTOLOAD_MSRS</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">vmx_msr_entry</span> <span class="n">host</span><span class="p">[</span><span class="n">NR_AUTOLOAD_MSRS</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">msr_autoload</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int</span>           <span class="n">loaded</span><span class="p">;</span>
		<span class="n">u16</span>           <span class="n">fs_sel</span><span class="p">,</span> <span class="n">gs_sel</span><span class="p">,</span> <span class="n">ldt_sel</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="n">u16</span>           <span class="n">ds_sel</span><span class="p">,</span> <span class="n">es_sel</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="kt">int</span>           <span class="n">gs_ldt_reload_needed</span><span class="p">;</span>
		<span class="kt">int</span>           <span class="n">fs_reload_needed</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">host_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">vm86_active</span><span class="p">;</span>
		<span class="n">ulong</span> <span class="n">save_rflags</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_save_segment</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">selector</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">limit</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">ar</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">tr</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">gs</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">rmode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">bitmask</span><span class="p">;</span> <span class="cm">/* 4 bits per segment (1 bit per field) */</span>
		<span class="k">struct</span> <span class="n">kvm_save_segment</span> <span class="n">seg</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">segment_cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vpid</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">emulation_required</span><span class="p">;</span>

	<span class="cm">/* Support for vnmi-less CPUs */</span>
	<span class="kt">int</span> <span class="n">soft_vnmi_blocked</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">entry_time</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">vnmi_blocked_time</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exit_reason</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">rdtscp_enabled</span><span class="p">;</span>

	<span class="cm">/* Support for a guest hypervisor (nested VMX) */</span>
	<span class="k">struct</span> <span class="n">nested_vmx</span> <span class="n">nested</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">segment_cache_field</span> <span class="p">{</span>
	<span class="n">SEG_FIELD_SEL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SEG_FIELD_BASE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SEG_FIELD_LIMIT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">SEG_FIELD_AR</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

	<span class="n">SEG_FIELD_NR</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="nf">to_vmx</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define VMCS12_OFFSET(x) offsetof(struct vmcs12, x)</span>
<span class="cp">#define FIELD(number, name)	[number] = VMCS12_OFFSET(name)</span>
<span class="cp">#define FIELD64(number, name)	[number] = VMCS12_OFFSET(name), \</span>
<span class="cp">				[number##_HIGH] = VMCS12_OFFSET(name)+4</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vmcs_field_to_offset_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VIRTUAL_PROCESSOR_ID</span><span class="p">,</span> <span class="n">virtual_processor_id</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_ES_SELECTOR</span><span class="p">,</span> <span class="n">guest_es_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">,</span> <span class="n">guest_cs_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_SS_SELECTOR</span><span class="p">,</span> <span class="n">guest_ss_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_DS_SELECTOR</span><span class="p">,</span> <span class="n">guest_ds_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_FS_SELECTOR</span><span class="p">,</span> <span class="n">guest_fs_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_GS_SELECTOR</span><span class="p">,</span> <span class="n">guest_gs_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_LDTR_SELECTOR</span><span class="p">,</span> <span class="n">guest_ldtr_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_TR_SELECTOR</span><span class="p">,</span> <span class="n">guest_tr_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_ES_SELECTOR</span><span class="p">,</span> <span class="n">host_es_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_CS_SELECTOR</span><span class="p">,</span> <span class="n">host_cs_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_SS_SELECTOR</span><span class="p">,</span> <span class="n">host_ss_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_DS_SELECTOR</span><span class="p">,</span> <span class="n">host_ds_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_FS_SELECTOR</span><span class="p">,</span> <span class="n">host_fs_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_GS_SELECTOR</span><span class="p">,</span> <span class="n">host_gs_selector</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_TR_SELECTOR</span><span class="p">,</span> <span class="n">host_tr_selector</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">IO_BITMAP_A</span><span class="p">,</span> <span class="n">io_bitmap_a</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">IO_BITMAP_B</span><span class="p">,</span> <span class="n">io_bitmap_b</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">MSR_BITMAP</span><span class="p">,</span> <span class="n">msr_bitmap</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">VM_EXIT_MSR_STORE_ADDR</span><span class="p">,</span> <span class="n">vm_exit_msr_store_addr</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">VM_EXIT_MSR_LOAD_ADDR</span><span class="p">,</span> <span class="n">vm_exit_msr_load_addr</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">VM_ENTRY_MSR_LOAD_ADDR</span><span class="p">,</span> <span class="n">vm_entry_msr_load_addr</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">,</span> <span class="n">tsc_offset</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">VIRTUAL_APIC_PAGE_ADDR</span><span class="p">,</span> <span class="n">virtual_apic_page_addr</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">APIC_ACCESS_ADDR</span><span class="p">,</span> <span class="n">apic_access_addr</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">EPT_POINTER</span><span class="p">,</span> <span class="n">ept_pointer</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">GUEST_PHYSICAL_ADDRESS</span><span class="p">,</span> <span class="n">guest_physical_address</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">VMCS_LINK_POINTER</span><span class="p">,</span> <span class="n">vmcs_link_pointer</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">GUEST_IA32_DEBUGCTL</span><span class="p">,</span> <span class="n">guest_ia32_debugctl</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">GUEST_IA32_PAT</span><span class="p">,</span> <span class="n">guest_ia32_pat</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">GUEST_IA32_EFER</span><span class="p">,</span> <span class="n">guest_ia32_efer</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">GUEST_IA32_PERF_GLOBAL_CTRL</span><span class="p">,</span> <span class="n">guest_ia32_perf_global_ctrl</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">GUEST_PDPTR0</span><span class="p">,</span> <span class="n">guest_pdptr0</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">GUEST_PDPTR1</span><span class="p">,</span> <span class="n">guest_pdptr1</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">GUEST_PDPTR2</span><span class="p">,</span> <span class="n">guest_pdptr2</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">GUEST_PDPTR3</span><span class="p">,</span> <span class="n">guest_pdptr3</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">HOST_IA32_PAT</span><span class="p">,</span> <span class="n">host_ia32_pat</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">HOST_IA32_EFER</span><span class="p">,</span> <span class="n">host_ia32_efer</span><span class="p">),</span>
	<span class="n">FIELD64</span><span class="p">(</span><span class="n">HOST_IA32_PERF_GLOBAL_CTRL</span><span class="p">,</span> <span class="n">host_ia32_perf_global_ctrl</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">PIN_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">pin_based_vm_exec_control</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">EXCEPTION_BITMAP</span><span class="p">,</span> <span class="n">exception_bitmap</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">PAGE_FAULT_ERROR_CODE_MASK</span><span class="p">,</span> <span class="n">page_fault_error_code_mask</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">PAGE_FAULT_ERROR_CODE_MATCH</span><span class="p">,</span> <span class="n">page_fault_error_code_match</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CR3_TARGET_COUNT</span><span class="p">,</span> <span class="n">cr3_target_count</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_EXIT_CONTROLS</span><span class="p">,</span> <span class="n">vm_exit_controls</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_EXIT_MSR_STORE_COUNT</span><span class="p">,</span> <span class="n">vm_exit_msr_store_count</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_EXIT_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="n">vm_exit_msr_load_count</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span> <span class="n">vm_entry_controls</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_ENTRY_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="n">vm_entry_msr_load_count</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">,</span> <span class="n">vm_entry_intr_info_field</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_ENTRY_EXCEPTION_ERROR_CODE</span><span class="p">,</span> <span class="n">vm_entry_exception_error_code</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_ENTRY_INSTRUCTION_LEN</span><span class="p">,</span> <span class="n">vm_entry_instruction_len</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">TPR_THRESHOLD</span><span class="p">,</span> <span class="n">tpr_threshold</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">secondary_vm_exec_control</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_INSTRUCTION_ERROR</span><span class="p">,</span> <span class="n">vm_instruction_error</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_EXIT_REASON</span><span class="p">,</span> <span class="n">vm_exit_reason</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_EXIT_INTR_INFO</span><span class="p">,</span> <span class="n">vm_exit_intr_info</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_EXIT_INTR_ERROR_CODE</span><span class="p">,</span> <span class="n">vm_exit_intr_error_code</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">IDT_VECTORING_INFO_FIELD</span><span class="p">,</span> <span class="n">idt_vectoring_info_field</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">IDT_VECTORING_ERROR_CODE</span><span class="p">,</span> <span class="n">idt_vectoring_error_code</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">,</span> <span class="n">vm_exit_instruction_len</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">VMX_INSTRUCTION_INFO</span><span class="p">,</span> <span class="n">vmx_instruction_info</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_ES_LIMIT</span><span class="p">,</span> <span class="n">guest_es_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_CS_LIMIT</span><span class="p">,</span> <span class="n">guest_cs_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_SS_LIMIT</span><span class="p">,</span> <span class="n">guest_ss_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_DS_LIMIT</span><span class="p">,</span> <span class="n">guest_ds_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_FS_LIMIT</span><span class="p">,</span> <span class="n">guest_fs_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_GS_LIMIT</span><span class="p">,</span> <span class="n">guest_gs_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_LDTR_LIMIT</span><span class="p">,</span> <span class="n">guest_ldtr_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_TR_LIMIT</span><span class="p">,</span> <span class="n">guest_tr_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_GDTR_LIMIT</span><span class="p">,</span> <span class="n">guest_gdtr_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_IDTR_LIMIT</span><span class="p">,</span> <span class="n">guest_idtr_limit</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_ES_AR_BYTES</span><span class="p">,</span> <span class="n">guest_es_ar_bytes</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_CS_AR_BYTES</span><span class="p">,</span> <span class="n">guest_cs_ar_bytes</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_SS_AR_BYTES</span><span class="p">,</span> <span class="n">guest_ss_ar_bytes</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_DS_AR_BYTES</span><span class="p">,</span> <span class="n">guest_ds_ar_bytes</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_FS_AR_BYTES</span><span class="p">,</span> <span class="n">guest_fs_ar_bytes</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_GS_AR_BYTES</span><span class="p">,</span> <span class="n">guest_gs_ar_bytes</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_LDTR_AR_BYTES</span><span class="p">,</span> <span class="n">guest_ldtr_ar_bytes</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_TR_AR_BYTES</span><span class="p">,</span> <span class="n">guest_tr_ar_bytes</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">,</span> <span class="n">guest_interruptibility_info</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_ACTIVITY_STATE</span><span class="p">,</span> <span class="n">guest_activity_state</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_SYSENTER_CS</span><span class="p">,</span> <span class="n">guest_sysenter_cs</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_IA32_SYSENTER_CS</span><span class="p">,</span> <span class="n">host_ia32_sysenter_cs</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CR0_GUEST_HOST_MASK</span><span class="p">,</span> <span class="n">cr0_guest_host_mask</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CR4_GUEST_HOST_MASK</span><span class="p">,</span> <span class="n">cr4_guest_host_mask</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span> <span class="n">cr0_read_shadow</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CR4_READ_SHADOW</span><span class="p">,</span> <span class="n">cr4_read_shadow</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE0</span><span class="p">,</span> <span class="n">cr3_target_value0</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE1</span><span class="p">,</span> <span class="n">cr3_target_value1</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE2</span><span class="p">,</span> <span class="n">cr3_target_value2</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">CR3_TARGET_VALUE3</span><span class="p">,</span> <span class="n">cr3_target_value3</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">,</span> <span class="n">exit_qualification</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_LINEAR_ADDRESS</span><span class="p">,</span> <span class="n">guest_linear_address</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="n">guest_cr0</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="n">guest_cr3</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="n">guest_cr4</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_ES_BASE</span><span class="p">,</span> <span class="n">guest_es_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">,</span> <span class="n">guest_cs_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_SS_BASE</span><span class="p">,</span> <span class="n">guest_ss_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_DS_BASE</span><span class="p">,</span> <span class="n">guest_ds_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_FS_BASE</span><span class="p">,</span> <span class="n">guest_fs_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_GS_BASE</span><span class="p">,</span> <span class="n">guest_gs_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_LDTR_BASE</span><span class="p">,</span> <span class="n">guest_ldtr_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_TR_BASE</span><span class="p">,</span> <span class="n">guest_tr_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_GDTR_BASE</span><span class="p">,</span> <span class="n">guest_gdtr_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_IDTR_BASE</span><span class="p">,</span> <span class="n">guest_idtr_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">,</span> <span class="n">guest_dr7</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">,</span> <span class="n">guest_rsp</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="n">guest_rip</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">,</span> <span class="n">guest_rflags</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_PENDING_DBG_EXCEPTIONS</span><span class="p">,</span> <span class="n">guest_pending_dbg_exceptions</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_SYSENTER_ESP</span><span class="p">,</span> <span class="n">guest_sysenter_esp</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">GUEST_SYSENTER_EIP</span><span class="p">,</span> <span class="n">guest_sysenter_eip</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_CR0</span><span class="p">,</span> <span class="n">host_cr0</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_CR3</span><span class="p">,</span> <span class="n">host_cr3</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_CR4</span><span class="p">,</span> <span class="n">host_cr4</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_FS_BASE</span><span class="p">,</span> <span class="n">host_fs_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_GS_BASE</span><span class="p">,</span> <span class="n">host_gs_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_TR_BASE</span><span class="p">,</span> <span class="n">host_tr_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_GDTR_BASE</span><span class="p">,</span> <span class="n">host_gdtr_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_IDTR_BASE</span><span class="p">,</span> <span class="n">host_idtr_base</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_IA32_SYSENTER_ESP</span><span class="p">,</span> <span class="n">host_ia32_sysenter_esp</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_IA32_SYSENTER_EIP</span><span class="p">,</span> <span class="n">host_ia32_sysenter_eip</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_RSP</span><span class="p">,</span> <span class="n">host_rsp</span><span class="p">),</span>
	<span class="n">FIELD</span><span class="p">(</span><span class="n">HOST_RIP</span><span class="p">,</span> <span class="n">host_rip</span><span class="p">),</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_vmcs_field</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">vmcs_field_to_offset_table</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">short</span> <span class="nf">vmcs_field_to_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">field</span> <span class="o">&gt;=</span> <span class="n">max_vmcs_field</span> <span class="o">||</span> <span class="n">vmcs_field_to_offset_table</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vmcs_field_to_offset_table</span><span class="p">[</span><span class="n">field</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="nf">get_vmcs12</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">nested_get_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">gfn_to_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_error_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_release_page_clean</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nested_release_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_release_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nested_release_page_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_release_page_clean</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">root_hpa</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">kvm_cpu_vmxon</span><span class="p">(</span><span class="n">u64</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">kvm_cpu_vmxoff</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">vmx_set_cr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vmx_set_tss_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="p">,</span> <span class="n">vmxarea</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="p">,</span> <span class="n">current_vmcs</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * We maintain a per-CPU linked-list of VMCS loaded on that CPU. This is needed</span>
<span class="cm"> * when a CPU is brought down, and we need to VMCLEAR all VMCSs loaded on it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">,</span> <span class="n">loaded_vmcss_on_cpu</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">desc_ptr</span><span class="p">,</span> <span class="n">host_gdt</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vmx_io_bitmap_a</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vmx_io_bitmap_b</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vmx_msr_bitmap_legacy</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vmx_msr_bitmap_longmode</span><span class="p">;</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">cpu_has_load_ia32_efer</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">cpu_has_load_perf_global_ctrl</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">vmx_vpid_bitmap</span><span class="p">,</span> <span class="n">VMX_NR_VPIDS</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">vmx_vpid_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vmcs_config</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">revision_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pin_based_exec_ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cpu_based_exec_ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cpu_based_2nd_exec_ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vmexit_ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vmentry_ctrl</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vmcs_config</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vmx_capability</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">ept</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vpid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vmx_capability</span><span class="p">;</span>

<span class="cp">#define VMX_SEGMENT_FIELD(seg)					\</span>
<span class="cp">	[VCPU_SREG_##seg] = {                                   \</span>
<span class="cp">		.selector = GUEST_##seg##_SELECTOR,		\</span>
<span class="cp">		.base = GUEST_##seg##_BASE,		   	\</span>
<span class="cp">		.limit = GUEST_##seg##_LIMIT,		   	\</span>
<span class="cp">		.ar_bytes = GUEST_##seg##_AR_BYTES,	   	\</span>
<span class="cp">	}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_vmx_segment_field</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">selector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ar_bytes</span><span class="p">;</span>
<span class="p">}</span> <span class="n">kvm_vmx_segment_fields</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">VMX_SEGMENT_FIELD</span><span class="p">(</span><span class="n">CS</span><span class="p">),</span>
	<span class="n">VMX_SEGMENT_FIELD</span><span class="p">(</span><span class="n">DS</span><span class="p">),</span>
	<span class="n">VMX_SEGMENT_FIELD</span><span class="p">(</span><span class="n">ES</span><span class="p">),</span>
	<span class="n">VMX_SEGMENT_FIELD</span><span class="p">(</span><span class="n">FS</span><span class="p">),</span>
	<span class="n">VMX_SEGMENT_FIELD</span><span class="p">(</span><span class="n">GS</span><span class="p">),</span>
	<span class="n">VMX_SEGMENT_FIELD</span><span class="p">(</span><span class="n">SS</span><span class="p">),</span>
	<span class="n">VMX_SEGMENT_FIELD</span><span class="p">(</span><span class="n">TR</span><span class="p">),</span>
	<span class="n">VMX_SEGMENT_FIELD</span><span class="p">(</span><span class="n">LDTR</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">host_efer</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ept_save_pdptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Keep MSR_STAR at the end, as setup_msrs() will try to optimize it</span>
<span class="cm"> * away by decrementing the array size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">vmx_msr_index</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">MSR_SYSCALL_MASK</span><span class="p">,</span> <span class="n">MSR_LSTAR</span><span class="p">,</span> <span class="n">MSR_CSTAR</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="n">MSR_EFER</span><span class="p">,</span> <span class="n">MSR_TSC_AUX</span><span class="p">,</span> <span class="n">MSR_STAR</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define NR_VMX_MSR ARRAY_SIZE(vmx_msr_index)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_page_fault</span><span class="p">(</span><span class="n">u32</span> <span class="n">intr_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">intr_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_INFO_INTR_TYPE_MASK</span> <span class="o">|</span> <span class="n">INTR_INFO_VECTOR_MASK</span> <span class="o">|</span>
			     <span class="n">INTR_INFO_VALID_MASK</span><span class="p">))</span> <span class="o">==</span>
		<span class="p">(</span><span class="n">INTR_TYPE_HARD_EXCEPTION</span> <span class="o">|</span> <span class="n">PF_VECTOR</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_no_device</span><span class="p">(</span><span class="n">u32</span> <span class="n">intr_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">intr_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_INFO_INTR_TYPE_MASK</span> <span class="o">|</span> <span class="n">INTR_INFO_VECTOR_MASK</span> <span class="o">|</span>
			     <span class="n">INTR_INFO_VALID_MASK</span><span class="p">))</span> <span class="o">==</span>
		<span class="p">(</span><span class="n">INTR_TYPE_HARD_EXCEPTION</span> <span class="o">|</span> <span class="n">NM_VECTOR</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_invalid_opcode</span><span class="p">(</span><span class="n">u32</span> <span class="n">intr_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">intr_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_INFO_INTR_TYPE_MASK</span> <span class="o">|</span> <span class="n">INTR_INFO_VECTOR_MASK</span> <span class="o">|</span>
			     <span class="n">INTR_INFO_VALID_MASK</span><span class="p">))</span> <span class="o">==</span>
		<span class="p">(</span><span class="n">INTR_TYPE_HARD_EXCEPTION</span> <span class="o">|</span> <span class="n">UD_VECTOR</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_external_interrupt</span><span class="p">(</span><span class="n">u32</span> <span class="n">intr_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">intr_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_INFO_INTR_TYPE_MASK</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">))</span>
		<span class="o">==</span> <span class="p">(</span><span class="n">INTR_TYPE_EXT_INTR</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_machine_check</span><span class="p">(</span><span class="n">u32</span> <span class="n">intr_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">intr_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_INFO_INTR_TYPE_MASK</span> <span class="o">|</span> <span class="n">INTR_INFO_VECTOR_MASK</span> <span class="o">|</span>
			     <span class="n">INTR_INFO_VALID_MASK</span><span class="p">))</span> <span class="o">==</span>
		<span class="p">(</span><span class="n">INTR_TYPE_HARD_EXCEPTION</span> <span class="o">|</span> <span class="n">MC_VECTOR</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_msr_bitmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_exec_ctrl</span> <span class="o">&amp;</span> <span class="n">CPU_BASED_USE_MSR_BITMAPS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_tpr_shadow</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_exec_ctrl</span> <span class="o">&amp;</span> <span class="n">CPU_BASED_TPR_SHADOW</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">vm_need_tpr_shadow</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cpu_has_vmx_tpr_shadow</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_secondary_exec_ctrls</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_exec_ctrl</span> <span class="o">&amp;</span>
		<span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_virtualize_apic_accesses</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_2nd_exec_ctrl</span> <span class="o">&amp;</span>
		<span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_flexpriority</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_has_vmx_tpr_shadow</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
		<span class="n">cpu_has_vmx_virtualize_apic_accesses</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_ept_execute_only</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span> <span class="o">&amp;</span> <span class="n">VMX_EPT_EXECUTE_ONLY_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_eptp_uncacheable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span> <span class="o">&amp;</span> <span class="n">VMX_EPTP_UC_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_eptp_writeback</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span> <span class="o">&amp;</span> <span class="n">VMX_EPTP_WB_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_ept_2m_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span> <span class="o">&amp;</span> <span class="n">VMX_EPT_2MB_PAGE_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_ept_1g_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span> <span class="o">&amp;</span> <span class="n">VMX_EPT_1GB_PAGE_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_ept_4levels</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span> <span class="o">&amp;</span> <span class="n">VMX_EPT_PAGE_WALK_4_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_invept_individual_addr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span> <span class="o">&amp;</span> <span class="n">VMX_EPT_EXTENT_INDIVIDUAL_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_invept_context</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span> <span class="o">&amp;</span> <span class="n">VMX_EPT_EXTENT_CONTEXT_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_invept_global</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span> <span class="o">&amp;</span> <span class="n">VMX_EPT_EXTENT_GLOBAL_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_invvpid_single</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">vpid</span> <span class="o">&amp;</span> <span class="n">VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_invvpid_global</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">vpid</span> <span class="o">&amp;</span> <span class="n">VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_ept</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_2nd_exec_ctrl</span> <span class="o">&amp;</span>
		<span class="n">SECONDARY_EXEC_ENABLE_EPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_unrestricted_guest</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_2nd_exec_ctrl</span> <span class="o">&amp;</span>
		<span class="n">SECONDARY_EXEC_UNRESTRICTED_GUEST</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_ple</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_2nd_exec_ctrl</span> <span class="o">&amp;</span>
		<span class="n">SECONDARY_EXEC_PAUSE_LOOP_EXITING</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">vm_need_virtualize_apic_accesses</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">flexpriority_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_vpid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_2nd_exec_ctrl</span> <span class="o">&amp;</span>
		<span class="n">SECONDARY_EXEC_ENABLE_VPID</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_rdtscp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_2nd_exec_ctrl</span> <span class="o">&amp;</span>
		<span class="n">SECONDARY_EXEC_RDTSCP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_virtual_nmis</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">pin_based_exec_ctrl</span> <span class="o">&amp;</span> <span class="n">PIN_BASED_VIRTUAL_NMIS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpu_has_vmx_wbinvd_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_2nd_exec_ctrl</span> <span class="o">&amp;</span>
		<span class="n">SECONDARY_EXEC_WBINVD_EXITING</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">report_flexpriority</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">flexpriority_enabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">nested_cpu_has</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cpu_based_vm_exec_control</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">nested_cpu_has2</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cpu_based_vm_exec_control</span> <span class="o">&amp;</span>
			<span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">secondary_vm_exec_control</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">nested_cpu_has_virtual_nmis</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">pin_based_vm_exec_control</span> <span class="o">&amp;</span> <span class="n">PIN_BASED_VIRTUAL_NMIS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_exception</span><span class="p">(</span><span class="n">u32</span> <span class="n">intr_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">intr_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_INFO_INTR_TYPE_MASK</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">))</span>
		<span class="o">==</span> <span class="p">(</span><span class="n">INTR_TYPE_HARD_EXCEPTION</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">nested_vmx_vmexit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">nested_vmx_entry_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">qualification</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__find_msr_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nmsrs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmx_msr_index</span><span class="p">[</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">msr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__invvpid</span><span class="p">(</span><span class="kt">int</span> <span class="n">ext</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vpid</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">vpid</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rsvd</span> <span class="o">:</span> <span class="mi">48</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">gva</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">operand</span> <span class="o">=</span> <span class="p">{</span> <span class="n">vpid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gva</span> <span class="p">};</span>

    <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="n">__ex</span><span class="p">(</span><span class="n">ASM_VMX_INVVPID</span><span class="p">)</span>
		  <span class="cm">/* CF==1 or ZF==1 --&gt; rc = -1 */</span>
		  <span class="s">&quot;; ja 1f ; ud2 ; 1:&quot;</span>
		  <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">operand</span><span class="p">),</span> <span class="s">&quot;c&quot;</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__invept</span><span class="p">(</span><span class="kt">int</span> <span class="n">ext</span><span class="p">,</span> <span class="n">u64</span> <span class="n">eptp</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">eptp</span><span class="p">,</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">operand</span> <span class="o">=</span> <span class="p">{</span><span class="n">eptp</span><span class="p">,</span> <span class="n">gpa</span><span class="p">};</span>

	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="n">__ex</span><span class="p">(</span><span class="n">ASM_VMX_INVEPT</span><span class="p">)</span>
			<span class="cm">/* CF==1 or ZF==1 --&gt; rc = -1 */</span>
			<span class="s">&quot;; ja 1f ; ud2 ; 1:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="o">:</span> <span class="o">:</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">operand</span><span class="p">),</span> <span class="s">&quot;c&quot;</span> <span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">shared_msr_entry</span> <span class="o">*</span><span class="nf">find_msr_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">__find_msr_index</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmcs_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="n">vmcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">phys_addr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vmcs</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="n">__ex</span><span class="p">(</span><span class="n">ASM_VMX_VMCLEAR_RAX</span><span class="p">)</span> <span class="s">&quot;; setna %0&quot;</span>
		      <span class="o">:</span> <span class="s">&quot;=qm&quot;</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phys_addr</span><span class="p">),</span> <span class="s">&quot;m&quot;</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">)</span>
		      <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: vmclear fail: %p/%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">vmcs</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">loaded_vmcs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">loaded_vmcs</span> <span class="o">*</span><span class="n">loaded_vmcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_clear</span><span class="p">(</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span><span class="p">);</span>
	<span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">launched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmcs_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="n">vmcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">phys_addr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vmcs</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="n">__ex</span><span class="p">(</span><span class="n">ASM_VMX_VMPTRLD_RAX</span><span class="p">)</span> <span class="s">&quot;; setna %0&quot;</span>
			<span class="o">:</span> <span class="s">&quot;=qm&quot;</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phys_addr</span><span class="p">),</span> <span class="s">&quot;m&quot;</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">)</span>
			<span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: vmptrld %p/%llx failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">vmcs</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__loaded_vmcs_clear</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loaded_vmcs</span> <span class="o">*</span><span class="n">loaded_vmcs</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* vcpu migration can race with cpu offline */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">current_vmcs</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span><span class="p">)</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">current_vmcs</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">loaded_vmcss_on_cpu_link</span><span class="p">);</span>
	<span class="n">loaded_vmcs_init</span><span class="p">(</span><span class="n">loaded_vmcs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">loaded_vmcs_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">loaded_vmcs</span> <span class="o">*</span><span class="n">loaded_vmcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span>
			<span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">__loaded_vmcs_clear</span><span class="p">,</span> <span class="n">loaded_vmcs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vpid_sync_vcpu_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vmx_invvpid_single</span><span class="p">())</span>
		<span class="n">__invvpid</span><span class="p">(</span><span class="n">VMX_VPID_EXTENT_SINGLE_CONTEXT</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vpid_sync_vcpu_global</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vmx_invvpid_global</span><span class="p">())</span>
		<span class="n">__invvpid</span><span class="p">(</span><span class="n">VMX_VPID_EXTENT_ALL_CONTEXT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vpid_sync_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vmx_invvpid_single</span><span class="p">())</span>
		<span class="n">vpid_sync_vcpu_single</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vpid_sync_vcpu_global</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ept_sync_global</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vmx_invept_global</span><span class="p">())</span>
		<span class="n">__invept</span><span class="p">(</span><span class="n">VMX_EPT_EXTENT_GLOBAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ept_sync_context</span><span class="p">(</span><span class="n">u64</span> <span class="n">eptp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vmx_invept_context</span><span class="p">())</span>
			<span class="n">__invept</span><span class="p">(</span><span class="n">VMX_EPT_EXTENT_CONTEXT</span><span class="p">,</span> <span class="n">eptp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ept_sync_global</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ept_sync_individual_addr</span><span class="p">(</span><span class="n">u64</span> <span class="n">eptp</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vmx_invept_individual_addr</span><span class="p">())</span>
			<span class="n">__invept</span><span class="p">(</span><span class="n">VMX_EPT_EXTENT_INDIVIDUAL_ADDR</span><span class="p">,</span>
					<span class="n">eptp</span><span class="p">,</span> <span class="n">gpa</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ept_sync_context</span><span class="p">(</span><span class="n">eptp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vmcs_readl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="n">__ex_clear</span><span class="p">(</span><span class="n">ASM_VMX_VMREAD_RDX_RAX</span><span class="p">,</span> <span class="s">&quot;%0&quot;</span><span class="p">)</span>
		      <span class="o">:</span> <span class="s">&quot;=a&quot;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;d&quot;</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="n">u16</span> <span class="nf">vmcs_read16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="n">u32</span> <span class="nf">vmcs_read32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="n">u64</span> <span class="nf">vmcs_read64</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">return</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">vmwrite_error</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vmwrite error: reg %lx value %lx (err %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">field</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_INSTRUCTION_ERROR</span><span class="p">));</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmcs_writel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="n">__ex</span><span class="p">(</span><span class="n">ASM_VMX_VMWRITE_RAX_RDX</span><span class="p">)</span> <span class="s">&quot;; setna %0&quot;</span>
		       <span class="o">:</span> <span class="s">&quot;=q&quot;</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s">&quot;d&quot;</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="n">vmwrite_error</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmcs_write16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmcs_write32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmcs_write64</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_X86_64</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">field</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmcs_clear_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmcs_set_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_segment_cache_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">segment_cache</span><span class="p">.</span><span class="n">bitmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmx_segment_cache_test_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">seg</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">seg</span> <span class="o">*</span> <span class="n">SEG_FIELD_NR</span> <span class="o">+</span> <span class="n">field</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_EXREG_SEGMENTS</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_EXREG_SEGMENTS</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">segment_cache</span><span class="p">.</span><span class="n">bitmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">segment_cache</span><span class="p">.</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">segment_cache</span><span class="p">.</span><span class="n">bitmask</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">vmx_read_guest_seg_selector</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">segment_cache</span><span class="p">.</span><span class="n">seg</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">selector</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx_segment_cache_test_set</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">SEG_FIELD_SEL</span><span class="p">))</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">kvm_vmx_segment_fields</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">selector</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ulong</span> <span class="nf">vmx_read_guest_seg_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ulong</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">segment_cache</span><span class="p">.</span><span class="n">seg</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx_segment_cache_test_set</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">SEG_FIELD_BASE</span><span class="p">))</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">kvm_vmx_segment_fields</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vmx_read_guest_seg_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">segment_cache</span><span class="p">.</span><span class="n">seg</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx_segment_cache_test_set</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">SEG_FIELD_LIMIT</span><span class="p">))</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">kvm_vmx_segment_fields</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">limit</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vmx_read_guest_seg_ar</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">segment_cache</span><span class="p">.</span><span class="n">seg</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">ar</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx_segment_cache_test_set</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">SEG_FIELD_AR</span><span class="p">))</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">kvm_vmx_segment_fields</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">ar_bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_exception_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eb</span><span class="p">;</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">PF_VECTOR</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">UD_VECTOR</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">MC_VECTOR</span><span class="p">)</span> <span class="o">|</span>
	     <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">NM_VECTOR</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">DB_VECTOR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span>
	     <span class="p">(</span><span class="n">KVM_GUESTDBG_ENABLE</span> <span class="o">|</span> <span class="n">KVM_GUESTDBG_USE_SW_BP</span><span class="p">))</span> <span class="o">==</span>
	    <span class="p">(</span><span class="n">KVM_GUESTDBG_ENABLE</span> <span class="o">|</span> <span class="n">KVM_GUESTDBG_USE_SW_BP</span><span class="p">))</span>
		<span class="n">eb</span> <span class="o">|=</span> <span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">BP_VECTOR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span><span class="p">)</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span>
		<span class="n">eb</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">PF_VECTOR</span><span class="p">);</span> <span class="cm">/* bypass_guest_pf = 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">fpu_active</span><span class="p">)</span>
		<span class="n">eb</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">NM_VECTOR</span><span class="p">);</span>

	<span class="cm">/* When we are running a nested L2 guest and L1 specified for it a</span>
<span class="cm">	 * certain exception bitmap, we must trap the same exceptions and pass</span>
<span class="cm">	 * them to L1. When running L2, we will only handle the exceptions</span>
<span class="cm">	 * specified above if L1 did not want them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">eb</span> <span class="o">|=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">exception_bitmap</span><span class="p">;</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">EXCEPTION_BITMAP</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_atomic_switch_msr_special</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_clear_bits</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="n">vmcs_clear_bits</span><span class="p">(</span><span class="n">VM_EXIT_CONTROLS</span><span class="p">,</span> <span class="n">exit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_atomic_switch_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msr_autoload</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">msr_autoload</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSR_EFER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_load_ia32_efer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_atomic_switch_msr_special</span><span class="p">(</span><span class="n">VM_ENTRY_LOAD_IA32_EFER</span><span class="p">,</span>
					<span class="n">VM_EXIT_LOAD_IA32_EFER</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_CORE_PERF_GLOBAL_CTRL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_load_perf_global_ctrl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_atomic_switch_msr_special</span><span class="p">(</span>
					<span class="n">VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL</span><span class="p">,</span>
					<span class="n">VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">guest</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">==</span> <span class="n">msr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="o">--</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">guest</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">guest</span><span class="p">[</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">];</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">[</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">];</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_EXIT_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_atomic_switch_msr_special</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">guest_val_vmcs</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">host_val_vmcs</span><span class="p">,</span> <span class="n">u64</span> <span class="n">guest_val</span><span class="p">,</span> <span class="n">u64</span> <span class="n">host_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">guest_val_vmcs</span><span class="p">,</span> <span class="n">guest_val</span><span class="p">);</span>
	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">host_val_vmcs</span><span class="p">,</span> <span class="n">host_val</span><span class="p">);</span>
	<span class="n">vmcs_set_bits</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="n">vmcs_set_bits</span><span class="p">(</span><span class="n">VM_EXIT_CONTROLS</span><span class="p">,</span> <span class="n">exit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_atomic_switch_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">msr</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">guest_val</span><span class="p">,</span> <span class="n">u64</span> <span class="n">host_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msr_autoload</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">msr_autoload</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSR_EFER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_load_ia32_efer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">add_atomic_switch_msr_special</span><span class="p">(</span><span class="n">VM_ENTRY_LOAD_IA32_EFER</span><span class="p">,</span>
					<span class="n">VM_EXIT_LOAD_IA32_EFER</span><span class="p">,</span>
					<span class="n">GUEST_IA32_EFER</span><span class="p">,</span>
					<span class="n">HOST_IA32_EFER</span><span class="p">,</span>
					<span class="n">guest_val</span><span class="p">,</span> <span class="n">host_val</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_CORE_PERF_GLOBAL_CTRL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_load_perf_global_ctrl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">add_atomic_switch_msr_special</span><span class="p">(</span>
					<span class="n">VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL</span><span class="p">,</span>
					<span class="n">VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL</span><span class="p">,</span>
					<span class="n">GUEST_IA32_PERF_GLOBAL_CTRL</span><span class="p">,</span>
					<span class="n">HOST_IA32_PERF_GLOBAL_CTRL</span><span class="p">,</span>
					<span class="n">guest_val</span><span class="p">,</span> <span class="n">host_val</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">guest</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">==</span> <span class="n">msr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NR_AUTOLOAD_MSRS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;Not enough mst switch entries. &quot;</span>
				<span class="s">&quot;Can&#39;t add msr %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_EXIT_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">m</span><span class="o">-&gt;</span><span class="n">guest</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">msr</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">guest</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">guest_val</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">msr</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">host_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reload_tss</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * VT restores TR but not its size.  Useless.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">gdt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">host_gdt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">descs</span><span class="p">;</span>

	<span class="n">descs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">gdt</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
	<span class="n">descs</span><span class="p">[</span><span class="n">GDT_ENTRY_TSS</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="cm">/* available TSS */</span>
	<span class="n">load_TR_desc</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">update_transition_efer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">efer_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">guest_efer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ignore_bits</span><span class="p">;</span>

	<span class="n">guest_efer</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NX is emulated; LMA and LME handled by hardware; SCE meaninless</span>
<span class="cm">	 * outside long mode</span>
<span class="cm">	 */</span>
	<span class="n">ignore_bits</span> <span class="o">=</span> <span class="n">EFER_NX</span> <span class="o">|</span> <span class="n">EFER_SCE</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">ignore_bits</span> <span class="o">|=</span> <span class="n">EFER_LMA</span> <span class="o">|</span> <span class="n">EFER_LME</span><span class="p">;</span>
	<span class="cm">/* SCE is meaningful only in long mode on Intel */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">guest_efer</span> <span class="o">&amp;</span> <span class="n">EFER_LMA</span><span class="p">)</span>
		<span class="n">ignore_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">EFER_SCE</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">guest_efer</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ignore_bits</span><span class="p">;</span>
	<span class="n">guest_efer</span> <span class="o">|=</span> <span class="n">host_efer</span> <span class="o">&amp;</span> <span class="n">ignore_bits</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">efer_offset</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="n">guest_efer</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">efer_offset</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">ignore_bits</span><span class="p">;</span>

	<span class="n">clear_atomic_switch_msr</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">MSR_EFER</span><span class="p">);</span>
	<span class="cm">/* On ept, can&#39;t emulate nx, and must switch nx atomically */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">^</span> <span class="n">host_efer</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EFER_NX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">guest_efer</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">guest_efer</span> <span class="o">&amp;</span> <span class="n">EFER_LMA</span><span class="p">))</span>
			<span class="n">guest_efer</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EFER_LME</span><span class="p">;</span>
		<span class="n">add_atomic_switch_msr</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">MSR_EFER</span><span class="p">,</span> <span class="n">guest_efer</span><span class="p">,</span> <span class="n">host_efer</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">segment_base</span><span class="p">(</span><span class="n">u16</span> <span class="n">selector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">gdt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">host_gdt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">table_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">table_base</span> <span class="o">=</span> <span class="n">gdt</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>           <span class="cm">/* from ldt */</span>
		<span class="n">u16</span> <span class="n">ldt_selector</span> <span class="o">=</span> <span class="n">kvm_read_ldt</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ldt_selector</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">table_base</span> <span class="o">=</span> <span class="n">segment_base</span><span class="p">(</span><span class="n">ldt_selector</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="p">)(</span><span class="n">table_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">));</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">get_desc_base</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="mi">9</span> <span class="o">||</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="mi">11</span><span class="p">))</span>
               <span class="n">v</span> <span class="o">|=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)((</span><span class="k">struct</span> <span class="n">ldttss_desc64</span> <span class="o">*</span><span class="p">)</span><span class="n">d</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">base3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kvm_read_tr_base</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tr</span><span class="p">;</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;str %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=g&quot;</span><span class="p">(</span><span class="n">tr</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">segment_base</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_save_host_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">loaded</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not</span>
<span class="cm">	 * allow segment selectors with cpl &gt; 0 or ti == 1.</span>
<span class="cm">	 */</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">ldt_sel</span> <span class="o">=</span> <span class="n">kvm_read_ldt</span><span class="p">();</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">gs_ldt_reload_needed</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">ldt_sel</span><span class="p">;</span>
	<span class="n">savesegment</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">fs_sel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">fs_sel</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_FS_SELECTOR</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">fs_sel</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">fs_reload_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_FS_SELECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">fs_reload_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">savesegment</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">gs_sel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">gs_sel</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_GS_SELECTOR</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">gs_sel</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_GS_SELECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">gs_ldt_reload_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">savesegment</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">ds_sel</span><span class="p">);</span>
	<span class="n">savesegment</span><span class="p">(</span><span class="n">es</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">es_sel</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_FS_BASE</span><span class="p">,</span> <span class="n">read_msr</span><span class="p">(</span><span class="n">MSR_FS_BASE</span><span class="p">));</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_GS_BASE</span><span class="p">,</span> <span class="n">read_msr</span><span class="p">(</span><span class="n">MSR_GS_BASE</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_FS_BASE</span><span class="p">,</span> <span class="n">segment_base</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">fs_sel</span><span class="p">));</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_GS_BASE</span><span class="p">,</span> <span class="n">segment_base</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">gs_sel</span><span class="p">));</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_KERNEL_GS_BASE</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">msr_host_kernel_gs_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_KERNEL_GS_BASE</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">msr_guest_kernel_gs_base</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">save_nmsrs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">kvm_set_shared_msr</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">,</span>
				   <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span>
				   <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vmx_load_host_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">loaded</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="o">++</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">stat</span><span class="p">.</span><span class="n">host_state_reload</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_KERNEL_GS_BASE</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">msr_guest_kernel_gs_base</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">gs_ldt_reload_needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_load_ldt</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">ldt_sel</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="n">load_gs_index</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">gs_sel</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">loadsegment</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">gs_sel</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">fs_reload_needed</span><span class="p">)</span>
		<span class="n">loadsegment</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">fs_sel</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">ds_sel</span> <span class="o">|</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">es_sel</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">loadsegment</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">ds_sel</span><span class="p">);</span>
		<span class="n">loadsegment</span><span class="p">(</span><span class="n">es</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_state</span><span class="p">.</span><span class="n">es_sel</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * The sysexit path does not restore ds/es, so we must set them to</span>
<span class="cm">	 * a reasonable value ourselves.</span>
<span class="cm">	 */</span>
	<span class="n">loadsegment</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">__USER_DS</span><span class="p">);</span>
	<span class="n">loadsegment</span><span class="p">(</span><span class="n">es</span><span class="p">,</span> <span class="n">__USER_DS</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">reload_tss</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_KERNEL_GS_BASE</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">msr_host_kernel_gs_base</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_has_fpu</span><span class="p">())</span>
		<span class="n">clts</span><span class="p">();</span>
	<span class="n">load_gdt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">host_gdt</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_load_host_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">__vmx_load_host_state</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Switches to specified vcpu, until a matching vcpu_put(), but assumes</span>
<span class="cm"> * vcpu mutex is already taken.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_vcpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">phys_addr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">vmxarea</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmm_exclusive</span><span class="p">)</span>
		<span class="n">kvm_cpu_vmxon</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="n">loaded_vmcs_clear</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">current_vmcs</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">current_vmcs</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span><span class="p">;</span>
		<span class="n">vmcs_load</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">gdt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">host_gdt</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysenter_esp</span><span class="p">;</span>

		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TLB_FLUSH</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">loaded_vmcss_on_cpu_link</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">loaded_vmcss_on_cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * Linux uses per-cpu TSS and GDT, so set these when switching</span>
<span class="cm">		 * processors.</span>
<span class="cm">		 */</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_TR_BASE</span><span class="p">,</span> <span class="n">kvm_read_tr_base</span><span class="p">());</span> <span class="cm">/* 22.2.4 */</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_GDTR_BASE</span><span class="p">,</span> <span class="n">gdt</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>   <span class="cm">/* 22.2.4 */</span>

		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_ESP</span><span class="p">,</span> <span class="n">sysenter_esp</span><span class="p">);</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_IA32_SYSENTER_ESP</span><span class="p">,</span> <span class="n">sysenter_esp</span><span class="p">);</span> <span class="cm">/* 22.2.3 */</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_vcpu_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__vmx_load_host_state</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmm_exclusive</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__loaded_vmcs_clear</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">kvm_cpu_vmxoff</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_fpu_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ulong</span> <span class="n">cr0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">fpu_active</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">fpu_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cr0</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">);</span>
	<span class="n">cr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">X86_CR0_TS</span> <span class="o">|</span> <span class="n">X86_CR0_MP</span><span class="p">);</span>
	<span class="n">cr0</span> <span class="o">|=</span> <span class="n">kvm_read_cr0_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR0_TS</span> <span class="o">|</span> <span class="n">X86_CR0_MP</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="n">cr0</span><span class="p">);</span>
	<span class="n">update_exception_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span> <span class="o">=</span> <span class="n">X86_CR0_TS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span> <span class="o">&amp;=</span>
			<span class="o">~</span><span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span><span class="p">;</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_GUEST_HOST_MASK</span><span class="p">,</span> <span class="o">~</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">vmx_decache_cr0_guest_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return the cr0 value that a nested guest would read. This is a combination</span>
<span class="cm"> * of the real cr0 used to run the guest (guest_cr0), and the bits shadowed by</span>
<span class="cm"> * its hypervisor (cr0_read_shadow).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nested_read_cr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">fields</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">fields</span><span class="o">-&gt;</span><span class="n">guest_cr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">fields</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">fields</span><span class="o">-&gt;</span><span class="n">cr0_read_shadow</span> <span class="o">&amp;</span> <span class="n">fields</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nested_read_cr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">fields</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">fields</span><span class="o">-&gt;</span><span class="n">guest_cr4</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">fields</span><span class="o">-&gt;</span><span class="n">cr4_guest_host_mask</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">fields</span><span class="o">-&gt;</span><span class="n">cr4_read_shadow</span> <span class="o">&amp;</span> <span class="n">fields</span><span class="o">-&gt;</span><span class="n">cr4_guest_host_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_fpu_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Note that there is no vcpu-&gt;fpu_active = 0 here. The caller must</span>
<span class="cm">	 * set this *before* calling this function.</span>
<span class="cm">	 */</span>
	<span class="n">vmx_decache_cr0_guest_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vmcs_set_bits</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="n">X86_CR0_TS</span> <span class="o">|</span> <span class="n">X86_CR0_MP</span><span class="p">);</span>
	<span class="n">update_exception_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_GUEST_HOST_MASK</span><span class="p">,</span> <span class="o">~</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * L1&#39;s specified read shadow might not contain the TS bit,</span>
<span class="cm">		 * so now that we turned on shadowing of this bit, we need to</span>
<span class="cm">		 * set this bit of the shadow. Like in nested_vmx_run we need</span>
<span class="cm">		 * nested_read_cr0(vmcs12), but vmcs12-&gt;guest_cr0 is not yet</span>
<span class="cm">		 * up-to-date here because we just decached cr0.TS (and we&#39;ll</span>
<span class="cm">		 * only update vmcs12-&gt;guest_cr0 on nested exit).</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span> <span class="o">=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr0</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">X86_CR0_TS</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_TS</span><span class="p">);</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span> <span class="n">nested_read_cr0</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vmx_get_rflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rflags</span><span class="p">,</span> <span class="n">save_rflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_RFLAGS</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_RFLAGS</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
		<span class="n">rflags</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rflags</span> <span class="o">&amp;=</span> <span class="n">RMODE_GUEST_OWNED_EFLAGS_BITS</span><span class="p">;</span>
			<span class="n">save_rflags</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">save_rflags</span><span class="p">;</span>
			<span class="n">rflags</span> <span class="o">|=</span> <span class="n">save_rflags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RMODE_GUEST_OWNED_EFLAGS_BITS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rflags</span> <span class="o">=</span> <span class="n">rflags</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rflags</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_rflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_RFLAGS</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_CPL</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
	<span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rflags</span> <span class="o">=</span> <span class="n">rflags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">save_rflags</span> <span class="o">=</span> <span class="n">rflags</span><span class="p">;</span>
		<span class="n">rflags</span> <span class="o">|=</span> <span class="n">X86_EFLAGS_IOPL</span> <span class="o">|</span> <span class="n">X86_EFLAGS_VM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">,</span> <span class="n">rflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vmx_get_interrupt_shadow</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">interruptibility</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interruptibility</span> <span class="o">&amp;</span> <span class="n">GUEST_INTR_STATE_STI</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">KVM_X86_SHADOW_INT_STI</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interruptibility</span> <span class="o">&amp;</span> <span class="n">GUEST_INTR_STATE_MOV_SS</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">KVM_X86_SHADOW_INT_MOV_SS</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_interrupt_shadow</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">interruptibility_old</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">interruptibility</span> <span class="o">=</span> <span class="n">interruptibility_old</span><span class="p">;</span>

	<span class="n">interruptibility</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">GUEST_INTR_STATE_STI</span> <span class="o">|</span> <span class="n">GUEST_INTR_STATE_MOV_SS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">KVM_X86_SHADOW_INT_MOV_SS</span><span class="p">)</span>
		<span class="n">interruptibility</span> <span class="o">|=</span> <span class="n">GUEST_INTR_STATE_MOV_SS</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">KVM_X86_SHADOW_INT_STI</span><span class="p">)</span>
		<span class="n">interruptibility</span> <span class="o">|=</span> <span class="n">GUEST_INTR_STATE_STI</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">interruptibility</span> <span class="o">!=</span> <span class="n">interruptibility_old</span><span class="p">))</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">,</span> <span class="n">interruptibility</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skip_emulated_instruction</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rip</span><span class="p">;</span>

	<span class="n">rip</span> <span class="o">=</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">rip</span> <span class="o">+=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">);</span>
	<span class="n">kvm_rip_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">rip</span><span class="p">);</span>

	<span class="cm">/* skipping an emulated instruction also counts */</span>
	<span class="n">vmx_set_interrupt_shadow</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * KVM wants to inject page-faults which it got to the guest. This function</span>
<span class="cm"> * checks whether in a nested guest, we need to inject them to L1 or L2.</span>
<span class="cm"> * This function assumes it is called with the exit reason in vmcs02 being</span>
<span class="cm"> * a #PF exception (this is the only case in which KVM injects a #PF when L2</span>
<span class="cm"> * is running).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nested_pf_handled</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span> <span class="o">=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/* TODO: also check PFEC_MATCH/MASK, not just EB.PF. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">exception_bitmap</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">PF_VECTOR</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nested_vmx_vmexit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_queue_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">has_error_code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">reinject</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">intr_info</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="n">PF_VECTOR</span> <span class="o">&amp;&amp;</span> <span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">nested_pf_handled</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_error_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_EXCEPTION_ERROR_CODE</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
		<span class="n">intr_info</span> <span class="o">|=</span> <span class="n">INTR_INFO_DELIVER_CODE_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">inc_eip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_exception_is_soft</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span>
			<span class="n">inc_eip</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">event_exit_inst_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_inject_realmode_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">inc_eip</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EMULATE_DONE</span><span class="p">)</span>
			<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TRIPLE_FAULT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_exception_is_soft</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INSTRUCTION_LEN</span><span class="p">,</span>
			     <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">event_exit_inst_len</span><span class="p">);</span>
		<span class="n">intr_info</span> <span class="o">|=</span> <span class="n">INTR_TYPE_SOFT_EXCEPTION</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">intr_info</span> <span class="o">|=</span> <span class="n">INTR_TYPE_HARD_EXCEPTION</span><span class="p">;</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">,</span> <span class="n">intr_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmx_rdtscp_supported</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_has_vmx_rdtscp</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Swap MSR entry in host/guest MSR entry array.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_msr_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">shared_msr_entry</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">to</span><span class="p">];</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">from</span><span class="p">];</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up the vmcs to automatically save and restore system</span>
<span class="cm"> * msrs.  Don&#39;t touch the 64-bit msrs if the guest is in legacy</span>
<span class="cm"> * mode, as fiddling with msrs is very expensive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_msrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">save_nmsrs</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">msr_bitmap</span><span class="p">;</span>

	<span class="n">save_nmsrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">__find_msr_index</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">MSR_SYSCALL_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">move_msr_up</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">save_nmsrs</span><span class="o">++</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">__find_msr_index</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">MSR_LSTAR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">move_msr_up</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">save_nmsrs</span><span class="o">++</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">__find_msr_index</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">MSR_CSTAR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">move_msr_up</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">save_nmsrs</span><span class="o">++</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">__find_msr_index</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">MSR_TSC_AUX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rdtscp_enabled</span><span class="p">)</span>
			<span class="n">move_msr_up</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">save_nmsrs</span><span class="o">++</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * MSR_STAR is only needed on long mode guests, and only</span>
<span class="cm">		 * if efer.sce is enabled.</span>
<span class="cm">		 */</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">__find_msr_index</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">MSR_STAR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_SCE</span><span class="p">))</span>
			<span class="n">move_msr_up</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">save_nmsrs</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">__find_msr_index</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">MSR_EFER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">update_transition_efer</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
		<span class="n">move_msr_up</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">save_nmsrs</span><span class="o">++</span><span class="p">);</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">save_nmsrs</span> <span class="o">=</span> <span class="n">save_nmsrs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vmx_msr_bitmap</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="n">msr_bitmap</span> <span class="o">=</span> <span class="n">vmx_msr_bitmap_longmode</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">msr_bitmap</span> <span class="o">=</span> <span class="n">vmx_msr_bitmap_legacy</span><span class="p">;</span>

		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">MSR_BITMAP</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">msr_bitmap</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * reads and returns guest&#39;s timestamp counter &quot;register&quot;</span>
<span class="cm"> * guest_tsc = host_tsc + tsc_offset    -- 21.3</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">guest_read_tsc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">host_tsc</span><span class="p">,</span> <span class="n">tsc_offset</span><span class="p">;</span>

	<span class="n">rdtscll</span><span class="p">(</span><span class="n">host_tsc</span><span class="p">);</span>
	<span class="n">tsc_offset</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">host_tsc</span> <span class="o">+</span> <span class="n">tsc_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Like guest_read_tsc, but always returns L1&#39;s notion of the timestamp</span>
<span class="cm"> * counter, even if a nested guest (L2) is currently running.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">vmx_read_l1_tsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">host_tsc</span><span class="p">,</span> <span class="n">tsc_offset</span><span class="p">;</span>

	<span class="n">rdtscll</span><span class="p">(</span><span class="n">host_tsc</span><span class="p">);</span>
	<span class="n">tsc_offset</span> <span class="o">=</span> <span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs01_tsc_offset</span> <span class="o">:</span>
		<span class="n">vmcs_read64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">host_tsc</span> <span class="o">+</span> <span class="n">tsc_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Engage any workarounds for mis-matched TSC rates.  Currently limited to</span>
<span class="cm"> * software catchup for faster rates on slower CPUs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_tsc_khz</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">user_tsc_khz</span><span class="p">,</span> <span class="n">bool</span> <span class="n">scale</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scale</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_tsc_khz</span> <span class="o">&gt;</span> <span class="n">tsc_khz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_catchup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_always_catchup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;user requested TSC rate below hardware speed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * writes &#39;offset&#39; into guest&#39;s timestamp counter offset register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_write_tsc_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re here if L1 chose not to trap WRMSR to TSC. According</span>
<span class="cm">		 * to the spec, this should set L1&#39;s TSC; The offset that L1</span>
<span class="cm">		 * set for L2 remains unchanged, and still needs to be added</span>
<span class="cm">		 * to the newly set TSC to get L2&#39;s TSC.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">;</span>
		<span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs01_tsc_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="cm">/* recalculate vmcs02.TSC_OFFSET: */</span>
		<span class="n">vmcs12</span> <span class="o">=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_USE_TSC_OFFSETING</span><span class="p">)</span> <span class="o">?</span>
			 <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">tsc_offset</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_adjust_tsc_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">s64</span> <span class="n">adjustment</span><span class="p">,</span> <span class="n">bool</span> <span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">);</span>
	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">adjustment</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Even when running L2, the adjustment needs to apply to L1 */</span>
		<span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs01_tsc_offset</span> <span class="o">+=</span> <span class="n">adjustment</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">vmx_compute_tsc_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">target_tsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">target_tsc</span> <span class="o">-</span> <span class="n">native_read_tsc</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">guest_cpuid_has_vmx</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">best</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">best</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">best</span><span class="o">-&gt;</span><span class="n">ecx</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">X86_FEATURE_VMX</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nested_vmx_allowed() checks whether a guest should be allowed to use VMX</span>
<span class="cm"> * instructions and MSRs (i.e., nested VMX). Nested VMX is disabled for</span>
<span class="cm"> * all guests if the &quot;nested&quot; module option is off, and can also be disabled</span>
<span class="cm"> * for a single guest by disabling its VMX cpuid bit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">nested_vmx_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nested</span> <span class="o">&amp;&amp;</span> <span class="n">guest_cpuid_has_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nested_vmx_setup_ctls_msrs() sets up variables containing the values to be</span>
<span class="cm"> * returned for the various VMX controls MSRs when nested VMX is enabled.</span>
<span class="cm"> * The same values should also be used to verify that vmcs12 control fields are</span>
<span class="cm"> * valid during nested entry from L1 to L2.</span>
<span class="cm"> * Each of these control msrs has a low and high 32-bit half: A low bit is on</span>
<span class="cm"> * if the corresponding bit in the (32-bit) control field *must* be on, and a</span>
<span class="cm"> * bit in the high half is on if the corresponding bit in the control field</span>
<span class="cm"> * may be on. See also vmx_control_verify().</span>
<span class="cm"> * TODO: allow these variables to be modified (downgraded) by module options</span>
<span class="cm"> * or other means.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">nested_vmx_procbased_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_procbased_ctls_high</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">nested_vmx_secondary_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_secondary_ctls_high</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">nested_vmx_pinbased_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_pinbased_ctls_high</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">nested_vmx_exit_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_exit_ctls_high</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">nested_vmx_entry_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_entry_ctls_high</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">nested_vmx_setup_ctls_msrs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note that as a general rule, the high half of the MSRs (bits in</span>
<span class="cm">	 * the control fields which may be 1) should be initialized by the</span>
<span class="cm">	 * intersection of the underlying hardware&#39;s MSR (i.e., features which</span>
<span class="cm">	 * can be supported) and the list of features we want to expose -</span>
<span class="cm">	 * because they are known to be properly supported in our code.</span>
<span class="cm">	 * Also, usually, the low half of the MSRs (bits which must be 1) can</span>
<span class="cm">	 * be set to 0, meaning that L1 may turn off any of these bits. The</span>
<span class="cm">	 * reason is that if one of these bits is necessary, it will appear</span>
<span class="cm">	 * in vmcs01 and prepare_vmcs02, when it bitwise-or&#39;s the control</span>
<span class="cm">	 * fields of vmcs01 and vmcs02, will turn these bits off - and</span>
<span class="cm">	 * nested_vmx_exit_handled() will not pass related exits to L1.</span>
<span class="cm">	 * These rules have exceptions below.</span>
<span class="cm">	 */</span>

	<span class="cm">/* pin-based controls */</span>
	<span class="cm">/*</span>
<span class="cm">	 * According to the Intel spec, if bit 55 of VMX_BASIC is off (as it is</span>
<span class="cm">	 * in our case), bits 1, 2 and 4 (i.e., 0x16) must be 1 in this MSR.</span>
<span class="cm">	 */</span>
	<span class="n">nested_vmx_pinbased_ctls_low</span> <span class="o">=</span> <span class="mh">0x16</span> <span class="p">;</span>
	<span class="n">nested_vmx_pinbased_ctls_high</span> <span class="o">=</span> <span class="mh">0x16</span> <span class="o">|</span>
		<span class="n">PIN_BASED_EXT_INTR_MASK</span> <span class="o">|</span> <span class="n">PIN_BASED_NMI_EXITING</span> <span class="o">|</span>
		<span class="n">PIN_BASED_VIRTUAL_NMIS</span><span class="p">;</span>

	<span class="cm">/* exit controls */</span>
	<span class="n">nested_vmx_exit_ctls_low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Note that guest use of VM_EXIT_ACK_INTR_ON_EXIT is not supported. */</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">nested_vmx_exit_ctls_high</span> <span class="o">=</span> <span class="n">VM_EXIT_HOST_ADDR_SPACE_SIZE</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">nested_vmx_exit_ctls_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* entry controls */</span>
	<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_VMX_ENTRY_CTLS</span><span class="p">,</span>
		<span class="n">nested_vmx_entry_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_entry_ctls_high</span><span class="p">);</span>
	<span class="n">nested_vmx_entry_ctls_low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nested_vmx_entry_ctls_high</span> <span class="o">&amp;=</span>
		<span class="n">VM_ENTRY_LOAD_IA32_PAT</span> <span class="o">|</span> <span class="n">VM_ENTRY_IA32E_MODE</span><span class="p">;</span>

	<span class="cm">/* cpu-based controls */</span>
	<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_VMX_PROCBASED_CTLS</span><span class="p">,</span>
		<span class="n">nested_vmx_procbased_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_procbased_ctls_high</span><span class="p">);</span>
	<span class="n">nested_vmx_procbased_ctls_low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nested_vmx_procbased_ctls_high</span> <span class="o">&amp;=</span>
		<span class="n">CPU_BASED_VIRTUAL_INTR_PENDING</span> <span class="o">|</span> <span class="n">CPU_BASED_USE_TSC_OFFSETING</span> <span class="o">|</span>
		<span class="n">CPU_BASED_HLT_EXITING</span> <span class="o">|</span> <span class="n">CPU_BASED_INVLPG_EXITING</span> <span class="o">|</span>
		<span class="n">CPU_BASED_MWAIT_EXITING</span> <span class="o">|</span> <span class="n">CPU_BASED_CR3_LOAD_EXITING</span> <span class="o">|</span>
		<span class="n">CPU_BASED_CR3_STORE_EXITING</span> <span class="o">|</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="n">CPU_BASED_CR8_LOAD_EXITING</span> <span class="o">|</span> <span class="n">CPU_BASED_CR8_STORE_EXITING</span> <span class="o">|</span>
<span class="cp">#endif</span>
		<span class="n">CPU_BASED_MOV_DR_EXITING</span> <span class="o">|</span> <span class="n">CPU_BASED_UNCOND_IO_EXITING</span> <span class="o">|</span>
		<span class="n">CPU_BASED_USE_IO_BITMAPS</span> <span class="o">|</span> <span class="n">CPU_BASED_MONITOR_EXITING</span> <span class="o">|</span>
		<span class="n">CPU_BASED_RDPMC_EXITING</span> <span class="o">|</span>
		<span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can allow some features even when not supported by the</span>
<span class="cm">	 * hardware. For example, L1 can specify an MSR bitmap - and we</span>
<span class="cm">	 * can use it to avoid exits to L1 - even when L0 runs L2</span>
<span class="cm">	 * without MSR bitmaps.</span>
<span class="cm">	 */</span>
	<span class="n">nested_vmx_procbased_ctls_high</span> <span class="o">|=</span> <span class="n">CPU_BASED_USE_MSR_BITMAPS</span><span class="p">;</span>

	<span class="cm">/* secondary cpu-based controls */</span>
	<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_VMX_PROCBASED_CTLS2</span><span class="p">,</span>
		<span class="n">nested_vmx_secondary_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_secondary_ctls_high</span><span class="p">);</span>
	<span class="n">nested_vmx_secondary_ctls_low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nested_vmx_secondary_ctls_high</span> <span class="o">&amp;=</span>
		<span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">vmx_control_verify</span><span class="p">(</span><span class="n">u32</span> <span class="n">control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Bits 0 in high must be 0, and bits 1 in low must be 1.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">high</span><span class="p">)</span> <span class="o">|</span> <span class="n">low</span><span class="p">)</span> <span class="o">==</span> <span class="n">control</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">vmx_control_msr</span><span class="p">(</span><span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">low</span> <span class="o">|</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">high</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we allow our guest to use VMX instructions (i.e., nested VMX), we should</span>
<span class="cm"> * also let it use VMX-specific MSRs.</span>
<span class="cm"> * vmx_get_vmx_msr() and vmx_set_vmx_msr() return 1 when we handled a</span>
<span class="cm"> * VMX-specific MSR, or 0 when we haven&#39;t (and the caller should handle it</span>
<span class="cm"> * like all other MSRs).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_get_vmx_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">msr_index</span> <span class="o">&gt;=</span> <span class="n">MSR_IA32_VMX_BASIC</span> <span class="o">&amp;&amp;</span>
		     <span class="n">msr_index</span> <span class="o">&lt;=</span> <span class="n">MSR_IA32_VMX_TRUE_ENTRY_CTLS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * According to the spec, processors which do not support VMX</span>
<span class="cm">		 * should throw a #GP(0) when VMX capability MSRs are read.</span>
<span class="cm">		 */</span>
		<span class="n">kvm_queue_exception_e</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">GP_VECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr_index</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSR_IA32_FEATURE_CONTROL</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_BASIC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * This MSR reports some information about VMX support. We</span>
<span class="cm">		 * should return information about the VMX we emulate for the</span>
<span class="cm">		 * guest, and the VMCS structure we give it - not about the</span>
<span class="cm">		 * VMX support of the underlying hardware.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">VMCS12_REVISION</span> <span class="o">|</span>
			   <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">VMCS12_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">VMX_BASIC_VMCS_SIZE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			   <span class="p">(</span><span class="n">VMX_BASIC_MEM_TYPE_WB</span> <span class="o">&lt;&lt;</span> <span class="n">VMX_BASIC_MEM_TYPE_SHIFT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_TRUE_PINBASED_CTLS</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_PINBASED_CTLS</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">vmx_control_msr</span><span class="p">(</span><span class="n">nested_vmx_pinbased_ctls_low</span><span class="p">,</span>
					<span class="n">nested_vmx_pinbased_ctls_high</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_TRUE_PROCBASED_CTLS</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">vmx_control_msr</span><span class="p">(</span><span class="n">nested_vmx_procbased_ctls_low</span><span class="p">,</span>
					<span class="n">nested_vmx_procbased_ctls_high</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_TRUE_EXIT_CTLS</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_EXIT_CTLS</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">vmx_control_msr</span><span class="p">(</span><span class="n">nested_vmx_exit_ctls_low</span><span class="p">,</span>
					<span class="n">nested_vmx_exit_ctls_high</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_TRUE_ENTRY_CTLS</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_ENTRY_CTLS</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">vmx_control_msr</span><span class="p">(</span><span class="n">nested_vmx_entry_ctls_low</span><span class="p">,</span>
					<span class="n">nested_vmx_entry_ctls_high</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_MISC</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * These MSRs specify bits which the guest must keep fixed (on or off)</span>
<span class="cm">	 * while L1 is in VMXON mode (in L1&#39;s root mode, or running an L2).</span>
<span class="cm">	 * We picked the standard core2 setting.</span>
<span class="cm">	 */</span>
<span class="cp">#define VMXON_CR0_ALWAYSON	(X86_CR0_PE | X86_CR0_PG | X86_CR0_NE)</span>
<span class="cp">#define VMXON_CR4_ALWAYSON	X86_CR4_VMXE</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_CR0_FIXED0</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">VMXON_CR0_ALWAYSON</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_CR0_FIXED1</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1ULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_CR4_FIXED0</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">VMXON_CR4_ALWAYSON</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_CR4_FIXED1</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1ULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_VMCS_ENUM</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS2</span>:
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">vmx_control_msr</span><span class="p">(</span><span class="n">nested_vmx_secondary_ctls_low</span><span class="p">,</span>
					<span class="n">nested_vmx_secondary_ctls_high</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_VMX_EPT_VPID_CAP</span>:
		<span class="cm">/* Currently, no nested ept or nested vpid */</span>
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_set_vmx_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msr_index</span> <span class="o">==</span> <span class="n">MSR_IA32_FEATURE_CONTROL</span><span class="p">)</span>
		<span class="cm">/* TODO: the right thing. */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * No need to treat VMX capability MSRs specially: If we don&#39;t handle</span>
<span class="cm">	 * them, handle_wrmsr will #GP(0), which is correct (they are readonly)</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reads an msr value (of &#39;msr_index&#39;) into &#39;pdata&#39;.</span>
<span class="cm"> * Returns 0 on success, non-0 otherwise.</span>
<span class="cm"> * Assumes vcpu_load() was already called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_get_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shared_msr_entry</span> <span class="o">*</span><span class="n">msr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;BUG: get_msr called with NULL pdata</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr_index</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">case</span> <span class="n">MSR_FS_BASE</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_FS_BASE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_GS_BASE</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_GS_BASE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_KERNEL_GS_BASE</span>:
		<span class="n">vmx_load_host_state</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">msr_guest_kernel_gs_base</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">MSR_EFER</span>:
		<span class="k">return</span> <span class="n">kvm_get_msr_common</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MSR_IA32_TSC</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">guest_read_tsc</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_SYSENTER_CS</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_SYSENTER_CS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_SYSENTER_EIP</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_SYSENTER_EIP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_SYSENTER_ESP</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_SYSENTER_ESP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_TSC_AUX</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rdtscp_enabled</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Otherwise falls through */</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmx_get_vmx_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">pdata</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">msr</span> <span class="o">=</span> <span class="n">find_msr_entry</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">msr_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">msr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">kvm_get_msr_common</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Writes msr value into into the appropriate &quot;register&quot;.</span>
<span class="cm"> * Returns 0 on success, non-0 otherwise.</span>
<span class="cm"> * Assumes vcpu_load() was already called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_set_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shared_msr_entry</span> <span class="o">*</span><span class="n">msr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr_index</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSR_EFER</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_set_msr_common</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">case</span> <span class="n">MSR_FS_BASE</span>:
		<span class="n">vmx_segment_cache_clear</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_FS_BASE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_GS_BASE</span>:
		<span class="n">vmx_segment_cache_clear</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_GS_BASE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_KERNEL_GS_BASE</span>:
		<span class="n">vmx_load_host_state</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">msr_guest_kernel_gs_base</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">MSR_IA32_SYSENTER_CS</span>:
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_SYSENTER_CS</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_SYSENTER_EIP</span>:
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_SYSENTER_EIP</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_SYSENTER_ESP</span>:
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_SYSENTER_ESP</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_TSC</span>:
		<span class="n">kvm_write_tsc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_CR_PAT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">vmcs_config</span><span class="p">.</span><span class="n">vmentry_ctrl</span> <span class="o">&amp;</span> <span class="n">VM_ENTRY_LOAD_IA32_PAT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_IA32_PAT</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pat</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_set_msr_common</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_TSC_AUX</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rdtscp_enabled</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Check reserved bit, higher 32 bits should be zero */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Otherwise falls through */</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmx_set_vmx_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msr</span> <span class="o">=</span> <span class="n">find_msr_entry</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">-</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span> <span class="o">&lt;</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">save_nmsrs</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">preempt_disable</span><span class="p">();</span>
				<span class="n">kvm_set_shared_msr</span><span class="p">(</span><span class="n">msr</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">msr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						   <span class="n">msr</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
				<span class="n">preempt_enable</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_set_msr_common</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_cache_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_reg</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VCPU_REGS_RSP</span>:
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RSP</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VCPU_REGS_RIP</span>:
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RIP</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VCPU_EXREG_PDPTR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span>
			<span class="n">ept_save_pdptrs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_guest_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_guest_debug</span> <span class="o">*</span><span class="n">dbg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_USE_HW_BP</span><span class="p">)</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">,</span> <span class="n">dbg</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">debugreg</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span><span class="p">);</span>

	<span class="n">update_exception_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">cpu_has_kvm_support</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_has_vmx</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">vmx_disabled_by_bios</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">msr</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_FEATURE_CONTROL</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">FEATURE_CONTROL_LOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* launched w/ TXT and VMX disabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">tboot_enabled</span><span class="p">())</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* launched w/o TXT and VMX only enabled w/ TXT */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tboot_enabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;kvm: disable TXT in the BIOS or &quot;</span>
				<span class="s">&quot;activate TXT before enabling KVM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* launched w/o TXT and VMX disabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tboot_enabled</span><span class="p">())</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_cpu_vmxon</span><span class="p">(</span><span class="n">u64</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="n">ASM_VMX_VMXON_RAX</span>
			<span class="o">:</span> <span class="o">:</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">),</span> <span class="s">&quot;m&quot;</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
			<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hardware_enable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">garbage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
	<span class="n">u64</span> <span class="n">phys_addr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">vmxarea</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
	<span class="n">u64</span> <span class="n">old</span><span class="p">,</span> <span class="n">test_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_cr4</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">X86_CR4_VMXE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">loaded_vmcss_on_cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_FEATURE_CONTROL</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>

	<span class="n">test_bits</span> <span class="o">=</span> <span class="n">FEATURE_CONTROL_LOCKED</span><span class="p">;</span>
	<span class="n">test_bits</span> <span class="o">|=</span> <span class="n">FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tboot_enabled</span><span class="p">())</span>
		<span class="n">test_bits</span> <span class="o">|=</span> <span class="n">FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">test_bits</span><span class="p">)</span> <span class="o">!=</span> <span class="n">test_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable and lock */</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_FEATURE_CONTROL</span><span class="p">,</span> <span class="n">old</span> <span class="o">|</span> <span class="n">test_bits</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_cr4</span><span class="p">(</span><span class="n">read_cr4</span><span class="p">()</span> <span class="o">|</span> <span class="n">X86_CR4_VMXE</span><span class="p">);</span> <span class="cm">/* FIXME: not cpu hotplug safe */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmm_exclusive</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_cpu_vmxon</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">);</span>
		<span class="n">ept_sync_global</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">store_gdt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">host_gdt</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmclear_local_loaded_vmcss</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">loaded_vmcs</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">loaded_vmcss_on_cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span>
				 <span class="n">loaded_vmcss_on_cpu_link</span><span class="p">)</span>
		<span class="n">__loaded_vmcs_clear</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Just like cpu_vmxoff(), but with the __kvm_handle_fault_on_reboot()</span>
<span class="cm"> * tricks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_cpu_vmxoff</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="n">__ex</span><span class="p">(</span><span class="n">ASM_VMX_VMXOFF</span><span class="p">)</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardware_disable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">garbage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmm_exclusive</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmclear_local_loaded_vmcss</span><span class="p">();</span>
		<span class="n">kvm_cpu_vmxoff</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">write_cr4</span><span class="p">(</span><span class="n">read_cr4</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">X86_CR4_VMXE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">adjust_vmx_controls</span><span class="p">(</span><span class="n">u32</span> <span class="n">ctl_min</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctl_opt</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vmx_msr_low</span><span class="p">,</span> <span class="n">vmx_msr_high</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctl</span> <span class="o">=</span> <span class="n">ctl_min</span> <span class="o">|</span> <span class="n">ctl_opt</span><span class="p">;</span>

	<span class="n">rdmsr</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="n">vmx_msr_low</span><span class="p">,</span> <span class="n">vmx_msr_high</span><span class="p">);</span>

	<span class="n">ctl</span> <span class="o">&amp;=</span> <span class="n">vmx_msr_high</span><span class="p">;</span> <span class="cm">/* bit == 0 in high word ==&gt; must be zero */</span>
	<span class="n">ctl</span> <span class="o">|=</span> <span class="n">vmx_msr_low</span><span class="p">;</span>  <span class="cm">/* bit == 1 in low word  ==&gt; must be one  */</span>

	<span class="cm">/* Ensure minimum (required) set of control bits are supported. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctl_min</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ctl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">ctl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="n">bool</span> <span class="nf">allow_1_setting</span><span class="p">(</span><span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vmx_msr_low</span><span class="p">,</span> <span class="n">vmx_msr_high</span><span class="p">;</span>

	<span class="n">rdmsr</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="n">vmx_msr_low</span><span class="p">,</span> <span class="n">vmx_msr_high</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vmx_msr_high</span> <span class="o">&amp;</span> <span class="n">ctl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_vmcs_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs_config</span> <span class="o">*</span><span class="n">vmcs_conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vmx_msr_low</span><span class="p">,</span> <span class="n">vmx_msr_high</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">min2</span><span class="p">,</span> <span class="n">opt2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_pin_based_exec_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_cpu_based_exec_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_cpu_based_2nd_exec_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_vmexit_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_vmentry_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">min</span> <span class="o">=</span> <span class="n">PIN_BASED_EXT_INTR_MASK</span> <span class="o">|</span> <span class="n">PIN_BASED_NMI_EXITING</span><span class="p">;</span>
	<span class="n">opt</span> <span class="o">=</span> <span class="n">PIN_BASED_VIRTUAL_NMIS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adjust_vmx_controls</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PINBASED_CTLS</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">_pin_based_exec_control</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">min</span> <span class="o">=</span> <span class="n">CPU_BASED_HLT_EXITING</span> <span class="o">|</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	      <span class="n">CPU_BASED_CR8_LOAD_EXITING</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_CR8_STORE_EXITING</span> <span class="o">|</span>
<span class="cp">#endif</span>
	      <span class="n">CPU_BASED_CR3_LOAD_EXITING</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_CR3_STORE_EXITING</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_USE_IO_BITMAPS</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_MOV_DR_EXITING</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_USE_TSC_OFFSETING</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_MWAIT_EXITING</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_MONITOR_EXITING</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_INVLPG_EXITING</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_RDPMC_EXITING</span><span class="p">;</span>

	<span class="n">opt</span> <span class="o">=</span> <span class="n">CPU_BASED_TPR_SHADOW</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_USE_MSR_BITMAPS</span> <span class="o">|</span>
	      <span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adjust_vmx_controls</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_PROCBASED_CTLS</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">_cpu_based_exec_control</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">_cpu_based_exec_control</span> <span class="o">&amp;</span> <span class="n">CPU_BASED_TPR_SHADOW</span><span class="p">))</span>
		<span class="n">_cpu_based_exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_CR8_LOAD_EXITING</span> <span class="o">&amp;</span>
					   <span class="o">~</span><span class="n">CPU_BASED_CR8_STORE_EXITING</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_cpu_based_exec_control</span> <span class="o">&amp;</span> <span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">min2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">opt2</span> <span class="o">=</span> <span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span> <span class="o">|</span>
			<span class="n">SECONDARY_EXEC_WBINVD_EXITING</span> <span class="o">|</span>
			<span class="n">SECONDARY_EXEC_ENABLE_VPID</span> <span class="o">|</span>
			<span class="n">SECONDARY_EXEC_ENABLE_EPT</span> <span class="o">|</span>
			<span class="n">SECONDARY_EXEC_UNRESTRICTED_GUEST</span> <span class="o">|</span>
			<span class="n">SECONDARY_EXEC_PAUSE_LOOP_EXITING</span> <span class="o">|</span>
			<span class="n">SECONDARY_EXEC_RDTSCP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adjust_vmx_controls</span><span class="p">(</span><span class="n">min2</span><span class="p">,</span> <span class="n">opt2</span><span class="p">,</span>
					<span class="n">MSR_IA32_VMX_PROCBASED_CTLS2</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">_cpu_based_2nd_exec_control</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifndef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">_cpu_based_2nd_exec_control</span> <span class="o">&amp;</span>
				<span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span><span class="p">))</span>
		<span class="n">_cpu_based_exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_TPR_SHADOW</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_cpu_based_2nd_exec_control</span> <span class="o">&amp;</span> <span class="n">SECONDARY_EXEC_ENABLE_EPT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* CR3 accesses and invlpg don&#39;t need to cause VM Exits when EPT</span>
<span class="cm">		   enabled */</span>
		<span class="n">_cpu_based_exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CPU_BASED_CR3_LOAD_EXITING</span> <span class="o">|</span>
					     <span class="n">CPU_BASED_CR3_STORE_EXITING</span> <span class="o">|</span>
					     <span class="n">CPU_BASED_INVLPG_EXITING</span><span class="p">);</span>
		<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_VMX_EPT_VPID_CAP</span><span class="p">,</span>
		      <span class="n">vmx_capability</span><span class="p">.</span><span class="n">ept</span><span class="p">,</span> <span class="n">vmx_capability</span><span class="p">.</span><span class="n">vpid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">min</span> <span class="o">|=</span> <span class="n">VM_EXIT_HOST_ADDR_SPACE_SIZE</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">opt</span> <span class="o">=</span> <span class="n">VM_EXIT_SAVE_IA32_PAT</span> <span class="o">|</span> <span class="n">VM_EXIT_LOAD_IA32_PAT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adjust_vmx_controls</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_EXIT_CTLS</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">_vmexit_control</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">opt</span> <span class="o">=</span> <span class="n">VM_ENTRY_LOAD_IA32_PAT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adjust_vmx_controls</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">MSR_IA32_VMX_ENTRY_CTLS</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">_vmentry_control</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_VMX_BASIC</span><span class="p">,</span> <span class="n">vmx_msr_low</span><span class="p">,</span> <span class="n">vmx_msr_high</span><span class="p">);</span>

	<span class="cm">/* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vmx_msr_high</span> <span class="o">&amp;</span> <span class="mh">0x1fff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="cm">/* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx_msr_high</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1u</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Require Write-Back (WB) memory type for VMCS accesses. */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">vmx_msr_high</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">vmcs_conf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">vmx_msr_high</span> <span class="o">&amp;</span> <span class="mh">0x1fff</span><span class="p">;</span>
	<span class="n">vmcs_conf</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">vmcs_config</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="n">vmcs_conf</span><span class="o">-&gt;</span><span class="n">revision_id</span> <span class="o">=</span> <span class="n">vmx_msr_low</span><span class="p">;</span>

	<span class="n">vmcs_conf</span><span class="o">-&gt;</span><span class="n">pin_based_exec_ctrl</span> <span class="o">=</span> <span class="n">_pin_based_exec_control</span><span class="p">;</span>
	<span class="n">vmcs_conf</span><span class="o">-&gt;</span><span class="n">cpu_based_exec_ctrl</span> <span class="o">=</span> <span class="n">_cpu_based_exec_control</span><span class="p">;</span>
	<span class="n">vmcs_conf</span><span class="o">-&gt;</span><span class="n">cpu_based_2nd_exec_ctrl</span> <span class="o">=</span> <span class="n">_cpu_based_2nd_exec_control</span><span class="p">;</span>
	<span class="n">vmcs_conf</span><span class="o">-&gt;</span><span class="n">vmexit_ctrl</span>         <span class="o">=</span> <span class="n">_vmexit_control</span><span class="p">;</span>
	<span class="n">vmcs_conf</span><span class="o">-&gt;</span><span class="n">vmentry_ctrl</span>        <span class="o">=</span> <span class="n">_vmentry_control</span><span class="p">;</span>

	<span class="n">cpu_has_load_ia32_efer</span> <span class="o">=</span>
		<span class="n">allow_1_setting</span><span class="p">(</span><span class="n">MSR_IA32_VMX_ENTRY_CTLS</span><span class="p">,</span>
				<span class="n">VM_ENTRY_LOAD_IA32_EFER</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">allow_1_setting</span><span class="p">(</span><span class="n">MSR_IA32_VMX_EXIT_CTLS</span><span class="p">,</span>
				   <span class="n">VM_EXIT_LOAD_IA32_EFER</span><span class="p">);</span>

	<span class="n">cpu_has_load_perf_global_ctrl</span> <span class="o">=</span>
		<span class="n">allow_1_setting</span><span class="p">(</span><span class="n">MSR_IA32_VMX_ENTRY_CTLS</span><span class="p">,</span>
				<span class="n">VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">allow_1_setting</span><span class="p">(</span><span class="n">MSR_IA32_VMX_EXIT_CTLS</span><span class="p">,</span>
				   <span class="n">VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some cpus support VM_ENTRY_(LOAD|SAVE)_IA32_PERF_GLOBAL_CTRL</span>
<span class="cm">	 * but due to arrata below it can&#39;t be used. Workaround is to use</span>
<span class="cm">	 * msr load mechanism to switch IA32_PERF_GLOBAL_CTRL.</span>
<span class="cm">	 *</span>
<span class="cm">	 * VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]</span>
<span class="cm">	 *</span>
<span class="cm">	 * AAK155             (model 26)</span>
<span class="cm">	 * AAP115             (model 30)</span>
<span class="cm">	 * AAT100             (model 37)</span>
<span class="cm">	 * BC86,AAY89,BD102   (model 44)</span>
<span class="cm">	 * BA97               (model 46)</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_load_perf_global_ctrl</span> <span class="o">&amp;&amp;</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_model</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">26</span>:
		<span class="k">case</span> <span class="mi">30</span>:
		<span class="k">case</span> <span class="mi">37</span>:
		<span class="k">case</span> <span class="mi">44</span>:
		<span class="k">case</span> <span class="mi">46</span>:
			<span class="n">cpu_has_load_perf_global_ctrl</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL &quot;</span>
					<span class="s">&quot;does not work properly. Using workaround</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="nf">alloc_vmcs_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="n">vmcs</span><span class="p">;</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">alloc_pages_exact_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vmcs</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vmcs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="n">vmcs</span><span class="o">-&gt;</span><span class="n">revision_id</span> <span class="o">=</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">revision_id</span><span class="p">;</span> <span class="cm">/* vmcs revision id */</span>
	<span class="k">return</span> <span class="n">vmcs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="nf">alloc_vmcs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_vmcs_cpu</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_vmcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="n">vmcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmcs</span><span class="p">,</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free a VMCS, but before that VMCLEAR it on the CPU where it was last loaded</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_loaded_vmcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">loaded_vmcs</span> <span class="o">*</span><span class="n">loaded_vmcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">loaded_vmcs_clear</span><span class="p">(</span><span class="n">loaded_vmcs</span><span class="p">);</span>
	<span class="n">free_vmcs</span><span class="p">(</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span><span class="p">);</span>
	<span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_kvm_area</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_vmcs</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">vmxarea</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">vmxarea</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">alloc_kvm_area</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmcs</span> <span class="o">*</span><span class="n">vmcs</span><span class="p">;</span>

		<span class="n">vmcs</span> <span class="o">=</span> <span class="n">alloc_vmcs_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmcs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_kvm_area</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">per_cpu</span><span class="p">(</span><span class="n">vmxarea</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">vmcs</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">hardware_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">setup_vmcs_config</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmcs_config</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_NX</span><span class="p">))</span>
		<span class="n">kvm_enable_efer_bits</span><span class="p">(</span><span class="n">EFER_NX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_vmx_vpid</span><span class="p">())</span>
		<span class="n">enable_vpid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_vmx_ept</span><span class="p">()</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">cpu_has_vmx_ept_4levels</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">enable_ept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">enable_unrestricted_guest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_vmx_unrestricted_guest</span><span class="p">())</span>
		<span class="n">enable_unrestricted_guest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_vmx_flexpriority</span><span class="p">())</span>
		<span class="n">flexpriority_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_vmx_tpr_shadow</span><span class="p">())</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">update_cr8_intercept</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_has_vmx_ept_2m_page</span><span class="p">())</span>
		<span class="n">kvm_disable_largepages</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_vmx_ple</span><span class="p">())</span>
		<span class="n">ple_gap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nested</span><span class="p">)</span>
		<span class="n">nested_vmx_setup_ctls_msrs</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">alloc_kvm_area</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__exit</span> <span class="kt">void</span> <span class="nf">hardware_unsetup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_kvm_area</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fix_pmode_dataseg</span><span class="p">(</span><span class="kt">int</span> <span class="n">seg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_save_segment</span> <span class="o">*</span><span class="n">save</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vmx_segment_field</span> <span class="o">*</span><span class="n">sf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvm_vmx_segment_fields</span><span class="p">[</span><span class="n">seg</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">==</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">save</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&amp;</span> <span class="n">AR_S_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">,</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">);</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">);</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">ar_bytes</span><span class="p">,</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">ar</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">dpl</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmcs_read16</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SELECTOR_RPL_MASK</span><span class="p">)</span>
			<span class="o">&lt;&lt;</span> <span class="n">AR_DPL_SHIFT</span><span class="p">;</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">ar_bytes</span><span class="p">,</span> <span class="mh">0x93</span> <span class="o">|</span> <span class="n">dpl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enter_pmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">emulation_required</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vmx_segment_cache_clear</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_TR_SELECTOR</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">selector</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_TR_BASE</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">base</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_TR_LIMIT</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_TR_AR_BYTES</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">ar</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">RMODE_GUEST_OWNED_EFLAGS_BITS</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">save_rflags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RMODE_GUEST_OWNED_EFLAGS_BITS</span><span class="p">;</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="p">(</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">X86_CR4_VME</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">CR4_READ_SHADOW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">X86_CR4_VME</span><span class="p">));</span>

	<span class="n">update_exception_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emulate_invalid_guest_state</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fix_pmode_dataseg</span><span class="p">(</span><span class="n">VCPU_SREG_ES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">es</span><span class="p">);</span>
	<span class="n">fix_pmode_dataseg</span><span class="p">(</span><span class="n">VCPU_SREG_DS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">ds</span><span class="p">);</span>
	<span class="n">fix_pmode_dataseg</span><span class="p">(</span><span class="n">VCPU_SREG_GS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">gs</span><span class="p">);</span>
	<span class="n">fix_pmode_dataseg</span><span class="p">(</span><span class="n">VCPU_SREG_FS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">fs</span><span class="p">);</span>

	<span class="n">vmx_segment_cache_clear</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_SS_SELECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_SS_AR_BYTES</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">);</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">,</span>
		     <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SELECTOR_RPL_MASK</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_CS_AR_BYTES</span><span class="p">,</span> <span class="mh">0x9b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gva_t</span> <span class="nf">rmode_tss_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tss_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
		<span class="n">gfn_t</span> <span class="n">base_gfn</span><span class="p">;</span>

		<span class="n">slots</span> <span class="o">=</span> <span class="n">kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">id_to_memslot</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">base_gfn</span> <span class="o">=</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">+</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">base_gfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tss_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fix_rmode_seg</span><span class="p">(</span><span class="kt">int</span> <span class="n">seg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_save_segment</span> <span class="o">*</span><span class="n">save</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vmx_segment_field</span> <span class="o">*</span><span class="n">sf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvm_vmx_segment_fields</span><span class="p">[</span><span class="n">seg</span><span class="p">];</span>

	<span class="n">save</span><span class="o">-&gt;</span><span class="n">selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">);</span>
	<span class="n">save</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">save</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">);</span>
	<span class="n">save</span><span class="o">-&gt;</span><span class="n">ar</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">ar_bytes</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">,</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&amp;</span> <span class="mh">0xffff0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">ar_bytes</span><span class="p">,</span> <span class="mh">0xf3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">save</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;kvm: segment base is not paragraph&quot;</span>
			    <span class="s">&quot; aligned when entering protected mode (seg=%d)&quot;</span><span class="p">,</span>
			    <span class="n">seg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enter_rmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_unrestricted_guest</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">emulation_required</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Very old userspace does not call KVM_SET_TSS_ADDR before entering</span>
<span class="cm">	 * vcpu. Call it here with phys address pointing 16M below 4G.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tss_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;kvm: KVM_SET_TSS_ADDR need to be &quot;</span>
			     <span class="s">&quot;called before entering vcpu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>
		<span class="n">vmx_set_tss_addr</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="mh">0xfeffd000</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vmx_segment_cache_clear</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_TR_SELECTOR</span><span class="p">);</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_TR_BASE</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_TR_BASE</span><span class="p">,</span> <span class="n">rmode_tss_base</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">));</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_TR_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_TR_LIMIT</span><span class="p">,</span> <span class="n">RMODE_TSS_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">ar</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_TR_AR_BYTES</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_TR_AR_BYTES</span><span class="p">,</span> <span class="mh">0x008b</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">);</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">save_rflags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">X86_EFLAGS_IOPL</span> <span class="o">|</span> <span class="n">X86_EFLAGS_VM</span><span class="p">;</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">)</span> <span class="o">|</span> <span class="n">X86_CR4_VME</span><span class="p">);</span>
	<span class="n">update_exception_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emulate_invalid_guest_state</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">continue_rmode</span><span class="p">;</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_SS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_SS_BASE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_SS_LIMIT</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_SS_AR_BYTES</span><span class="p">,</span> <span class="mh">0xf3</span><span class="p">);</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_CS_AR_BYTES</span><span class="p">,</span> <span class="mh">0xf3</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_CS_LIMIT</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xffff0000</span><span class="p">)</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">,</span> <span class="mh">0xf0000</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">fix_rmode_seg</span><span class="p">(</span><span class="n">VCPU_SREG_ES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">es</span><span class="p">);</span>
	<span class="n">fix_rmode_seg</span><span class="p">(</span><span class="n">VCPU_SREG_DS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">ds</span><span class="p">);</span>
	<span class="n">fix_rmode_seg</span><span class="p">(</span><span class="n">VCPU_SREG_GS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">gs</span><span class="p">);</span>
	<span class="n">fix_rmode_seg</span><span class="p">(</span><span class="n">VCPU_SREG_FS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">fs</span><span class="p">);</span>

<span class="nl">continue_rmode:</span>
	<span class="n">kvm_mmu_reset_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_efer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">efer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shared_msr_entry</span> <span class="o">*</span><span class="n">msr</span> <span class="o">=</span> <span class="n">find_msr_entry</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">MSR_EFER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Force kernel_gs_base reloading before EFER changes, as control</span>
<span class="cm">	 * of this msr depends on is_long_mode().</span>
<span class="cm">	 */</span>
	<span class="n">vmx_load_host_state</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">=</span> <span class="n">efer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_LMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span>
			     <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">VM_ENTRY_IA32E_MODE</span><span class="p">);</span>
		<span class="n">msr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">efer</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span>
			     <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">)</span> <span class="o">&amp;</span>
			     <span class="o">~</span><span class="n">VM_ENTRY_IA32E_MODE</span><span class="p">);</span>

		<span class="n">msr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">efer</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EFER_LME</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">setup_msrs</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enter_lmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">guest_tr_ar</span><span class="p">;</span>

	<span class="n">vmx_segment_cache_clear</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>

	<span class="n">guest_tr_ar</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_TR_AR_BYTES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">guest_tr_ar</span> <span class="o">&amp;</span> <span class="n">AR_TYPE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">AR_TYPE_BUSY_64_TSS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug_ratelimited</span><span class="p">(</span><span class="s">&quot;%s: tss fixup for long mode. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_TR_AR_BYTES</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">guest_tr_ar</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AR_TYPE_MASK</span><span class="p">)</span>
			     <span class="o">|</span> <span class="n">AR_TYPE_BUSY_64_TSS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vmx_set_efer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">|</span> <span class="n">EFER_LMA</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">exit_lmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span>
		     <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">)</span>
		     <span class="o">&amp;</span> <span class="o">~</span><span class="n">VM_ENTRY_IA32E_MODE</span><span class="p">);</span>
	<span class="n">vmx_set_efer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EFER_LMA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_flush_tlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vpid_sync_context</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">ept_sync_context</span><span class="p">(</span><span class="n">construct_eptp</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_decache_cr0_guest_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ulong</span> <span class="n">cr0_guest_owned_bits</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cr0_guest_owned_bits</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">|=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cr0_guest_owned_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_decache_cr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span> <span class="o">&amp;&amp;</span> <span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr3</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_CR3</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_decache_cr4_guest_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ulong</span> <span class="n">cr4_guest_owned_bits</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cr4_guest_owned_bits</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4</span> <span class="o">|=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cr4_guest_owned_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ept_load_pdptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_PDPTR</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_dirty</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_PDPTR0</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pdptrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_PDPTR1</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pdptrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_PDPTR2</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pdptrs</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_PDPTR3</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pdptrs</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ept_save_pdptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pdptrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">GUEST_PDPTR0</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pdptrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">GUEST_PDPTR1</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pdptrs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">GUEST_PDPTR2</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pdptrs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">GUEST_PDPTR3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_PDPTR</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_PDPTR</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_dirty</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">vmx_set_cr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr4</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ept_update_paging_mode_cr0</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">hw_cr0</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr0</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_CR3</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">))</span>
		<span class="n">vmx_decache_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_PG</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* From paging/starting to nonpaging */</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span>
			     <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">)</span> <span class="o">|</span>
			     <span class="p">(</span><span class="n">CPU_BASED_CR3_LOAD_EXITING</span> <span class="o">|</span>
			      <span class="n">CPU_BASED_CR3_STORE_EXITING</span><span class="p">));</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">=</span> <span class="n">cr0</span><span class="p">;</span>
		<span class="n">vmx_set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_read_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* From nonpaging to paging */</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span>
			     <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span>
			     <span class="o">~</span><span class="p">(</span><span class="n">CPU_BASED_CR3_LOAD_EXITING</span> <span class="o">|</span>
			       <span class="n">CPU_BASED_CR3_STORE_EXITING</span><span class="p">));</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">=</span> <span class="n">cr0</span><span class="p">;</span>
		<span class="n">vmx_set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_read_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_WP</span><span class="p">))</span>
		<span class="o">*</span><span class="n">hw_cr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_CR0_WP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_cr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr0</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hw_cr0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_unrestricted_guest</span><span class="p">)</span>
		<span class="n">hw_cr0</span> <span class="o">=</span> <span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">KVM_GUEST_CR0_MASK_UNRESTRICTED_GUEST</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw_cr0</span> <span class="o">=</span> <span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">KVM_GUEST_CR0_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">KVM_VM_CR0_ALWAYS_ON</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_PE</span><span class="p">))</span>
		<span class="n">enter_pmode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_PE</span><span class="p">))</span>
		<span class="n">enter_rmode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_LME</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_PG</span><span class="p">))</span>
			<span class="n">enter_lmode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_PG</span><span class="p">))</span>
			<span class="n">exit_lmode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span>
		<span class="n">ept_update_paging_mode_cr0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw_cr0</span><span class="p">,</span> <span class="n">cr0</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">fpu_active</span><span class="p">)</span>
		<span class="n">hw_cr0</span> <span class="o">|=</span> <span class="n">X86_CR0_TS</span> <span class="o">|</span> <span class="n">X86_CR0_MP</span><span class="p">;</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span> <span class="n">cr0</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">,</span> <span class="n">hw_cr0</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">=</span> <span class="n">cr0</span><span class="p">;</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_CPL</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">construct_eptp</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">root_hpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">eptp</span><span class="p">;</span>

	<span class="cm">/* TODO write the value reading from MSR */</span>
	<span class="n">eptp</span> <span class="o">=</span> <span class="n">VMX_EPT_DEFAULT_MT</span> <span class="o">|</span>
		<span class="n">VMX_EPT_DEFAULT_GAW</span> <span class="o">&lt;&lt;</span> <span class="n">VMX_EPT_GAW_EPTP_SHIFT</span><span class="p">;</span>
	<span class="n">eptp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">root_hpa</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">eptp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_cr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">guest_cr3</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">eptp</span><span class="p">;</span>

	<span class="n">guest_cr3</span> <span class="o">=</span> <span class="n">cr3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eptp</span> <span class="o">=</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="n">cr3</span><span class="p">);</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">EPT_POINTER</span><span class="p">,</span> <span class="n">eptp</span><span class="p">);</span>
		<span class="n">guest_cr3</span> <span class="o">=</span> <span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">?</span> <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_map_addr</span><span class="p">;</span>
		<span class="n">ept_load_pdptrs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vmx_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CR3</span><span class="p">,</span> <span class="n">guest_cr3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_set_cr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr4</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hw_cr4</span> <span class="o">=</span> <span class="n">cr4</span> <span class="o">|</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span> <span class="o">?</span>
		    <span class="n">KVM_RMODE_VM_CR4_ALWAYS_ON</span> <span class="o">:</span> <span class="n">KVM_PMODE_VM_CR4_ALWAYS_ON</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="n">X86_CR4_VMXE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * To use VMXON (and later other VMX instructions), a guest</span>
<span class="cm">		 * must first be able to turn on cr4.VMXE (see handle_vmon()).</span>
<span class="cm">		 * So basically the check on whether to allow nested VMX</span>
<span class="cm">		 * is here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmxon</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4</span> <span class="o">=</span> <span class="n">cr4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hw_cr4</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_CR4_PAE</span><span class="p">;</span>
			<span class="n">hw_cr4</span> <span class="o">|=</span> <span class="n">X86_CR4_PSE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="n">X86_CR4_PAE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hw_cr4</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_CR4_PAE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR4_READ_SHADOW</span><span class="p">,</span> <span class="n">cr4</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">,</span> <span class="n">hw_cr4</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_get_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kvm_segment</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kvm_save_segment</span> <span class="o">*</span><span class="n">save</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ar</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">seg</span> <span class="o">==</span> <span class="n">VCPU_SREG_TR</span> <span class="o">||</span> <span class="n">seg</span> <span class="o">==</span> <span class="n">VCPU_SREG_ES</span>
		<span class="o">||</span> <span class="n">seg</span> <span class="o">==</span> <span class="n">VCPU_SREG_DS</span> <span class="o">||</span> <span class="n">seg</span> <span class="o">==</span> <span class="n">VCPU_SREG_FS</span>
		<span class="o">||</span> <span class="n">seg</span> <span class="o">==</span> <span class="n">VCPU_SREG_GS</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">emulate_invalid_guest_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">VCPU_SREG_TR</span>: <span class="n">save</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VCPU_SREG_ES</span>: <span class="n">save</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">es</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VCPU_SREG_DS</span>: <span class="n">save</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">ds</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VCPU_SREG_FS</span>: <span class="n">save</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">fs</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VCPU_SREG_GS</span>: <span class="n">save</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">gs</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">var</span><span class="o">-&gt;</span><span class="n">selector</span> <span class="o">=</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">;</span>
		<span class="n">var</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">var</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">;</span>
		<span class="n">ar</span> <span class="o">=</span> <span class="n">save</span><span class="o">-&gt;</span><span class="n">ar</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seg</span> <span class="o">==</span> <span class="n">VCPU_SREG_TR</span>
		    <span class="o">||</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">selector</span> <span class="o">==</span> <span class="n">vmx_read_guest_seg_selector</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">seg</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">use_saved_rmode_seg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">vmx_read_guest_seg_base</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">vmx_read_guest_seg_limit</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">selector</span> <span class="o">=</span> <span class="n">vmx_read_guest_seg_selector</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
	<span class="n">ar</span> <span class="o">=</span> <span class="n">vmx_read_guest_seg_ar</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
<span class="nl">use_saved_rmode_seg:</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ar</span> <span class="o">&amp;</span> <span class="n">AR_UNUSABLE_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">emulate_invalid_guest_state</span><span class="p">)</span>
		<span class="n">ar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ar</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">dpl</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">avl</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">db</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">unusable</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">vmx_get_segment_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">vmx_read_guest_seg_base</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">seg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vmx_get_cpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_protmode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">kvm_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_VM</span><span class="p">))</span> <span class="cm">/* if virtual 8086 */</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vmx_read_guest_seg_selector</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">VCPU_SREG_CS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_get_cpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_CPL</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_CPL</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
		<span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpl</span> <span class="o">=</span> <span class="n">__vmx_get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpl</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">u32</span> <span class="nf">vmx_segment_access_rights</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_segment</span> <span class="o">*</span><span class="n">var</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ar</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">unusable</span><span class="p">)</span>
		<span class="n">ar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ar</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
		<span class="n">ar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">ar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">dpl</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">ar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">ar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">avl</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">ar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">;</span>
		<span class="n">ar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">db</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">;</span>
		<span class="n">ar</span> <span class="o">|=</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ar</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* a 0 value means unusable */</span>
		<span class="n">ar</span> <span class="o">=</span> <span class="n">AR_UNUSABLE_MASK</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ar</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kvm_segment</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kvm_vmx_segment_field</span> <span class="o">*</span><span class="n">sf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvm_vmx_segment_fields</span><span class="p">[</span><span class="n">seg</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">ar</span><span class="p">;</span>

	<span class="n">vmx_segment_cache_clear</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span> <span class="o">&amp;&amp;</span> <span class="n">seg</span> <span class="o">==</span> <span class="n">VCPU_SREG_TR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">,</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">tr</span><span class="p">.</span><span class="n">ar</span> <span class="o">=</span> <span class="n">vmx_segment_access_rights</span><span class="p">(</span><span class="n">var</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">,</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span> <span class="o">&amp;&amp;</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Hack real-mode segments into vm86 compatibility.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">==</span> <span class="mh">0xffff0000</span> <span class="o">&amp;&amp;</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">selector</span> <span class="o">==</span> <span class="mh">0xf000</span><span class="p">)</span>
			<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mh">0xf0000</span><span class="p">);</span>
		<span class="n">ar</span> <span class="o">=</span> <span class="mh">0xf3</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ar</span> <span class="o">=</span> <span class="n">vmx_segment_access_rights</span><span class="p">(</span><span class="n">var</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *   Fix the &quot;Accessed&quot; bit in AR field of segment registers for older</span>
<span class="cm">	 * qemu binaries.</span>
<span class="cm">	 *   IA32 arch specifies that at the time of processor reset the</span>
<span class="cm">	 * &quot;Accessed&quot; bit in the AR field of segment registers is 1. And qemu</span>
<span class="cm">	 * is setting it to 0 in the usedland code. This causes invalid guest</span>
<span class="cm">	 * state vmexit when &quot;unrestricted guest&quot; mode is turned on.</span>
<span class="cm">	 *    Fix for this setup issue in cpu_reset is being pushed in the qemu</span>
<span class="cm">	 * tree. Newer qemu binaries with that qemu fix would not need this</span>
<span class="cm">	 * kvm hack.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_unrestricted_guest</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">seg</span> <span class="o">!=</span> <span class="n">VCPU_SREG_LDTR</span><span class="p">))</span>
		<span class="n">ar</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span> <span class="cm">/* Accessed */</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">ar_bytes</span><span class="p">,</span> <span class="n">ar</span><span class="p">);</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_CPL</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_get_cs_db_l_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">db</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ar</span> <span class="o">=</span> <span class="n">vmx_read_guest_seg_ar</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>

	<span class="o">*</span><span class="n">db</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_get_idt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_IDTR_LIMIT</span><span class="p">);</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_IDTR_BASE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_idt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_IDTR_LIMIT</span><span class="p">,</span> <span class="n">dt</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_IDTR_BASE</span><span class="p">,</span> <span class="n">dt</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_get_gdt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_GDTR_LIMIT</span><span class="p">);</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_GDTR_BASE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_gdt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_GDTR_LIMIT</span><span class="p">,</span> <span class="n">dt</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_GDTR_BASE</span><span class="p">,</span> <span class="n">dt</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">rmode_segment_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">var</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ar</span><span class="p">;</span>

	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">var</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
	<span class="n">ar</span> <span class="o">=</span> <span class="n">vmx_segment_access_rights</span><span class="p">(</span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">base</span> <span class="o">!=</span> <span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">selector</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">limit</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ar</span> <span class="o">!=</span> <span class="mh">0xf3</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">code_segment_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">cs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cs_rpl</span><span class="p">;</span>

	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>
	<span class="n">cs_rpl</span> <span class="o">=</span> <span class="n">cs</span><span class="p">.</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="n">SELECTOR_RPL_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="p">.</span><span class="n">unusable</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">cs</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR_TYPE_CODE_MASK</span><span class="o">|</span><span class="n">AR_TYPE_ACCESSES_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cs</span><span class="p">.</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AR_TYPE_WRITEABLE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="p">.</span><span class="n">dpl</span> <span class="o">&gt;</span> <span class="n">cs_rpl</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="p">.</span><span class="n">dpl</span> <span class="o">!=</span> <span class="n">cs_rpl</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cs</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* TODO: Add Reserved field check, this&#39;ll require a new member in the kvm_segment_field structure */</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">stack_segment_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">ss</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ss_rpl</span><span class="p">;</span>

	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">,</span> <span class="n">VCPU_SREG_SS</span><span class="p">);</span>
	<span class="n">ss_rpl</span> <span class="o">=</span> <span class="n">ss</span><span class="p">.</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="n">SELECTOR_RPL_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="p">.</span><span class="n">unusable</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">ss</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="p">.</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="p">.</span><span class="n">dpl</span> <span class="o">!=</span> <span class="n">ss_rpl</span><span class="p">)</span> <span class="cm">/* DPL != RPL */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">data_segment_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">var</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rpl</span><span class="p">;</span>

	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">var</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
	<span class="n">rpl</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="n">SELECTOR_RPL_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">unusable</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">var</span><span class="p">.</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">var</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">var</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AR_TYPE_CODE_MASK</span><span class="o">|</span><span class="n">AR_TYPE_WRITEABLE_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">dpl</span> <span class="o">&lt;</span> <span class="n">rpl</span><span class="p">)</span> <span class="cm">/* DPL &lt; RPL */</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* TODO: Add other members to kvm_segment_field to allow checking for other access</span>
<span class="cm">	 * rights flags</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">tr_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">tr</span><span class="p">;</span>

	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tr</span><span class="p">,</span> <span class="n">VCPU_SREG_TR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">unusable</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="n">SELECTOR_TI_MASK</span><span class="p">)</span>	<span class="cm">/* TI = 1 */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">tr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="mi">11</span><span class="p">)</span> <span class="cm">/* TODO: Check if guest is in IA32e mode */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tr</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">ldtr_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">ldtr</span><span class="p">;</span>

	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldtr</span><span class="p">,</span> <span class="n">VCPU_SREG_LDTR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ldtr</span><span class="p">.</span><span class="n">unusable</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ldtr</span><span class="p">.</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="n">SELECTOR_TI_MASK</span><span class="p">)</span>	<span class="cm">/* TI = 1 */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ldtr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ldtr</span><span class="p">.</span><span class="n">present</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">cs_ss_rpl_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">cs</span><span class="p">,</span> <span class="n">ss</span><span class="p">;</span>

	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>
	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">,</span> <span class="n">VCPU_SREG_SS</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">cs</span><span class="p">.</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="n">SELECTOR_RPL_MASK</span><span class="p">)</span> <span class="o">==</span>
		 <span class="p">(</span><span class="n">ss</span><span class="p">.</span><span class="n">selector</span> <span class="o">&amp;</span> <span class="n">SELECTOR_RPL_MASK</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if guest state is valid. Returns true if valid, false if</span>
<span class="cm"> * not.</span>
<span class="cm"> * We assume that registers are always usable</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">guest_state_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* real mode guest state checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_protmode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmode_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmode_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_SS</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmode_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_DS</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmode_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_ES</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmode_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_FS</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmode_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_GS</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="cm">/* protected mode guest state checks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cs_ss_rpl_check</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">code_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stack_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_DS</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_ES</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_FS</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_segment_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_GS</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tr_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ldtr_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* TODO:</span>
<span class="cm">	 * - Add checks on RIP</span>
<span class="cm">	 * - Add checks on RFLAGS</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_rmode_tss</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">fn</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">fn</span> <span class="o">=</span> <span class="n">rmode_tss_base</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_clear_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">TSS_BASE_SIZE</span> <span class="o">+</span> <span class="n">TSS_REDIRECTION_SIZE</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_write_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">fn</span><span class="o">++</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>
			<span class="n">TSS_IOPB_BASE_OFFSET</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_clear_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">fn</span><span class="o">++</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_clear_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_write_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>
				 <span class="n">RMODE_TSS_SIZE</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_rmode_identity_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">pfn_t</span> <span class="n">identity_map_pfn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_ept</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_pagetable</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EPT: identity-mapping pagetable &quot;</span>
			<span class="s">&quot;haven&#39;t been allocated!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_pagetable_done</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">identity_map_pfn</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_map_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_clear_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">identity_map_pfn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* Set up identity-mapping pagetable for EPT in real mode */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PT32_ENT_PER_PAGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">_PAGE_PRESENT</span> <span class="o">|</span> <span class="n">_PAGE_RW</span> <span class="o">|</span> <span class="n">_PAGE_USER</span> <span class="o">|</span>
			<span class="n">_PAGE_ACCESSED</span> <span class="o">|</span> <span class="n">_PAGE_DIRTY</span> <span class="o">|</span> <span class="n">_PAGE_PSE</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_write_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">identity_map_pfn</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_pagetable_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">seg_setup</span><span class="p">(</span><span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vmx_segment_field</span> <span class="o">*</span><span class="n">sf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvm_vmx_segment_fields</span><span class="p">[</span><span class="n">seg</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ar</span><span class="p">;</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">selector</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_unrestricted_guest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ar</span> <span class="o">=</span> <span class="mh">0x93</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seg</span> <span class="o">==</span> <span class="n">VCPU_SREG_CS</span><span class="p">)</span>
			<span class="n">ar</span> <span class="o">|=</span> <span class="mh">0x08</span><span class="p">;</span> <span class="cm">/* code segment */</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ar</span> <span class="o">=</span> <span class="mh">0xf3</span><span class="p">;</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">ar_bytes</span><span class="p">,</span> <span class="n">ar</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_apic_access_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="n">kvm_userspace_mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">APIC_ACCESS_PAGE_PRIVATE_MEMSLOT</span><span class="p">;</span>
	<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">guest_phys_addr</span> <span class="o">=</span> <span class="mh">0xfee00000ULL</span><span class="p">;</span>
	<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">memory_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__kvm_set_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_userspace_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic_access_page</span> <span class="o">=</span> <span class="n">gfn_to_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="mh">0xfee00</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_identity_pagetable</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="n">kvm_userspace_mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_pagetable</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">IDENTITY_PAGETABLE_PRIVATE_MEMSLOT</span><span class="p">;</span>
	<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">guest_phys_addr</span> <span class="o">=</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_map_addr</span><span class="p">;</span>
	<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">memory_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__kvm_set_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_userspace_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_pagetable</span> <span class="o">=</span> <span class="n">gfn_to_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span>
			<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_map_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">allocate_vpid</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vpid</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_vpid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx_vpid_lock</span><span class="p">);</span>
	<span class="n">vpid</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">vmx_vpid_bitmap</span><span class="p">,</span> <span class="n">VMX_NR_VPIDS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vpid</span> <span class="o">&lt;</span> <span class="n">VMX_NR_VPIDS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span> <span class="o">=</span> <span class="n">vpid</span><span class="p">;</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">vpid</span><span class="p">,</span> <span class="n">vmx_vpid_bitmap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx_vpid_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_vpid</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_vpid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx_vpid_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span><span class="p">,</span> <span class="n">vmx_vpid_bitmap</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx_vpid_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">msr_bitmap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_vmx_msr_bitmap</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals</span>
<span class="cm">	 * have the write-low and read-high bitmap offsets the wrong way round.</span>
<span class="cm">	 * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&lt;=</span> <span class="mh">0x1fff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="n">msr_bitmap</span> <span class="o">+</span> <span class="mh">0x000</span> <span class="o">/</span> <span class="n">f</span><span class="p">);</span> <span class="cm">/* read-low */</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="n">msr_bitmap</span> <span class="o">+</span> <span class="mh">0x800</span> <span class="o">/</span> <span class="n">f</span><span class="p">);</span> <span class="cm">/* write-low */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">msr</span> <span class="o">&gt;=</span> <span class="mh">0xc0000000</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&lt;=</span> <span class="mh">0xc0001fff</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">msr</span> <span class="o">&amp;=</span> <span class="mh">0x1fff</span><span class="p">;</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="n">msr_bitmap</span> <span class="o">+</span> <span class="mh">0x400</span> <span class="o">/</span> <span class="n">f</span><span class="p">);</span> <span class="cm">/* read-high */</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="n">msr_bitmap</span> <span class="o">+</span> <span class="mh">0xc00</span> <span class="o">/</span> <span class="n">f</span><span class="p">);</span> <span class="cm">/* write-high */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">longmode_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">longmode_only</span><span class="p">)</span>
		<span class="n">__vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="n">vmx_msr_bitmap_legacy</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
	<span class="n">__vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="n">vmx_msr_bitmap_longmode</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up the vmcs&#39;s constant host-state fields, i.e., host-state fields that</span>
<span class="cm"> * will not change in the lifetime of the guest.</span>
<span class="cm"> * Note that host-state that does change is set elsewhere. E.g., host-state</span>
<span class="cm"> * that is set differently for each CPU is set in vmx_vcpu_load(), not here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_constant_host_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">low32</span><span class="p">,</span> <span class="n">high32</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmpl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="n">dt</span><span class="p">;</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_CR0</span><span class="p">,</span> <span class="n">read_cr0</span><span class="p">()</span> <span class="o">|</span> <span class="n">X86_CR0_TS</span><span class="p">);</span>  <span class="cm">/* 22.2.3 */</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_CR4</span><span class="p">,</span> <span class="n">read_cr4</span><span class="p">());</span>  <span class="cm">/* 22.2.3, 22.2.5 */</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_CR3</span><span class="p">,</span> <span class="n">read_cr3</span><span class="p">());</span>  <span class="cm">/* 22.2.3  FIXME: shadow tables */</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_CS_SELECTOR</span><span class="p">,</span> <span class="n">__KERNEL_CS</span><span class="p">);</span>  <span class="cm">/* 22.2.4 */</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="cm">/*</span>
<span class="cm">	 * Load null selectors, so we can avoid reloading them in</span>
<span class="cm">	 * __vmx_load_host_state(), in case userspace uses the null selectors</span>
<span class="cm">	 * too (the expected case).</span>
<span class="cm">	 */</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_DS_SELECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_ES_SELECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_DS_SELECTOR</span><span class="p">,</span> <span class="n">__KERNEL_DS</span><span class="p">);</span>  <span class="cm">/* 22.2.4 */</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_ES_SELECTOR</span><span class="p">,</span> <span class="n">__KERNEL_DS</span><span class="p">);</span>  <span class="cm">/* 22.2.4 */</span>
<span class="cp">#endif</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_SS_SELECTOR</span><span class="p">,</span> <span class="n">__KERNEL_DS</span><span class="p">);</span>  <span class="cm">/* 22.2.4 */</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_TR_SELECTOR</span><span class="p">,</span> <span class="n">GDT_ENTRY_TSS</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>  <span class="cm">/* 22.2.4 */</span>

	<span class="n">native_store_idt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_IDTR_BASE</span><span class="p">,</span> <span class="n">dt</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>   <span class="cm">/* 22.2.4 */</span>

	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;mov $.Lkvm_vmx_return, %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">tmpl</span><span class="p">));</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_RIP</span><span class="p">,</span> <span class="n">tmpl</span><span class="p">);</span> <span class="cm">/* 22.2.5 */</span>

	<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_CS</span><span class="p">,</span> <span class="n">low32</span><span class="p">,</span> <span class="n">high32</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">HOST_IA32_SYSENTER_CS</span><span class="p">,</span> <span class="n">low32</span><span class="p">);</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_EIP</span><span class="p">,</span> <span class="n">tmpl</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_IA32_SYSENTER_EIP</span><span class="p">,</span> <span class="n">tmpl</span><span class="p">);</span>   <span class="cm">/* 22.2.3 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs_config</span><span class="p">.</span><span class="n">vmexit_ctrl</span> <span class="o">&amp;</span> <span class="n">VM_EXIT_LOAD_IA32_PAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_CR_PAT</span><span class="p">,</span> <span class="n">low32</span><span class="p">,</span> <span class="n">high32</span><span class="p">);</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">HOST_IA32_PAT</span><span class="p">,</span> <span class="n">low32</span> <span class="o">|</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">high32</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_cr4_guest_host_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span> <span class="o">=</span> <span class="n">KVM_CR4_GUEST_OWNED_BITS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span> <span class="o">|=</span> <span class="n">X86_CR4_PGE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span> <span class="o">&amp;=</span>
			<span class="o">~</span><span class="n">get_vmcs12</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cr4_guest_host_mask</span><span class="p">;</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR4_GUEST_HOST_MASK</span><span class="p">,</span> <span class="o">~</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vmx_exec_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">exec_control</span> <span class="o">=</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_exec_ctrl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vm_need_tpr_shadow</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">kvm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_TPR_SHADOW</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="n">exec_control</span> <span class="o">|=</span> <span class="n">CPU_BASED_CR8_STORE_EXITING</span> <span class="o">|</span>
				<span class="n">CPU_BASED_CR8_LOAD_EXITING</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_ept</span><span class="p">)</span>
		<span class="n">exec_control</span> <span class="o">|=</span> <span class="n">CPU_BASED_CR3_STORE_EXITING</span> <span class="o">|</span>
				<span class="n">CPU_BASED_CR3_LOAD_EXITING</span>  <span class="o">|</span>
				<span class="n">CPU_BASED_INVLPG_EXITING</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">exec_control</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vmx_secondary_exec_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">exec_control</span> <span class="o">=</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">cpu_based_2nd_exec_ctrl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vm_need_virtualize_apic_accesses</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">kvm</span><span class="p">))</span>
		<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SECONDARY_EXEC_ENABLE_VPID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SECONDARY_EXEC_ENABLE_EPT</span><span class="p">;</span>
		<span class="n">enable_unrestricted_guest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_unrestricted_guest</span><span class="p">)</span>
		<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SECONDARY_EXEC_UNRESTRICTED_GUEST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ple_gap</span><span class="p">)</span>
		<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SECONDARY_EXEC_PAUSE_LOOP_EXITING</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">exec_control</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ept_set_mmio_spte_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * EPT Misconfigurations can be generated if the value of bits 2:0</span>
<span class="cm">	 * of an EPT paging-structure entry is 110b (write/execute).</span>
<span class="cm">	 * Also, magic bits (0xffull &lt;&lt; 49) is set to quickly identify mmio</span>
<span class="cm">	 * spte.</span>
<span class="cm">	 */</span>
	<span class="n">kvm_mmu_set_mmio_spte_mask</span><span class="p">(</span><span class="mh">0xffull</span> <span class="o">&lt;&lt;</span> <span class="mi">49</span> <span class="o">|</span> <span class="mh">0x6ull</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sets up the vmcs for emulated real mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_vcpu_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* I/O */</span>
	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">IO_BITMAP_A</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vmx_io_bitmap_a</span><span class="p">));</span>
	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">IO_BITMAP_B</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vmx_io_bitmap_b</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vmx_msr_bitmap</span><span class="p">())</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">MSR_BITMAP</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vmx_msr_bitmap_legacy</span><span class="p">));</span>

	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">VMCS_LINK_POINTER</span><span class="p">,</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">);</span> <span class="cm">/* 22.3.1.5 */</span>

	<span class="cm">/* Control */</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">PIN_BASED_VM_EXEC_CONTROL</span><span class="p">,</span>
		<span class="n">vmcs_config</span><span class="p">.</span><span class="n">pin_based_exec_ctrl</span><span class="p">);</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">vmx_exec_control</span><span class="p">(</span><span class="n">vmx</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_secondary_exec_ctrls</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">,</span>
				<span class="n">vmx_secondary_exec_control</span><span class="p">(</span><span class="n">vmx</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ple_gap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">PLE_GAP</span><span class="p">,</span> <span class="n">ple_gap</span><span class="p">);</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">PLE_WINDOW</span><span class="p">,</span> <span class="n">ple_window</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">PAGE_FAULT_ERROR_CODE_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">PAGE_FAULT_ERROR_CODE_MATCH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">CR3_TARGET_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>           <span class="cm">/* 22.2.1 */</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_FS_SELECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>            <span class="cm">/* 22.2.4 */</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">HOST_GS_SELECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>            <span class="cm">/* 22.2.4 */</span>
	<span class="n">vmx_set_constant_host_state</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_FS_BASE</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_FS_BASE</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="cm">/* 22.2.4 */</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_GS_BASE</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_GS_BASE</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="cm">/* 22.2.4 */</span>
<span class="cp">#else</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_FS_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* 22.2.4 */</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">HOST_GS_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* 22.2.4 */</span>
<span class="cp">#endif</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_EXIT_MSR_STORE_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_EXIT_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">VM_EXIT_MSR_LOAD_ADDR</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">msr_autoload</span><span class="p">.</span><span class="n">host</span><span class="p">));</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_MSR_LOAD_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">VM_ENTRY_MSR_LOAD_ADDR</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">msr_autoload</span><span class="p">.</span><span class="n">guest</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs_config</span><span class="p">.</span><span class="n">vmentry_ctrl</span> <span class="o">&amp;</span> <span class="n">VM_ENTRY_LOAD_IA32_PAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">msr_low</span><span class="p">,</span> <span class="n">msr_high</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">host_pat</span><span class="p">;</span>
		<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_CR_PAT</span><span class="p">,</span> <span class="n">msr_low</span><span class="p">,</span> <span class="n">msr_high</span><span class="p">);</span>
		<span class="n">host_pat</span> <span class="o">=</span> <span class="n">msr_low</span> <span class="o">|</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">msr_high</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
		<span class="cm">/* Write the default value follow host pat */</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_IA32_PAT</span><span class="p">,</span> <span class="n">host_pat</span><span class="p">);</span>
		<span class="cm">/* Keep arch.pat sync with GUEST_IA32_PAT */</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">pat</span> <span class="o">=</span> <span class="n">host_pat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_VMX_MSR</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">index</span> <span class="o">=</span> <span class="n">vmx_msr_index</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u32</span> <span class="n">data_low</span><span class="p">,</span> <span class="n">data_high</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nmsrs</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rdmsr_safe</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_low</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_high</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wrmsr_safe</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data_low</span><span class="p">,</span> <span class="n">data_high</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">;</span>
		<span class="o">++</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nmsrs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_EXIT_CONTROLS</span><span class="p">,</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">vmexit_ctrl</span><span class="p">);</span>

	<span class="cm">/* 22.2.1, 20.8.1 */</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">vmentry_ctrl</span><span class="p">);</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_GUEST_HOST_MASK</span><span class="p">,</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">);</span>
	<span class="n">set_cr4_guest_host_mask</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="n">kvm_write_tsc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_vcpu_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">msr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_REGS_RIP</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_REGS_RSP</span><span class="p">));</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RDX</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_rdx_init_val</span><span class="p">();</span>
	<span class="n">kvm_set_cr8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">msr</span> <span class="o">=</span> <span class="mh">0xfee00000</span> <span class="o">|</span> <span class="n">MSR_IA32_APICBASE_ENABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vcpu_is_bsp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_IA32_APICBASE_BSP</span><span class="p">;</span>
	<span class="n">kvm_set_apic_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fx_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">vmx_segment_cache_clear</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="n">seg_setup</span><span class="p">(</span><span class="n">VCPU_SREG_CS</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * GUEST_CS_BASE should really be 0xffff0000, but VT vm86 mode</span>
<span class="cm">	 * insists on having GUEST_CS_BASE == GUEST_CS_SELECTOR &lt;&lt; 4.  Sigh.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vcpu_is_bsp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">,</span> <span class="mh">0xf000</span><span class="p">);</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">,</span> <span class="mh">0x000f0000</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">sipi_vector</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">sipi_vector</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">seg_setup</span><span class="p">(</span><span class="n">VCPU_SREG_DS</span><span class="p">);</span>
	<span class="n">seg_setup</span><span class="p">(</span><span class="n">VCPU_SREG_ES</span><span class="p">);</span>
	<span class="n">seg_setup</span><span class="p">(</span><span class="n">VCPU_SREG_FS</span><span class="p">);</span>
	<span class="n">seg_setup</span><span class="p">(</span><span class="n">VCPU_SREG_GS</span><span class="p">);</span>
	<span class="n">seg_setup</span><span class="p">(</span><span class="n">VCPU_SREG_SS</span><span class="p">);</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_TR_SELECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_TR_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_TR_LIMIT</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_TR_AR_BYTES</span><span class="p">,</span> <span class="mh">0x008b</span><span class="p">);</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_LDTR_SELECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_LDTR_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_LDTR_LIMIT</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_LDTR_AR_BYTES</span><span class="p">,</span> <span class="mh">0x00082</span><span class="p">);</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_SYSENTER_CS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_SYSENTER_ESP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_SYSENTER_EIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vcpu_is_bsp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">kvm_rip_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mh">0xfff0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kvm_rip_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">);</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_GDTR_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_GDTR_LIMIT</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>

	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_IDTR_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_IDTR_LIMIT</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_ACTIVITY_STATE</span><span class="p">,</span> <span class="n">GUEST_ACTIVITY_ACTIVE</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_PENDING_DBG_EXCEPTIONS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Special registers */</span>
	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_IA32_DEBUGCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">setup_msrs</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* 22.2.1 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vmx_tpr_shadow</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">VIRTUAL_APIC_PAGE_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_need_tpr_shadow</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">kvm</span><span class="p">))</span>
			<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">VIRTUAL_APIC_PAGE_ADDR</span><span class="p">,</span>
				     <span class="n">__pa</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">));</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">TPR_THRESHOLD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vm_need_virtualize_apic_accesses</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">kvm</span><span class="p">))</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">APIC_ACCESS_ADDR</span><span class="p">,</span>
			     <span class="n">page_to_phys</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">VIRTUAL_PROCESSOR_ID</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span><span class="p">);</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">=</span> <span class="n">X86_CR0_NW</span> <span class="o">|</span> <span class="n">X86_CR0_CD</span> <span class="o">|</span> <span class="n">X86_CR0_ET</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">vmx_set_cr0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_read_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span> <span class="cm">/* enter rmode */</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>
	<span class="n">vmx_set_cr4</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmx_set_efer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmx_fpu_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">update_exception_bitmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">vpid_sync_context</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* HACK: Don&#39;t enable emulation on guest boot/reset */</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">emulation_required</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In nested virtualization, check if L1 asked to exit on external interrupts.</span>
<span class="cm"> * For most existing hypervisors, this will always return true.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">nested_exit_on_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pin_based_vm_exec_control</span> <span class="o">&amp;</span>
		<span class="n">PIN_BASED_EXT_INTR_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_irq_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nested_exit_on_intr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We get here if vmx_interrupt_allowed() said we can&#39;t</span>
<span class="cm">		 * inject to L1 now because L2 must run. Ask L2 to exit</span>
<span class="cm">		 * right after entry, so we can inject to L1 more promptly.</span>
<span class="cm">		 */</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_IMMEDIATE_EXIT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cpu_based_vm_exec_control</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">);</span>
	<span class="n">cpu_based_vm_exec_control</span> <span class="o">|=</span> <span class="n">CPU_BASED_VIRTUAL_INTR_PENDING</span><span class="p">;</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_nmi_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_virtual_nmis</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">enable_irq_window</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">GUEST_INTR_STATE_STI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enable_irq_window</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpu_based_vm_exec_control</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">);</span>
	<span class="n">cpu_based_vm_exec_control</span> <span class="o">|=</span> <span class="n">CPU_BASED_VIRTUAL_NMI_PENDING</span><span class="p">;</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_inject_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">intr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span>

	<span class="n">trace_kvm_inj_virq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">irq_injections</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">inc_eip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">soft</span><span class="p">)</span>
			<span class="n">inc_eip</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">event_exit_inst_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_inject_realmode_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">inc_eip</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EMULATE_DONE</span><span class="p">)</span>
			<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TRIPLE_FAULT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">intr</span> <span class="o">=</span> <span class="n">irq</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">soft</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intr</span> <span class="o">|=</span> <span class="n">INTR_TYPE_SOFT_INTR</span><span class="p">;</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INSTRUCTION_LEN</span><span class="p">,</span>
			     <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">event_exit_inst_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">intr</span> <span class="o">|=</span> <span class="n">INTR_TYPE_EXT_INTR</span><span class="p">;</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">,</span> <span class="n">intr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_inject_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_virtual_nmis</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Tracking the NMI-blocked state in software is built upon</span>
<span class="cm">		 * finding the next open IRQ window. This, in turn, depends on</span>
<span class="cm">		 * well-behaving guests: They have to keep IRQs disabled at</span>
<span class="cm">		 * least as long as the NMI handler runs. Otherwise we may</span>
<span class="cm">		 * cause NMI nesting, maybe breaking the guest. But as this is</span>
<span class="cm">		 * highly unlikely, we can live with the residual risk.</span>
<span class="cm">		 */</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vnmi_blocked_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">nmi_injections</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nmi_known_unmasked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_inject_realmode_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">NMI_VECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EMULATE_DONE</span><span class="p">)</span>
			<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TRIPLE_FAULT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">,</span>
			<span class="n">INTR_TYPE_NMI_INTR</span> <span class="o">|</span> <span class="n">INTR_INFO_VALID_MASK</span> <span class="o">|</span> <span class="n">NMI_VECTOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_nmi_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_virtual_nmis</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span>	<span class="o">!</span><span class="p">(</span><span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">)</span> <span class="o">&amp;</span>
		  <span class="p">(</span><span class="n">GUEST_INTR_STATE_MOV_SS</span> <span class="o">|</span> <span class="n">GUEST_INTR_STATE_STI</span>
		   <span class="o">|</span> <span class="n">GUEST_INTR_STATE_NMI</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmx_get_nmi_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_virtual_nmis</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nmi_known_unmasked</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">)</span>	<span class="o">&amp;</span> <span class="n">GUEST_INTR_STATE_NMI</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_nmi_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">masked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_virtual_nmis</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span> <span class="o">!=</span> <span class="n">masked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span> <span class="o">=</span> <span class="n">masked</span><span class="p">;</span>
			<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vnmi_blocked_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nmi_known_unmasked</span> <span class="o">=</span> <span class="o">!</span><span class="n">masked</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">masked</span><span class="p">)</span>
			<span class="n">vmcs_set_bits</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">,</span>
				      <span class="n">GUEST_INTR_STATE_NMI</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">vmcs_clear_bits</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">,</span>
					<span class="n">GUEST_INTR_STATE_NMI</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_interrupt_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nested_exit_on_intr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span> <span class="o">=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">nested_run_pending</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info_field</span> <span class="o">&amp;</span>
		     <span class="n">VECTORING_INFO_VALID_MASK</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nested_vmx_vmexit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_reason</span> <span class="o">=</span> <span class="n">EXIT_REASON_EXTERNAL_INTERRUPT</span><span class="p">;</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_intr_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* fall through to normal code, but now in L1, not L2 */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="p">(</span><span class="n">GUEST_INTR_STATE_STI</span> <span class="o">|</span> <span class="n">GUEST_INTR_STATE_MOV_SS</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_set_tss_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="n">tss_mem</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">TSS_PRIVATE_MEMSLOT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">guest_phys_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">memory_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_set_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tss_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tss_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init_rmode_tss</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
		<span class="k">return</span>  <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_rmode_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">vec</span><span class="p">,</span> <span class="n">u32</span> <span class="n">err_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Instruction with address size override prefix opcode 0x67</span>
<span class="cm">	 * Cause the #SS fault with 0 error code in VM86 mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">vec</span> <span class="o">==</span> <span class="n">GP_VECTOR</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">vec</span> <span class="o">==</span> <span class="n">SS_VECTOR</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">err_code</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">EMULATE_DONE</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Forward all other exceptions that are valid in real mode.</span>
<span class="cm">	 * FIXME: Breaks guest debugging in real mode, needs to be fixed with</span>
<span class="cm">	 *        the required debugging infrastructure rework.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DB_VECTOR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span>
		    <span class="p">(</span><span class="n">KVM_GUESTDBG_SINGLESTEP</span> <span class="o">|</span> <span class="n">KVM_GUESTDBG_USE_HW_BP</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BP_VECTOR</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Update instruction length as we may reinject the exception</span>
<span class="cm">		 * from user space while in guest debugging mode.</span>
<span class="cm">		 */</span>
		<span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">event_exit_inst_len</span> <span class="o">=</span>
			<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_USE_SW_BP</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">DE_VECTOR</span>:
	<span class="k">case</span> <span class="n">OF_VECTOR</span>:
	<span class="k">case</span> <span class="n">BR_VECTOR</span>:
	<span class="k">case</span> <span class="n">UD_VECTOR</span>:
	<span class="k">case</span> <span class="n">DF_VECTOR</span>:
	<span class="k">case</span> <span class="n">SS_VECTOR</span>:
	<span class="k">case</span> <span class="n">GP_VECTOR</span>:
	<span class="k">case</span> <span class="n">MF_VECTOR</span>:
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Trigger machine check on the host. We assume all the MSRs are already set up</span>
<span class="cm"> * by the CPU and that we still run on the same CPU as the MCE occurred on.</span>
<span class="cm"> * We pass a fake environment to the machine check handler because we want</span>
<span class="cm"> * the guest to be always treated like user space, no matter what context</span>
<span class="cm"> * it used internally.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_machine_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_X86_MCE) &amp;&amp; defined(CONFIG_X86_64)</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">regs</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">cs</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* Fake ring 3 no matter what the guest ran on */</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">X86_EFLAGS_IF</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">do_machine_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_machine_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* already handled by vcpu_run */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intr_info</span><span class="p">,</span> <span class="n">ex_no</span><span class="p">,</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr2</span><span class="p">,</span> <span class="n">rip</span><span class="p">,</span> <span class="n">dr6</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vect_info</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">emulation_result</span> <span class="n">er</span><span class="p">;</span>

	<span class="n">vect_info</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span><span class="p">;</span>
	<span class="n">intr_info</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">exit_intr_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_machine_check</span><span class="p">(</span><span class="n">intr_info</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">handle_machine_check</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vect_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_VALID_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">is_page_fault</span><span class="p">(</span><span class="n">intr_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTERNAL_ERROR</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">internal</span><span class="p">.</span><span class="n">suberror</span> <span class="o">=</span> <span class="n">KVM_INTERNAL_ERROR_SIMUL_EX</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">internal</span><span class="p">.</span><span class="n">ndata</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">internal</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vect_info</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">internal</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">intr_info</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_INTR_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">INTR_TYPE_NMI_INTR</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* already handled by vmx_vcpu_run() */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_no_device</span><span class="p">(</span><span class="n">intr_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmx_fpu_activate</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_invalid_opcode</span><span class="p">(</span><span class="n">intr_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">er</span> <span class="o">=</span> <span class="n">emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">EMULTYPE_TRAP_UD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">er</span> <span class="o">!=</span> <span class="n">EMULATE_DONE</span><span class="p">)</span>
			<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_DELIVER_CODE_MASK</span><span class="p">)</span>
		<span class="n">error_code</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INTR_ERROR_CODE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_page_fault</span><span class="p">(</span><span class="n">intr_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* EPT won&#39;t cause page fault directly */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">enable_ept</span><span class="p">);</span>
		<span class="n">cr2</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
		<span class="n">trace_kvm_page_fault</span><span class="p">(</span><span class="n">cr2</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_event_needs_reinjection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvm_mmu_unprotect_page_virt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">kvm_mmu_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rmode</span><span class="p">.</span><span class="n">vm86_active</span> <span class="o">&amp;&amp;</span>
	    <span class="n">handle_rmode_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_VECTOR_MASK</span><span class="p">,</span>
								<span class="n">error_code</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">halt_request</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">halt_request</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">kvm_emulate_halt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ex_no</span> <span class="o">=</span> <span class="n">intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_VECTOR_MASK</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ex_no</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DB_VECTOR</span>:
		<span class="n">dr6</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span>
		      <span class="p">(</span><span class="n">KVM_GUESTDBG_SINGLESTEP</span> <span class="o">|</span> <span class="n">KVM_GUESTDBG_USE_HW_BP</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span> <span class="o">=</span> <span class="n">dr6</span> <span class="o">|</span> <span class="n">DR6_FIXED_1</span><span class="p">;</span>
			<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">DB_VECTOR</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span> <span class="o">=</span> <span class="n">dr6</span> <span class="o">|</span> <span class="n">DR6_FIXED_1</span><span class="p">;</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">BP_VECTOR</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Update instruction length as we may reinject #BP from</span>
<span class="cm">		 * user space while in guest debugging mode. Reading it for</span>
<span class="cm">		 * #DB as well causes no harm, it is not used in that case.</span>
<span class="cm">		 */</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">event_exit_inst_len</span> <span class="o">=</span>
			<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">);</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_DEBUG</span><span class="p">;</span>
		<span class="n">rip</span> <span class="o">=</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">)</span> <span class="o">+</span> <span class="n">rip</span><span class="p">;</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span> <span class="o">=</span> <span class="n">ex_no</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_EXCEPTION</span><span class="p">;</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">ex</span><span class="p">.</span><span class="n">exception</span> <span class="o">=</span> <span class="n">ex_no</span><span class="p">;</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">ex</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_external_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">irq_exits</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_triple_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_SHUTDOWN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">string</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
	<span class="n">string</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">io_exits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">string</span> <span class="o">||</span> <span class="n">in</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">exit_qualification</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kvm_fast_pio_out</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vmx_patch_hypercall</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hypercall</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Patch in the VMCALL instruction:</span>
<span class="cm">	 */</span>
	<span class="n">hypercall</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="n">hypercall</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">hypercall</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xc1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called to set cr0 as approriate for a mov-to-cr0 exit. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_set_cr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmxon</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">VMXON_CR0_ALWAYSON</span><span class="p">)</span> <span class="o">!=</span> <span class="n">VMXON_CR0_ALWAYSON</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We get here when L2 changed cr0 in a way that did not change</span>
<span class="cm">		 * any of L1&#39;s shadowed bits (see nested_vmx_exit_handled_cr),</span>
<span class="cm">		 * but did change L0 shadowed bits. This can currently happen</span>
<span class="cm">		 * with the TS bit: L0 may want to leave TS on (for lazy fpu</span>
<span class="cm">		 * loading) while pretending to allow the guest to change it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span><span class="p">)</span> <span class="o">|</span>
			 <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">kvm_set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_set_cr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span><span class="p">)</span> <span class="o">|</span>
			 <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR4_READ_SHADOW</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">kvm_set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called to set cr0 as approriate for clts instruction exit. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_clts</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We get here when L2 did CLTS, and L1 didn&#39;t shadow CR0.TS</span>
<span class="cm">		 * but we did (!fpu_active). We need to keep GUEST_CR0.TS on,</span>
<span class="cm">		 * just pretend it&#39;s off (also in arch.cr0 for fpu_activate).</span>
<span class="cm">		 */</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span>
			<span class="n">vmcs_readl</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">X86_CR0_TS</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_CR0_TS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">vmx_set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_read_cr0_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">~</span><span class="n">X86_CR0_TS</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_cr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
	<span class="n">cr</span> <span class="o">=</span> <span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">exit_qualification</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* mov to cr */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">trace_kvm_cr_write</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">handle_set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">kvm_complete_insn_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">kvm_set_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">kvm_complete_insn_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">handle_set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">kvm_complete_insn_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">8</span>: <span class="p">{</span>
				<span class="n">u8</span> <span class="n">cr8_prev</span> <span class="o">=</span> <span class="n">kvm_get_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
				<span class="n">u8</span> <span class="n">cr8</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">kvm_set_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr8</span><span class="p">);</span>
				<span class="n">kvm_complete_insn_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cr8_prev</span> <span class="o">&lt;=</span> <span class="n">cr8</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_SET_TPR</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">};</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* clts */</span>
		<span class="n">handle_clts</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">trace_kvm_cr_write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kvm_read_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">vmx_fpu_activate</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/*mov from cr*/</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">trace_kvm_cr_read</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">8</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">kvm_get_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">trace_kvm_cr_read</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* lmsw */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&gt;&gt;</span> <span class="n">LMSW_SOURCE_DATA_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
		<span class="n">trace_kvm_cr_write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">kvm_read_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xful</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">kvm_lmsw</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;unhandled control register: op %d cr %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">exit_qualification</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">cr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Do not handle if the CPL &gt; 0, will trigger GP on re-entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_require_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dr</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span> <span class="o">&amp;</span> <span class="n">DR7_GD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * As the vm-exit takes precedence over the debug trap, we</span>
<span class="cm">		 * need to emulate the latter, either for the host or the</span>
<span class="cm">		 * guest debugging itself.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_USE_HW_BP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span> <span class="o">=</span> <span class="n">dr</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span>
				<span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">);</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">debug</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span> <span class="o">=</span> <span class="n">DB_VECTOR</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_DEBUG</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DR7_GD</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span> <span class="o">|=</span> <span class="n">DR6_BD</span><span class="p">;</span>
			<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span><span class="p">);</span>
			<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">DB_VECTOR</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
	<span class="n">dr</span> <span class="o">=</span> <span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">DEBUG_REG_ACCESS_NUM</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">DEBUG_REG_ACCESS_REG</span><span class="p">(</span><span class="n">exit_qualification</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">TYPE_MOV_FROM_DR</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_get_dr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span>
			<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kvm_set_dr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">reg</span><span class="p">]);</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_dr7</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_emulate_cpuid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_rdmsr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ecx</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RCX</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx_get_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_kvm_msr_read_ex</span><span class="p">(</span><span class="n">ecx</span><span class="p">);</span>
		<span class="n">kvm_inject_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_kvm_msr_read</span><span class="p">(</span><span class="n">ecx</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/* FIXME: handling of bits 32:63 of rax, rdx */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RAX</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">1u</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RDX</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">1u</span><span class="p">;</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_wrmsr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ecx</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RCX</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RAX</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">1u</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">u64</span><span class="p">)(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RDX</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">1u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx_set_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_kvm_msr_write_ex</span><span class="p">(</span><span class="n">ecx</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="n">kvm_inject_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_kvm_msr_write</span><span class="p">(</span><span class="n">ecx</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_tpr_below_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_interrupt_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">;</span>

	<span class="cm">/* clear pending irq */</span>
	<span class="n">cpu_based_vm_exec_control</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">);</span>
	<span class="n">cpu_based_vm_exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_VIRTUAL_INTR_PENDING</span><span class="p">;</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">);</span>

	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">irq_window_exits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the user space waits to inject interrupts, exit as soon as</span>
<span class="cm">	 * possible</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">request_interrupt_window</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">kvm_cpu_has_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_IRQ_WINDOW_OPEN</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kvm_emulate_halt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_emulate_hypercall</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_invd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_invlpg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>

	<span class="n">kvm_mmu_invlpg</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">exit_qualification</span><span class="p">);</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_rdpmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kvm_rdpmc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_complete_insn_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_wbinvd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_emulate_wbinvd</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_xsetbv</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">new_bv</span> <span class="o">=</span> <span class="n">kvm_read_edx_eax</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">index</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RCX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_set_xcr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">new_bv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_apic_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">fasteoi</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">access_type</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">access_type</span> <span class="o">=</span> <span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">APIC_ACCESS_TYPE</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="n">APIC_ACCESS_OFFSET</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Sane guest uses MOV to write EOI, with written value</span>
<span class="cm">		 * not cared. So make a short-circuit here by avoiding</span>
<span class="cm">		 * heavy instruction emulation.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">access_type</span> <span class="o">==</span> <span class="n">TYPE_LINEAR_APIC_INST_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">APIC_EOI</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kvm_lapic_set_eoi</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_task_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_error_code</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tss_selector</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">idt_v</span><span class="p">,</span> <span class="n">idt_index</span><span class="p">;</span>

	<span class="n">idt_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_VALID_MASK</span><span class="p">);</span>
	<span class="n">idt_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_VECTOR_MASK</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_TYPE_MASK</span><span class="p">);</span>

	<span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>

	<span class="n">reason</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">exit_qualification</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">TASK_SWITCH_GATE</span> <span class="o">&amp;&amp;</span> <span class="n">idt_v</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">INTR_TYPE_NMI_INTR</span>:
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_injected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">vmx_set_nmi_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">INTR_TYPE_EXT_INTR</span>:
		<span class="k">case</span> <span class="n">INTR_TYPE_SOFT_INTR</span>:
			<span class="n">kvm_clear_interrupt_queue</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">INTR_TYPE_HARD_EXCEPTION</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span> <span class="o">&amp;</span>
			    <span class="n">VECTORING_INFO_DELIVER_CODE_MASK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">has_error_code</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">error_code</span> <span class="o">=</span>
					<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">IDT_VECTORING_ERROR_CODE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">INTR_TYPE_SOFT_EXCEPTION</span>:
			<span class="n">kvm_clear_exception_queue</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">tss_selector</span> <span class="o">=</span> <span class="n">exit_qualification</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idt_v</span> <span class="o">||</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">INTR_TYPE_HARD_EXCEPTION</span> <span class="o">&amp;&amp;</span>
		       <span class="n">type</span> <span class="o">!=</span> <span class="n">INTR_TYPE_EXT_INTR</span> <span class="o">&amp;&amp;</span>
		       <span class="n">type</span> <span class="o">!=</span> <span class="n">INTR_TYPE_NMI_INTR</span><span class="p">))</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_task_switch</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">tss_selector</span><span class="p">,</span>
			    <span class="n">type</span> <span class="o">==</span> <span class="n">INTR_TYPE_SOFT_INTR</span> <span class="o">?</span> <span class="n">idt_index</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span>
			    <span class="n">has_error_code</span><span class="p">,</span> <span class="n">error_code</span><span class="p">)</span> <span class="o">==</span> <span class="n">EMULATE_FAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTERNAL_ERROR</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">internal</span><span class="p">.</span><span class="n">suberror</span> <span class="o">=</span> <span class="n">KVM_INTERNAL_ERROR_EMULATION</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">internal</span><span class="p">.</span><span class="n">ndata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear all local breakpoint enable flags */</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">,</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">55</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: What about debug traps on tss switch?</span>
<span class="cm">	 *       Are we supposed to inject them and update dr6?</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_ept_violation</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span><span class="p">;</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gla_validity</span><span class="p">;</span>

	<span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EPT: GPA exceeds GAW!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gla_validity</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gla_validity</span> <span class="o">!=</span> <span class="mh">0x3</span> <span class="o">&amp;&amp;</span> <span class="n">gla_validity</span> <span class="o">!=</span> <span class="mh">0x1</span> <span class="o">&amp;&amp;</span> <span class="n">gla_validity</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EPT: Handling EPT violation failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EPT: GPA: 0x%lx, GVA: 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">vmcs_read64</span><span class="p">(</span><span class="n">GUEST_PHYSICAL_ADDRESS</span><span class="p">),</span>
			<span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_LINEAR_ADDRESS</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EPT: Exit qualification is 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">exit_qualification</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_UNKNOWN</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hardware_exit_reason</span> <span class="o">=</span> <span class="n">EXIT_REASON_EPT_VIOLATION</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gpa</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">GUEST_PHYSICAL_ADDRESS</span><span class="p">);</span>
	<span class="n">trace_kvm_page_fault</span><span class="p">(</span><span class="n">gpa</span><span class="p">,</span> <span class="n">exit_qualification</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kvm_mmu_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">ept_rsvd_mask</span><span class="p">(</span><span class="n">u64</span> <span class="n">spte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">51</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_phys_bits</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="cm">/* bits 7:3 reserved */</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="mh">0xf8</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">))</span>
			<span class="cm">/* 2MB ref, bits 20:12 reserved */</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="mh">0x1ff000</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* bits 6:3 reserved */</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="mh">0x78</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ept_misconfig_inspect_spte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">spte</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: spte 0x%llx level %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

	<span class="cm">/* 010b (write-only) */</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x2</span><span class="p">);</span>

	<span class="cm">/* 110b (write/execute) */</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x6</span><span class="p">);</span>

	<span class="cm">/* 100b (execute-only) and value not supported by logical processor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_vmx_ept_execute_only</span><span class="p">())</span>
		<span class="n">WARN_ON</span><span class="p">((</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x4</span><span class="p">);</span>

	<span class="cm">/* not 000b */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">rsvd_bits</span> <span class="o">=</span> <span class="n">spte</span> <span class="o">&amp;</span> <span class="n">ept_rsvd_mask</span><span class="p">(</span><span class="n">spte</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rsvd_bits</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: rsvd_bits = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">__func__</span><span class="p">,</span> <span class="n">rsvd_bits</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">ept_mem_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="mh">0x38</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ept_mem_type</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">ept_mem_type</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span>
			    <span class="n">ept_mem_type</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: ept_mem_type=0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">ept_mem_type</span><span class="p">);</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_ept_misconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">sptes</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">nr_sptes</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">;</span>

	<span class="n">gpa</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">GUEST_PHYSICAL_ADDRESS</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_mmio_page_fault_common</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">x86_emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span>
					      <span class="n">EMULATE_DONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* It is the real ept misconfig */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EPT: Misconfiguration.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EPT: GPA: 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gpa</span><span class="p">);</span>

	<span class="n">nr_sptes</span> <span class="o">=</span> <span class="n">kvm_mmu_get_spte_hierarchy</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">sptes</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">PT64_ROOT_LEVEL</span> <span class="o">-</span> <span class="n">nr_sptes</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
		<span class="n">ept_misconfig_inspect_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sptes</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_UNKNOWN</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hardware_exit_reason</span> <span class="o">=</span> <span class="n">EXIT_REASON_EPT_MISCONFIG</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_nmi_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">;</span>

	<span class="cm">/* clear pending NMI */</span>
	<span class="n">cpu_based_vm_exec_control</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">);</span>
	<span class="n">cpu_based_vm_exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_VIRTUAL_NMI_PENDING</span><span class="p">;</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">cpu_based_vm_exec_control</span><span class="p">);</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">nmi_window_exits</span><span class="p">;</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_invalid_guest_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">emulation_result</span> <span class="n">err</span> <span class="o">=</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cpu_exec_ctrl</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">intr_window_requested</span><span class="p">;</span>

	<span class="n">cpu_exec_ctrl</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">);</span>
	<span class="n">intr_window_requested</span> <span class="o">=</span> <span class="n">cpu_exec_ctrl</span> <span class="o">&amp;</span> <span class="n">CPU_BASED_VIRTUAL_INTR_PENDING</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">guest_state_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intr_window_requested</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">kvm_get_rflags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">handle_interrupt_window</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">EMULATE_DO_MMIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">EMULATE_DONE</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">emulation_required</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Indicate a busy-waiting vcpu in spinlock. We do not enable the PAUSE</span>
<span class="cm"> * exiting, so only get here on cpu with PAUSE-Loop-Exiting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_vcpu_on_spin</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_invalid_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To run an L2 guest, we need a vmcs02 based on the L1-specified vmcs12.</span>
<span class="cm"> * We could reuse a single VMCS for all the L2 guests, but we also want the</span>
<span class="cm"> * option to allocate a separate vmcs02 for each separate loaded vmcs12 - this</span>
<span class="cm"> * allows keeping them loaded on the processor, and in the future will allow</span>
<span class="cm"> * optimizations where prepare_vmcs02 doesn&#39;t need to set all the fields on</span>
<span class="cm"> * every entry if they never change.</span>
<span class="cm"> * So we keep, in vmx-&gt;nested.vmcs02_pool, a cache of size VMCS02_POOL_SIZE</span>
<span class="cm"> * (&gt;=0) with a vmcs02 for each recently loaded vmcs12s, most recent first.</span>
<span class="cm"> *</span>
<span class="cm"> * The following functions allocate and free a vmcs02 in this pool.</span>
<span class="cm"> */</span>

<span class="cm">/* Get a VMCS from the pool to use as vmcs02 for the current vmcs12. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">loaded_vmcs</span> <span class="o">*</span><span class="nf">nested_get_current_vmcs02</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmcs02_list</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_pool</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmptr</span> <span class="o">==</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_pool</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmcs02</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_num</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">(</span><span class="n">VMCS02_POOL_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Recycle the least recently used VMCS. */</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_pool</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vmcs02_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">vmptr</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmcs02</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create a new VMCS */</span>
	<span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vmcs02_list</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs02_list</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">vmcs02</span><span class="p">.</span><span class="n">vmcs</span> <span class="o">=</span> <span class="n">alloc_vmcs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmcs02</span><span class="p">.</span><span class="n">vmcs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">loaded_vmcs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmcs02</span><span class="p">);</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">vmptr</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_pool</span><span class="p">));</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_num</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmcs02</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free and remove from pool a vmcs02 saved for a vmcs12 (if there is one) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nested_free_vmcs02</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">vmptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmcs02_list</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_pool</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmptr</span> <span class="o">==</span> <span class="n">vmptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_loaded_vmcs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmcs02</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
			<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_num</span><span class="o">--</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free all VMCSs saved for this vcpu, except the one pointed by</span>
<span class="cm"> * vmx-&gt;loaded_vmcs. These include the VMCSs in vmcs02_pool (except the one</span>
<span class="cm"> * currently used, if running L2), and vmcs01 when running L2.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nested_free_all_saved_vmcss</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmcs02_list</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_pool</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmcs02</span><span class="p">)</span>
			<span class="n">free_loaded_vmcs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">vmcs02</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vmcs01</span><span class="p">)</span>
		<span class="n">free_loaded_vmcs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vmcs01</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Emulate the VMXON instruction.</span>
<span class="cm"> * Currently, we just remember that VMX is active, and do not save or even</span>
<span class="cm"> * inspect the argument to VMXON (the so-called &quot;VMXON pointer&quot;) because we</span>
<span class="cm"> * do not currently need to store anything in that guest-allocated memory</span>
<span class="cm"> * region. Consequently, VMCLEAR and VMPTRLD also do not verify that the their</span>
<span class="cm"> * argument is different from the VMXON pointer (which the spec says they do).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmon</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">cs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/* The Intel VMX Instruction Reference lists a bunch of bits that</span>
<span class="cm">	 * are prerequisite to running VMXON, most notably cr4.VMXE must be</span>
<span class="cm">	 * set to 1 (see vmx_set_cr4() for when we allow the guest to set this).</span>
<span class="cm">	 * Otherwise, we should fail with #UD. We test these now:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_read_cr4_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR4_VMXE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">kvm_read_cr0_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR0_PE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">vmx_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_VM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cs</span><span class="p">.</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx_get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_inject_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_pool</span><span class="p">));</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs02_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmxon</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Intel&#39;s VMX Instruction Reference specifies a common set of prerequisites</span>
<span class="cm"> * for running VMX instructions (except VMXON, whose prerequisites are</span>
<span class="cm"> * slightly different). It also specifies what exception to inject otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nested_vmx_check_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">cs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmxon</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmx_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vmx_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_VM</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cs</span><span class="p">.</span><span class="n">l</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx_get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_inject_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free whatever needs to be freed from vmx-&gt;nested when L1 goes down, or</span>
<span class="cm"> * just stops using VMX.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_nested</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmxon</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmxon</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12_page</span><span class="p">);</span>
		<span class="n">nested_release_page</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12_page</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Unpin physical memory we referred to in current vmcs02 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nested_release_page</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nested_free_all_saved_vmcss</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Emulate the VMXOFF instruction */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_check_permission</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">free_nested</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decode the memory-address operand of a vmx instruction, as recorded on an</span>
<span class="cm"> * exit caused by such an instruction (run by a guest hypervisor).</span>
<span class="cm"> * On success, returns 0. When the operand is invalid, returns 1 and throws</span>
<span class="cm"> * #UD or #GP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_vmx_mem_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">vmx_instruction_info</span><span class="p">,</span> <span class="n">gva_t</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * According to Vol. 3B, &quot;Information for VM Exits Due to Instruction</span>
<span class="cm">	 * Execution&quot;, on an exit, vmx_instruction_info holds most of the</span>
<span class="cm">	 * addressing components of the operand. Only the displacement part</span>
<span class="cm">	 * is put in exit_qualification (see 3B, &quot;Basic VM-Exit Information&quot;).</span>
<span class="cm">	 * For how an actual address is calculated from all these components,</span>
<span class="cm">	 * refer to Vol. 1, &quot;Operand Addressing&quot;.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="n">scaling</span> <span class="o">=</span> <span class="n">vmx_instruction_info</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">addr_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmx_instruction_info</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_reg</span> <span class="o">=</span> <span class="n">vmx_instruction_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="n">seg_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmx_instruction_info</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">index_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmx_instruction_info</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">index_is_valid</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">vmx_instruction_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">));</span>
	<span class="kt">int</span>  <span class="n">base_reg</span>       <span class="o">=</span> <span class="p">(</span><span class="n">vmx_instruction_info</span> <span class="o">&gt;&gt;</span> <span class="mi">23</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">base_is_valid</span>  <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">vmx_instruction_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Addr = segment_base + offset */</span>
	<span class="cm">/* offset = base + [index * scale] + displacement */</span>
	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">vmx_get_segment_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">seg_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base_is_valid</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">+=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">base_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index_is_valid</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">+=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">index_reg</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">scaling</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ret</span> <span class="o">+=</span> <span class="n">exit_qualification</span><span class="p">;</span> <span class="cm">/* holds the displacement */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* 32 bit */</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">&amp;=</span> <span class="mh">0xffffffff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: throw #GP (and return 1) in various cases that the VM*</span>
<span class="cm">	 * instructions require it - e.g., offset beyond segment limit,</span>
<span class="cm">	 * unusable or unreadable/unwritable segment, non-canonical 64-bit</span>
<span class="cm">	 * address, and so on. Currently these are not checked.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following 3 functions, nested_vmx_succeed()/failValid()/failInvalid(),</span>
<span class="cm"> * set the success or error code of an emulated VMX instruction, as specified</span>
<span class="cm"> * by Vol 2B, VMX Instruction Reference, &quot;Conventions&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nested_vmx_succeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmx_set_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmx_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">X86_EFLAGS_CF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_PF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_AF</span> <span class="o">|</span>
			    <span class="n">X86_EFLAGS_ZF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_SF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_OF</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nested_vmx_failInvalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmx_set_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="p">(</span><span class="n">vmx_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">X86_EFLAGS_PF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_AF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_ZF</span> <span class="o">|</span>
			    <span class="n">X86_EFLAGS_SF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_OF</span><span class="p">))</span>
			<span class="o">|</span> <span class="n">X86_EFLAGS_CF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nested_vmx_failValid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">vm_instruction_error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * failValid writes the error number to the current VMCS, which</span>
<span class="cm">		 * can&#39;t be done there isn&#39;t a current VMCS.</span>
<span class="cm">		 */</span>
		<span class="n">nested_vmx_failInvalid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vmx_set_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="p">(</span><span class="n">vmx_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">X86_EFLAGS_CF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_PF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_AF</span> <span class="o">|</span>
			    <span class="n">X86_EFLAGS_SF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_OF</span><span class="p">))</span>
			<span class="o">|</span> <span class="n">X86_EFLAGS_ZF</span><span class="p">);</span>
	<span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vm_instruction_error</span> <span class="o">=</span> <span class="n">vm_instruction_error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Emulate the VMCLEAR instruction */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmclear</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">gva_t</span> <span class="n">gva</span><span class="p">;</span>
	<span class="n">gpa_t</span> <span class="n">vmptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">x86_exception</span> <span class="n">e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_check_permission</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_vmx_mem_address</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">),</span>
			<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VMX_INSTRUCTION_INFO</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">gva</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_read_guest_virt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmptr</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">vmptr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_inject_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">vmptr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VMXERR_VMCLEAR_INVALID_ADDRESS</span><span class="p">);</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmptr</span> <span class="o">==</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12_page</span><span class="p">);</span>
		<span class="n">nested_release_page</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12_page</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">nested_get_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For accurate processor emulation, VMCLEAR beyond available</span>
<span class="cm">		 * physical memory should do nothing at all. However, it is</span>
<span class="cm">		 * possible that a nested vmx bug, not a guest hypervisor bug,</span>
<span class="cm">		 * resulted in this case, so let&#39;s shut down before doing any</span>
<span class="cm">		 * more damage:</span>
<span class="cm">		 */</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TRIPLE_FAULT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vmcs12</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">launch_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">nested_release_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">nested_free_vmcs02</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">vmptr</span><span class="p">);</span>

	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">nested_vmx_succeed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nested_vmx_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">launch</span><span class="p">);</span>

<span class="cm">/* Emulate the VMLAUNCH instruction */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmlaunch</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nested_vmx_run</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Emulate the VMRESUME instruction */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmresume</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">return</span> <span class="n">nested_vmx_run</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">vmcs_field_type</span> <span class="p">{</span>
	<span class="n">VMCS_FIELD_TYPE_U16</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VMCS_FIELD_TYPE_U64</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VMCS_FIELD_TYPE_U32</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VMCS_FIELD_TYPE_NATURAL_WIDTH</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vmcs_field_type</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&amp;</span> <span class="n">field</span><span class="p">)</span>	<span class="cm">/* the *_HIGH fields are all 32 bit */</span>
		<span class="k">return</span> <span class="n">VMCS_FIELD_TYPE_U32</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">field</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vmcs_field_readonly</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">field</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read a vmcs12 field. Since these can have varying lengths and we return</span>
<span class="cm"> * one type, we chose the biggest type (u64) and zero-extend the return value</span>
<span class="cm"> * to that size. Note that the caller, handle_vmread, might need to use only</span>
<span class="cm"> * some of the bits we return here (e.g., on 32-bit guests, only 32 bits of</span>
<span class="cm"> * 64-bit fields are to be returned).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">vmcs12_read_any</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vmcs_field_to_offset</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)))</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vmcs_field_type</span><span class="p">(</span><span class="n">field</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VMCS_FIELD_TYPE_NATURAL_WIDTH</span>:
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">natural_width</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VMCS_FIELD_TYPE_U16</span>:
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VMCS_FIELD_TYPE_U32</span>:
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VMCS_FIELD_TYPE_U64</span>:
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* can never happen. */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * VMX instructions which assume a current vmcs12 (i.e., that VMPTRLD was</span>
<span class="cm"> * used before) all generate the same failure when it is missing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nested_vmx_check_vmcs12</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nested_vmx_failInvalid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmread</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">field_value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">vmx_instruction_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VMX_INSTRUCTION_INFO</span><span class="p">);</span>
	<span class="n">gva_t</span> <span class="n">gva</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_check_permission</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">nested_vmx_check_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Decode instruction info and find the field to read */</span>
	<span class="n">field</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="p">(((</span><span class="n">vmx_instruction_info</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
	<span class="cm">/* Read the field, zero-extended to a u64 field_value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmcs12_read_any</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">field_value</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VMXERR_UNSUPPORTED_VMCS_COMPONENT</span><span class="p">);</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now copy part of this value to register or memory, as requested.</span>
<span class="cm">	 * Note that the number of bits actually copied is 32 or 64 depending</span>
<span class="cm">	 * on the guest&#39;s mode (32 or 64 bit), not on the given field&#39;s length.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx_instruction_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="p">(((</span><span class="n">vmx_instruction_info</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">),</span>
			<span class="n">field_value</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_vmx_mem_address</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">exit_qualification</span><span class="p">,</span>
				<span class="n">vmx_instruction_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gva</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* _system ok, as nested_vmx_check_permission verified cpl=0 */</span>
		<span class="n">kvm_write_guest_virt_system</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">field_value</span><span class="p">,</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">4</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nested_vmx_succeed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">;</span>
	<span class="n">gva_t</span> <span class="n">gva</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">vmx_instruction_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VMX_INSTRUCTION_INFO</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">offset</span><span class="p">;</span>
	<span class="cm">/* The value to write might be 32 or 64 bits, depending on L1&#39;s long</span>
<span class="cm">	 * mode, and eventually we need to write that into a field of several</span>
<span class="cm">	 * possible lengths. The code below first zero-extends the value to 64</span>
<span class="cm">	 * bit (field_value), and then copies only the approriate number of</span>
<span class="cm">	 * bits into the vmcs12 field.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">field_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">x86_exception</span> <span class="n">e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_check_permission</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">nested_vmx_check_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx_instruction_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">))</span>
		<span class="n">field_value</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span>
			<span class="p">(((</span><span class="n">vmx_instruction_info</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_vmx_mem_address</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">exit_qualification</span><span class="p">,</span>
				<span class="n">vmx_instruction_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gva</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_read_guest_virt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">field_value</span><span class="p">,</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">4</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kvm_inject_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="n">field</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="p">(((</span><span class="n">vmx_instruction_info</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs_field_readonly</span><span class="p">(</span><span class="n">field</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span>
			<span class="n">VMXERR_VMWRITE_READ_ONLY_VMCS_COMPONENT</span><span class="p">);</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">vmcs_field_to_offset</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VMXERR_UNSUPPORTED_VMCS_COMPONENT</span><span class="p">);</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vmcs_field_type</span><span class="p">(</span><span class="n">field</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VMCS_FIELD_TYPE_U16</span>:
		<span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">=</span> <span class="n">field_value</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VMCS_FIELD_TYPE_U32</span>:
		<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">=</span> <span class="n">field_value</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VMCS_FIELD_TYPE_U64</span>:
		<span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">=</span> <span class="n">field_value</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VMCS_FIELD_TYPE_NATURAL_WIDTH</span>:
		<span class="o">*</span><span class="p">(</span><span class="n">natural_width</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">=</span> <span class="n">field_value</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VMXERR_UNSUPPORTED_VMCS_COMPONENT</span><span class="p">);</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nested_vmx_succeed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Emulate the VMPTRLD instruction */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmptrld</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">gva_t</span> <span class="n">gva</span><span class="p">;</span>
	<span class="n">gpa_t</span> <span class="n">vmptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">x86_exception</span> <span class="n">e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_check_permission</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_vmx_mem_address</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">),</span>
			<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VMX_INSTRUCTION_INFO</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">gva</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_read_guest_virt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmptr</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">vmptr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_inject_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">vmptr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VMXERR_VMPTRLD_INVALID_ADDRESS</span><span class="p">);</span>
		<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span> <span class="o">!=</span> <span class="n">vmptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">new_vmcs12</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">nested_get_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nested_vmx_failInvalid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new_vmcs12</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_vmcs12</span><span class="o">-&gt;</span><span class="n">revision_id</span> <span class="o">!=</span> <span class="n">VMCS12_REVISION</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">nested_release_page_clean</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span>
				<span class="n">VMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID</span><span class="p">);</span>
			<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12_page</span><span class="p">);</span>
			<span class="n">nested_release_page</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12_page</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span> <span class="o">=</span> <span class="n">vmptr</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12</span> <span class="o">=</span> <span class="n">new_vmcs12</span><span class="p">;</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nested_vmx_succeed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Emulate the VMPTRST instruction */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vmptrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">vmx_instruction_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VMX_INSTRUCTION_INFO</span><span class="p">);</span>
	<span class="n">gva_t</span> <span class="n">vmcs_gva</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">x86_exception</span> <span class="n">e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_check_permission</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_vmx_mem_address</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">exit_qualification</span><span class="p">,</span>
			<span class="n">vmx_instruction_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmcs_gva</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* ok to use *_system, as nested_vmx_check_permission verified cpl=0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_write_guest_virt_system</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">,</span> <span class="n">vmcs_gva</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_inject_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nested_vmx_succeed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The exit handlers return 1 if the exit was handled fully and guest execution</span>
<span class="cm"> * may resume.  Otherwise they set the kvm_run parameter to indicate what needs</span>
<span class="cm"> * to be done to userspace and return 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">kvm_vmx_exit_handlers</span><span class="p">[])(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">EXIT_REASON_EXCEPTION_NMI</span><span class="p">]</span>           <span class="o">=</span> <span class="n">handle_exception</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_EXTERNAL_INTERRUPT</span><span class="p">]</span>      <span class="o">=</span> <span class="n">handle_external_interrupt</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_TRIPLE_FAULT</span><span class="p">]</span>            <span class="o">=</span> <span class="n">handle_triple_fault</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_NMI_WINDOW</span><span class="p">]</span>	      <span class="o">=</span> <span class="n">handle_nmi_window</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_IO_INSTRUCTION</span><span class="p">]</span>          <span class="o">=</span> <span class="n">handle_io</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_CR_ACCESS</span><span class="p">]</span>               <span class="o">=</span> <span class="n">handle_cr</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_DR_ACCESS</span><span class="p">]</span>               <span class="o">=</span> <span class="n">handle_dr</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_CPUID</span><span class="p">]</span>                   <span class="o">=</span> <span class="n">handle_cpuid</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_MSR_READ</span><span class="p">]</span>                <span class="o">=</span> <span class="n">handle_rdmsr</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_MSR_WRITE</span><span class="p">]</span>               <span class="o">=</span> <span class="n">handle_wrmsr</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_PENDING_INTERRUPT</span><span class="p">]</span>       <span class="o">=</span> <span class="n">handle_interrupt_window</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_HLT</span><span class="p">]</span>                     <span class="o">=</span> <span class="n">handle_halt</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_INVD</span><span class="p">]</span>		      <span class="o">=</span> <span class="n">handle_invd</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_INVLPG</span><span class="p">]</span>		      <span class="o">=</span> <span class="n">handle_invlpg</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_RDPMC</span><span class="p">]</span>                   <span class="o">=</span> <span class="n">handle_rdpmc</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMCALL</span><span class="p">]</span>                  <span class="o">=</span> <span class="n">handle_vmcall</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMCLEAR</span><span class="p">]</span>	              <span class="o">=</span> <span class="n">handle_vmclear</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMLAUNCH</span><span class="p">]</span>                <span class="o">=</span> <span class="n">handle_vmlaunch</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMPTRLD</span><span class="p">]</span>                 <span class="o">=</span> <span class="n">handle_vmptrld</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMPTRST</span><span class="p">]</span>                 <span class="o">=</span> <span class="n">handle_vmptrst</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMREAD</span><span class="p">]</span>                  <span class="o">=</span> <span class="n">handle_vmread</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMRESUME</span><span class="p">]</span>                <span class="o">=</span> <span class="n">handle_vmresume</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMWRITE</span><span class="p">]</span>                 <span class="o">=</span> <span class="n">handle_vmwrite</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMOFF</span><span class="p">]</span>                   <span class="o">=</span> <span class="n">handle_vmoff</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VMON</span><span class="p">]</span>                    <span class="o">=</span> <span class="n">handle_vmon</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_TPR_BELOW_THRESHOLD</span><span class="p">]</span>     <span class="o">=</span> <span class="n">handle_tpr_below_threshold</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_APIC_ACCESS</span><span class="p">]</span>             <span class="o">=</span> <span class="n">handle_apic_access</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_WBINVD</span><span class="p">]</span>                  <span class="o">=</span> <span class="n">handle_wbinvd</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_XSETBV</span><span class="p">]</span>                  <span class="o">=</span> <span class="n">handle_xsetbv</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_TASK_SWITCH</span><span class="p">]</span>             <span class="o">=</span> <span class="n">handle_task_switch</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_MCE_DURING_VMENTRY</span><span class="p">]</span>      <span class="o">=</span> <span class="n">handle_machine_check</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_EPT_VIOLATION</span><span class="p">]</span>	      <span class="o">=</span> <span class="n">handle_ept_violation</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_EPT_MISCONFIG</span><span class="p">]</span>           <span class="o">=</span> <span class="n">handle_ept_misconfig</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_PAUSE_INSTRUCTION</span><span class="p">]</span>       <span class="o">=</span> <span class="n">handle_pause</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_MWAIT_INSTRUCTION</span><span class="p">]</span>	      <span class="o">=</span> <span class="n">handle_invalid_op</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_MONITOR_INSTRUCTION</span><span class="p">]</span>     <span class="o">=</span> <span class="n">handle_invalid_op</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kvm_vmx_max_exit_handlers</span> <span class="o">=</span>
	<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kvm_vmx_exit_handlers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return 1 if we should exit from L2 to L1 to handle an MSR access access,</span>
<span class="cm"> * rather than handle it ourselves in L0. I.e., check whether L1 expressed</span>
<span class="cm"> * disinterest in the current event (read or write a specific MSR) by using an</span>
<span class="cm"> * MSR bitmap. This may be the case even when L0 doesn&#39;t use MSR bitmaps.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">nested_vmx_exit_handled_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">u32</span> <span class="n">exit_reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">msr_index</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RCX</span><span class="p">];</span>
	<span class="n">gpa_t</span> <span class="n">bitmap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">CPU_BASED_USE_MSR_BITMAPS</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The MSR_BITMAP page is divided into four 1024-byte bitmaps,</span>
<span class="cm">	 * for the four combinations of read/write and low/high MSR numbers.</span>
<span class="cm">	 * First we need to figure out which of the four to use:</span>
<span class="cm">	 */</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">msr_bitmap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exit_reason</span> <span class="o">==</span> <span class="n">EXIT_REASON_MSR_WRITE</span><span class="p">)</span>
		<span class="n">bitmap</span> <span class="o">+=</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr_index</span> <span class="o">&gt;=</span> <span class="mh">0xc0000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msr_index</span> <span class="o">-=</span> <span class="mh">0xc0000000</span><span class="p">;</span>
		<span class="n">bitmap</span> <span class="o">+=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Then read the msr_index&#39;th bit from this bitmap: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr_index</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">kvm_read_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">bitmap</span> <span class="o">+</span> <span class="n">msr_index</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">msr_index</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* let L1 handle the wrong parameter */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return 1 if we should exit from L2 to L1 to handle a CR access exit,</span>
<span class="cm"> * rather than handle it ourselves in L0. I.e., check if L1 wanted to</span>
<span class="cm"> * intercept (via guest_host_mask etc.) the current event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">nested_vmx_exit_handled_cr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cr</span> <span class="o">=</span> <span class="n">exit_qualification</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_qualification</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">((</span><span class="n">exit_qualification</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* mov to cr */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span> <span class="o">&amp;</span>
			    <span class="p">(</span><span class="n">val</span> <span class="o">^</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_read_shadow</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr3_target_count</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
					<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr3_target_value0</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr3_target_count</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
					<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr3_target_value1</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr3_target_count</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>
					<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr3_target_value2</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr3_target_count</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span>
					<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr3_target_value3</span> <span class="o">==</span> <span class="n">val</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_CR3_LOAD_EXITING</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr4_guest_host_mask</span> <span class="o">&amp;</span>
			    <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr4_read_shadow</span> <span class="o">^</span> <span class="n">val</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">8</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_CR8_LOAD_EXITING</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* clts */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span> <span class="o">&amp;</span> <span class="n">X86_CR0_TS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_read_shadow</span> <span class="o">&amp;</span> <span class="n">X86_CR0_TS</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* mov from cr */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cpu_based_vm_exec_control</span> <span class="o">&amp;</span>
			    <span class="n">CPU_BASED_CR3_STORE_EXITING</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">8</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cpu_based_vm_exec_control</span> <span class="o">&amp;</span>
			    <span class="n">CPU_BASED_CR8_STORE_EXITING</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* lmsw */</span>
		<span class="cm">/*</span>
<span class="cm">		 * lmsw can change bits 1..3 of cr0, and only set bit 0 of</span>
<span class="cm">		 * cr0. Other attempted changes are ignored, with no exit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span> <span class="o">&amp;</span> <span class="mh">0xe</span> <span class="o">&amp;</span>
		    <span class="p">(</span><span class="n">val</span> <span class="o">^</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_read_shadow</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_read_shadow</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return 1 if we should exit from L2 to L1 to handle an exit, or 0 if we</span>
<span class="cm"> * should handle it ourselves in L0 (and then continue L2). Only call this</span>
<span class="cm"> * when in is_guest_mode (L2).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">nested_vmx_exit_handled</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">exit_reason</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_REASON</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">intr_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INTR_INFO</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span> <span class="o">=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">nested_run_pending</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">fail</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_info_ratelimited</span><span class="p">(</span><span class="s">&quot;%s failed vm entry %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				    <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_INSTRUCTION_ERROR</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">exit_reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_EXCEPTION_NMI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_exception</span><span class="p">(</span><span class="n">intr_info</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_page_fault</span><span class="p">(</span><span class="n">intr_info</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">enable_ept</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">exception_bitmap</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_VECTOR_MASK</span><span class="p">));</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_EXTERNAL_INTERRUPT</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_TRIPLE_FAULT</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_PENDING_INTERRUPT</span>:
	<span class="k">case</span> <span class="n">EXIT_REASON_NMI_WINDOW</span>:
		<span class="cm">/*</span>
<span class="cm">		 * prepare_vmcs02() set the CPU_BASED_VIRTUAL_INTR_PENDING bit</span>
<span class="cm">		 * (aka Interrupt Window Exiting) only when L1 turned it on,</span>
<span class="cm">		 * so if we got a PENDING_INTERRUPT exit, this must be for L1.</span>
<span class="cm">		 * Same for NMI Window Exiting.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_TASK_SWITCH</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_CPUID</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_HLT</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_HLT_EXITING</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_INVD</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_INVLPG</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_INVLPG_EXITING</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_RDPMC</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_RDPMC_EXITING</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_RDTSC</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_RDTSC_EXITING</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_VMCALL</span>: <span class="k">case</span> <span class="n">EXIT_REASON_VMCLEAR</span>:
	<span class="k">case</span> <span class="n">EXIT_REASON_VMLAUNCH</span>: <span class="k">case</span> <span class="n">EXIT_REASON_VMPTRLD</span>:
	<span class="k">case</span> <span class="n">EXIT_REASON_VMPTRST</span>: <span class="k">case</span> <span class="n">EXIT_REASON_VMREAD</span>:
	<span class="k">case</span> <span class="n">EXIT_REASON_VMRESUME</span>: <span class="k">case</span> <span class="n">EXIT_REASON_VMWRITE</span>:
	<span class="k">case</span> <span class="n">EXIT_REASON_VMOFF</span>: <span class="k">case</span> <span class="n">EXIT_REASON_VMON</span>:
		<span class="cm">/*</span>
<span class="cm">		 * VMX instructions trap unconditionally. This allows L1 to</span>
<span class="cm">		 * emulate them for its L2 guest, i.e., allows 3-level nesting!</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_CR_ACCESS</span>:
		<span class="k">return</span> <span class="n">nested_vmx_exit_handled_cr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_DR_ACCESS</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_MOV_DR_EXITING</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_IO_INSTRUCTION</span>:
		<span class="cm">/* TODO: support IO bitmaps */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_MSR_READ</span>:
	<span class="k">case</span> <span class="n">EXIT_REASON_MSR_WRITE</span>:
		<span class="k">return</span> <span class="n">nested_vmx_exit_handled_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">,</span> <span class="n">exit_reason</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_INVALID_STATE</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_MWAIT_INSTRUCTION</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_MWAIT_EXITING</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_MONITOR_INSTRUCTION</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_MONITOR_EXITING</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_PAUSE_INSTRUCTION</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">CPU_BASED_PAUSE_EXITING</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">nested_cpu_has2</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span>
				<span class="n">SECONDARY_EXEC_PAUSE_LOOP_EXITING</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_MCE_DURING_VMENTRY</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_TPR_BELOW_THRESHOLD</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_APIC_ACCESS</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has2</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span>
			<span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_EPT_VIOLATION</span>:
	<span class="k">case</span> <span class="n">EXIT_REASON_EPT_MISCONFIG</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_WBINVD</span>:
		<span class="k">return</span> <span class="n">nested_cpu_has2</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">SECONDARY_EXEC_WBINVD_EXITING</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EXIT_REASON_XSETBV</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_get_exit_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">info1</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">info2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">info1</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>
	<span class="o">*</span><span class="n">info2</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INTR_INFO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The guest has exited.  See if we can fix it or if we need userspace</span>
<span class="cm"> * assistance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_handle_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">exit_reason</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">exit_reason</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vectoring_info</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span><span class="p">;</span>

	<span class="cm">/* If guest state is invalid, start emulating */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">emulation_required</span> <span class="o">&amp;&amp;</span> <span class="n">emulate_invalid_guest_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">handle_invalid_guest_state</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * the KVM_REQ_EVENT optimization bit is only on for one entry, and if</span>
<span class="cm">	 * we did not inject a still-pending event to L1 now because of</span>
<span class="cm">	 * nested_run_pending, we need to re-enable this bit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">nested_run_pending</span><span class="p">)</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">exit_reason</span> <span class="o">==</span> <span class="n">EXIT_REASON_VMLAUNCH</span> <span class="o">||</span>
	    <span class="n">exit_reason</span> <span class="o">==</span> <span class="n">EXIT_REASON_VMRESUME</span><span class="p">))</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">nested_run_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">nested_run_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nested_vmx_exit_handled</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nested_vmx_vmexit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exit_reason</span> <span class="o">&amp;</span> <span class="n">VMX_EXIT_REASONS_FAILED_VMENTRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_FAIL_ENTRY</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">fail_entry</span><span class="p">.</span><span class="n">hardware_entry_failure_reason</span>
			<span class="o">=</span> <span class="n">exit_reason</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">fail</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_FAIL_ENTRY</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">fail_entry</span><span class="p">.</span><span class="n">hardware_entry_failure_reason</span>
			<span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_INSTRUCTION_ERROR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_VALID_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">exit_reason</span> <span class="o">!=</span> <span class="n">EXIT_REASON_EXCEPTION_NMI</span> <span class="o">&amp;&amp;</span>
			<span class="n">exit_reason</span> <span class="o">!=</span> <span class="n">EXIT_REASON_EPT_VIOLATION</span> <span class="o">&amp;&amp;</span>
			<span class="n">exit_reason</span> <span class="o">!=</span> <span class="n">EXIT_REASON_TASK_SWITCH</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: unexpected, valid vectoring info &quot;</span>
		       <span class="s">&quot;(0x%x) and exit reason is 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">vectoring_info</span><span class="p">,</span> <span class="n">exit_reason</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_has_virtual_nmis</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nested_cpu_has_virtual_nmis</span><span class="p">(</span>
	                                <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">vcpu</span><span class="p">))))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmx_interrupt_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vnmi_blocked_time</span> <span class="o">&gt;</span> <span class="mi">1000000000LL</span> <span class="o">&amp;&amp;</span>
			   <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This CPU don&#39;t support us in finding the end of an</span>
<span class="cm">			 * NMI-blocked window if the guest runs with IRQs</span>
<span class="cm">			 * disabled. So we pull the trigger after 1 s of</span>
<span class="cm">			 * futile waiting, but inform the user about this.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Breaking out of NMI-blocked &quot;</span>
			       <span class="s">&quot;state on VCPU %d after 1 s timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">);</span>
			<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exit_reason</span> <span class="o">&lt;</span> <span class="n">kvm_vmx_max_exit_handlers</span>
	    <span class="o">&amp;&amp;</span> <span class="n">kvm_vmx_exit_handlers</span><span class="p">[</span><span class="n">exit_reason</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">kvm_vmx_exit_handlers</span><span class="p">[</span><span class="n">exit_reason</span><span class="p">](</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_UNKNOWN</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hardware_exit_reason</span> <span class="o">=</span> <span class="n">exit_reason</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cr8_intercept</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tpr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">tpr</span> <span class="o">&lt;</span> <span class="n">irr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">TPR_THRESHOLD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">TPR_THRESHOLD</span><span class="p">,</span> <span class="n">irr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_complete_atomic_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">exit_intr_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">==</span> <span class="n">EXIT_REASON_MCE_DURING_VMENTRY</span>
	      <span class="o">||</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">==</span> <span class="n">EXIT_REASON_EXCEPTION_NMI</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">exit_intr_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INTR_INFO</span><span class="p">);</span>
	<span class="n">exit_intr_info</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">exit_intr_info</span><span class="p">;</span>

	<span class="cm">/* Handle machine checks before interrupts are enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_machine_check</span><span class="p">(</span><span class="n">exit_intr_info</span><span class="p">))</span>
		<span class="n">kvm_machine_check</span><span class="p">();</span>

	<span class="cm">/* We need to handle NMIs before interrupts are enabled */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">exit_intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_INTR_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">INTR_TYPE_NMI_INTR</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">exit_intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_before_handle_nmi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">asm</span><span class="p">(</span><span class="s">&quot;int $2&quot;</span><span class="p">);</span>
		<span class="n">kvm_after_handle_nmi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_recover_nmi_blocking</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">exit_intr_info</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">unblock_nmi</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">vector</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">idtv_info_valid</span><span class="p">;</span>

	<span class="n">idtv_info_valid</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_VALID_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_virtual_nmis</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nmi_known_unmasked</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Can&#39;t use vmx-&gt;exit_intr_info since we&#39;re not sure what</span>
<span class="cm">		 * the exit reason is.</span>
<span class="cm">		 */</span>
		<span class="n">exit_intr_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INTR_INFO</span><span class="p">);</span>
		<span class="n">unblock_nmi</span> <span class="o">=</span> <span class="p">(</span><span class="n">exit_intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_UNBLOCK_NMI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vector</span> <span class="o">=</span> <span class="n">exit_intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_VECTOR_MASK</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * SDM 3: 27.7.1.2 (September 2008)</span>
<span class="cm">		 * Re-set bit &quot;block by NMI&quot; before VM entry if vmexit caused by</span>
<span class="cm">		 * a guest IRET fault.</span>
<span class="cm">		 * SDM 3: 23.2.2 (September 2008)</span>
<span class="cm">		 * Bit 12 is undefined in any of the following cases:</span>
<span class="cm">		 *  If the VM exit sets the valid bit in the IDT-vectoring</span>
<span class="cm">		 *   information field.</span>
<span class="cm">		 *  If the VM exit is due to a double fault.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">exit_intr_info</span> <span class="o">&amp;</span> <span class="n">INTR_INFO_VALID_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unblock_nmi</span> <span class="o">&amp;&amp;</span>
		    <span class="n">vector</span> <span class="o">!=</span> <span class="n">DF_VECTOR</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">idtv_info_valid</span><span class="p">)</span>
			<span class="n">vmcs_set_bits</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">,</span>
				      <span class="n">GUEST_INTR_STATE_NMI</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nmi_known_unmasked</span> <span class="o">=</span>
				<span class="o">!</span><span class="p">(</span><span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">)</span>
				  <span class="o">&amp;</span> <span class="n">GUEST_INTR_STATE_NMI</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span><span class="p">))</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vnmi_blocked_time</span> <span class="o">+=</span>
			<span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">entry_time</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vmx_complete_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">idt_vectoring_info</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">instr_len_field</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">error_code_field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">vector</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">idtv_info_valid</span><span class="p">;</span>

	<span class="n">idtv_info_valid</span> <span class="o">=</span> <span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_VALID_MASK</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_injected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">kvm_clear_exception_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_clear_interrupt_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idtv_info_valid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">vector</span> <span class="o">=</span> <span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_VECTOR_MASK</span><span class="p">;</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_TYPE_MASK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INTR_TYPE_NMI_INTR</span>:
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_injected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * SDM 3: 27.7.1.2 (September 2008)</span>
<span class="cm">		 * Clear bit &quot;block by NMI&quot; before VM entry if a NMI</span>
<span class="cm">		 * delivery faulted.</span>
<span class="cm">		 */</span>
		<span class="n">vmx_set_nmi_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INTR_TYPE_SOFT_EXCEPTION</span>:
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">event_exit_inst_len</span> <span class="o">=</span>
			<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">instr_len_field</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">INTR_TYPE_HARD_EXCEPTION</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_DELIVER_CODE_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">err</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">error_code_field</span><span class="p">);</span>
			<span class="n">kvm_queue_exception_e</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INTR_TYPE_SOFT_INTR</span>:
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">event_exit_inst_len</span> <span class="o">=</span>
			<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">instr_len_field</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">INTR_TYPE_EXT_INTR</span>:
		<span class="n">kvm_queue_interrupt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span>
			<span class="n">type</span> <span class="o">==</span> <span class="n">INTR_TYPE_SOFT_INTR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_complete_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">__vmx_complete_interrupts</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span><span class="p">,</span>
				  <span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">,</span>
				  <span class="n">IDT_VECTORING_ERROR_CODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_cancel_injection</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">__vmx_complete_interrupts</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span>
				  <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">),</span>
				  <span class="n">VM_ENTRY_INSTRUCTION_LEN</span><span class="p">,</span>
				  <span class="n">VM_ENTRY_EXCEPTION_ERROR_CODE</span><span class="p">);</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atomic_switch_perf_msrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr_msrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_guest_switch_msr</span> <span class="o">*</span><span class="n">msrs</span><span class="p">;</span>

	<span class="n">msrs</span> <span class="o">=</span> <span class="n">perf_guest_get_msrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_msrs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msrs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_msrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">host</span> <span class="o">==</span> <span class="n">msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guest</span><span class="p">)</span>
			<span class="n">clear_atomic_switch_msr</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">msr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">add_atomic_switch_msr</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">msr</span><span class="p">,</span> <span class="n">msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guest</span><span class="p">,</span>
					<span class="n">msrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cp">#define R &quot;r&quot;</span>
<span class="cp">#define Q &quot;q&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define R &quot;e&quot;</span>
<span class="cp">#define Q &quot;l&quot;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__noclone</span> <span class="nf">vmx_vcpu_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">nested_run_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span> <span class="o">=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info_field</span> <span class="o">&amp;</span>
				<span class="n">VECTORING_INFO_VALID_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">,</span>
				<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info_field</span><span class="p">);</span>
			<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INSTRUCTION_LEN</span><span class="p">,</span>
				<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_instruction_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info_field</span> <span class="o">&amp;</span>
					<span class="n">VECTORING_INFO_DELIVER_CODE_MASK</span><span class="p">)</span>
				<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_EXCEPTION_ERROR_CODE</span><span class="p">,</span>
					<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">idt_vectoring_error_code</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Record the guest&#39;s net vcpu time for enforced NMI injections. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_has_virtual_nmis</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">soft_vnmi_blocked</span><span class="p">))</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">entry_time</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>

	<span class="cm">/* Don&#39;t enter VMX if guest state is invalid, let the exit handler</span>
<span class="cm">	   start emulation until we arrive back to a valid state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">emulation_required</span> <span class="o">&amp;&amp;</span> <span class="n">emulate_invalid_guest_state</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">VCPU_REGS_RSP</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_dirty</span><span class="p">))</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_RSP</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RSP</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">VCPU_REGS_RIP</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_dirty</span><span class="p">))</span>
		<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RIP</span><span class="p">]);</span>

	<span class="cm">/* When single-stepping over STI and MOV SS, we must clear the</span>
<span class="cm">	 * corresponding interruptibility bits in the guest state. Otherwise</span>
<span class="cm">	 * vmentry fails as it then expects bit 14 (BS) in pending debug</span>
<span class="cm">	 * exceptions being set, but that&#39;s not correct for the guest debugging</span>
<span class="cm">	 * case. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_SINGLESTEP</span><span class="p">)</span>
		<span class="n">vmx_set_interrupt_shadow</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">atomic_switch_perf_msrs</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">__launched</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">launched</span><span class="p">;</span>
	<span class="n">asm</span><span class="p">(</span>
		<span class="cm">/* Store host registers */</span>
		<span class="s">&quot;push %%&quot;</span><span class="n">R</span><span class="s">&quot;dx; push %%&quot;</span><span class="n">R</span><span class="s">&quot;bp;&quot;</span>
		<span class="s">&quot;push %%&quot;</span><span class="n">R</span><span class="s">&quot;cx </span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="cm">/* placeholder for guest rcx */</span>
		<span class="s">&quot;push %%&quot;</span><span class="n">R</span><span class="s">&quot;cx </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;cmp %%&quot;</span><span class="n">R</span><span class="s">&quot;sp, %c[host_rsp](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;je 1f </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%&quot;</span><span class="n">R</span><span class="s">&quot;sp, %c[host_rsp](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="n">__ex</span><span class="p">(</span><span class="n">ASM_VMX_VMWRITE_RSP_RDX</span><span class="p">)</span> <span class="s">&quot;</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;1: </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="cm">/* Reload cr2 if changed */</span>
		<span class="s">&quot;mov %c[cr2](%0), %%&quot;</span><span class="n">R</span><span class="s">&quot;ax </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%cr2, %%&quot;</span><span class="n">R</span><span class="s">&quot;dx </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;cmp %%&quot;</span><span class="n">R</span><span class="s">&quot;ax, %%&quot;</span><span class="n">R</span><span class="s">&quot;dx </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;je 2f </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%&quot;</span><span class="n">R</span><span class="s">&quot;ax, %%cr2 </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;2: </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="cm">/* Check if vmlaunch of vmresume is needed */</span>
		<span class="s">&quot;cmpl $0, %c[launched](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="cm">/* Load guest registers.  Don&#39;t clobber flags. */</span>
		<span class="s">&quot;mov %c[rax](%0), %%&quot;</span><span class="n">R</span><span class="s">&quot;ax </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[rbx](%0), %%&quot;</span><span class="n">R</span><span class="s">&quot;bx </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[rdx](%0), %%&quot;</span><span class="n">R</span><span class="s">&quot;dx </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[rsi](%0), %%&quot;</span><span class="n">R</span><span class="s">&quot;si </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[rdi](%0), %%&quot;</span><span class="n">R</span><span class="s">&quot;di </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[rbp](%0), %%&quot;</span><span class="n">R</span><span class="s">&quot;bp </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="s">&quot;mov %c[r8](%0),  %%r8  </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[r9](%0),  %%r9  </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[r10](%0), %%r10 </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[r11](%0), %%r11 </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[r12](%0), %%r12 </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[r13](%0), %%r13 </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[r14](%0), %%r14 </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %c[r15](%0), %%r15 </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
		<span class="s">&quot;mov %c[rcx](%0), %%&quot;</span><span class="n">R</span><span class="s">&quot;cx </span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="cm">/* kills %0 (ecx) */</span>

		<span class="cm">/* Enter guest mode */</span>
		<span class="s">&quot;jne .Llaunched </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="n">__ex</span><span class="p">(</span><span class="n">ASM_VMX_VMLAUNCH</span><span class="p">)</span> <span class="s">&quot;</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;jmp .Lkvm_vmx_return </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.Llaunched: &quot;</span> <span class="n">__ex</span><span class="p">(</span><span class="n">ASM_VMX_VMRESUME</span><span class="p">)</span> <span class="s">&quot;</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.Lkvm_vmx_return: &quot;</span>
		<span class="cm">/* Save guest registers, load host registers, keep flags */</span>
		<span class="s">&quot;mov %0, %c[wordsize](%%&quot;</span><span class="n">R</span><span class="s">&quot;sp) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;pop %0 </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%&quot;</span><span class="n">R</span><span class="s">&quot;ax, %c[rax](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%&quot;</span><span class="n">R</span><span class="s">&quot;bx, %c[rbx](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;pop&quot;</span><span class="n">Q</span><span class="s">&quot; %c[rcx](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%&quot;</span><span class="n">R</span><span class="s">&quot;dx, %c[rdx](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%&quot;</span><span class="n">R</span><span class="s">&quot;si, %c[rsi](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%&quot;</span><span class="n">R</span><span class="s">&quot;di, %c[rdi](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%&quot;</span><span class="n">R</span><span class="s">&quot;bp, %c[rbp](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="s">&quot;mov %%r8,  %c[r8](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%r9,  %c[r9](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%r10, %c[r10](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%r11, %c[r11](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%r12, %c[r12](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%r13, %c[r13](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%r14, %c[r14](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%r15, %c[r15](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
		<span class="s">&quot;mov %%cr2, %%&quot;</span><span class="n">R</span><span class="s">&quot;ax   </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov %%&quot;</span><span class="n">R</span><span class="s">&quot;ax, %c[cr2](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>

		<span class="s">&quot;pop  %%&quot;</span><span class="n">R</span><span class="s">&quot;bp; pop  %%&quot;</span><span class="n">R</span><span class="s">&quot;dx </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;setbe %c[fail](%0) </span><span class="se">\n\t</span><span class="s">&quot;</span>
	      <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;c&quot;</span><span class="p">(</span><span class="n">vmx</span><span class="p">),</span> <span class="s">&quot;d&quot;</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">HOST_RSP</span><span class="p">),</span>
		<span class="p">[</span><span class="n">launched</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">__launched</span><span class="p">)),</span>
		<span class="p">[</span><span class="n">fail</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">fail</span><span class="p">)),</span>
		<span class="p">[</span><span class="n">host_rsp</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">host_rsp</span><span class="p">)),</span>
		<span class="p">[</span><span class="n">rax</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RAX</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">rbx</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RBX</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">rcx</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RCX</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">rdx</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RDX</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">rsi</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RSI</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">rdi</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RDI</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">rbp</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_RBP</span><span class="p">])),</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="p">[</span><span class="n">r8</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_R8</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">r9</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_R9</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">r10</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_R10</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">r11</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_R11</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">r12</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_R12</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">r13</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_R13</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">r14</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_R14</span><span class="p">])),</span>
		<span class="p">[</span><span class="n">r15</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="n">VCPU_REGS_R15</span><span class="p">])),</span>
<span class="cp">#endif</span>
		<span class="p">[</span><span class="n">cr2</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">cr2</span><span class="p">)),</span>
		<span class="p">[</span><span class="n">wordsize</span><span class="p">]</span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ulong</span><span class="p">))</span>
	      <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span>
		<span class="p">,</span> <span class="n">R</span><span class="s">&quot;ax&quot;</span><span class="p">,</span> <span class="n">R</span><span class="s">&quot;bx&quot;</span><span class="p">,</span> <span class="n">R</span><span class="s">&quot;di&quot;</span><span class="p">,</span> <span class="n">R</span><span class="s">&quot;si&quot;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="p">,</span> <span class="s">&quot;r8&quot;</span><span class="p">,</span> <span class="s">&quot;r9&quot;</span><span class="p">,</span> <span class="s">&quot;r10&quot;</span><span class="p">,</span> <span class="s">&quot;r11&quot;</span><span class="p">,</span> <span class="s">&quot;r12&quot;</span><span class="p">,</span> <span class="s">&quot;r13&quot;</span><span class="p">,</span> <span class="s">&quot;r14&quot;</span><span class="p">,</span> <span class="s">&quot;r15&quot;</span>
<span class="cp">#endif</span>
	      <span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_REGS_RIP</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_REGS_RSP</span><span class="p">)</span>
				  <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_EXREG_RFLAGS</span><span class="p">)</span>
				  <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_EXREG_CPL</span><span class="p">)</span>
				  <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_EXREG_PDPTR</span><span class="p">)</span>
				  <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_EXREG_SEGMENTS</span><span class="p">)</span>
				  <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VCPU_EXREG_CR3</span><span class="p">));</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">IDT_VECTORING_INFO_FIELD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span> <span class="o">=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info_field</span> <span class="o">=</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info</span> <span class="o">&amp;</span> <span class="n">VECTORING_INFO_VALID_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">idt_vectoring_error_code</span> <span class="o">=</span>
				<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">IDT_VECTORING_ERROR_CODE</span><span class="p">);</span>
			<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_instruction_len</span> <span class="o">=</span>
				<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">launched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_REASON</span><span class="p">);</span>
	<span class="n">trace_kvm_exit</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">exit_reason</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">KVM_ISA_VMX</span><span class="p">);</span>

	<span class="n">vmx_complete_atomic_exit</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
	<span class="n">vmx_recover_nmi_blocking</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
	<span class="n">vmx_complete_interrupts</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#undef R</span>
<span class="cp">#undef Q</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_free_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">free_vpid</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
	<span class="n">free_nested</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
	<span class="n">free_loaded_vmcs</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">);</span>
	<span class="n">kvm_vcpu_uninit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kvm_vcpu_cache</span><span class="p">,</span> <span class="n">vmx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="nf">vmx_create_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">kvm_vcpu_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">allocate_vpid</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kvm_vcpu_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_vcpu</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">uninit_vcpu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vmcs01</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span> <span class="o">=</span> <span class="n">alloc_vmcs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="o">-&gt;</span><span class="n">vmcs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_msrs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmm_exclusive</span><span class="p">)</span>
		<span class="n">kvm_cpu_vmxon</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">vmxarea</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">())));</span>
	<span class="n">loaded_vmcs_init</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmm_exclusive</span><span class="p">)</span>
		<span class="n">kvm_cpu_vmxoff</span><span class="p">();</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">vmx_vcpu_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vmx_vcpu_setup</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
	<span class="n">vmx_vcpu_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_vmcs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_need_virtualize_apic_accesses</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_apic_access_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_vmcs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_map_addr</span><span class="p">)</span>
			<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_map_addr</span> <span class="o">=</span>
				<span class="n">VMX_EPT_IDENTITY_PAGETABLE_ADDR</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alloc_identity_pagetable</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_vmcs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init_rmode_identity_map</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_vmcs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">;</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmcs12</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">;</span>

<span class="nl">free_vmcs:</span>
	<span class="n">free_loaded_vmcs</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span><span class="p">);</span>
<span class="nl">free_msrs:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">guest_msrs</span><span class="p">);</span>
<span class="nl">uninit_vcpu:</span>
	<span class="n">kvm_vcpu_uninit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">);</span>
<span class="nl">free_vcpu:</span>
	<span class="n">free_vpid</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kvm_vcpu_cache</span><span class="p">,</span> <span class="n">vmx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">vmx_check_processor_compat</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rtn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmcs_config</span> <span class="n">vmcs_conf</span><span class="p">;</span>

	<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">rtn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">setup_vmcs_config</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmcs_conf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">rtn</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmcs_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmcs_conf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmcs_config</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: CPU %d feature inconsistency!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">rtn</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_ept_level</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">VMX_EPT_DEFAULT_GAW</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">vmx_get_mt_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* For VT-d and EPT combination</span>
<span class="cm">	 * 1. MMIO: always map as UC</span>
<span class="cm">	 * 2. EPT with VT-d:</span>
<span class="cm">	 *   a. VT-d without snooping control feature: can&#39;t guarantee the</span>
<span class="cm">	 *	result, try to trust guest.</span>
<span class="cm">	 *   b. VT-d with snooping control feature: snooping control feature of</span>
<span class="cm">	 *	VT-d engine can guarantee the cache correctness. Just set it</span>
<span class="cm">	 *	to WB to keep consistent with host. So the same as item 3.</span>
<span class="cm">	 * 3. EPT without VT-d: always map as WB and set IPAT=1 to keep</span>
<span class="cm">	 *    consistent with host MTRR</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_mmio</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MTRR_TYPE_UNCACHABLE</span> <span class="o">&lt;&lt;</span> <span class="n">VMX_EPT_MT_EPTE_SHIFT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">iommu_domain</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">iommu_flags</span> <span class="o">&amp;</span> <span class="n">KVM_IOMMU_CACHE_COHERENCY</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_get_guest_memory_type</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
		      <span class="n">VMX_EPT_MT_EPTE_SHIFT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">MTRR_TYPE_WRBACK</span> <span class="o">&lt;&lt;</span> <span class="n">VMX_EPT_MT_EPTE_SHIFT</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">VMX_EPT_IPAT_BIT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_get_lpage_level</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_has_vmx_ept_1g_page</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">PT_DIRECTORY_LEVEL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* For shadow and EPT supported 1GB page */</span>
		<span class="k">return</span> <span class="n">PT_PDPE_LEVEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_cpuid_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">best</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">exec_control</span><span class="p">;</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rdtscp_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx_rdtscp_supported</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">exec_control</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exec_control</span> <span class="o">&amp;</span> <span class="n">SECONDARY_EXEC_RDTSCP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">best</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mh">0x80000001</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">best</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">best</span><span class="o">-&gt;</span><span class="n">edx</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">(</span><span class="n">X86_FEATURE_RDTSCP</span><span class="p">)))</span>
				<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rdtscp_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SECONDARY_EXEC_RDTSCP</span><span class="p">;</span>
				<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">,</span>
						<span class="n">exec_control</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_set_supported_cpuid</span><span class="p">(</span><span class="n">u32</span> <span class="n">func</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">func</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nested</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ecx</span> <span class="o">|=</span> <span class="n">bit</span><span class="p">(</span><span class="n">X86_FEATURE_VMX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * prepare_vmcs02 is called when the L1 guest hypervisor runs its nested</span>
<span class="cm"> * L2 guest. L1 has a vmcs for L2 (vmcs12), and this function &quot;merges&quot; it</span>
<span class="cm"> * with L0&#39;s requirements for its guest (a.k.a. vmsc01), so we can run the L2</span>
<span class="cm"> * guest in a way that will both be appropriate to L1&#39;s requests, and our</span>
<span class="cm"> * needs. In addition to modifying the active vmcs (which is vmcs02), this</span>
<span class="cm"> * function also has additional necessary side-effects, like setting various</span>
<span class="cm"> * vcpu-&gt;arch fields.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">prepare_vmcs02</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">exec_control</span><span class="p">;</span>

	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_ES_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_es_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cs_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_SS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ss_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_DS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ds_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_FS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_fs_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_GS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gs_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_LDTR_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ldtr_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_TR_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_tr_selector</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_ES_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_es_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_CS_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cs_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_SS_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ss_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_DS_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ds_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_FS_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_fs_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_GS_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gs_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_LDTR_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ldtr_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_TR_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_tr_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_GDTR_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gdtr_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_IDTR_LIMIT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_idtr_limit</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_ES_AR_BYTES</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_es_ar_bytes</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_CS_AR_BYTES</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cs_ar_bytes</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_SS_AR_BYTES</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ss_ar_bytes</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_DS_AR_BYTES</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ds_ar_bytes</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_FS_AR_BYTES</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_fs_ar_bytes</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_GS_AR_BYTES</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gs_ar_bytes</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_LDTR_AR_BYTES</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ldtr_ar_bytes</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_TR_AR_BYTES</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_tr_ar_bytes</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_ES_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_es_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cs_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_SS_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ss_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_DS_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ds_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_FS_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_fs_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_GS_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gs_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_LDTR_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ldtr_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_TR_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_tr_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_GDTR_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gdtr_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_IDTR_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_idtr_base</span><span class="p">);</span>

	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_IA32_DEBUGCTL</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ia32_debugctl</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INTR_INFO_FIELD</span><span class="p">,</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_intr_info_field</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_EXCEPTION_ERROR_CODE</span><span class="p">,</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_exception_error_code</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_INSTRUCTION_LEN</span><span class="p">,</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_instruction_len</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">,</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_interruptibility_info</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_ACTIVITY_STATE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_activity_state</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_SYSENTER_CS</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_sysenter_cs</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_DR7</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_dr7</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_rflags</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_PENDING_DBG_EXCEPTIONS</span><span class="p">,</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_pending_dbg_exceptions</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_SYSENTER_ESP</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_sysenter_esp</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_SYSENTER_EIP</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_sysenter_eip</span><span class="p">);</span>

	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">VMCS_LINK_POINTER</span><span class="p">,</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">);</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">PIN_BASED_VM_EXEC_CONTROL</span><span class="p">,</span>
		<span class="p">(</span><span class="n">vmcs_config</span><span class="p">.</span><span class="n">pin_based_exec_ctrl</span> <span class="o">|</span>
		 <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">pin_based_vm_exec_control</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Whether page-faults are trapped is determined by a combination of</span>
<span class="cm">	 * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.</span>
<span class="cm">	 * If enable_ept, L0 doesn&#39;t care about page faults and we should</span>
<span class="cm">	 * set all of these to L1&#39;s desires. However, if !enable_ept, L0 does</span>
<span class="cm">	 * care about (at least some) page faults, and because it is not easy</span>
<span class="cm">	 * (if at all possible?) to merge L0 and L1&#39;s desires, we simply ask</span>
<span class="cm">	 * to exit on each and every L2 page fault. This is done by setting</span>
<span class="cm">	 * MASK=MATCH=0 and (see below) EB.PF=1.</span>
<span class="cm">	 * Note that below we don&#39;t need special code to set EB.PF beyond the</span>
<span class="cm">	 * &quot;or&quot;ing of the EB of vmcs01 and vmcs12, because when enable_ept,</span>
<span class="cm">	 * vmcs01&#39;s EB.PF is 0 so the &quot;or&quot; will take vmcs12&#39;s value, and when</span>
<span class="cm">	 * !enable_ept, EB.PF is 1, so the &quot;or&quot; will always be 1.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A problem with this approach (when !enable_ept) is that L1 may be</span>
<span class="cm">	 * injected with more page faults than it asked for. This could have</span>
<span class="cm">	 * caused problems, but in practice existing hypervisors don&#39;t care.</span>
<span class="cm">	 * To fix this, we will need to emulate the PFEC checking (on the L1</span>
<span class="cm">	 * page tables), using walk_addr(), when injecting PFs to L1.</span>
<span class="cm">	 */</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">PAGE_FAULT_ERROR_CODE_MASK</span><span class="p">,</span>
		<span class="n">enable_ept</span> <span class="o">?</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">page_fault_error_code_mask</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">PAGE_FAULT_ERROR_CODE_MATCH</span><span class="p">,</span>
		<span class="n">enable_ept</span> <span class="o">?</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">page_fault_error_code_match</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_secondary_exec_ctrls</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">exec_control</span> <span class="o">=</span> <span class="n">vmx_secondary_exec_control</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">rdtscp_enabled</span><span class="p">)</span>
			<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SECONDARY_EXEC_RDTSCP</span><span class="p">;</span>
		<span class="cm">/* Take the following fields only from vmcs12 */</span>
		<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nested_cpu_has</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span>
				<span class="n">CPU_BASED_ACTIVATE_SECONDARY_CONTROLS</span><span class="p">))</span>
			<span class="n">exec_control</span> <span class="o">|=</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">secondary_vm_exec_control</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">exec_control</span> <span class="o">&amp;</span> <span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Translate L1 physical address to host physical</span>
<span class="cm">			 * address for vmcs02. Keep the page pinned, so this</span>
<span class="cm">			 * physical address remains valid. We keep a reference</span>
<span class="cm">			 * to it so we can release it later.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">)</span> <span class="cm">/* shouldn&#39;t happen */</span>
				<span class="n">nested_release_page</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">);</span>
			<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span> <span class="o">=</span>
				<span class="n">nested_get_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">apic_access_addr</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If translation failed, no matter: This feature asks</span>
<span class="cm">			 * to exit when accessing the given address, and if it</span>
<span class="cm">			 * can never be accessed, this feature won&#39;t do</span>
<span class="cm">			 * anything anyway.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">)</span>
				<span class="n">exec_control</span> <span class="o">&amp;=</span>
				  <span class="o">~</span><span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">APIC_ACCESS_ADDR</span><span class="p">,</span>
				  <span class="n">page_to_phys</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">SECONDARY_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">exec_control</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * Set host-state according to L0&#39;s settings (vmcs12 is irrelevant here)</span>
<span class="cm">	 * Some constant fields are set here by vmx_set_constant_host_state().</span>
<span class="cm">	 * Other fields are different per CPU, and will be set later when</span>
<span class="cm">	 * vmx_vcpu_load() is called, and when vmx_save_host_state() is called.</span>
<span class="cm">	 */</span>
	<span class="n">vmx_set_constant_host_state</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * HOST_RSP is normally set correctly in vmx_vcpu_run() just before</span>
<span class="cm">	 * entry, but only if the current (host) sp changed from the value</span>
<span class="cm">	 * we wrote last (vmx-&gt;host_rsp). This cache is no longer relevant</span>
<span class="cm">	 * if we switch vmcs, and rather than hold a separate cache per vmcs,</span>
<span class="cm">	 * here we just force the write to happen on entry.</span>
<span class="cm">	 */</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_rsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">exec_control</span> <span class="o">=</span> <span class="n">vmx_exec_control</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span> <span class="cm">/* L0&#39;s desires */</span>
	<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_VIRTUAL_INTR_PENDING</span><span class="p">;</span>
	<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_VIRTUAL_NMI_PENDING</span><span class="p">;</span>
	<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_TPR_SHADOW</span><span class="p">;</span>
	<span class="n">exec_control</span> <span class="o">|=</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cpu_based_vm_exec_control</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Merging of IO and MSR bitmaps not currently supported.</span>
<span class="cm">	 * Rather, exit every time.</span>
<span class="cm">	 */</span>
	<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_USE_MSR_BITMAPS</span><span class="p">;</span>
	<span class="n">exec_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_BASED_USE_IO_BITMAPS</span><span class="p">;</span>
	<span class="n">exec_control</span> <span class="o">|=</span> <span class="n">CPU_BASED_UNCOND_IO_EXITING</span><span class="p">;</span>

	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">CPU_BASED_VM_EXEC_CONTROL</span><span class="p">,</span> <span class="n">exec_control</span><span class="p">);</span>

	<span class="cm">/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the</span>
<span class="cm">	 * bitwise-or of what L1 wants to trap for L2, and what we want to</span>
<span class="cm">	 * trap. Note that CR0.TS also needs updating - we do this later.</span>
<span class="cm">	 */</span>
	<span class="n">update_exception_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span><span class="p">;</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_GUEST_HOST_MASK</span><span class="p">,</span> <span class="o">~</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span><span class="p">);</span>

	<span class="cm">/* Note: IA32_MODE, LOAD_IA32_EFER are modified by vmx_set_efer below */</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_EXIT_CONTROLS</span><span class="p">,</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_controls</span> <span class="o">|</span> <span class="n">vmcs_config</span><span class="p">.</span><span class="n">vmexit_ctrl</span><span class="p">);</span>
	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">VM_ENTRY_CONTROLS</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_controls</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">vmcs_config</span><span class="p">.</span><span class="n">vmentry_ctrl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VM_ENTRY_IA32E_MODE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_controls</span> <span class="o">&amp;</span> <span class="n">VM_ENTRY_LOAD_IA32_PAT</span><span class="p">)</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_IA32_PAT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ia32_pat</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vmcs_config</span><span class="p">.</span><span class="n">vmentry_ctrl</span> <span class="o">&amp;</span> <span class="n">VM_ENTRY_LOAD_IA32_PAT</span><span class="p">)</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_IA32_PAT</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">pat</span><span class="p">);</span>


	<span class="n">set_cr4_guest_host_mask</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cpu_based_vm_exec_control</span> <span class="o">&amp;</span> <span class="n">CPU_BASED_USE_TSC_OFFSETING</span><span class="p">)</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">,</span>
			<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs01_tsc_offset</span> <span class="o">+</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">tsc_offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs01_tsc_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_vpid</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Trivially support vpid by letting L2s share their parent</span>
<span class="cm">		 * L1&#39;s vpid. TODO: move to a more elaborate solution, giving</span>
<span class="cm">		 * each L2 its own vpid and exposing the vpid feature to L1.</span>
<span class="cm">		 */</span>
		<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">VIRTUAL_PROCESSOR_ID</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vpid</span><span class="p">);</span>
		<span class="n">vmx_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_controls</span> <span class="o">&amp;</span> <span class="n">VM_ENTRY_LOAD_IA32_EFER</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">=</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ia32_efer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_controls</span> <span class="o">&amp;</span> <span class="n">VM_ENTRY_IA32E_MODE</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EFER_LMA</span> <span class="o">|</span> <span class="n">EFER_LME</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EFER_LMA</span> <span class="o">|</span> <span class="n">EFER_LME</span><span class="p">);</span>
	<span class="cm">/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */</span>
	<span class="n">vmx_set_efer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This sets GUEST_CR0 to vmcs12-&gt;guest_cr0, with possibly a modified</span>
<span class="cm">	 * TS bit (for lazy fpu) and bits which we consider mandatory enabled.</span>
<span class="cm">	 * The CR0_READ_SHADOW is what L2 should have expected to read given</span>
<span class="cm">	 * the specifications by L1; It&#39;s not enough to take</span>
<span class="cm">	 * vmcs12-&gt;cr0_read_shadow because on our cr0_guest_host_mask we we</span>
<span class="cm">	 * have more bits than L1 expected.</span>
<span class="cm">	 */</span>
	<span class="n">vmx_set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr0</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">,</span> <span class="n">nested_read_cr0</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">));</span>

	<span class="n">vmx_set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr4</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR4_READ_SHADOW</span><span class="p">,</span> <span class="n">nested_read_cr4</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">));</span>

	<span class="cm">/* shadow page tables on either EPT or shadow page tables */</span>
	<span class="n">kvm_set_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr3</span><span class="p">);</span>
	<span class="n">kvm_mmu_reset_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSP</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_rsp</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RIP</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_rip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nested_vmx_run() handles a nested entry, i.e., a VMLAUNCH or VMRESUME on L1</span>
<span class="cm"> * for running an L2 nested guest.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nested_vmx_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">launch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loaded_vmcs</span> <span class="o">*</span><span class="n">vmcs02</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested_vmx_check_permission</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">nested_vmx_check_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vmcs12</span> <span class="o">=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The nested entry process starts with enforcing various prerequisites</span>
<span class="cm">	 * on vmcs12 as required by the Intel SDM, and act appropriately when</span>
<span class="cm">	 * they fail: As the SDM explains, some conditions should cause the</span>
<span class="cm">	 * instruction to fail, while others will cause the instruction to seem</span>
<span class="cm">	 * to succeed, but return an EXIT_REASON_INVALID_STATE.</span>
<span class="cm">	 * To speed up the normal (success) code path, we should avoid checking</span>
<span class="cm">	 * for misconfigurations which will anyway be caught by the processor</span>
<span class="cm">	 * when using the merged vmcs02.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">launch_state</span> <span class="o">==</span> <span class="n">launch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span>
			<span class="n">launch</span> <span class="o">?</span> <span class="n">VMXERR_VMLAUNCH_NONCLEAR_VMCS</span>
			       <span class="o">:</span> <span class="n">VMXERR_VMRESUME_NONLAUNCHED_VMCS</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cpu_based_vm_exec_control</span> <span class="o">&amp;</span> <span class="n">CPU_BASED_USE_MSR_BITMAPS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">msr_bitmap</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*TODO: Also verify bits beyond physical address width are 0*/</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VMXERR_ENTRY_INVALID_CONTROL_FIELD</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nested_cpu_has2</span><span class="p">(</span><span class="n">vmcs12</span><span class="p">,</span> <span class="n">SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">apic_access_addr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*TODO: Also verify bits beyond physical address width are 0*/</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VMXERR_ENTRY_INVALID_CONTROL_FIELD</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_msr_load_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_msr_load_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_msr_store_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;%s: VMCS MSR_{LOAD,STORE} unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">__func__</span><span class="p">);</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VMXERR_ENTRY_INVALID_CONTROL_FIELD</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx_control_verify</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cpu_based_vm_exec_control</span><span class="p">,</span>
	      <span class="n">nested_vmx_procbased_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_procbased_ctls_high</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">vmx_control_verify</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">secondary_vm_exec_control</span><span class="p">,</span>
	      <span class="n">nested_vmx_secondary_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_secondary_ctls_high</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">vmx_control_verify</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">pin_based_vm_exec_control</span><span class="p">,</span>
	      <span class="n">nested_vmx_pinbased_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_pinbased_ctls_high</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">vmx_control_verify</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_controls</span><span class="p">,</span>
	      <span class="n">nested_vmx_exit_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_exit_ctls_high</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">vmx_control_verify</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_controls</span><span class="p">,</span>
	      <span class="n">nested_vmx_entry_ctls_low</span><span class="p">,</span> <span class="n">nested_vmx_entry_ctls_high</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VMXERR_ENTRY_INVALID_CONTROL_FIELD</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_cr0</span> <span class="o">&amp;</span> <span class="n">VMXON_CR0_ALWAYSON</span><span class="p">)</span> <span class="o">!=</span> <span class="n">VMXON_CR0_ALWAYSON</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_cr4</span> <span class="o">&amp;</span> <span class="n">VMXON_CR4_ALWAYSON</span><span class="p">)</span> <span class="o">!=</span> <span class="n">VMXON_CR4_ALWAYSON</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span>
			<span class="n">VMXERR_ENTRY_INVALID_HOST_STATE_FIELD</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr0</span> <span class="o">&amp;</span> <span class="n">VMXON_CR0_ALWAYSON</span><span class="p">)</span> <span class="o">!=</span> <span class="n">VMXON_CR0_ALWAYSON</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr4</span> <span class="o">&amp;</span> <span class="n">VMXON_CR4_ALWAYSON</span><span class="p">)</span> <span class="o">!=</span> <span class="n">VMXON_CR4_ALWAYSON</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nested_vmx_entry_failure</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">,</span>
			<span class="n">EXIT_REASON_INVALID_STATE</span><span class="p">,</span> <span class="n">ENTRY_FAIL_DEFAULT</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vmcs_link_pointer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1ull</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nested_vmx_entry_failure</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">,</span>
			<span class="n">EXIT_REASON_INVALID_STATE</span><span class="p">,</span> <span class="n">ENTRY_FAIL_VMCS_LINK_PTR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re finally done with prerequisite checking, and can start with</span>
<span class="cm">	 * the nested entry.</span>
<span class="cm">	 */</span>

	<span class="n">vmcs02</span> <span class="o">=</span> <span class="n">nested_get_current_vmcs02</span><span class="p">(</span><span class="n">vmx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmcs02</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">enter_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs01_tsc_offset</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span> <span class="o">=</span> <span class="n">vmcs02</span><span class="p">;</span>
	<span class="n">vmx_vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vmx_vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">launch_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">prepare_vmcs02</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note no nested_vmx_succeed or nested_vmx_fail here. At this point</span>
<span class="cm">	 * we are no longer running L1, and VMLAUNCH/VMRESUME has not yet</span>
<span class="cm">	 * returned as far as L1 is concerned. It will only return (and set</span>
<span class="cm">	 * the success flag) when L2 exits (see nested_vmx_vmexit()).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On a nested exit from L2 to L1, vmcs12.guest_cr0 might not be up-to-date</span>
<span class="cm"> * because L2 may have changed some cr0 bits directly (CRO_GUEST_HOST_MASK).</span>
<span class="cm"> * This function returns the new value we should put in vmcs12.guest_cr0.</span>
<span class="cm"> * It&#39;s not enough to just return the vmcs02 GUEST_CR0. Rather,</span>
<span class="cm"> *  1. Bits that neither L0 nor L1 trapped, were set directly by L2 and are now</span>
<span class="cm"> *     available in vmcs02 GUEST_CR0. (Note: It&#39;s enough to check that L0</span>
<span class="cm"> *     didn&#39;t trap the bit, because if L1 did, so would L0).</span>
<span class="cm"> *  2. Bits that L1 asked to trap (and therefore L0 also did) could not have</span>
<span class="cm"> *     been modified by L2, and L1 knows it. So just leave the old value of</span>
<span class="cm"> *     the bit from vmcs12.guest_cr0. Note that the bit from vmcs02 GUEST_CR0</span>
<span class="cm"> *     isn&#39;t relevant, because if L0 traps this bit it can set it to anything.</span>
<span class="cm"> *  3. Bits that L1 didn&#39;t trap, but L0 did. L1 believes the guest could have</span>
<span class="cm"> *     changed these bits, and therefore they need to be updated, but L0</span>
<span class="cm"> *     didn&#39;t necessarily allow them to be changed in GUEST_CR0 - and rather</span>
<span class="cm"> *     put them in vmcs02 CR0_READ_SHADOW. So take these bits from there.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">vmcs12_guest_cr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>
	<span class="cm">/*1*/</span>	<span class="p">(</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CR0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span><span class="p">)</span> <span class="o">|</span>
	<span class="cm">/*2*/</span>	<span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr0</span> <span class="o">&amp;</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span><span class="p">)</span> <span class="o">|</span>
	<span class="cm">/*3*/</span>	<span class="p">(</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">CR0_READ_SHADOW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr0_guest_host_mask</span> <span class="o">|</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">vmcs12_guest_cr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>
	<span class="cm">/*1*/</span>	<span class="p">(</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CR4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span><span class="p">)</span> <span class="o">|</span>
	<span class="cm">/*2*/</span>	<span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr4</span> <span class="o">&amp;</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr4_guest_host_mask</span><span class="p">)</span> <span class="o">|</span>
	<span class="cm">/*3*/</span>	<span class="p">(</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">CR4_READ_SHADOW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">cr4_guest_host_mask</span> <span class="o">|</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * prepare_vmcs12 is part of what we need to do when the nested L2 guest exits</span>
<span class="cm"> * and we want to prepare to run its L1 parent. L1 keeps a vmcs for L2 (vmcs12),</span>
<span class="cm"> * and this function updates it to reflect the changes to the guest state while</span>
<span class="cm"> * L2 was running (and perhaps made some exits which were handled directly by L0</span>
<span class="cm"> * without going back to L1), and to reflect the exit reason.</span>
<span class="cm"> * Note that we do not have to copy here all VMCS fields, just those that</span>
<span class="cm"> * could have changed by the L2 guest or the exit - i.e., the guest-state and</span>
<span class="cm"> * exit-information fields only. Other fields are modified by L1 with VMWRITE,</span>
<span class="cm"> * which already writes to vmcs12 directly.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">prepare_vmcs12</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* update guest state fields: */</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr0</span> <span class="o">=</span> <span class="n">vmcs12_guest_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cr4</span> <span class="o">=</span> <span class="n">vmcs12_guest_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">);</span>

	<span class="n">kvm_get_dr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_dr7</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_rsp</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSP</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_rip</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RIP</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_rflags</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RFLAGS</span><span class="p">);</span>

	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_es_selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_ES_SELECTOR</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cs_selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ss_selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_SS_SELECTOR</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ds_selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_DS_SELECTOR</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_fs_selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_FS_SELECTOR</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gs_selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_GS_SELECTOR</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ldtr_selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_LDTR_SELECTOR</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_tr_selector</span> <span class="o">=</span> <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_TR_SELECTOR</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_es_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_ES_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cs_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_CS_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ss_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_SS_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ds_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_DS_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_fs_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_FS_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gs_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_GS_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ldtr_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_LDTR_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_tr_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_TR_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gdtr_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_GDTR_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_idtr_limit</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_IDTR_LIMIT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_es_ar_bytes</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_ES_AR_BYTES</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cs_ar_bytes</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_CS_AR_BYTES</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ss_ar_bytes</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_SS_AR_BYTES</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ds_ar_bytes</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_DS_AR_BYTES</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_fs_ar_bytes</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_FS_AR_BYTES</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gs_ar_bytes</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_GS_AR_BYTES</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ldtr_ar_bytes</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_LDTR_AR_BYTES</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_tr_ar_bytes</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_TR_AR_BYTES</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_es_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_ES_BASE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_cs_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_CS_BASE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ss_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_SS_BASE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ds_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_DS_BASE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_fs_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_FS_BASE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gs_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_GS_BASE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ldtr_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_LDTR_BASE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_tr_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_TR_BASE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_gdtr_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_GDTR_BASE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_idtr_base</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_IDTR_BASE</span><span class="p">);</span>

	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_activity_state</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_ACTIVITY_STATE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_interruptibility_info</span> <span class="o">=</span>
		<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_INTERRUPTIBILITY_INFO</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_pending_dbg_exceptions</span> <span class="o">=</span>
		<span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_PENDING_DBG_EXCEPTIONS</span><span class="p">);</span>

	<span class="cm">/* TODO: These cannot have changed unless we have MSR bitmaps and</span>
<span class="cm">	 * the relevant bit asks not to trap the change */</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ia32_debugctl</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">GUEST_IA32_DEBUGCTL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_controls</span> <span class="o">&amp;</span> <span class="n">VM_EXIT_SAVE_IA32_PAT</span><span class="p">)</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_ia32_pat</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">GUEST_IA32_PAT</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_sysenter_cs</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">GUEST_SYSENTER_CS</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_sysenter_esp</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_SYSENTER_ESP</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">guest_sysenter_eip</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_SYSENTER_EIP</span><span class="p">);</span>

	<span class="cm">/* update exit information fields: */</span>

	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_reason</span>  <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_REASON</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">EXIT_QUALIFICATION</span><span class="p">);</span>

	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_intr_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INTR_INFO</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_intr_error_code</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INTR_ERROR_CODE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">idt_vectoring_info_field</span> <span class="o">=</span>
		<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">IDT_VECTORING_INFO_FIELD</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">idt_vectoring_error_code</span> <span class="o">=</span>
		<span class="n">vmcs_read32</span><span class="p">(</span><span class="n">IDT_VECTORING_ERROR_CODE</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_instruction_len</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_EXIT_INSTRUCTION_LEN</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vmx_instruction_info</span> <span class="o">=</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VMX_INSTRUCTION_INFO</span><span class="p">);</span>

	<span class="cm">/* clear vm-entry fields which are to be cleared on exit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_reason</span> <span class="o">&amp;</span> <span class="n">VMX_EXIT_REASONS_FAILED_VMENTRY</span><span class="p">))</span>
		<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_entry_intr_info_field</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INTR_INFO_VALID_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A part of what we need to when the nested L2 guest exits and we want to</span>
<span class="cm"> * run its L1 parent, is to reset L1&#39;s guest state to the host state specified</span>
<span class="cm"> * in vmcs12.</span>
<span class="cm"> * This function is to be called not only on normal nested exit, but also on</span>
<span class="cm"> * a nested entry failure, as explained in Intel&#39;s spec, 3B.23.7 (&quot;VM-Entry</span>
<span class="cm"> * Failures During or After Loading Guest State&quot;).</span>
<span class="cm"> * This function should be called when the active VMCS is L1&#39;s (vmcs01).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">load_vmcs12_host_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_controls</span> <span class="o">&amp;</span> <span class="n">VM_EXIT_LOAD_IA32_EFER</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">=</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_ia32_efer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_controls</span> <span class="o">&amp;</span> <span class="n">VM_EXIT_HOST_ADDR_SPACE_SIZE</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">|=</span> <span class="p">(</span><span class="n">EFER_LMA</span> <span class="o">|</span> <span class="n">EFER_LME</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EFER_LMA</span> <span class="o">|</span> <span class="n">EFER_LME</span><span class="p">);</span>
	<span class="n">vmx_set_efer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span><span class="p">);</span>

	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSP</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_rsp</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RIP</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_rip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note that calling vmx_set_cr0 is important, even if cr0 hasn&#39;t</span>
<span class="cm">	 * actually changed, because it depends on the current state of</span>
<span class="cm">	 * fpu_active (which may have changed).</span>
<span class="cm">	 * Note that vmx_set_cr0 refers to efer set above.</span>
<span class="cm">	 */</span>
	<span class="n">kvm_set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_cr0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we did fpu_activate()/fpu_deactivate() during L2&#39;s run, we need</span>
<span class="cm">	 * to apply the same changes to L1&#39;s vmcs. We just set cr0 correctly,</span>
<span class="cm">	 * but we also need to update cr0_guest_host_mask and exception_bitmap.</span>
<span class="cm">	 */</span>
	<span class="n">update_exception_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">fpu_active</span> <span class="o">?</span> <span class="n">X86_CR0_TS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">CR0_GUEST_HOST_MASK</span><span class="p">,</span> <span class="o">~</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0_guest_owned_bits</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that CR4_GUEST_HOST_MASK is already set in the original vmcs01</span>
<span class="cm">	 * (KVM doesn&#39;t change it)- no reason to call set_cr4_guest_host_mask();</span>
<span class="cm">	 */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr4_guest_owned_bits</span> <span class="o">=</span> <span class="o">~</span><span class="n">vmcs_readl</span><span class="p">(</span><span class="n">CR4_GUEST_HOST_MASK</span><span class="p">);</span>
	<span class="n">kvm_set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_cr4</span><span class="p">);</span>

	<span class="cm">/* shadow page tables on either EPT or shadow page tables */</span>
	<span class="n">kvm_set_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_cr3</span><span class="p">);</span>
	<span class="n">kvm_mmu_reset_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_vpid</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Trivially support vpid by letting L2s share their parent</span>
<span class="cm">		 * L1&#39;s vpid. TODO: move to a more elaborate solution, giving</span>
<span class="cm">		 * each L2 its own vpid and exposing the vpid feature to L1.</span>
<span class="cm">		 */</span>
		<span class="n">vmx_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="n">vmcs_write32</span><span class="p">(</span><span class="n">GUEST_SYSENTER_CS</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_ia32_sysenter_cs</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_SYSENTER_ESP</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_ia32_sysenter_esp</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_SYSENTER_EIP</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_ia32_sysenter_eip</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_IDTR_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_idtr_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_GDTR_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_gdtr_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_TR_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_tr_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_GS_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_gs_base</span><span class="p">);</span>
	<span class="n">vmcs_writel</span><span class="p">(</span><span class="n">GUEST_FS_BASE</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_fs_base</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_ES_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_es_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_cs_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_SS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_ss_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_DS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_ds_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_FS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_fs_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_GS_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_gs_selector</span><span class="p">);</span>
	<span class="n">vmcs_write16</span><span class="p">(</span><span class="n">GUEST_TR_SELECTOR</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_tr_selector</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_controls</span> <span class="o">&amp;</span> <span class="n">VM_EXIT_LOAD_IA32_PAT</span><span class="p">)</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_IA32_PAT</span><span class="p">,</span> <span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_ia32_pat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_controls</span> <span class="o">&amp;</span> <span class="n">VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL</span><span class="p">)</span>
		<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">GUEST_IA32_PERF_GLOBAL_CTRL</span><span class="p">,</span>
			<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">host_ia32_perf_global_ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Emulate an exit from nested guest (L2) to L1, i.e., prepare to run L1</span>
<span class="cm"> * and modify vmcs12 to make it see what it would expect to see there if</span>
<span class="cm"> * L2 was its real guest. Must only be called when in L2 (is_guest_mode())</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nested_vmx_vmexit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span> <span class="o">=</span> <span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span> <span class="o">=</span> <span class="n">get_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">leave_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">prepare_vmcs12</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">loaded_vmcs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">vmcs01</span><span class="p">;</span>
	<span class="n">vmx_vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vmx_vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="cm">/* if no vmcs02 cache requested, remove the one we used */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VMCS02_POOL_SIZE</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nested_free_vmcs02</span><span class="p">(</span><span class="n">vmx</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">current_vmptr</span><span class="p">);</span>

	<span class="n">load_vmcs12_host_state</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">);</span>

	<span class="cm">/* Update TSC_OFFSET if TSC was changed while L2 ran */</span>
	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">TSC_OFFSET</span><span class="p">,</span> <span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">vmcs01_tsc_offset</span><span class="p">);</span>

	<span class="cm">/* This is needed for same reason as it was needed in prepare_vmcs02 */</span>
	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">host_rsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Unpin physical memory we referred to in vmcs02 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nested_release_page</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">);</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">nested</span><span class="p">.</span><span class="n">apic_access_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Exiting from L2 to L1, we&#39;re now back to L1 which thinks it just</span>
<span class="cm">	 * finished a VMLAUNCH or VMRESUME instruction, so we need to set the</span>
<span class="cm">	 * success or failure flag accordingly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">fail</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">fail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nested_vmx_failValid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs_read32</span><span class="p">(</span><span class="n">VM_INSTRUCTION_ERROR</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">nested_vmx_succeed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * L1&#39;s failure to enter L2 is a subset of a normal exit, as explained in</span>
<span class="cm"> * 23.7 &quot;VM-entry failures during or after loading guest state&quot; (this also</span>
<span class="cm"> * lists the acceptable exit-reason and exit-qualification parameters).</span>
<span class="cm"> * It should only be called before L2 actually succeeded to run, and when</span>
<span class="cm"> * vmcs01 is current (it doesn&#39;t leave_guest_mode() or switch vmcss).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nested_vmx_entry_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vmcs12</span> <span class="o">*</span><span class="n">vmcs12</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">qualification</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">load_vmcs12_host_state</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vmcs12</span><span class="p">);</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">vm_exit_reason</span> <span class="o">=</span> <span class="n">reason</span> <span class="o">|</span> <span class="n">VMX_EXIT_REASONS_FAILED_VMENTRY</span><span class="p">;</span>
	<span class="n">vmcs12</span><span class="o">-&gt;</span><span class="n">exit_qualification</span> <span class="o">=</span> <span class="n">qualification</span><span class="p">;</span>
	<span class="n">nested_vmx_succeed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_check_intercept</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">x86_instruction_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">x86_intercept_stage</span> <span class="n">stage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_x86_ops</span> <span class="n">vmx_x86_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cpu_has_kvm_support</span> <span class="o">=</span> <span class="n">cpu_has_kvm_support</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disabled_by_bios</span> <span class="o">=</span> <span class="n">vmx_disabled_by_bios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hardware_setup</span> <span class="o">=</span> <span class="n">hardware_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hardware_unsetup</span> <span class="o">=</span> <span class="n">hardware_unsetup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_processor_compatibility</span> <span class="o">=</span> <span class="n">vmx_check_processor_compat</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hardware_enable</span> <span class="o">=</span> <span class="n">hardware_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hardware_disable</span> <span class="o">=</span> <span class="n">hardware_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cpu_has_accelerated_tpr</span> <span class="o">=</span> <span class="n">report_flexpriority</span><span class="p">,</span>

	<span class="p">.</span><span class="n">vcpu_create</span> <span class="o">=</span> <span class="n">vmx_create_vcpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vcpu_free</span> <span class="o">=</span> <span class="n">vmx_free_vcpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vcpu_reset</span> <span class="o">=</span> <span class="n">vmx_vcpu_reset</span><span class="p">,</span>

	<span class="p">.</span><span class="n">prepare_guest_switch</span> <span class="o">=</span> <span class="n">vmx_save_host_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vcpu_load</span> <span class="o">=</span> <span class="n">vmx_vcpu_load</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vcpu_put</span> <span class="o">=</span> <span class="n">vmx_vcpu_put</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_guest_debug</span> <span class="o">=</span> <span class="n">set_guest_debug</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msr</span> <span class="o">=</span> <span class="n">vmx_get_msr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msr</span> <span class="o">=</span> <span class="n">vmx_set_msr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_segment_base</span> <span class="o">=</span> <span class="n">vmx_get_segment_base</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_segment</span> <span class="o">=</span> <span class="n">vmx_get_segment</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_segment</span> <span class="o">=</span> <span class="n">vmx_set_segment</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cpl</span> <span class="o">=</span> <span class="n">vmx_get_cpl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cs_db_l_bits</span> <span class="o">=</span> <span class="n">vmx_get_cs_db_l_bits</span><span class="p">,</span>
	<span class="p">.</span><span class="n">decache_cr0_guest_bits</span> <span class="o">=</span> <span class="n">vmx_decache_cr0_guest_bits</span><span class="p">,</span>
	<span class="p">.</span><span class="n">decache_cr3</span> <span class="o">=</span> <span class="n">vmx_decache_cr3</span><span class="p">,</span>
	<span class="p">.</span><span class="n">decache_cr4_guest_bits</span> <span class="o">=</span> <span class="n">vmx_decache_cr4_guest_bits</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_cr0</span> <span class="o">=</span> <span class="n">vmx_set_cr0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_cr3</span> <span class="o">=</span> <span class="n">vmx_set_cr3</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_cr4</span> <span class="o">=</span> <span class="n">vmx_set_cr4</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_efer</span> <span class="o">=</span> <span class="n">vmx_set_efer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_idt</span> <span class="o">=</span> <span class="n">vmx_get_idt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_idt</span> <span class="o">=</span> <span class="n">vmx_set_idt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_gdt</span> <span class="o">=</span> <span class="n">vmx_get_gdt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_gdt</span> <span class="o">=</span> <span class="n">vmx_set_gdt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_dr7</span> <span class="o">=</span> <span class="n">vmx_set_dr7</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_reg</span> <span class="o">=</span> <span class="n">vmx_cache_reg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_rflags</span> <span class="o">=</span> <span class="n">vmx_get_rflags</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_rflags</span> <span class="o">=</span> <span class="n">vmx_set_rflags</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fpu_activate</span> <span class="o">=</span> <span class="n">vmx_fpu_activate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fpu_deactivate</span> <span class="o">=</span> <span class="n">vmx_fpu_deactivate</span><span class="p">,</span>

	<span class="p">.</span><span class="n">tlb_flush</span> <span class="o">=</span> <span class="n">vmx_flush_tlb</span><span class="p">,</span>

	<span class="p">.</span><span class="n">run</span> <span class="o">=</span> <span class="n">vmx_vcpu_run</span><span class="p">,</span>
	<span class="p">.</span><span class="n">handle_exit</span> <span class="o">=</span> <span class="n">vmx_handle_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">skip_emulated_instruction</span> <span class="o">=</span> <span class="n">skip_emulated_instruction</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_interrupt_shadow</span> <span class="o">=</span> <span class="n">vmx_set_interrupt_shadow</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_interrupt_shadow</span> <span class="o">=</span> <span class="n">vmx_get_interrupt_shadow</span><span class="p">,</span>
	<span class="p">.</span><span class="n">patch_hypercall</span> <span class="o">=</span> <span class="n">vmx_patch_hypercall</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_irq</span> <span class="o">=</span> <span class="n">vmx_inject_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_nmi</span> <span class="o">=</span> <span class="n">vmx_inject_nmi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queue_exception</span> <span class="o">=</span> <span class="n">vmx_queue_exception</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cancel_injection</span> <span class="o">=</span> <span class="n">vmx_cancel_injection</span><span class="p">,</span>
	<span class="p">.</span><span class="n">interrupt_allowed</span> <span class="o">=</span> <span class="n">vmx_interrupt_allowed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nmi_allowed</span> <span class="o">=</span> <span class="n">vmx_nmi_allowed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_nmi_mask</span> <span class="o">=</span> <span class="n">vmx_get_nmi_mask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_nmi_mask</span> <span class="o">=</span> <span class="n">vmx_set_nmi_mask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_nmi_window</span> <span class="o">=</span> <span class="n">enable_nmi_window</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_irq_window</span> <span class="o">=</span> <span class="n">enable_irq_window</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_cr8_intercept</span> <span class="o">=</span> <span class="n">update_cr8_intercept</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_tss_addr</span> <span class="o">=</span> <span class="n">vmx_set_tss_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_tdp_level</span> <span class="o">=</span> <span class="n">get_ept_level</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_mt_mask</span> <span class="o">=</span> <span class="n">vmx_get_mt_mask</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_exit_info</span> <span class="o">=</span> <span class="n">vmx_get_exit_info</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_lpage_level</span> <span class="o">=</span> <span class="n">vmx_get_lpage_level</span><span class="p">,</span>

	<span class="p">.</span><span class="n">cpuid_update</span> <span class="o">=</span> <span class="n">vmx_cpuid_update</span><span class="p">,</span>

	<span class="p">.</span><span class="n">rdtscp_supported</span> <span class="o">=</span> <span class="n">vmx_rdtscp_supported</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_supported_cpuid</span> <span class="o">=</span> <span class="n">vmx_set_supported_cpuid</span><span class="p">,</span>

	<span class="p">.</span><span class="n">has_wbinvd_exit</span> <span class="o">=</span> <span class="n">cpu_has_vmx_wbinvd_exit</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_tsc_khz</span> <span class="o">=</span> <span class="n">vmx_set_tsc_khz</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_tsc_offset</span> <span class="o">=</span> <span class="n">vmx_write_tsc_offset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">adjust_tsc_offset</span> <span class="o">=</span> <span class="n">vmx_adjust_tsc_offset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compute_tsc_offset</span> <span class="o">=</span> <span class="n">vmx_compute_tsc_offset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_l1_tsc</span> <span class="o">=</span> <span class="n">vmx_read_l1_tsc</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_tdp_cr3</span> <span class="o">=</span> <span class="n">vmx_set_cr3</span><span class="p">,</span>

	<span class="p">.</span><span class="n">check_intercept</span> <span class="o">=</span> <span class="n">vmx_check_intercept</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">vmx_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rdmsrl_safe</span><span class="p">(</span><span class="n">MSR_EFER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host_efer</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_VMX_MSR</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">kvm_define_shared_msr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vmx_msr_index</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">vmx_io_bitmap_a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx_io_bitmap_a</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">vmx_io_bitmap_b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx_io_bitmap_b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmx_msr_bitmap_legacy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx_msr_bitmap_legacy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmx_msr_bitmap_longmode</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmx_msr_bitmap_longmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow direct access to the PC debug port (it is often used for I/O</span>
<span class="cm">	 * delays, but the vmexits simply slow things down).</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vmx_io_bitmap_a</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">vmx_io_bitmap_a</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">vmx_io_bitmap_b</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">vmx_msr_bitmap_legacy</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vmx_msr_bitmap_longmode</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmx_vpid_bitmap</span><span class="p">);</span> <span class="cm">/* 0 is reserved for host */</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmx_x86_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">),</span>
		     <span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span><span class="p">),</span> <span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>

	<span class="n">vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="n">MSR_FS_BASE</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="n">MSR_GS_BASE</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="n">MSR_KERNEL_GS_BASE</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_CS</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_ESP</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">vmx_disable_intercept_for_msr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_EIP</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_mmu_set_mask_ptes</span><span class="p">(</span><span class="mi">0ull</span><span class="p">,</span> <span class="mi">0ull</span><span class="p">,</span> <span class="mi">0ull</span><span class="p">,</span> <span class="mi">0ull</span><span class="p">,</span>
				<span class="n">VMX_EPT_EXECUTABLE_MASK</span><span class="p">);</span>
		<span class="n">ept_set_mmio_spte_mask</span><span class="p">();</span>
		<span class="n">kvm_enable_tdp</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kvm_disable_tdp</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out3:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmx_msr_bitmap_longmode</span><span class="p">);</span>
<span class="nl">out2:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmx_msr_bitmap_legacy</span><span class="p">);</span>
<span class="nl">out1:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmx_io_bitmap_b</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmx_io_bitmap_a</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">vmx_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmx_msr_bitmap_legacy</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmx_msr_bitmap_longmode</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmx_io_bitmap_b</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmx_io_bitmap_a</span><span class="p">);</span>

	<span class="n">kvm_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">vmx_init</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">vmx_exit</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
