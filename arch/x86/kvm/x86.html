<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kvm › x86.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>x86.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Kernel-based Virtual Machine driver for Linux</span>
<span class="cm"> *</span>
<span class="cm"> * derived from drivers/kvm/kvm_main.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Qumranet, Inc.</span>
<span class="cm"> * Copyright (C) 2008 Qumranet, Inc.</span>
<span class="cm"> * Copyright IBM Corporation, 2008</span>
<span class="cm"> * Copyright 2010 Red Hat, Inc. and/or its affiliates.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *   Avi Kivity   &lt;avi@qumranet.com&gt;</span>
<span class="cm"> *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;</span>
<span class="cm"> *   Amit Shah    &lt;amit.shah@qumranet.com&gt;</span>
<span class="cm"> *   Ben-Ami Yassour &lt;benami@il.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This work is licensed under the terms of the GNU GPL, version 2.  See</span>
<span class="cm"> * the COPYING file in the top-level directory.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kvm_host.h&gt;</span>
<span class="cp">#include &quot;irq.h&quot;</span>
<span class="cp">#include &quot;mmu.h&quot;</span>
<span class="cp">#include &quot;i8254.h&quot;</span>
<span class="cp">#include &quot;tss.h&quot;</span>
<span class="cp">#include &quot;kvm_cache_regs.h&quot;</span>
<span class="cp">#include &quot;x86.h&quot;</span>
<span class="cp">#include &quot;cpuid.h&quot;</span>

<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kvm.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/iommu.h&gt;</span>
<span class="cp">#include &lt;linux/intel-iommu.h&gt;</span>
<span class="cp">#include &lt;linux/cpufreq.h&gt;</span>
<span class="cp">#include &lt;linux/user-return-notifier.h&gt;</span>
<span class="cp">#include &lt;linux/srcu.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;trace/events/kvm.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &quot;trace.h&quot;</span>

<span class="cp">#include &lt;asm/debugreg.h&gt;</span>
<span class="cp">#include &lt;asm/msr.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/mtrr.h&gt;</span>
<span class="cp">#include &lt;asm/mce.h&gt;</span>
<span class="cp">#include &lt;asm/i387.h&gt;</span>
<span class="cp">#include &lt;asm/fpu-internal.h&gt; </span><span class="cm">/* Ugh! */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/xcr.h&gt;</span>
<span class="cp">#include &lt;asm/pvclock.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>

<span class="cp">#define MAX_IO_MSRS 256</span>
<span class="cp">#define KVM_MAX_MCE_BANKS 32</span>
<span class="cp">#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)</span>

<span class="cp">#define emul_to_vcpu(ctxt) \</span>
<span class="cp">	container_of(ctxt, struct kvm_vcpu, arch.emulate_ctxt)</span>

<span class="cm">/* EFER defaults:</span>
<span class="cm"> * - enable syscall per default because its emulated by KVM</span>
<span class="cm"> * - enable LME and LMA per default on 64 bit KVM</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">static</span>
<span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">efer_reserved_bits</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)(</span><span class="n">EFER_SCE</span> <span class="o">|</span> <span class="n">EFER_LME</span> <span class="o">|</span> <span class="n">EFER_LMA</span><span class="p">));</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">efer_reserved_bits</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">EFER_SCE</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#define VM_STAT(x) offsetof(struct kvm, stat.x), KVM_STAT_VM</span>
<span class="cp">#define VCPU_STAT(x) offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">update_cr8_intercept</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">process_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">kvm_x86_ops</span> <span class="o">*</span><span class="n">kvm_x86_ops</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_x86_ops</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">ignore_msrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ignore_msrs</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

<span class="n">bool</span> <span class="n">kvm_has_tsc_control</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_has_tsc_control</span><span class="p">);</span>
<span class="n">u32</span>  <span class="n">kvm_max_guest_tsc_khz</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_max_guest_tsc_khz</span><span class="p">);</span>

<span class="cm">/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">tsc_tolerance_ppm</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">tsc_tolerance_ppm</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

<span class="cp">#define KVM_NR_SHARED_MSRS 16</span>

<span class="k">struct</span> <span class="n">kvm_shared_msrs_global</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msrs</span><span class="p">[</span><span class="n">KVM_NR_SHARED_MSRS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_shared_msrs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_return_notifier</span> <span class="n">urn</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">registered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_shared_msr_values</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">host</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">curr</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">values</span><span class="p">[</span><span class="n">KVM_NR_SHARED_MSRS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_shared_msrs_global</span> <span class="n">__read_mostly</span> <span class="n">shared_msrs_global</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_shared_msrs</span><span class="p">,</span> <span class="n">shared_msrs</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">kvm_stats_debugfs_item</span> <span class="n">debugfs_entries</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;pf_fixed&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">pf_fixed</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;pf_guest&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">pf_guest</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tlb_flush&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">tlb_flush</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;invlpg&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">invlpg</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;exits&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">exits</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;io_exits&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">io_exits</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mmio_exits&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">mmio_exits</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal_exits&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">signal_exits</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;irq_window&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">irq_window_exits</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;nmi_window&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">nmi_window_exits</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;halt_exits&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">halt_exits</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;halt_wakeup&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">halt_wakeup</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;hypercalls&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">hypercalls</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;request_irq&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">request_irq_exits</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;irq_exits&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">irq_exits</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;host_state_reload&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">host_state_reload</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;efer_reload&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">efer_reload</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;fpu_reload&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">fpu_reload</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;insn_emulation&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">insn_emulation</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;insn_emulation_fail&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">insn_emulation_fail</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;irq_injections&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">irq_injections</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;nmi_injections&quot;</span><span class="p">,</span> <span class="n">VCPU_STAT</span><span class="p">(</span><span class="n">nmi_injections</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mmu_shadow_zapped&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">mmu_shadow_zapped</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mmu_pte_write&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">mmu_pte_write</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mmu_pte_updated&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">mmu_pte_updated</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mmu_pde_zapped&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">mmu_pde_zapped</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mmu_flooded&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">mmu_flooded</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mmu_recycled&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">mmu_recycled</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mmu_cache_miss&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">mmu_cache_miss</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mmu_unsync&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">mmu_unsync</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;remote_tlb_flush&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">remote_tlb_flush</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;largepages&quot;</span><span class="p">,</span> <span class="n">VM_STAT</span><span class="p">(</span><span class="n">lpages</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">host_xcr0</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">emulator_fix_hypercall</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_async_pf_hash_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">ASYNC_PF_PER_VCPU</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_on_user_return</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_return_notifier</span> <span class="o">*</span><span class="n">urn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_shared_msrs</span> <span class="o">*</span><span class="n">locals</span>
		<span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">urn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_shared_msrs</span><span class="p">,</span> <span class="n">urn</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kvm_shared_msr_values</span> <span class="o">*</span><span class="n">values</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="n">shared_msrs_global</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span> <span class="o">++</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">values</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">locals</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">values</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">!=</span> <span class="n">values</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wrmsrl</span><span class="p">(</span><span class="n">shared_msrs_global</span><span class="p">.</span><span class="n">msrs</span><span class="p">[</span><span class="n">slot</span><span class="p">],</span> <span class="n">values</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
			<span class="n">values</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">values</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">locals</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">user_return_notifier_unregister</span><span class="p">(</span><span class="n">urn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shared_msr_update</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_shared_msrs</span> <span class="o">*</span><span class="n">smsr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">smsr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">shared_msrs</span><span class="p">);</span>
	<span class="cm">/* only read, and nobody should modify it at this time,</span>
<span class="cm">	 * so don&#39;t need lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">shared_msrs_global</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: invalid MSR slot!&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rdmsrl_safe</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">smsr</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">host</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">smsr</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">curr</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_define_shared_msr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">shared_msrs_global</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span>
		<span class="n">shared_msrs_global</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">shared_msrs_global</span><span class="p">.</span><span class="n">msrs</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">msr</span><span class="p">;</span>
	<span class="cm">/* we need ensured the shared_msr_global have been updated */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_define_shared_msr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_shared_msr_cpu_online</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">shared_msrs_global</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">shared_msr_update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">shared_msrs_global</span><span class="p">.</span><span class="n">msrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_set_shared_msr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_shared_msrs</span> <span class="o">*</span><span class="n">smsr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">shared_msrs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">value</span> <span class="o">^</span> <span class="n">smsr</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">curr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">smsr</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">curr</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">shared_msrs_global</span><span class="p">.</span><span class="n">msrs</span><span class="p">[</span><span class="n">slot</span><span class="p">],</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smsr</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smsr</span><span class="o">-&gt;</span><span class="n">urn</span><span class="p">.</span><span class="n">on_user_return</span> <span class="o">=</span> <span class="n">kvm_on_user_return</span><span class="p">;</span>
		<span class="n">user_return_notifier_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smsr</span><span class="o">-&gt;</span><span class="n">urn</span><span class="p">);</span>
		<span class="n">smsr</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_shared_msr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_user_return_notifiers</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ignore</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_shared_msrs</span> <span class="o">*</span><span class="n">smsr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">shared_msrs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smsr</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="n">kvm_on_user_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smsr</span><span class="o">-&gt;</span><span class="n">urn</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">kvm_get_apic_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic_base</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic_base</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_get_apic_base</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_set_apic_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* TODO: reserve bits check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
		<span class="n">kvm_lapic_set_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic_base</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_apic_base</span><span class="p">);</span>

<span class="cp">#define EXCPT_BENIGN		0</span>
<span class="cp">#define EXCPT_CONTRIBUTORY	1</span>
<span class="cp">#define EXCPT_PF		2</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">exception_class</span><span class="p">(</span><span class="kt">int</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">vector</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PF_VECTOR</span>:
		<span class="k">return</span> <span class="n">EXCPT_PF</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DE_VECTOR</span>:
	<span class="k">case</span> <span class="n">TS_VECTOR</span>:
	<span class="k">case</span> <span class="n">NP_VECTOR</span>:
	<span class="k">case</span> <span class="n">SS_VECTOR</span>:
	<span class="k">case</span> <span class="n">GP_VECTOR</span>:
		<span class="k">return</span> <span class="n">EXCPT_CONTRIBUTORY</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">EXCPT_BENIGN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_multiple_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">has_error</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">reinject</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">prev_nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">class1</span><span class="p">,</span> <span class="n">class2</span><span class="p">;</span>

	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">queue:</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">has_error_code</span> <span class="o">=</span> <span class="n">has_error</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">reinject</span> <span class="o">=</span> <span class="n">reinject</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* to check exception */</span>
	<span class="n">prev_nr</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev_nr</span> <span class="o">==</span> <span class="n">DF_VECTOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* triple fault -&gt; shutdown */</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TRIPLE_FAULT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">class1</span> <span class="o">=</span> <span class="n">exception_class</span><span class="p">(</span><span class="n">prev_nr</span><span class="p">);</span>
	<span class="n">class2</span> <span class="o">=</span> <span class="n">exception_class</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">class1</span> <span class="o">==</span> <span class="n">EXCPT_CONTRIBUTORY</span> <span class="o">&amp;&amp;</span> <span class="n">class2</span> <span class="o">==</span> <span class="n">EXCPT_CONTRIBUTORY</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">class1</span> <span class="o">==</span> <span class="n">EXCPT_PF</span> <span class="o">&amp;&amp;</span> <span class="n">class2</span> <span class="o">!=</span> <span class="n">EXCPT_BENIGN</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* generate double fault per SDM Table 5-5 */</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">has_error_code</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">DF_VECTOR</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* replace previous exception with a new one in a hope</span>
<span class="cm">		   that instruction re-execution will regenerate lost</span>
<span class="cm">		   exception */</span>
		<span class="k">goto</span> <span class="n">queue</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_queue_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_multiple_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_queue_exception</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_requeue_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_multiple_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_requeue_exception</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_complete_insn_gp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">kvm_inject_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_complete_insn_gp</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_inject_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pf_guest</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr2</span> <span class="o">=</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
	<span class="n">kvm_queue_exception_e</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">PF_VECTOR</span><span class="p">,</span> <span class="n">fault</span><span class="o">-&gt;</span><span class="n">error_code</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_inject_page_fault</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_propagate_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_is_nested</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fault</span><span class="o">-&gt;</span><span class="n">nested_page_fault</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nested_mmu</span><span class="p">.</span><span class="n">inject_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fault</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">inject_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fault</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_inject_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_queued</span><span class="p">);</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_NMI</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_inject_nmi</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_queue_exception_e</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_multiple_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_queue_exception_e</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_requeue_exception_e</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_multiple_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_requeue_exception_e</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Checks if cpl &lt;= required_cpl; if true, return true.  Otherwise queue</span>
<span class="cm"> * a #GP and return false.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">kvm_require_cpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">required_cpl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">required_cpl</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">kvm_queue_exception_e</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">GP_VECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_require_cpl</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This function will be used to read from the physical memory of the currently</span>
<span class="cm"> * running guest. The difference to kvm_read_guest_page is that this function</span>
<span class="cm"> * can read from guest physical or from the guest&#39;s guest physical memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kvm_read_guest_page_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">mmu</span><span class="p">,</span>
			    <span class="n">gfn_t</span> <span class="n">ngfn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">real_gfn</span><span class="p">;</span>
	<span class="n">gpa_t</span> <span class="n">ngpa</span><span class="p">;</span>

	<span class="n">ngpa</span>     <span class="o">=</span> <span class="n">gfn_to_gpa</span><span class="p">(</span><span class="n">ngfn</span><span class="p">);</span>
	<span class="n">real_gfn</span> <span class="o">=</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">translate_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ngpa</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">real_gfn</span> <span class="o">==</span> <span class="n">UNMAPPED_GVA</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">real_gfn</span> <span class="o">=</span> <span class="n">gpa_to_gfn</span><span class="p">(</span><span class="n">real_gfn</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kvm_read_guest_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">real_gfn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_read_guest_page_mmu</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_read_nested_guest_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_read_guest_page_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span>
				       <span class="n">data</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Load the pae pdptrs.  Return true is they are all valid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">load_pdptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">mmu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">pdpt_gfn</span> <span class="o">=</span> <span class="n">cr3</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">cr3</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pdpte</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">pdptrs</span><span class="p">)];</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_read_guest_page_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">mmu</span><span class="p">,</span> <span class="n">pdpt_gfn</span><span class="p">,</span> <span class="n">pdpte</span><span class="p">,</span>
				      <span class="n">offset</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pdpte</span><span class="p">),</span>
				      <span class="n">PFERR_USER_MASK</span><span class="o">|</span><span class="n">PFERR_WRITE_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pdpte</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_present_gpte</span><span class="p">(</span><span class="n">pdpte</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pdpte</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">pdptrs</span><span class="p">,</span> <span class="n">pdpte</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">pdptrs</span><span class="p">));</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_PDPTR</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_PDPTR</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_dirty</span><span class="p">);</span>
<span class="nl">out:</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">load_pdptrs</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">pdptrs_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">pdpte</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">pdptrs</span><span class="p">)];</span>
	<span class="n">bool</span> <span class="n">changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_PDPTR</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">gfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">31u</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">31u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_read_nested_guest_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pdpte</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pdpte</span><span class="p">),</span>
				       <span class="n">PFERR_USER_MASK</span> <span class="o">|</span> <span class="n">PFERR_WRITE_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">changed</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">pdpte</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">pdptrs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pdpte</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>

	<span class="k">return</span> <span class="n">changed</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_set_cr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr0</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_cr0</span> <span class="o">=</span> <span class="n">kvm_read_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">update_bits</span> <span class="o">=</span> <span class="n">X86_CR0_PG</span> <span class="o">|</span> <span class="n">X86_CR0_WP</span> <span class="o">|</span>
				    <span class="n">X86_CR0_CD</span> <span class="o">|</span> <span class="n">X86_CR0_NW</span><span class="p">;</span>

	<span class="n">cr0</span> <span class="o">|=</span> <span class="n">X86_CR0_ET</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="mh">0xffffffff00000000UL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">cr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CR0_RESERVED_BITS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_NW</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_CD</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_PG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_PE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">X86_CR0_PG</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_LME</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">cs_db</span><span class="p">,</span> <span class="n">cs_l</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cs_db_l_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs_db</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs_l</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cs_l</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">load_pdptrs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="p">,</span>
						 <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cr0</span> <span class="o">^</span> <span class="n">old_cr0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">X86_CR0_PG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_clear_async_pf_completion_queue</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">kvm_async_pf_hash_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cr0</span> <span class="o">^</span> <span class="n">old_cr0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">update_bits</span><span class="p">)</span>
		<span class="n">kvm_mmu_reset_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_cr0</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_lmsw</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">kvm_set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_read_cr0_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">~</span><span class="mh">0x0eul</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">msw</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_lmsw</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__kvm_set_xcr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">xcr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">xcr0</span><span class="p">;</span>

	<span class="cm">/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">XCR_XFEATURE_ENABLED_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xcr0</span> <span class="o">=</span> <span class="n">xcr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xcr0</span> <span class="o">&amp;</span> <span class="n">XSTATE_FP</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">xcr0</span> <span class="o">&amp;</span> <span class="n">XSTATE_YMM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">xcr0</span> <span class="o">&amp;</span> <span class="n">XSTATE_SSE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xcr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">host_xcr0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xcr0</span> <span class="o">=</span> <span class="n">xcr0</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_xcr0_loaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_set_xcr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">xcr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__kvm_set_xcr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">xcr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_inject_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_xcr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_set_cr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr4</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_cr4</span> <span class="o">=</span> <span class="n">kvm_read_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pdptr_bits</span> <span class="o">=</span> <span class="n">X86_CR4_PGE</span> <span class="o">|</span> <span class="n">X86_CR4_PSE</span> <span class="o">|</span>
				   <span class="n">X86_CR4_PAE</span> <span class="o">|</span> <span class="n">X86_CR4_SMEP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="n">CR4_RESERVED_BITS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">guest_cpuid_has_xsave</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="n">X86_CR4_OSXSAVE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">guest_cpuid_has_smep</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="n">X86_CR4_SMEP</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">guest_cpuid_has_fsgsbase</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="n">X86_CR4_RDWRGSFS</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="n">X86_CR4_PAE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="n">X86_CR4_PAE</span><span class="p">)</span>
		   <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">cr4</span> <span class="o">^</span> <span class="n">old_cr4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pdptr_bits</span><span class="p">)</span>
		   <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">load_pdptrs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="p">,</span>
				   <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr4</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cr4</span> <span class="o">^</span> <span class="n">old_cr4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pdptr_bits</span><span class="p">)</span>
		<span class="n">kvm_mmu_reset_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cr4</span> <span class="o">^</span> <span class="n">old_cr4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">X86_CR4_OSXSAVE</span><span class="p">)</span>
		<span class="n">kvm_update_cpuid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_cr4</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_set_cr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cr3</span> <span class="o">==</span> <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pdptrs_changed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_mmu_sync_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">kvm_mmu_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cr3</span> <span class="o">&amp;</span> <span class="n">CR3_L_MODE_RESERVED_BITS</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cr3</span> <span class="o">&amp;</span> <span class="n">CR3_PAE_RESERVED_BITS</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">load_pdptrs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="p">,</span> <span class="n">cr3</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t check reserved bits in nonpae mode, because</span>
<span class="cm">		 * this isn&#39;t enforced, and VMware depends on this.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Does the new cr3 value map to physical memory? (Note, we</span>
<span class="cm">	 * catch an invalid cr3 even in real-mode, because it would</span>
<span class="cm">	 * cause trouble later on when we turn on paging anyway.)</span>
<span class="cm">	 *</span>
<span class="cm">	 * A real CPU would silently accept an invalid cr3 and would</span>
<span class="cm">	 * attempt to use it - with largely undefined (and often hard</span>
<span class="cm">	 * to debug) behavior on the guest side.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">cr3</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr3</span> <span class="o">=</span> <span class="n">cr3</span><span class="p">;</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_CR3</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">new_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_cr3</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_set_cr8</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr8</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cr8</span> <span class="o">&amp;</span> <span class="n">CR8_RESERVED_BITS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
		<span class="n">kvm_lapic_set_tpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr8</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr8</span> <span class="o">=</span> <span class="n">cr8</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_cr8</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kvm_get_cr8</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">kvm_lapic_get_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr8</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_get_cr8</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__kvm_set_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span> <span class="p">...</span> <span class="mi">3</span>:
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">dr</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_USE_HW_BP</span><span class="p">))</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">eff_db</span><span class="p">[</span><span class="n">dr</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_read_cr4_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR4_DE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* #UD */</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffffffff00000000ULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* #GP */</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">DR6_VOLATILE</span><span class="p">)</span> <span class="o">|</span> <span class="n">DR6_FIXED_1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_read_cr4_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR4_DE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* #UD */</span>
		<span class="cm">/* fall through */</span>
	<span class="nl">default:</span> <span class="cm">/* 7 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffffffff00000000ULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* #GP */</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">DR7_VOLATILE</span><span class="p">)</span> <span class="o">|</span> <span class="n">DR7_FIXED_1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_USE_HW_BP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_dr7</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span><span class="p">);</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">switch_db_regs</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">DR7_BP_EN_MASK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_set_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">__kvm_set_dr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kvm_inject_gp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_dr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_kvm_get_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span> <span class="p">...</span> <span class="mi">3</span>:
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">dr</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_read_cr4_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR4_DE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_read_cr4_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR4_DE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="nl">default:</span> <span class="cm">/* 7 */</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_get_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_kvm_get_dr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_get_dr</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">kvm_rdpmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ecx</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RCX</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kvm_pmu_read_pmc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDX</span><span class="p">,</span> <span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_rdpmc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * List of msr numbers which we expose to userspace through KVM_GET_MSRS</span>
<span class="cm"> * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.</span>
<span class="cm"> *</span>
<span class="cm"> * This list is modified at module load time to reflect the</span>
<span class="cm"> * capabilities of the host cpu. This capabilities test skips MSRs that are</span>
<span class="cm"> * kvm-specific. Those are put in the beginning of the list.</span>
<span class="cm"> */</span>

<span class="cp">#define KVM_SAVE_MSRS_BEGIN	9</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">msrs_to_save</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">MSR_KVM_SYSTEM_TIME</span><span class="p">,</span> <span class="n">MSR_KVM_WALL_CLOCK</span><span class="p">,</span>
	<span class="n">MSR_KVM_SYSTEM_TIME_NEW</span><span class="p">,</span> <span class="n">MSR_KVM_WALL_CLOCK_NEW</span><span class="p">,</span>
	<span class="n">HV_X64_MSR_GUEST_OS_ID</span><span class="p">,</span> <span class="n">HV_X64_MSR_HYPERCALL</span><span class="p">,</span>
	<span class="n">HV_X64_MSR_APIC_ASSIST_PAGE</span><span class="p">,</span> <span class="n">MSR_KVM_ASYNC_PF_EN</span><span class="p">,</span> <span class="n">MSR_KVM_STEAL_TIME</span><span class="p">,</span>
	<span class="n">MSR_IA32_SYSENTER_CS</span><span class="p">,</span> <span class="n">MSR_IA32_SYSENTER_ESP</span><span class="p">,</span> <span class="n">MSR_IA32_SYSENTER_EIP</span><span class="p">,</span>
	<span class="n">MSR_STAR</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">MSR_CSTAR</span><span class="p">,</span> <span class="n">MSR_KERNEL_GS_BASE</span><span class="p">,</span> <span class="n">MSR_SYSCALL_MASK</span><span class="p">,</span> <span class="n">MSR_LSTAR</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="n">MSR_IA32_TSC</span><span class="p">,</span> <span class="n">MSR_IA32_CR_PAT</span><span class="p">,</span> <span class="n">MSR_VM_HSAVE_PA</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">num_msrs_to_save</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">emulated_msrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">MSR_IA32_TSCDEADLINE</span><span class="p">,</span>
	<span class="n">MSR_IA32_MISC_ENABLE</span><span class="p">,</span>
	<span class="n">MSR_IA32_MCG_STATUS</span><span class="p">,</span>
	<span class="n">MSR_IA32_MCG_CTL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_efer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">efer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">old_efer</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">efer_reserved_bits</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_LME</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_LME</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_FFXSR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">feat</span><span class="p">;</span>

		<span class="n">feat</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mh">0x80000001</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">feat</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">feat</span><span class="o">-&gt;</span><span class="n">edx</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">(</span><span class="n">X86_FEATURE_FXSR_OPT</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_SVME</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">feat</span><span class="p">;</span>

		<span class="n">feat</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mh">0x80000001</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">feat</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">feat</span><span class="o">-&gt;</span><span class="n">ecx</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">(</span><span class="n">X86_FEATURE_SVM</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">efer</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EFER_LMA</span><span class="p">;</span>
	<span class="n">efer</span> <span class="o">|=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_LMA</span><span class="p">;</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_efer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">efer</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">base_role</span><span class="p">.</span><span class="n">nxe</span> <span class="o">=</span> <span class="p">(</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_NX</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tdp_enabled</span><span class="p">;</span>

	<span class="cm">/* Update reserved bits */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">efer</span> <span class="o">^</span> <span class="n">old_efer</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EFER_NX</span><span class="p">)</span>
		<span class="n">kvm_mmu_reset_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_enable_efer_bits</span><span class="p">(</span><span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">efer_reserved_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_enable_efer_bits</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Writes msr value into into the appropriate &quot;register&quot;.</span>
<span class="cm"> * Returns 0 on success, non-0 otherwise.</span>
<span class="cm"> * Assumes vcpu_load() was already called.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kvm_set_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Adapt set_msr() to msr_io()&#39;s calling convention</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_set_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_set_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_write_wall_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">wall_clock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvclock_wall_clock</span> <span class="n">wc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">boot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wall_clock</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_read_guest</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">wall_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">version</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">version</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">++</span><span class="n">version</span><span class="p">;</span>  <span class="cm">/* first time write, random junk */</span>

	<span class="o">++</span><span class="n">version</span><span class="p">;</span>

	<span class="n">kvm_write_guest</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">wall_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">version</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">version</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The guest calculates current wall clock time by adding</span>
<span class="cm">	 * system time (updated by kvm_guest_time_update below) to the</span>
<span class="cm">	 * wall clock specified here.  guest system time equals host</span>
<span class="cm">	 * system time for us, thus we must fill in host boot time here.</span>
<span class="cm">	 */</span>
	<span class="n">getboottime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot</span><span class="p">);</span>

	<span class="n">wc</span><span class="p">.</span><span class="n">sec</span> <span class="o">=</span> <span class="n">boot</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">wc</span><span class="p">.</span><span class="n">nsec</span> <span class="o">=</span> <span class="n">boot</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="n">wc</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">version</span><span class="p">;</span>

	<span class="n">kvm_write_guest</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">wall_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wc</span><span class="p">));</span>

	<span class="n">version</span><span class="o">++</span><span class="p">;</span>
	<span class="n">kvm_write_guest</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">wall_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">version</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">version</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">div_frac</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">dividend</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">divisor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t try to replace with do_div(), this one calculates</span>
<span class="cm">	 * &quot;(dividend &lt;&lt; 32) / divisor&quot; */</span>
	<span class="n">__asm__</span> <span class="p">(</span> <span class="s">&quot;divl %4&quot;</span>
		  <span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">quotient</span><span class="p">),</span> <span class="s">&quot;=d&quot;</span> <span class="p">(</span><span class="n">remainder</span><span class="p">)</span>
		  <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">dividend</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">divisor</span><span class="p">)</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">quotient</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_get_time_scale</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">scaled_khz</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">base_khz</span><span class="p">,</span>
			       <span class="n">s8</span> <span class="o">*</span><span class="n">pshift</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pmultiplier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">scaled64</span><span class="p">;</span>
	<span class="kt">int32_t</span>  <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">tps64</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tps32</span><span class="p">;</span>

	<span class="n">tps64</span> <span class="o">=</span> <span class="n">base_khz</span> <span class="o">*</span> <span class="mi">1000LL</span><span class="p">;</span>
	<span class="n">scaled64</span> <span class="o">=</span> <span class="n">scaled_khz</span> <span class="o">*</span> <span class="mi">1000LL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tps64</span> <span class="o">&gt;</span> <span class="n">scaled64</span><span class="o">*</span><span class="mi">2</span> <span class="o">||</span> <span class="n">tps64</span> <span class="o">&amp;</span> <span class="mh">0xffffffff00000000ULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tps64</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">shift</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tps32</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">tps64</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tps32</span> <span class="o">&lt;=</span> <span class="n">scaled64</span> <span class="o">||</span> <span class="n">scaled64</span> <span class="o">&amp;</span> <span class="mh">0xffffffff00000000ULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scaled64</span> <span class="o">&amp;</span> <span class="mh">0xffffffff00000000ULL</span> <span class="o">||</span> <span class="n">tps32</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span>
			<span class="n">scaled64</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tps32</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">shift</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pshift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pmultiplier</span> <span class="o">=</span> <span class="n">div_frac</span><span class="p">(</span><span class="n">scaled64</span><span class="p">,</span> <span class="n">tps32</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: base_khz %u =&gt; %u, shift %d, mul %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">base_khz</span><span class="p">,</span> <span class="n">scaled_khz</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="o">*</span><span class="n">pmultiplier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">get_kernel_ns</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>
	<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="n">monotonic_to_bootbased</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">timespec_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">cpu_tsc_khz</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_tsc_khz</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">nsec_to_cycles</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pvclock_scale_delta</span><span class="p">(</span><span class="n">nsec</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_mult</span><span class="p">,</span>
				   <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_shift</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">adjust_tsc_khz</span><span class="p">(</span><span class="n">u32</span> <span class="n">khz</span><span class="p">,</span> <span class="n">s32</span> <span class="n">ppm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">khz</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">+</span> <span class="n">ppm</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_set_tsc_khz</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">this_tsc_khz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">thresh_lo</span><span class="p">,</span> <span class="n">thresh_hi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_scaling</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Compute a scale to convert nanoseconds in TSC cycles */</span>
	<span class="n">kvm_get_time_scale</span><span class="p">(</span><span class="n">this_tsc_khz</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_shift</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_mult</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_khz</span> <span class="o">=</span> <span class="n">this_tsc_khz</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute the variation in TSC rate which is acceptable</span>
<span class="cm">	 * within the range of tolerance and decide if the</span>
<span class="cm">	 * rate being applied is within that bounds of the hardware</span>
<span class="cm">	 * rate.  If so, no scaling or compensation need be done.</span>
<span class="cm">	 */</span>
	<span class="n">thresh_lo</span> <span class="o">=</span> <span class="n">adjust_tsc_khz</span><span class="p">(</span><span class="n">tsc_khz</span><span class="p">,</span> <span class="o">-</span><span class="n">tsc_tolerance_ppm</span><span class="p">);</span>
	<span class="n">thresh_hi</span> <span class="o">=</span> <span class="n">adjust_tsc_khz</span><span class="p">(</span><span class="n">tsc_khz</span><span class="p">,</span> <span class="n">tsc_tolerance_ppm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_tsc_khz</span> <span class="o">&lt;</span> <span class="n">thresh_lo</span> <span class="o">||</span> <span class="n">this_tsc_khz</span> <span class="o">&gt;</span> <span class="n">thresh_hi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kvm: requested TSC rate %u falls outside tolerance [%u,%u]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_tsc_khz</span><span class="p">,</span> <span class="n">thresh_lo</span><span class="p">,</span> <span class="n">thresh_hi</span><span class="p">);</span>
		<span class="n">use_scaling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_tsc_khz</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">this_tsc_khz</span><span class="p">,</span> <span class="n">use_scaling</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">compute_guest_tsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">s64</span> <span class="n">kernel_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tsc</span> <span class="o">=</span> <span class="n">pvclock_scale_delta</span><span class="p">(</span><span class="n">kernel_ns</span><span class="o">-</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">this_tsc_nsec</span><span class="p">,</span>
				      <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_mult</span><span class="p">,</span>
				      <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_shift</span><span class="p">);</span>
	<span class="n">tsc</span> <span class="o">+=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">this_tsc_write</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tsc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_write_tsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">usdiff</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_write_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">compute_tsc_offset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">get_kernel_ns</span><span class="p">();</span>
	<span class="n">elapsed</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">-</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_tsc_nsec</span><span class="p">;</span>

	<span class="cm">/* n.b - signed multiplication and division required */</span>
	<span class="n">usdiff</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_tsc_write</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">usdiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">usdiff</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_khz</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/* do_div() only does unsigned */</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;idivl %2; xor %%edx, %%edx&quot;</span>
	    <span class="o">:</span> <span class="s">&quot;=A&quot;</span><span class="p">(</span><span class="n">usdiff</span><span class="p">)</span>
	    <span class="o">:</span> <span class="s">&quot;A&quot;</span><span class="p">(</span><span class="n">usdiff</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">),</span> <span class="s">&quot;rm&quot;</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_khz</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">elapsed</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">usdiff</span> <span class="o">-=</span> <span class="n">elapsed</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usdiff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">usdiff</span> <span class="o">=</span> <span class="o">-</span><span class="n">usdiff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Special case: TSC write with a small delta (1 second) of virtual</span>
<span class="cm">	 * cycle time against real time is interpreted as an attempt to</span>
<span class="cm">	 * synchronize the CPU.</span>
<span class="cm">         *</span>
<span class="cm">	 * For a reliable TSC, we can match TSC offsets, and for an unstable</span>
<span class="cm">	 * TSC, we add elapsed time in this computation.  We could let the</span>
<span class="cm">	 * compensation code attempt to catch up if we fall behind, but</span>
<span class="cm">	 * it&#39;s better to try to match offsets from the beginning.</span>
<span class="cm">         */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usdiff</span> <span class="o">&lt;</span> <span class="n">USEC_PER_SEC</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_khz</span> <span class="o">==</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_tsc_khz</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_tsc_unstable</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cur_tsc_offset</span><span class="p">;</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kvm: matched tsc offset for %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">nsec_to_cycles</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">compute_tsc_offset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kvm: adjusted tsc offset by %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We split periods of matched TSC writes into generations.</span>
<span class="cm">		 * For each generation, we track the original measured</span>
<span class="cm">		 * nanosecond time, offset, and write, so if TSCs are in</span>
<span class="cm">		 * sync, we can match exact offset, and if not, we can match</span>
<span class="cm">		 * exact software computaion in compute_guest_tsc()</span>
<span class="cm">		 *</span>
<span class="cm">		 * These values are tracked in kvm-&gt;arch.cur_xxx variables.</span>
<span class="cm">		 */</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cur_tsc_generation</span><span class="o">++</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cur_tsc_nsec</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cur_tsc_write</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cur_tsc_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kvm: new tsc generation %u, clock %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cur_tsc_generation</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We also track th most recent recorded KHZ, write and time to</span>
<span class="cm">	 * allow the matching interval to be extended at each write.</span>
<span class="cm">	 */</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_tsc_nsec</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_tsc_write</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_tsc_khz</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_khz</span><span class="p">;</span>

	<span class="cm">/* Reset of TSC must disable overshoot protection below */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">tsc_timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_guest_tsc</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Keep track of which generation this VCPU has synchronized to */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">this_tsc_generation</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cur_tsc_generation</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">this_tsc_nsec</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cur_tsc_nsec</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">this_tsc_write</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cur_tsc_write</span><span class="p">;</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">write_tsc_offset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_write_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_write_tsc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_guest_time_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu_arch</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">shared_kaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_tsc_khz</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">kernel_ns</span><span class="p">,</span> <span class="n">max_kernel_ns</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tsc_timestamp</span><span class="p">;</span>

	<span class="cm">/* Keep irq disabled to prevent changes to the clock */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">tsc_timestamp</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">read_l1_tsc</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="n">kernel_ns</span> <span class="o">=</span> <span class="n">get_kernel_ns</span><span class="p">();</span>
	<span class="n">this_tsc_khz</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_tsc_khz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">this_tsc_khz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_CLOCK_UPDATE</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may have to catch up the TSC to match elapsed wall clock</span>
<span class="cm">	 * time for two reasons, even if kvmclock is used.</span>
<span class="cm">	 *   1) CPU could have been running below the maximum TSC rate</span>
<span class="cm">	 *   2) Broken TSC compensation resets the base at each VCPU</span>
<span class="cm">	 *      entry to avoid unknown leaps of TSC even when running</span>
<span class="cm">	 *      again on the same CPU.  This may cause apparent elapsed</span>
<span class="cm">	 *      time to disappear, and the guest to stand still or run</span>
<span class="cm">	 *	very slowly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">tsc_catchup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">tsc</span> <span class="o">=</span> <span class="n">compute_guest_tsc</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">kernel_ns</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsc</span> <span class="o">&gt;</span> <span class="n">tsc_timestamp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adjust_tsc_offset_guest</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">tsc</span> <span class="o">-</span> <span class="n">tsc_timestamp</span><span class="p">);</span>
			<span class="n">tsc_timestamp</span> <span class="o">=</span> <span class="n">tsc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">time_page</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Time as measured by the TSC may go backwards when resetting the base</span>
<span class="cm">	 * tsc_timestamp.  The reason for this is that the TSC resolution is</span>
<span class="cm">	 * higher than the resolution of the other clock scales.  Thus, many</span>
<span class="cm">	 * possible measurments of the TSC correspond to one measurement of any</span>
<span class="cm">	 * other clock, and so a spread of values is possible.  This is not a</span>
<span class="cm">	 * problem for the computation of the nanosecond clock; with TSC rates</span>
<span class="cm">	 * around 1GHZ, there can only be a few cycles which correspond to one</span>
<span class="cm">	 * nanosecond value, and any path through this code will inevitably</span>
<span class="cm">	 * take longer than that.  However, with the kernel_ns value itself,</span>
<span class="cm">	 * the precision may be much lower, down to HZ granularity.  If the</span>
<span class="cm">	 * first sampling of TSC against kernel_ns ends in the low part of the</span>
<span class="cm">	 * range, and the second in the high end of the range, we can get:</span>
<span class="cm">	 *</span>
<span class="cm">	 * (TSC - offset_low) * S + kns_old &gt; (TSC - offset_high) * S + kns_new</span>
<span class="cm">	 *</span>
<span class="cm">	 * As the sampling errors potentially range in the thousands of cycles,</span>
<span class="cm">	 * it is possible such a time value has already been observed by the</span>
<span class="cm">	 * guest.  To protect against this, we must compute the system time as</span>
<span class="cm">	 * observed by the guest and ensure the new system time is greater.</span>
<span class="cm">	 */</span>
	<span class="n">max_kernel_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">tsc_timestamp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_kernel_ns</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">last_guest_tsc</span> <span class="o">-</span>
				<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">tsc_timestamp</span><span class="p">;</span>
		<span class="n">max_kernel_ns</span> <span class="o">=</span> <span class="n">pvclock_scale_delta</span><span class="p">(</span><span class="n">max_kernel_ns</span><span class="p">,</span>
				    <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">tsc_to_system_mul</span><span class="p">,</span>
				    <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">tsc_shift</span><span class="p">);</span>
		<span class="n">max_kernel_ns</span> <span class="o">+=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">last_kernel_ns</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hw_tsc_khz</span> <span class="o">!=</span> <span class="n">this_tsc_khz</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_get_time_scale</span><span class="p">(</span><span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">this_tsc_khz</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">tsc_shift</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">tsc_to_system_mul</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hw_tsc_khz</span> <span class="o">=</span> <span class="n">this_tsc_khz</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_kernel_ns</span> <span class="o">&gt;</span> <span class="n">kernel_ns</span><span class="p">)</span>
		<span class="n">kernel_ns</span> <span class="o">=</span> <span class="n">max_kernel_ns</span><span class="p">;</span>

	<span class="cm">/* With all the info we got, fill in the values */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">tsc_timestamp</span> <span class="o">=</span> <span class="n">tsc_timestamp</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">system_time</span> <span class="o">=</span> <span class="n">kernel_ns</span> <span class="o">+</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">kvmclock_offset</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">last_kernel_ns</span> <span class="o">=</span> <span class="n">kernel_ns</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">last_guest_tsc</span> <span class="o">=</span> <span class="n">tsc_timestamp</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The interface expects us to write an even number signaling that the</span>
<span class="cm">	 * update is finished. Since the guest won&#39;t see the intermediate</span>
<span class="cm">	 * state, we just increase by 2 at the end.</span>
<span class="cm">	 */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">.</span><span class="n">version</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">shared_kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">time_page</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">shared_kaddr</span> <span class="o">+</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">time_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">hv_clock</span><span class="p">));</span>

	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">shared_kaddr</span><span class="p">);</span>

	<span class="n">mark_page_dirty</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">msr_mtrr_valid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x200</span> <span class="p">...</span> <span class="mh">0x200</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">KVM_NR_VAR_MTRR</span> <span class="o">-</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix64K_00000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix16K_80000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix16K_A0000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix4K_C0000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix4K_C8000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix4K_D0000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix4K_D8000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix4K_E0000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix4K_E8000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix4K_F0000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRfix4K_F8000</span>:
	<span class="k">case</span> <span class="n">MSR_MTRRdefType</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_CR_PAT</span>:
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2f8</span>:
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">valid_pat_type</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf3</span><span class="p">;</span> <span class="cm">/* 0, 1, 4, 5, 6, 7 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">valid_mtrr_type</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x73</span><span class="p">;</span> <span class="cm">/* 0, 1, 4, 5, 6 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mtrr_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msr_mtrr_valid</span><span class="p">(</span><span class="n">msr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_IA32_CR_PAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_pat_type</span><span class="p">((</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_MTRRdefType</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xcff</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">valid_mtrr_type</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&gt;=</span> <span class="n">MSR_MTRRfix64K_00000</span> <span class="o">&amp;&amp;</span> <span class="n">msr</span> <span class="o">&lt;=</span> <span class="n">MSR_MTRRfix4K_F8000</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_mtrr_type</span><span class="p">((</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* variable MTRRs */</span>
	<span class="k">return</span> <span class="n">valid_mtrr_type</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_msr_mtrr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">fixed_ranges</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtrr_valid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_MTRRdefType</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">def_type</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xc00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_MTRRfix64K_00000</span><span class="p">)</span>
		<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_MTRRfix16K_80000</span> <span class="o">||</span> <span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_MTRRfix16K_A0000</span><span class="p">)</span>
		<span class="n">p</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">msr</span> <span class="o">-</span> <span class="n">MSR_MTRRfix16K_80000</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&gt;=</span> <span class="n">MSR_MTRRfix4K_C0000</span> <span class="o">&amp;&amp;</span> <span class="n">msr</span> <span class="o">&lt;=</span> <span class="n">MSR_MTRRfix4K_F8000</span><span class="p">)</span>
		<span class="n">p</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">msr</span> <span class="o">-</span> <span class="n">MSR_MTRRfix4K_C0000</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_IA32_CR_PAT</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pat</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>	<span class="cm">/* Variable MTRRs */</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">is_mtrr_mask</span><span class="p">;</span>
		<span class="n">u64</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>

		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">msr</span> <span class="o">-</span> <span class="mh">0x200</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">is_mtrr_mask</span> <span class="o">=</span> <span class="n">msr</span> <span class="o">-</span> <span class="mh">0x200</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_mtrr_mask</span><span class="p">)</span>
			<span class="n">pt</span> <span class="o">=</span>
			  <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">base_lo</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pt</span> <span class="o">=</span>
			  <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">mask_lo</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvm_mmu_reset_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_msr_mce</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mcg_cap</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_cap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bank_num</span> <span class="o">=</span> <span class="n">mcg_cap</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSR_IA32_MCG_STATUS</span>:
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_status</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_MCG_CTL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mcg_cap</span> <span class="o">&amp;</span> <span class="n">MCG_CTL_P</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">data</span> <span class="o">!=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_ctl</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&gt;=</span> <span class="n">MSR_IA32_MC0_CTL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">msr</span> <span class="o">&lt;</span> <span class="n">MSR_IA32_MC0_CTL</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">bank_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">msr</span> <span class="o">-</span> <span class="n">MSR_IA32_MC0_CTL</span><span class="p">;</span>
			<span class="cm">/* only 0 or all 1s can be written to IA32_MCi_CTL</span>
<span class="cm">			 * some Linux kernels though clear bit 10 in bank 4 to</span>
<span class="cm">			 * workaround a BIOS/GART TBL issue on AMD K8s, ignore</span>
<span class="cm">			 * this to avoid an uncatched #GP in the guest</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">))</span> <span class="o">!=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xen_hvm_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lm</span> <span class="o">=</span> <span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">blob_addr</span> <span class="o">=</span> <span class="n">lm</span> <span class="o">?</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xen_hvm_config</span><span class="p">.</span><span class="n">blob_addr_64</span>
		<span class="o">:</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xen_hvm_config</span><span class="p">.</span><span class="n">blob_addr_32</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">blob_size</span> <span class="o">=</span> <span class="n">lm</span> <span class="o">?</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xen_hvm_config</span><span class="p">.</span><span class="n">blob_size_64</span>
		<span class="o">:</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xen_hvm_config</span><span class="p">.</span><span class="n">blob_size_32</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_addr</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">&gt;=</span> <span class="n">blob_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">blob_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_write_guest</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">page_addr</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">kvm_hv_hypercall_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_hypercall</span> <span class="o">&amp;</span> <span class="n">HV_X64_MSR_HYPERCALL_ENABLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">kvm_hv_msr_partition_wide</span><span class="p">(</span><span class="n">u32</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_GUEST_OS_ID</span>:
	<span class="k">case</span> <span class="n">HV_X64_MSR_HYPERCALL</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_msr_hyperv_pw</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_GUEST_OS_ID</span>:
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_guest_os_id</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="cm">/* setting guest os id to zero disables hypercall page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_guest_os_id</span><span class="p">)</span>
			<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_hypercall</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HV_X64_MSR_HYPERCALL_ENABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_HYPERCALL</span>: <span class="p">{</span>
		<span class="n">u64</span> <span class="n">gfn</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">instructions</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

		<span class="cm">/* if guest os id is not set hypercall should remain disabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_guest_os_id</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">HV_X64_MSR_HYPERCALL_ENABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_hypercall</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">gfn</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="n">HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">patch_hypercall</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">instructions</span><span class="p">);</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">instructions</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xc3</span><span class="p">;</span> <span class="cm">/* ret */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">instructions</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_hypercall</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;HYPER-V unimplemented wrmsr: 0x%x &quot;</span>
			  <span class="s">&quot;data 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_msr_hyperv</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_APIC_ASSIST_PAGE</span>: <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_vapic</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">data</span> <span class="o">&gt;&gt;</span>
				  <span class="n">HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__clear_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_vapic</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_EOI</span>:
		<span class="k">return</span> <span class="n">kvm_hv_vapic_msr_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">APIC_EOI</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_ICR</span>:
		<span class="k">return</span> <span class="n">kvm_hv_vapic_msr_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">APIC_ICR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_TPR</span>:
		<span class="k">return</span> <span class="n">kvm_hv_vapic_msr_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">APIC_TASKPRI</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;HYPER-V unimplemented wrmsr: 0x%x &quot;</span>
			  <span class="s">&quot;data 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_pv_enable_async_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3f</span><span class="p">;</span>

	<span class="cm">/* Bits 2:5 are resrved, Should be zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x3c</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">KVM_ASYNC_PF_ENABLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_clear_async_pf_completion_queue</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">kvm_async_pf_hash_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_gfn_to_hva_cache_init</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">gpa</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">send_user_only</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">KVM_ASYNC_PF_SEND_ALWAYS</span><span class="p">);</span>
	<span class="n">kvm_async_pf_wakeup_all</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmclock_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_release_page_dirty</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time_page</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">accumulate_steal_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">&amp;</span> <span class="n">KVM_MSR_ENABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sched_info</span><span class="p">.</span><span class="n">run_delay</span> <span class="o">-</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">last_steal</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">last_steal</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sched_info</span><span class="p">.</span><span class="n">run_delay</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">accum_steal</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">record_steal_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">&amp;</span> <span class="n">KVM_MSR_ENABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kvm_read_guest_cached</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">stime</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">steal</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_steal_time</span><span class="p">))))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">steal</span><span class="p">.</span><span class="n">steal</span> <span class="o">+=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">accum_steal</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">steal</span><span class="p">.</span><span class="n">version</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">accum_steal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kvm_write_guest_cached</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">stime</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">steal</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_steal_time</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_set_msr_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">pr</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSR_EFER</span>:
		<span class="k">return</span> <span class="n">set_efer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MSR_K7_HWCR</span>:
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mh">0x40</span><span class="p">;</span>	<span class="cm">/* ignore flush filter disable */</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mh">0x100</span><span class="p">;</span>	<span class="cm">/* ignore ignne emulation enable */</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mh">0x8</span><span class="p">;</span>	<span class="cm">/* ignore TLB cache disable */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;unimplemented HWCR wrmsr: 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">data</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_FAM10H_MMIO_CONF_BASE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;unimplemented MMIO_CONF_BASE wrmsr: &quot;</span>
				<span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_AMD64_NB_CFG</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_DEBUGCTLMSR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We support the non-activated case already */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">DEBUGCTLMSR_LBR</span> <span class="o">|</span> <span class="n">DEBUGCTLMSR_BTF</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Values other than LBR and BTF are vendor-specific,</span>
<span class="cm">			   thus reserved and should throw a #GP */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_UCODE_REV</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_UCODE_WRITE</span>:
	<span class="k">case</span> <span class="n">MSR_VM_HSAVE_PA</span>:
	<span class="k">case</span> <span class="n">MSR_AMD64_PATCH_LOADER</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x200</span> <span class="p">...</span> <span class="mh">0x2ff</span>:
		<span class="k">return</span> <span class="n">set_msr_mtrr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MSR_IA32_APICBASE</span>:
		<span class="n">kvm_set_apic_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">APIC_BASE_MSR</span> <span class="p">...</span> <span class="n">APIC_BASE_MSR</span> <span class="o">+</span> <span class="mh">0x3ff</span>:
		<span class="k">return</span> <span class="n">kvm_x2apic_msr_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MSR_IA32_TSCDEADLINE</span>:
		<span class="n">kvm_set_lapic_tscdeadline_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_MISC_ENABLE</span>:
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ia32_misc_enable_msr</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_KVM_WALL_CLOCK_NEW</span>:
	<span class="k">case</span> <span class="n">MSR_KVM_WALL_CLOCK</span>:
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wall_clock</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">kvm_write_wall_clock</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_KVM_SYSTEM_TIME_NEW</span>:
	<span class="k">case</span> <span class="n">MSR_KVM_SYSTEM_TIME</span>: <span class="p">{</span>
		<span class="n">kvmclock_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_CLOCK_UPDATE</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

		<span class="cm">/* we verify if the enable bit is set... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* ...but clean it before doing the actual write */</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time_offset</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PAGE_MASK</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time_page</span> <span class="o">=</span>
				<span class="n">gfn_to_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_error_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kvm_release_page_clean</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time_page</span><span class="p">);</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">MSR_KVM_ASYNC_PF_EN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_pv_enable_async_pf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_KVM_STEAL_TIME</span>:

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sched_info_on</span><span class="p">()))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">KVM_STEAL_RESERVED_MASK</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_gfn_to_hva_cache_init</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">stime</span><span class="p">,</span>
							<span class="n">data</span> <span class="o">&amp;</span> <span class="n">KVM_STEAL_VALID_BITS</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">KVM_MSR_ENABLED</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">last_steal</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sched_info</span><span class="p">.</span><span class="n">run_delay</span><span class="p">;</span>

		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">accumulate_steal_time</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">preempt_enable</span><span class="p">();</span>

		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_STEAL_UPDATE</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MSR_IA32_MCG_CTL</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_MCG_STATUS</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_MC0_CTL</span> <span class="p">...</span> <span class="n">MSR_IA32_MC0_CTL</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">KVM_MAX_MCE_BANKS</span> <span class="o">-</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="n">set_msr_mce</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/* Performance counters are not protected by a CPUID bit,</span>
<span class="cm">	 * so we should check all of them in the generic path for the sake of</span>
<span class="cm">	 * cross vendor migration.</span>
<span class="cm">	 * Writing a zero into the event select MSRs disables them,</span>
<span class="cm">	 * which we perfectly emulate ;-). Any other value should be at least</span>
<span class="cm">	 * reported, some guests depend on them.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">MSR_K7_EVNTSEL0</span>:
	<span class="k">case</span> <span class="n">MSR_K7_EVNTSEL1</span>:
	<span class="k">case</span> <span class="n">MSR_K7_EVNTSEL2</span>:
	<span class="k">case</span> <span class="n">MSR_K7_EVNTSEL3</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;unimplemented perfctr wrmsr: &quot;</span>
				<span class="s">&quot;0x%x data 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* at least RHEL 4 unconditionally writes to the perfctr registers,</span>
<span class="cm">	 * so we ignore writes to make it happy.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">MSR_K7_PERFCTR0</span>:
	<span class="k">case</span> <span class="n">MSR_K7_PERFCTR1</span>:
	<span class="k">case</span> <span class="n">MSR_K7_PERFCTR2</span>:
	<span class="k">case</span> <span class="n">MSR_K7_PERFCTR3</span>:
		<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;unimplemented perfctr wrmsr: &quot;</span>
			<span class="s">&quot;0x%x data 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_P6_PERFCTR0</span>:
	<span class="k">case</span> <span class="n">MSR_P6_PERFCTR1</span>:
		<span class="n">pr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_P6_EVNTSEL0</span>:
	<span class="k">case</span> <span class="n">MSR_P6_EVNTSEL1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_pmu_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">kvm_pmu_set_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pr</span> <span class="o">||</span> <span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;disabled perfctr wrmsr: &quot;</span>
				<span class="s">&quot;0x%x data 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_K7_CLK_CTL</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Ignore all writes to this no longer documented MSR.</span>
<span class="cm">		 * Writes are only relevant for old K7 processors,</span>
<span class="cm">		 * all pre-dating SVM, but a recommended workaround from</span>
<span class="cm">		 * AMD for these chips. It is possible to speicify the</span>
<span class="cm">		 * affected processor models on the command line, hence</span>
<span class="cm">		 * the need to ignore the workaround.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_GUEST_OS_ID</span> <span class="p">...</span> <span class="n">HV_X64_MSR_SINT15</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_hv_msr_partition_wide</span><span class="p">(</span><span class="n">msr</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">set_msr_hyperv_pw</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="n">set_msr_hyperv</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_BBL_CR_CTL3</span>:
		<span class="cm">/* Drop writes to this legacy MSR -- see rdmsr</span>
<span class="cm">		 * counterpart for further detail.</span>
<span class="cm">		 */</span>
		<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;ignored wrmsr: 0x%x data %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_AMD64_OSVW_ID_LENGTH</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">guest_cpuid_has_osvw</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">osvw</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_AMD64_OSVW_STATUS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">guest_cpuid_has_osvw</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">osvw</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xen_hvm_config</span><span class="p">.</span><span class="n">msr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">xen_hvm_config</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_pmu_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">kvm_pmu_set_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ignore_msrs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;unhandled wrmsr: 0x%x data %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;ignored wrmsr: 0x%x data %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">msr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_msr_common</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Reads an msr value (of &#39;msr_index&#39;) into &#39;pdata&#39;.</span>
<span class="cm"> * Returns 0 on success, non-0 otherwise.</span>
<span class="cm"> * Assumes vcpu_load() was already called.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kvm_get_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_msr_mtrr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">fixed_ranges</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msr_mtrr_valid</span><span class="p">(</span><span class="n">msr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_MTRRdefType</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">def_type</span> <span class="o">+</span>
			 <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">enabled</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_MTRRfix64K_00000</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_MTRRfix16K_80000</span> <span class="o">||</span> <span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_MTRRfix16K_A0000</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">msr</span> <span class="o">-</span> <span class="n">MSR_MTRRfix16K_80000</span><span class="p">];</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&gt;=</span> <span class="n">MSR_MTRRfix4K_C0000</span> <span class="o">&amp;&amp;</span> <span class="n">msr</span> <span class="o">&lt;=</span> <span class="n">MSR_MTRRfix4K_F8000</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">msr</span> <span class="o">-</span> <span class="n">MSR_MTRRfix4K_C0000</span><span class="p">];</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_IA32_CR_PAT</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pat</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>	<span class="cm">/* Variable MTRRs */</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">is_mtrr_mask</span><span class="p">;</span>
		<span class="n">u64</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>

		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">msr</span> <span class="o">-</span> <span class="mh">0x200</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">is_mtrr_mask</span> <span class="o">=</span> <span class="n">msr</span> <span class="o">-</span> <span class="mh">0x200</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_mtrr_mask</span><span class="p">)</span>
			<span class="n">pt</span> <span class="o">=</span>
			  <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">base_lo</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pt</span> <span class="o">=</span>
			  <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">mask_lo</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_msr_mce</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mcg_cap</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_cap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bank_num</span> <span class="o">=</span> <span class="n">mcg_cap</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSR_IA32_P5_MC_ADDR</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_P5_MC_TYPE</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_MCG_CAP</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_cap</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_MCG_CTL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mcg_cap</span> <span class="o">&amp;</span> <span class="n">MCG_CTL_P</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_ctl</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_MCG_STATUS</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&gt;=</span> <span class="n">MSR_IA32_MC0_CTL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">msr</span> <span class="o">&lt;</span> <span class="n">MSR_IA32_MC0_CTL</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">bank_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">msr</span> <span class="o">-</span> <span class="n">MSR_IA32_MC0_CTL</span><span class="p">;</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_msr_hyperv_pw</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_GUEST_OS_ID</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_guest_os_id</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_HYPERCALL</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_hypercall</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;Hyper-V unhandled rdmsr: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_msr_hyperv</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_VP_INDEX</span>: <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
		<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">vcpu</span><span class="p">)</span>
				<span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_EOI</span>:
		<span class="k">return</span> <span class="n">kvm_hv_vapic_msr_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">APIC_EOI</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_ICR</span>:
		<span class="k">return</span> <span class="n">kvm_hv_vapic_msr_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">APIC_ICR</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_TPR</span>:
		<span class="k">return</span> <span class="n">kvm_hv_vapic_msr_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">APIC_TASKPRI</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_APIC_ASSIST_PAGE</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_vapic</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;Hyper-V unhandled rdmsr: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_get_msr_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSR_IA32_PLATFORM_ID</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_EBL_CR_POWERON</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_DEBUGCTLMSR</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_LASTBRANCHFROMIP</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_LASTBRANCHTOIP</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_LASTINTFROMIP</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_LASTINTTOIP</span>:
	<span class="k">case</span> <span class="n">MSR_K8_SYSCFG</span>:
	<span class="k">case</span> <span class="n">MSR_K7_HWCR</span>:
	<span class="k">case</span> <span class="n">MSR_VM_HSAVE_PA</span>:
	<span class="k">case</span> <span class="n">MSR_K7_EVNTSEL0</span>:
	<span class="k">case</span> <span class="n">MSR_K7_PERFCTR0</span>:
	<span class="k">case</span> <span class="n">MSR_K8_INT_PENDING_MSG</span>:
	<span class="k">case</span> <span class="n">MSR_AMD64_NB_CFG</span>:
	<span class="k">case</span> <span class="n">MSR_FAM10H_MMIO_CONF_BASE</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_P6_PERFCTR0</span>:
	<span class="k">case</span> <span class="n">MSR_P6_PERFCTR1</span>:
	<span class="k">case</span> <span class="n">MSR_P6_EVNTSEL0</span>:
	<span class="k">case</span> <span class="n">MSR_P6_EVNTSEL1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_pmu_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">kvm_pmu_get_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_UCODE_REV</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="mh">0x100000000ULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_MTRRcap</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="mh">0x500</span> <span class="o">|</span> <span class="n">KVM_NR_VAR_MTRR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x200</span> <span class="p">...</span> <span class="mh">0x2ff</span>:
		<span class="k">return</span> <span class="n">get_msr_mtrr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
	<span class="k">case</span> <span class="mh">0xcd</span>: <span class="cm">/* fsb frequency */</span>
		<span class="n">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * MSR_EBC_FREQUENCY_ID</span>
<span class="cm">		 * Conservative value valid for even the basic CPU models.</span>
<span class="cm">		 * Models 0,1: 000 in bits 23:21 indicating a bus speed of</span>
<span class="cm">		 * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,</span>
<span class="cm">		 * and 266MHz for model 3, or 4. Set Core Clock</span>
<span class="cm">		 * Frequency to System Bus Frequency Ratio to 1 (bits</span>
<span class="cm">		 * 31:24) even though these are only valid for CPU</span>
<span class="cm">		 * models &gt; 2, however guests may end up dividing or</span>
<span class="cm">		 * multiplying by zero otherwise.</span>
<span class="cm">		 */</span>
	<span class="k">case</span> <span class="n">MSR_EBC_FREQUENCY_ID</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_APICBASE</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">kvm_get_apic_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">APIC_BASE_MSR</span> <span class="p">...</span> <span class="n">APIC_BASE_MSR</span> <span class="o">+</span> <span class="mh">0x3ff</span>:
		<span class="k">return</span> <span class="n">kvm_x2apic_msr_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_TSCDEADLINE</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">kvm_get_lapic_tscdeadline_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_MISC_ENABLE</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ia32_misc_enable_msr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_PERF_STATUS</span>:
		<span class="cm">/* TSC increment by tick */</span>
		<span class="n">data</span> <span class="o">=</span> <span class="mi">1000ULL</span><span class="p">;</span>
		<span class="cm">/* CPU multiplier */</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="p">(((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mi">4ULL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_EFER</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_KVM_WALL_CLOCK</span>:
	<span class="k">case</span> <span class="n">MSR_KVM_WALL_CLOCK_NEW</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wall_clock</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_KVM_SYSTEM_TIME</span>:
	<span class="k">case</span> <span class="n">MSR_KVM_SYSTEM_TIME_NEW</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_KVM_ASYNC_PF_EN</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">msr_val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_KVM_STEAL_TIME</span>:
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">msr_val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_P5_MC_ADDR</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_P5_MC_TYPE</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_MCG_CAP</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_MCG_CTL</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_MCG_STATUS</span>:
	<span class="k">case</span> <span class="n">MSR_IA32_MC0_CTL</span> <span class="p">...</span> <span class="n">MSR_IA32_MC0_CTL</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">KVM_MAX_MCE_BANKS</span> <span class="o">-</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="n">get_msr_mce</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MSR_K7_CLK_CTL</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Provide expected ramp-up count for K7. All other</span>
<span class="cm">		 * are set to zero, indicating minimum divisors for</span>
<span class="cm">		 * every field.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This prevents guest kernels on AMD host with CPU</span>
<span class="cm">		 * type 6, model 8 and higher from exploding due to</span>
<span class="cm">		 * the rdmsr failing.</span>
<span class="cm">		 */</span>
		<span class="n">data</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HV_X64_MSR_GUEST_OS_ID</span> <span class="p">...</span> <span class="n">HV_X64_MSR_SINT15</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_hv_msr_partition_wide</span><span class="p">(</span><span class="n">msr</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">get_msr_hyperv_pw</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="n">get_msr_hyperv</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_IA32_BBL_CR_CTL3</span>:
		<span class="cm">/* This legacy MSR exists but isn&#39;t fully documented in current</span>
<span class="cm">		 * silicon.  It is however accessed by winxp in very narrow</span>
<span class="cm">		 * scenarios where it sets bit #19, itself documented as</span>
<span class="cm">		 * a &quot;reserved&quot; bit.  Best effort attempt to source coherent</span>
<span class="cm">		 * read data here should the balance of the register be</span>
<span class="cm">		 * interpreted by the guest:</span>
<span class="cm">		 *</span>
<span class="cm">		 * L2 cache control register 3: 64GB range, 256KB size,</span>
<span class="cm">		 * enabled, latency 0x1, configured</span>
<span class="cm">		 */</span>
		<span class="n">data</span> <span class="o">=</span> <span class="mh">0xbe702111</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_AMD64_OSVW_ID_LENGTH</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">guest_cpuid_has_osvw</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">osvw</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSR_AMD64_OSVW_STATUS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">guest_cpuid_has_osvw</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">osvw</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_pmu_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">kvm_pmu_get_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">msr</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ignore_msrs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;unhandled rdmsr: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_unimpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;ignored rdmsr: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_get_msr_common</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Read or write a bunch of msrs. All parameters are kernel addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * @return number of msrs set successfully.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__msr_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_msrs</span> <span class="o">*</span><span class="n">msrs</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">kvm_msr_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">do_msr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msrs</span><span class="o">-&gt;</span><span class="n">nmsrs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read or write a bunch of msrs. Parameters are user addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * @return number of msrs set successfully.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msr_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_msrs</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_msrs</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">do_msr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
		  <span class="kt">int</span> <span class="n">writeback</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_msrs</span> <span class="n">msrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_msr_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msrs</span><span class="p">,</span> <span class="n">user_msrs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">msrs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msrs</span><span class="p">.</span><span class="n">nmsrs</span> <span class="o">&gt;=</span> <span class="n">MAX_IO_MSRS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_msr_entry</span><span class="p">)</span> <span class="o">*</span> <span class="n">msrs</span><span class="p">.</span><span class="n">nmsrs</span><span class="p">;</span>
	<span class="n">entries</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">user_msrs</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">entries</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">entries</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">=</span> <span class="n">__msr_io</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msrs</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">do_msr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">writeback</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_msrs</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entries</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_dev_ioctl_check_extension</span><span class="p">(</span><span class="kt">long</span> <span class="n">ext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_CAP_IRQCHIP</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_HLT</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_MMU_SHADOW_CACHE_CONTROL</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_SET_TSS_ADDR</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_EXT_CPUID</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_CLOCKSOURCE</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_PIT</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_NOP_IO_DELAY</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_MP_STATE</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_SYNC_MMU</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_USER_NMI</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_REINJECT_CONTROL</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_IRQ_INJECT_STATUS</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_ASSIGN_DEV_IRQ</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_IRQFD</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_IOEVENTFD</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_PIT2</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_PIT_STATE2</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_SET_IDENTITY_MAP_ADDR</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_XEN_HVM</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_ADJUST_CLOCK</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_VCPU_EVENTS</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_HYPERV</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_HYPERV_VAPIC</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_HYPERV_SPIN</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_PCI_SEGMENT</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_DEBUGREGS</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_X86_ROBUST_SINGLESTEP</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_XSAVE</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_ASYNC_PF</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_GET_TSC_KHZ</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_PCI_2_3</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_KVMCLOCK_CTRL</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_COALESCED_MMIO</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">KVM_COALESCED_MMIO_PAGE_OFFSET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_VAPIC</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="o">!</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">cpu_has_accelerated_tpr</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_NR_VCPUS</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">KVM_SOFT_MAX_VCPUS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_MAX_VCPUS</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">KVM_MAX_VCPUS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_NR_MEMSLOTS</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">KVM_MEMORY_SLOTS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_PV_MMU</span>:	<span class="cm">/* obsolete */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_IOMMU</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">iommu_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_MCE</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">KVM_MAX_MCE_BANKS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_XCRS</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">cpu_has_xsave</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_TSC_CONTROL</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_has_tsc_control</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_TSC_DEADLINE_TIMER</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_TSC_DEADLINE_TIMER</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">long</span> <span class="nf">kvm_arch_dev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_GET_MSR_INDEX_LIST</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_msr_list</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_msr_list</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_msr_list</span> <span class="n">msr_list</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msr_list</span><span class="p">,</span> <span class="n">user_msr_list</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">msr_list</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">msr_list</span><span class="p">.</span><span class="n">nmsrs</span><span class="p">;</span>
		<span class="n">msr_list</span><span class="p">.</span><span class="n">nmsrs</span> <span class="o">=</span> <span class="n">num_msrs_to_save</span> <span class="o">+</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">emulated_msrs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_msr_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msr_list</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">msr_list</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">msr_list</span><span class="p">.</span><span class="n">nmsrs</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_msr_list</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msrs_to_save</span><span class="p">,</span>
				 <span class="n">num_msrs_to_save</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_msr_list</span><span class="o">-&gt;</span><span class="n">indices</span> <span class="o">+</span> <span class="n">num_msrs_to_save</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">emulated_msrs</span><span class="p">,</span>
				 <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">emulated_msrs</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_SUPPORTED_CPUID</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid2</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cpuid_arg</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid2</span> <span class="n">cpuid</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">cpuid_arg</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cpuid</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_dev_ioctl_get_supported_cpuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span>
						      <span class="n">cpuid_arg</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">cpuid_arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cpuid</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_X86_GET_MCE_CAP_SUPPORTED</span>: <span class="p">{</span>
		<span class="n">u64</span> <span class="n">mce_cap</span><span class="p">;</span>

		<span class="n">mce_cap</span> <span class="o">=</span> <span class="n">KVM_MCE_CAP_SUPPORTED</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mce_cap</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">mce_cap</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wbinvd_ipi</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">garbage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wbinvd</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">need_emulate_wbinvd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">iommu_domain</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">iommu_flags</span> <span class="o">&amp;</span> <span class="n">KVM_IOMMU_CACHE_COHERENCY</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_vcpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Address WBINVD may be executed by guest */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_emulate_wbinvd</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">has_wbinvd_exit</span><span class="p">())</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wbinvd_dirty_mask</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span>
			<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
					<span class="n">wbinvd_ipi</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* Apply any externally detected TSC adjustments (due to suspend) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_offset_adjustment</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adjust_tsc_offset_host</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_offset_adjustment</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_offset_adjustment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">KVM_REQ_CLOCK_UPDATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="n">check_tsc_unstable</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">tsc_delta</span> <span class="o">=</span> <span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_host_tsc</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
				<span class="n">native_read_tsc</span><span class="p">()</span> <span class="o">-</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_host_tsc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsc_delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mark_tsc_unstable</span><span class="p">(</span><span class="s">&quot;KVM discovered backwards TSC&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_tsc_unstable</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">compute_tsc_offset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span>
						<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_guest_tsc</span><span class="p">);</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">write_tsc_offset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_catchup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_CLOCK_UPDATE</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span>
			<span class="n">kvm_migrate_timers</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">accumulate_steal_time</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_STEAL_UPDATE</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_vcpu_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_put_guest_fpu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_host_tsc</span> <span class="o">=</span> <span class="n">native_read_tsc</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_get_lapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_lapic_state</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_set_lapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_lapic_state</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
	<span class="n">kvm_apic_post_state_restore</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">update_cr8_intercept</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_interrupt</span> <span class="o">*</span><span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">irq</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">kvm_queue_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">irq</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_inject_nmi</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vcpu_ioctl_tpr_access_reporting</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">kvm_tpr_access_ctl</span> <span class="o">*</span><span class="n">tac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tac</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tpr_access_reporting</span> <span class="o">=</span> <span class="o">!!</span><span class="n">tac</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_x86_setup_mce</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">mcg_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bank_num</span> <span class="o">=</span> <span class="n">mcg_cap</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">bank</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bank_num</span> <span class="o">||</span> <span class="n">bank_num</span> <span class="o">&gt;=</span> <span class="n">KVM_MAX_MCE_BANKS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcg_cap</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">KVM_MCE_CAP_SUPPORTED</span> <span class="o">|</span> <span class="mh">0xff</span> <span class="o">|</span> <span class="mh">0xff0000</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_cap</span> <span class="o">=</span> <span class="n">mcg_cap</span><span class="p">;</span>
	<span class="cm">/* Init IA32_MCG_CTL to all 1s */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcg_cap</span> <span class="o">&amp;</span> <span class="n">MCG_CTL_P</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_ctl</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Init IA32_MCi_CTL to all 1s */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bank</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bank</span> <span class="o">&lt;</span> <span class="n">bank_num</span><span class="p">;</span> <span class="n">bank</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">bank</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_x86_set_mce</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">kvm_x86_mce</span> <span class="o">*</span><span class="n">mce</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mcg_cap</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_cap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bank_num</span> <span class="o">=</span> <span class="n">mcg_cap</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">banks</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mce_banks</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mce</span><span class="o">-&gt;</span><span class="n">bank</span> <span class="o">&gt;=</span> <span class="n">bank_num</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_VAL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if IA32_MCG_CTL is not all 1s, the uncorrected error</span>
<span class="cm">	 * reporting is disabled</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_UC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mcg_cap</span> <span class="o">&amp;</span> <span class="n">MCG_CTL_P</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_ctl</span> <span class="o">!=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">banks</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if IA32_MCi_CTL is not all 1s, the uncorrected error</span>
<span class="cm">	 * reporting is disabled for the bank</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_UC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">banks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_UC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_status</span> <span class="o">&amp;</span> <span class="n">MCG_STATUS_MCIP</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">kvm_read_cr4_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR4_MCE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TRIPLE_FAULT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">banks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_VAL</span><span class="p">)</span>
			<span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">MCI_STATUS_OVER</span><span class="p">;</span>
		<span class="n">banks</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">banks</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_status</span> <span class="o">=</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">mcg_status</span><span class="p">;</span>
		<span class="n">banks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">MC_VECTOR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">banks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_VAL</span><span class="p">)</span>
		   <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">banks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_UC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">banks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_VAL</span><span class="p">)</span>
			<span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">MCI_STATUS_OVER</span><span class="p">;</span>
		<span class="n">banks</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">banks</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">;</span>
		<span class="n">banks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mce</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">banks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">MCI_STATUS_OVER</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_vcpu_ioctl_x86_get_vcpu_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">kvm_vcpu_events</span> <span class="o">*</span><span class="n">events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">process_nmi</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">injected</span> <span class="o">=</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">pending</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">kvm_exception_is_soft</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span><span class="p">);</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">has_error_code</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">has_error_code</span><span class="p">;</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code</span><span class="p">;</span>

	<span class="n">events</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">.</span><span class="n">injected</span> <span class="o">=</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">pending</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">soft</span><span class="p">;</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">.</span><span class="n">soft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">.</span><span class="n">shadow</span> <span class="o">=</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_interrupt_shadow</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span>
			<span class="n">KVM_X86_SHADOW_INT_MOV_SS</span> <span class="o">|</span> <span class="n">KVM_X86_SHADOW_INT_STI</span><span class="p">);</span>

	<span class="n">events</span><span class="o">-&gt;</span><span class="n">nmi</span><span class="p">.</span><span class="n">injected</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_injected</span><span class="p">;</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">nmi</span><span class="p">.</span><span class="n">pending</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">nmi</span><span class="p">.</span><span class="n">masked</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_nmi_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">events</span><span class="o">-&gt;</span><span class="n">nmi</span><span class="p">.</span><span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">events</span><span class="o">-&gt;</span><span class="n">sipi_vector</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">sipi_vector</span><span class="p">;</span>

	<span class="n">events</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">KVM_VCPUEVENT_VALID_NMI_PENDING</span>
			 <span class="o">|</span> <span class="n">KVM_VCPUEVENT_VALID_SIPI_VECTOR</span>
			 <span class="o">|</span> <span class="n">KVM_VCPUEVENT_VALID_SHADOW</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">events</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">events</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_x86_set_vcpu_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">kvm_vcpu_events</span> <span class="o">*</span><span class="n">events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">KVM_VCPUEVENT_VALID_NMI_PENDING</span>
			      <span class="o">|</span> <span class="n">KVM_VCPUEVENT_VALID_SIPI_VECTOR</span>
			      <span class="o">|</span> <span class="n">KVM_VCPUEVENT_VALID_SHADOW</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">process_nmi</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">pending</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">injected</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">has_error_code</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">has_error_code</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">pending</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">.</span><span class="n">injected</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">soft</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">.</span><span class="n">soft</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_VCPUEVENT_VALID_SHADOW</span><span class="p">)</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_interrupt_shadow</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span>
						  <span class="n">events</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">.</span><span class="n">shadow</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_injected</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">nmi</span><span class="p">.</span><span class="n">injected</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_VCPUEVENT_VALID_NMI_PENDING</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">nmi</span><span class="p">.</span><span class="n">pending</span><span class="p">;</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_nmi_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">nmi</span><span class="p">.</span><span class="n">masked</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_VCPUEVENT_VALID_SIPI_VECTOR</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">sipi_vector</span> <span class="o">=</span> <span class="n">events</span><span class="o">-&gt;</span><span class="n">sipi_vector</span><span class="p">;</span>

	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_vcpu_ioctl_x86_get_debugregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">kvm_debugregs</span> <span class="o">*</span><span class="n">dbgregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">db</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">db</span><span class="p">));</span>
	<span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">dr6</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span><span class="p">;</span>
	<span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">dr7</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span><span class="p">;</span>
	<span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_x86_set_debugregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">kvm_debugregs</span> <span class="o">*</span><span class="n">dbgregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">db</span><span class="p">,</span> <span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">db</span><span class="p">));</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span> <span class="o">=</span> <span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">dr6</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span> <span class="o">=</span> <span class="n">dbgregs</span><span class="o">-&gt;</span><span class="n">dr7</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_vcpu_ioctl_x86_get_xsave</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">kvm_xsave</span> <span class="o">*</span><span class="n">guest_xsave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_xsave</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">guest_xsave</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xsave</span><span class="p">,</span>
			<span class="n">xstate_size</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">guest_xsave</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fxsave</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i387_fxsave_struct</span><span class="p">));</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">guest_xsave</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">[</span><span class="n">XSAVE_HDR_OFFSET</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)]</span> <span class="o">=</span>
			<span class="n">XSTATE_FPSSE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_x86_set_xsave</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kvm_xsave</span> <span class="o">*</span><span class="n">guest_xsave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">xstate_bv</span> <span class="o">=</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">guest_xsave</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">[</span><span class="n">XSAVE_HDR_OFFSET</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_xsave</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xsave</span><span class="p">,</span>
			<span class="n">guest_xsave</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">,</span> <span class="n">xstate_size</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xstate_bv</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">XSTATE_FPSSE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fxsave</span><span class="p">,</span>
			<span class="n">guest_xsave</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i387_fxsave_struct</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_vcpu_ioctl_x86_get_xcrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kvm_xcrs</span> <span class="o">*</span><span class="n">guest_xcrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_xsave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">nr_xcrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">nr_xcrs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">xcrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xcr</span> <span class="o">=</span> <span class="n">XCR_XFEATURE_ENABLED_MASK</span><span class="p">;</span>
	<span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">xcrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xcr0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_x86_set_xcrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">kvm_xcrs</span> <span class="o">*</span><span class="n">guest_xcrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_xsave</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">nr_xcrs</span> <span class="o">&gt;</span> <span class="n">KVM_MAX_XCRS</span> <span class="o">||</span> <span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">nr_xcrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="cm">/* Only support XCR0 currently */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">xcrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xcr</span> <span class="o">==</span> <span class="n">XCR_XFEATURE_ENABLED_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">__kvm_set_xcr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">XCR_XFEATURE_ENABLED_MASK</span><span class="p">,</span>
				<span class="n">guest_xcrs</span><span class="o">-&gt;</span><span class="n">xcrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kvm_set_guest_paused() indicates to the guest kernel that it has been</span>
<span class="cm"> * stopped by the hypervisor.  This function will be called from the host only.</span>
<span class="cm"> * EINVAL is returned when the host attempts to set the flag for a guest that</span>
<span class="cm"> * does not support pv clocks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_set_guest_paused</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvclock_vcpu_time_info</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hv_clock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time_page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">src</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PVCLOCK_GUEST_STOPPED</span><span class="p">;</span>
	<span class="n">mark_page_dirty</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">time</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_CLOCK_UPDATE</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">kvm_arch_vcpu_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_lapic_state</span> <span class="o">*</span><span class="n">lapic</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_xsave</span> <span class="o">*</span><span class="n">xsave</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_xcrs</span> <span class="o">*</span><span class="n">xcrs</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>

	<span class="n">u</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_GET_LAPIC</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">u</span><span class="p">.</span><span class="n">lapic</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_lapic_state</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u</span><span class="p">.</span><span class="n">lapic</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_get_lapic</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">lapic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">lapic</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_lapic_state</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_LAPIC</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">u</span><span class="p">.</span><span class="n">lapic</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">.</span><span class="n">lapic</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">lapic</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">lapic</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_set_lapic</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">lapic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_INTERRUPT</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_interrupt</span> <span class="n">irq</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">irq</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_NMI</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_nmi</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_CPUID</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cpuid_arg</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid</span> <span class="n">cpuid</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">cpuid_arg</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cpuid</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_set_cpuid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">cpuid_arg</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_CPUID2</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid2</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cpuid_arg</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid2</span> <span class="n">cpuid</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">cpuid_arg</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cpuid</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_set_cpuid2</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span>
					      <span class="n">cpuid_arg</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_CPUID2</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid2</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cpuid_arg</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_cpuid2</span> <span class="n">cpuid</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">cpuid_arg</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cpuid</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_get_cpuid2</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span>
					      <span class="n">cpuid_arg</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">cpuid_arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuid</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cpuid</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_MSRS</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">msr_io</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="n">kvm_get_msr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_SET_MSRS</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">msr_io</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="n">do_set_msr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_TPR_ACCESS_REPORTING</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_tpr_access_ctl</span> <span class="n">tac</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tac</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">tac</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">vcpu_ioctl_tpr_access_reporting</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tac</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tac</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">tac</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">case</span> <span class="n">KVM_SET_VAPIC_ADDR</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_vapic_addr</span> <span class="n">va</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">va</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">va</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kvm_lapic_set_vapic_addr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">va</span><span class="p">.</span><span class="n">vapic_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_X86_SETUP_MCE</span>: <span class="p">{</span>
		<span class="n">u64</span> <span class="n">mcg_cap</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcg_cap</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">mcg_cap</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_x86_setup_mce</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">mcg_cap</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_X86_SET_MCE</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_x86_mce</span> <span class="n">mce</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">mce</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_x86_set_mce</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mce</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_VCPU_EVENTS</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_vcpu_events</span> <span class="n">events</span><span class="p">;</span>

		<span class="n">kvm_vcpu_ioctl_x86_get_vcpu_events</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu_events</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_VCPU_EVENTS</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_vcpu_events</span> <span class="n">events</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu_events</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_x86_set_vcpu_events</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_DEBUGREGS</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_debugregs</span> <span class="n">dbgregs</span><span class="p">;</span>

		<span class="n">kvm_vcpu_ioctl_x86_get_debugregs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbgregs</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbgregs</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_debugregs</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_DEBUGREGS</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_debugregs</span> <span class="n">dbgregs</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbgregs</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_debugregs</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_x86_set_debugregs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbgregs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_XSAVE</span>: <span class="p">{</span>
		<span class="n">u</span><span class="p">.</span><span class="n">xsave</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_xsave</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u</span><span class="p">.</span><span class="n">xsave</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">kvm_vcpu_ioctl_x86_get_xsave</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">xsave</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">xsave</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_xsave</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_XSAVE</span>: <span class="p">{</span>
		<span class="n">u</span><span class="p">.</span><span class="n">xsave</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">.</span><span class="n">xsave</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">xsave</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">xsave</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_x86_set_xsave</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">xsave</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_XCRS</span>: <span class="p">{</span>
		<span class="n">u</span><span class="p">.</span><span class="n">xcrs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_xcrs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u</span><span class="p">.</span><span class="n">xcrs</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">kvm_vcpu_ioctl_x86_get_xcrs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">xcrs</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">xcrs</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_xcrs</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_XCRS</span>: <span class="p">{</span>
		<span class="n">u</span><span class="p">.</span><span class="n">xcrs</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">.</span><span class="n">xcrs</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">xcrs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">xcrs</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_ioctl_x86_set_xcrs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">xcrs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_TSC_KHZ</span>: <span class="p">{</span>
		<span class="n">u32</span> <span class="n">user_tsc_khz</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">user_tsc_khz</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">user_tsc_khz</span> <span class="o">&gt;=</span> <span class="n">kvm_max_guest_tsc_khz</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">user_tsc_khz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">user_tsc_khz</span> <span class="o">=</span> <span class="n">tsc_khz</span><span class="p">;</span>

		<span class="n">kvm_set_tsc_khz</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">user_tsc_khz</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_TSC_KHZ</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">virtual_tsc_khz</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_KVMCLOCK_CTRL</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_set_guest_paused</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_set_tss_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">-</span><span class="mi">3</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_tss_addr</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_set_identity_map_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
					      <span class="n">u64</span> <span class="n">ident_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_map_addr</span> <span class="o">=</span> <span class="n">ident_addr</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_set_nr_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
					  <span class="n">u32</span> <span class="n">kvm_nr_mmu_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_nr_mmu_pages</span> <span class="o">&lt;</span> <span class="n">KVM_MIN_ALLOC_MMU_PAGES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="n">kvm_mmu_change_mmu_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">kvm_nr_mmu_pages</span><span class="p">);</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">n_requested_mmu_pages</span> <span class="o">=</span> <span class="n">kvm_nr_mmu_pages</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_get_nr_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">n_max_mmu_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_get_irqchip</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_IRQCHIP_PIC_MASTER</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">pic</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pic_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pics</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_pic_state</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_IRQCHIP_PIC_SLAVE</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">pic</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pic_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pics</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_pic_state</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_IRQCHIP_IOAPIC</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_get_ioapic</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ioapic</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_set_irqchip</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_IRQCHIP_PIC_MASTER</span>:
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pic_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pic_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pics</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">pic</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_pic_state</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pic_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_IRQCHIP_PIC_SLAVE</span>:
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pic_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pic_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pics</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">pic</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_pic_state</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pic_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_IRQCHIP_IOAPIC</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_set_ioapic</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ioapic</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kvm_pic_update_irq</span><span class="p">(</span><span class="n">pic_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_get_pit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_pit_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_pit_state</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_set_pit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_pit_state</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_pit_state</span><span class="p">));</span>
	<span class="n">kvm_pit_load_count</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_get_pit2</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_pit_state2</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">channels</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">));</span>
	<span class="n">ps</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_set_pit2</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_pit_state2</span> <span class="o">*</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">prev_legacy</span><span class="p">,</span> <span class="n">cur_legacy</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">prev_legacy</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_PIT_FLAGS_HPET_LEGACY</span><span class="p">;</span>
	<span class="n">cur_legacy</span> <span class="o">=</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_PIT_FLAGS_HPET_LEGACY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_legacy</span> <span class="o">&amp;&amp;</span> <span class="n">cur_legacy</span><span class="p">)</span>
		<span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">channels</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">channels</span><span class="p">));</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ps</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">kvm_pit_load_count</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_reinject</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kvm_reinject_control</span> <span class="o">*</span><span class="n">control</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">pit_timer</span><span class="p">.</span><span class="n">reinject</span> <span class="o">=</span> <span class="n">control</span><span class="o">-&gt;</span><span class="n">pit_reinject</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="o">-&gt;</span><span class="n">pit_state</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kvm_vm_ioctl_get_dirty_log - get and clear the log of dirty pages in a slot</span>
<span class="cm"> * @kvm: kvm instance</span>
<span class="cm"> * @log: slot id and address to which we copy the log</span>
<span class="cm"> *</span>
<span class="cm"> * We need to keep it in mind that VCPU threads can write to the bitmap</span>
<span class="cm"> * concurrently.  So, to avoid losing data, we keep the following order for</span>
<span class="cm"> * each bit:</span>
<span class="cm"> *</span>
<span class="cm"> *   1. Take a snapshot of the bit and clear it if needed.</span>
<span class="cm"> *   2. Write protect the corresponding page.</span>
<span class="cm"> *   3. Flush TLB&#39;s if needed.</span>
<span class="cm"> *   4. Copy the snapshot to the userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * Between 2 and 3, the guest may write to the page using the remaining TLB</span>
<span class="cm"> * entry.  This is not a problem because the page will be reported dirty at</span>
<span class="cm"> * step 4 using the snapshot taken before and step 3 ensures that successive</span>
<span class="cm"> * writes will be logged for the next call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kvm_vm_ioctl_get_dirty_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dirty_bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dirty_bitmap_buffer</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_dirty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">KVM_MEMORY_SLOTS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memslot</span> <span class="o">=</span> <span class="n">id_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>

	<span class="n">dirty_bitmap</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirty_bitmap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">kvm_dirty_bitmap_bytes</span><span class="p">(</span><span class="n">memslot</span><span class="p">);</span>

	<span class="n">dirty_bitmap_buffer</span> <span class="o">=</span> <span class="n">dirty_bitmap</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dirty_bitmap_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">gfn_t</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirty_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">is_dirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">mask</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirty_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dirty_bitmap_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="n">kvm_mmu_write_protect_pt_masked</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">memslot</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_dirty</span><span class="p">)</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">,</span> <span class="n">dirty_bitmap_buffer</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">kvm_arch_vm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This union makes it completely explicit to gcc-3.x</span>
<span class="cm">	 * that these two variables&#39; stack usage should be</span>
<span class="cm">	 * combined, not added together.</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_pit_state</span> <span class="n">ps</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_pit_state2</span> <span class="n">ps2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_pit_config</span> <span class="n">pit_config</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_SET_TSS_ADDR</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_set_tss_addr</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_SET_IDENTITY_MAP_ADDR</span>: <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ident_addr</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ident_addr</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ident_addr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_set_identity_map_addr</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">ident_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_NR_MMU_PAGES</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_set_nr_mmu_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_GET_NR_MMU_PAGES</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_get_nr_mmu_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CREATE_IRQCHIP</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_pic</span> <span class="o">*</span><span class="n">vpic</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpic</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">create_irqchip_unlock</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">create_irqchip_unlock</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">vpic</span> <span class="o">=</span> <span class="n">kvm_create_pic</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vpic</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_ioapic_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
				<span class="n">kvm_io_bus_unregister_dev</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_PIO_BUS</span><span class="p">,</span>
							  <span class="o">&amp;</span><span class="n">vpic</span><span class="o">-&gt;</span><span class="n">dev_master</span><span class="p">);</span>
				<span class="n">kvm_io_bus_unregister_dev</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_PIO_BUS</span><span class="p">,</span>
							  <span class="o">&amp;</span><span class="n">vpic</span><span class="o">-&gt;</span><span class="n">dev_slave</span><span class="p">);</span>
				<span class="n">kvm_io_bus_unregister_dev</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_PIO_BUS</span><span class="p">,</span>
							  <span class="o">&amp;</span><span class="n">vpic</span><span class="o">-&gt;</span><span class="n">dev_eclr</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">vpic</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">create_irqchip_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">goto</span> <span class="n">create_irqchip_unlock</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpic</span> <span class="o">=</span> <span class="n">vpic</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_setup_default_irq_routing</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
			<span class="n">kvm_ioapic_destroy</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
			<span class="n">kvm_destroy_pic</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="nl">create_irqchip_unlock:</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_CREATE_PIT</span>:
		<span class="n">u</span><span class="p">.</span><span class="n">pit_config</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">KVM_PIT_SPEAKER_DUMMY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">create_pit</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CREATE_PIT2</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">pit_config</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_pit_config</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="nl">create_pit:</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">create_pit_unlock</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span> <span class="o">=</span> <span class="n">kvm_create_pit</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">pit_config</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">create_pit_unlock:</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_IRQ_LINE_STATUS</span>:
	<span class="k">case</span> <span class="n">KVM_IRQ_LINE</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_irq_level</span> <span class="n">irq_event</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_event</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">irq_event</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__s32</span> <span class="n">status</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">kvm_set_irq</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_USERSPACE_IRQ_SOURCE_ID</span><span class="p">,</span>
					<span class="n">irq_event</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_event</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span> <span class="o">==</span> <span class="n">KVM_IRQ_LINE_STATUS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="n">irq_event</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_event</span><span class="p">,</span>
							<span class="k">sizeof</span> <span class="n">irq_event</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_IRQCHIP</span>: <span class="p">{</span>
		<span class="cm">/* 0: PIC master, 1: PIC slave, 2: IOAPIC */</span>
		<span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

		<span class="n">chip</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chip</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">get_irqchip_out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_get_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">get_irqchip_out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">chip</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">get_irqchip_out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">get_irqchip_out:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_IRQCHIP</span>: <span class="p">{</span>
		<span class="cm">/* 0: PIC master, 1: PIC slave, 2: IOAPIC */</span>
		<span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

		<span class="n">chip</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chip</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">set_irqchip_out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_set_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">set_irqchip_out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">set_irqchip_out:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_PIT</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">ps</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_pit_state</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_get_pit</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">ps</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_pit_state</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_PIT</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">ps</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">u</span><span class="p">.</span><span class="n">ps</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_set_pit</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_PIT2</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_get_pit2</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">ps2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">ps2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">ps2</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_PIT2</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">ps2</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">ps2</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpit</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_set_pit2</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">ps2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_REINJECT_CONTROL</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_reinject_control</span> <span class="n">control</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span>  <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">control</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">control</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_reinject</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">control</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_XEN_HVM_CONFIG</span>: <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xen_hvm_config</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_xen_hvm_config</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xen_hvm_config</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_CLOCK</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_clock_data</span> <span class="n">user_ns</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">now_ns</span><span class="p">;</span>
		<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">user_ns</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_ns</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">now_ns</span> <span class="o">=</span> <span class="n">get_kernel_ns</span><span class="p">();</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">user_ns</span><span class="p">.</span><span class="n">clock</span> <span class="o">-</span> <span class="n">now_ns</span><span class="p">;</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">kvmclock_offset</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_CLOCK</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_clock_data</span> <span class="n">user_ns</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">now_ns</span><span class="p">;</span>

		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">now_ns</span> <span class="o">=</span> <span class="n">get_kernel_ns</span><span class="p">();</span>
		<span class="n">user_ns</span><span class="p">.</span><span class="n">clock</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">kvmclock_offset</span> <span class="o">+</span> <span class="n">now_ns</span><span class="p">;</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">user_ns</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_ns</span><span class="p">.</span><span class="n">pad</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">user_ns</span><span class="p">.</span><span class="n">pad</span><span class="p">));</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user_ns</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">user_ns</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_init_msr_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dummy</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* skip the first msrs in the list. KVM-specific */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">KVM_SAVE_MSRS_BEGIN</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">msrs_to_save</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rdmsr_safe</span><span class="p">(</span><span class="n">msrs_to_save</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">msrs_to_save</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">msrs_to_save</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">num_msrs_to_save</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vcpu_mmio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span> <span class="o">&amp;&amp;</span>
		      <span class="o">!</span><span class="n">kvm_iodevice_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
		    <span class="o">&amp;&amp;</span> <span class="n">kvm_io_bus_write</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_MMIO_BUS</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">handled</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">v</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">handled</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vcpu_mmio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span> <span class="o">&amp;&amp;</span>
		      <span class="o">!</span><span class="n">kvm_iodevice_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
		    <span class="o">&amp;&amp;</span> <span class="n">kvm_io_bus_read</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_MMIO_BUS</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">trace_kvm_mmio</span><span class="p">(</span><span class="n">KVM_TRACE_MMIO_READ</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">v</span><span class="p">);</span>
		<span class="n">handled</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">v</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">handled</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_set_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_get_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">kvm_segment</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">gpa_t</span> <span class="nf">translate_nested_gpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gpa_t</span> <span class="n">t_gpa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">x86_exception</span> <span class="n">exception</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mmu_is_nested</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>

	<span class="cm">/* NPT walks are always user-walks */</span>
	<span class="n">access</span> <span class="o">|=</span> <span class="n">PFERR_USER_MASK</span><span class="p">;</span>
	<span class="n">t_gpa</span>  <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">gva_to_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">t_gpa</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">gpa_t</span> <span class="nf">kvm_mmu_gva_to_gpa_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">access</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="n">PFERR_USER_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
<span class="p">}</span>

 <span class="n">gpa_t</span> <span class="nf">kvm_mmu_gva_to_gpa_fetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">access</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="n">PFERR_USER_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">access</span> <span class="o">|=</span> <span class="n">PFERR_FETCH_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">gpa_t</span> <span class="nf">kvm_mmu_gva_to_gpa_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">access</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="n">PFERR_USER_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">access</span> <span class="o">|=</span> <span class="n">PFERR_WRITE_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* uses this to access any guest&#39;s mapped memory without checking CPL */</span>
<span class="n">gpa_t</span> <span class="nf">kvm_mmu_gva_to_gpa_system</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_read_guest_virt_helper</span><span class="p">(</span><span class="n">gva_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">access</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gpa_t</span> <span class="n">gpa</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span>
							    <span class="n">exception</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">toread</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">gpa</span> <span class="o">==</span> <span class="n">UNMAPPED_GVA</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">X86EMUL_PROPAGATE_FAULT</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_read_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">toread</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">X86EMUL_IO_NEEDED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">toread</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">toread</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">toread</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* used for instruction fetching */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_fetch_guest_virt</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
				<span class="n">gva_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">access</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="n">PFERR_USER_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kvm_read_guest_virt_helper</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span>
					  <span class="n">access</span> <span class="o">|</span> <span class="n">PFERR_FETCH_MASK</span><span class="p">,</span>
					  <span class="n">exception</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_read_guest_virt</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			       <span class="n">gva_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">access</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="n">PFERR_USER_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kvm_read_guest_virt_helper</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span>
					  <span class="n">exception</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_read_guest_virt</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_read_guest_virt_system</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
				      <span class="n">gva_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kvm_read_guest_virt_helper</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_write_guest_virt_system</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
				       <span class="n">gva_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gpa_t</span> <span class="n">gpa</span> <span class="o">=</span>  <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
							     <span class="n">PFERR_WRITE_MASK</span><span class="p">,</span>
							     <span class="n">exception</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">towrite</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">gpa</span> <span class="o">==</span> <span class="n">UNMAPPED_GVA</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">X86EMUL_PROPAGATE_FAULT</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_write_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">towrite</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">X86EMUL_IO_NEEDED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">towrite</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">towrite</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">towrite</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_write_guest_virt_system</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vcpu_mmio_gva_to_gpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gva</span><span class="p">,</span>
				<span class="n">gpa_t</span> <span class="o">*</span><span class="n">gpa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">access</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="n">PFERR_USER_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu_match_mmio_gva</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		  <span class="n">check_write_user_access</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span>
		  <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">access</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">gpa</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmio_gfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">gva</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">trace_vcpu_match_mmio</span><span class="p">(</span><span class="n">gva</span><span class="p">,</span> <span class="o">*</span><span class="n">gpa</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
		<span class="n">access</span> <span class="o">|=</span> <span class="n">PFERR_WRITE_MASK</span><span class="p">;</span>

	<span class="o">*</span><span class="n">gpa</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">gpa</span> <span class="o">==</span> <span class="n">UNMAPPED_GVA</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* For APIC access vmexit */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">gpa</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">APIC_DEFAULT_PHYS_BASE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu_match_mmio_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">*</span><span class="n">gpa</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_vcpu_match_mmio</span><span class="p">(</span><span class="n">gva</span><span class="p">,</span> <span class="o">*</span><span class="n">gpa</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">emulator_write_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_write_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kvm_mmu_pte_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">read_write_emulator_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_write_prepare</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_write_emulate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_write_mmio</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_write_exit_mmio</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">write</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_read_completed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_kvm_mmio</span><span class="p">(</span><span class="n">KVM_TRACE_MMIO_READ</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
			       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_fragments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gpa</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_read_completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_emulate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">kvm_read_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_emulate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">emulator_write_phys</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_mmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_kvm_mmio</span><span class="p">(</span><span class="n">KVM_TRACE_MMIO_WRITE</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vcpu_mmio_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_exit_mmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_kvm_mmio</span><span class="p">(</span><span class="n">KVM_TRACE_MMIO_READ_UNSATISFIED</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">X86EMUL_IO_NEEDED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_exit_mmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmio_fragment</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_fragments</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">read_write_emulator_ops</span> <span class="n">read_emultor</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read_write_prepare</span> <span class="o">=</span> <span class="n">read_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_write_emulate</span> <span class="o">=</span> <span class="n">read_emulate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_write_mmio</span> <span class="o">=</span> <span class="n">vcpu_mmio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_write_exit_mmio</span> <span class="o">=</span> <span class="n">read_exit_mmio</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">read_write_emulator_ops</span> <span class="n">write_emultor</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read_write_emulate</span> <span class="o">=</span> <span class="n">write_emulate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_write_mmio</span> <span class="o">=</span> <span class="n">write_mmio</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_write_exit_mmio</span> <span class="o">=</span> <span class="n">write_exit_mmio</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_read_write_onepage</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">read_write_emulator_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handled</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">write</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmio_fragment</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vcpu_mmio_gva_to_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpa</span><span class="p">,</span> <span class="n">exception</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">X86EMUL_PROPAGATE_FAULT</span><span class="p">;</span>

	<span class="cm">/* For APIC access vmexit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">mmio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_write_emulate</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>

<span class="nl">mmio:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Is this MMIO handled locally?</span>
<span class="cm">	 */</span>
	<span class="n">handled</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_write_mmio</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handled</span> <span class="o">==</span> <span class="n">bytes</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>

	<span class="n">gpa</span> <span class="o">+=</span> <span class="n">handled</span><span class="p">;</span>
	<span class="n">bytes</span> <span class="o">-=</span> <span class="n">handled</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">+=</span> <span class="n">handled</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">now</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="mi">8U</span><span class="p">);</span>

		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_fragments</span><span class="p">[</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_nr_fragments</span><span class="o">++</span><span class="p">];</span>
		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">gpa</span> <span class="o">=</span> <span class="n">gpa</span><span class="p">;</span>
		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

		<span class="n">gpa</span> <span class="o">+=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">emulator_read_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">read_write_emulator_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_write_prepare</span> <span class="o">&amp;&amp;</span>
		  <span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_write_prepare</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_nr_fragments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Crossing a page boundary? */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">now</span><span class="p">;</span>

		<span class="n">now</span> <span class="o">=</span> <span class="o">-</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">emulator_read_write_onepage</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">exception</span><span class="p">,</span>
						 <span class="n">vcpu</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">emulator_read_write_onepage</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">exception</span><span class="p">,</span>
					 <span class="n">vcpu</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_nr_fragments</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">gpa</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_fragments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gpa</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_cur_fragment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_fragments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">is_write</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_is_write</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_MMIO</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">gpa</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_write_exit_mmio</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_read_emulated</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">emulator_read_write</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
				   <span class="n">exception</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read_emultor</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">emulator_write_emulated</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">emulator_read_write</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">val</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
				   <span class="n">exception</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_emultor</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define CMPXCHG_TYPE(t, ptr, old, new) \</span>
<span class="cp">	(cmpxchg((t *)(ptr), *(t *)(old), *(t *)(new)) == *(t *)(old))</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cp">#  define CMPXCHG64(ptr, old, new) CMPXCHG_TYPE(u64, ptr, old, new)</span>
<span class="cp">#else</span>
<span class="cp">#  define CMPXCHG64(ptr, old, new) \</span>
<span class="cp">	(cmpxchg64((u64 *)(ptr), *(u64 *)(old), *(u64 *)(new)) == *(u64 *)(old))</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_cmpxchg_emulated</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">exchanged</span><span class="p">;</span>

	<span class="cm">/* guests cmpxchg8b have to be emulated atomically */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="o">||</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">emul_write</span><span class="p">;</span>

	<span class="n">gpa</span> <span class="o">=</span> <span class="n">kvm_mmu_gva_to_gpa_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gpa</span> <span class="o">==</span> <span class="n">UNMAPPED_GVA</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">gpa</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">APIC_DEFAULT_PHYS_BASE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">emul_write</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">gpa</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">gpa</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">emul_write</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">gfn_to_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_error_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_release_page_clean</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">emul_write</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kaddr</span> <span class="o">+=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">exchanged</span> <span class="o">=</span> <span class="n">CMPXCHG_TYPE</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">exchanged</span> <span class="o">=</span> <span class="n">CMPXCHG_TYPE</span><span class="p">(</span><span class="n">u16</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">exchanged</span> <span class="o">=</span> <span class="n">CMPXCHG_TYPE</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">exchanged</span> <span class="o">=</span> <span class="n">CMPXCHG64</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="n">kvm_release_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exchanged</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">X86EMUL_CMPXCHG_FAILED</span><span class="p">;</span>

	<span class="n">kvm_mmu_pte_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>

<span class="nl">emul_write:</span>
	<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;kvm: emulating exchange as write</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">emulator_write_emulated</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kernel_pio</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* TODO: String I/O for in kernel device */</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">in</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_io_bus_read</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_PIO_BUS</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">port</span><span class="p">,</span>
				    <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_io_bus_write</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_PIO_BUS</span><span class="p">,</span>
				     <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">port</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
				     <span class="n">pd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_pio_in_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">bool</span> <span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_kvm_pio</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">in</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">count</span>  <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kernel_pio</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_IO</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">in</span> <span class="o">?</span> <span class="n">KVM_EXIT_IO_IN</span> <span class="o">:</span> <span class="n">KVM_EXIT_IO_OUT</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">data_offset</span> <span class="o">=</span> <span class="n">KVM_PIO_PAGE_OFFSET</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_pio_in_emulated</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">data_avail</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">emulator_pio_in_out</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">data_avail:</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio_data</span><span class="p">,</span> <span class="n">size</span> <span class="o">*</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_pio_out_emulated</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio_data</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">size</span> <span class="o">*</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">emulator_pio_in_out</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">val</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_segment_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_segment_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_invlpg</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_mmu_invlpg</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_emulate_wbinvd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_emulate_wbinvd</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">has_wbinvd_exit</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wbinvd_dirty_mask</span><span class="p">);</span>
		<span class="n">smp_call_function_many</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wbinvd_dirty_mask</span><span class="p">,</span>
				<span class="n">wbinvd_ipi</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">put_cpu</span><span class="p">();</span>
		<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wbinvd_dirty_mask</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">wbinvd</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_emulate_wbinvd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_wbinvd</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_emulate_wbinvd</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">emulator_get_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_kvm_get_dr</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">emulator_set_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">return</span> <span class="n">__kvm_set_dr</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">dr</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">mk_cr_64</span><span class="p">(</span><span class="n">u64</span> <span class="n">curr_cr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">curr_cr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="n">new_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">emulator_get_cr</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="n">kvm_read_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="n">kvm_read_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="n">kvm_get_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">vcpu_printf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;%s: unexpected cr %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">cr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_set_cr</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cr</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">kvm_set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">mk_cr_64</span><span class="p">(</span><span class="n">kvm_read_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">val</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr2</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">kvm_set_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">kvm_set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">mk_cr_64</span><span class="p">(</span><span class="n">kvm_read_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="n">val</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">kvm_set_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">vcpu_printf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="s">&quot;%s: unexpected cr %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">cr</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_set_rflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_set_rflags</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_get_cpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_get_gdt</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_gdt</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">dt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_get_idt</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_idt</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">dt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_set_gdt</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_gdt</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">dt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_set_idt</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_idt</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">dt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">emulator_get_cached_segment_base</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_segment_base</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">seg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">emulator_get_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">selector</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">base3</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">var</span><span class="p">;</span>

	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">var</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
	<span class="o">*</span><span class="n">selector</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">selector</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">unusable</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">g</span><span class="p">)</span>
		<span class="n">var</span><span class="p">.</span><span class="n">limit</span> <span class="o">&gt;&gt;=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">set_desc_limit</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">var</span><span class="p">.</span><span class="n">limit</span><span class="p">);</span>
	<span class="n">set_desc_base</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">var</span><span class="p">.</span><span class="n">base</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base3</span><span class="p">)</span>
		<span class="o">*</span><span class="n">base3</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">dpl</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">dpl</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">present</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">avl</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">avl</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">l</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">l</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">d</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">db</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">g</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_set_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">u16</span> <span class="n">selector</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">base3</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">seg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">var</span><span class="p">;</span>

	<span class="n">var</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">selector</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">get_desc_base</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">var</span><span class="p">.</span><span class="n">base</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">base3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">var</span><span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">get_desc_limit</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">)</span>
		<span class="n">var</span><span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">limit</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xfff</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">present</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">dpl</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">avl</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">avl</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">present</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">unusable</span> <span class="o">=</span> <span class="o">!</span><span class="n">var</span><span class="p">.</span><span class="n">present</span><span class="p">;</span>
	<span class="n">var</span><span class="p">.</span><span class="n">padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kvm_set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">var</span><span class="p">,</span> <span class="n">seg</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_get_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_get_msr</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_set_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_set_msr</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_read_pmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">pmc</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_pmu_read_pmc</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">pmc</span><span class="p">,</span> <span class="n">pdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">halt_request</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_get_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">kvm_load_guest_fpu</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * CR0.TS may reference the host fpu state, not the guest fpu state,</span>
<span class="cm">	 * so it may be clear at this point.</span>
<span class="cm">	 */</span>
	<span class="n">clts</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">emulator_put_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">emulator_intercept</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">x86_instruction_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">x86_intercept_stage</span> <span class="n">stage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">check_intercept</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span> <span class="n">info</span><span class="p">,</span> <span class="n">stage</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">emulator_get_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">edx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">cpuid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eax</span> <span class="o">&amp;&amp;</span> <span class="n">ecx</span><span class="p">)</span>
		<span class="n">cpuid</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">),</span>
					    <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="o">*</span><span class="n">ecx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuid</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">cpuid</span><span class="o">-&gt;</span><span class="n">eax</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">cpuid</span><span class="o">-&gt;</span><span class="n">ecx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ebx</span><span class="p">)</span>
			<span class="o">*</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">cpuid</span><span class="o">-&gt;</span><span class="n">ebx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edx</span><span class="p">)</span>
			<span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="n">cpuid</span><span class="o">-&gt;</span><span class="n">edx</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">x86_emulate_ops</span> <span class="n">emulate_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read_std</span>            <span class="o">=</span> <span class="n">kvm_read_guest_virt_system</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_std</span>           <span class="o">=</span> <span class="n">kvm_write_guest_virt_system</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fetch</span>               <span class="o">=</span> <span class="n">kvm_fetch_guest_virt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_emulated</span>       <span class="o">=</span> <span class="n">emulator_read_emulated</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_emulated</span>      <span class="o">=</span> <span class="n">emulator_write_emulated</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmpxchg_emulated</span>    <span class="o">=</span> <span class="n">emulator_cmpxchg_emulated</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invlpg</span>              <span class="o">=</span> <span class="n">emulator_invlpg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pio_in_emulated</span>     <span class="o">=</span> <span class="n">emulator_pio_in_emulated</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pio_out_emulated</span>    <span class="o">=</span> <span class="n">emulator_pio_out_emulated</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_segment</span>         <span class="o">=</span> <span class="n">emulator_get_segment</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_segment</span>         <span class="o">=</span> <span class="n">emulator_set_segment</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cached_segment_base</span> <span class="o">=</span> <span class="n">emulator_get_cached_segment_base</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_gdt</span>             <span class="o">=</span> <span class="n">emulator_get_gdt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_idt</span>	     <span class="o">=</span> <span class="n">emulator_get_idt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_gdt</span>             <span class="o">=</span> <span class="n">emulator_set_gdt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_idt</span>	     <span class="o">=</span> <span class="n">emulator_set_idt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cr</span>              <span class="o">=</span> <span class="n">emulator_get_cr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_cr</span>              <span class="o">=</span> <span class="n">emulator_set_cr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_rflags</span>          <span class="o">=</span> <span class="n">emulator_set_rflags</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cpl</span>                 <span class="o">=</span> <span class="n">emulator_get_cpl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_dr</span>              <span class="o">=</span> <span class="n">emulator_get_dr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_dr</span>              <span class="o">=</span> <span class="n">emulator_set_dr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msr</span>             <span class="o">=</span> <span class="n">emulator_set_msr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msr</span>             <span class="o">=</span> <span class="n">emulator_get_msr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_pmc</span>            <span class="o">=</span> <span class="n">emulator_read_pmc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">halt</span>                <span class="o">=</span> <span class="n">emulator_halt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wbinvd</span>              <span class="o">=</span> <span class="n">emulator_wbinvd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fix_hypercall</span>       <span class="o">=</span> <span class="n">emulator_fix_hypercall</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_fpu</span>             <span class="o">=</span> <span class="n">emulator_get_fpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_fpu</span>             <span class="o">=</span> <span class="n">emulator_put_fpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intercept</span>           <span class="o">=</span> <span class="n">emulator_intercept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cpuid</span>           <span class="o">=</span> <span class="n">emulator_get_cpuid</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_all_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">);</span>
	<span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSP</span><span class="p">);</span>
	<span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RIP</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_dirty</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">toggle_interruptibility</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">int_shadow</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_interrupt_shadow</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * an sti; sti; sequence only disable interrupts for the first</span>
<span class="cm">	 * instruction. So, if the last instruction, be it emulated or</span>
<span class="cm">	 * not, left the system with the INT_STI flag enabled, it</span>
<span class="cm">	 * means that the last instruction is an sti. We should not</span>
<span class="cm">	 * leave the flag on in this case. The same goes for mov ss</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">int_shadow</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_interrupt_shadow</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inject_emulated_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">vector</span> <span class="o">==</span> <span class="n">PF_VECTOR</span><span class="p">)</span>
		<span class="n">kvm_propagate_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code_valid</span><span class="p">)</span>
		<span class="n">kvm_queue_exception_e</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">vector</span><span class="p">,</span>
				      <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">exception</span><span class="p">.</span><span class="n">vector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_decode_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">twobyte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">twobyte</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">));</span>

	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">fetch</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">fetch</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">io_read</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">io_read</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">mem_read</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">mem_read</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_emulate_ctxt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cs_db</span><span class="p">,</span> <span class="n">cs_l</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: fix emulate.c to use guest_read/write_register</span>
<span class="cm">	 * instead of direct -&gt;regs accesses, can save hundred cycles</span>
<span class="cm">	 * on Intel for instructions that don&#39;t read/change RSP, for</span>
<span class="cm">	 * for example.</span>
<span class="cm">	 */</span>
	<span class="n">cache_all_regs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cs_db_l_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs_db</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs_l</span><span class="p">);</span>

	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eflags</span> <span class="o">=</span> <span class="n">kvm_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">=</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">is_protmode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>		<span class="o">?</span> <span class="n">X86EMUL_MODE_REAL</span> <span class="o">:</span>
		     <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eflags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_VM</span><span class="p">)</span>	<span class="o">?</span> <span class="n">X86EMUL_MODE_VM86</span> <span class="o">:</span>
		     <span class="n">cs_l</span>				<span class="o">?</span> <span class="n">X86EMUL_MODE_PROT64</span> <span class="o">:</span>
		     <span class="n">cs_db</span>				<span class="o">?</span> <span class="n">X86EMUL_MODE_PROT32</span> <span class="o">:</span>
							  <span class="n">X86EMUL_MODE_PROT16</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">guest_mode</span> <span class="o">=</span> <span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">init_decode_cache</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_regs_need_sync_from_vcpu</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_inject_realmode_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc_eip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">init_emulate_ctxt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">op_bytes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">ad_bytes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">_eip</span> <span class="o">=</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">+</span> <span class="n">inc_eip</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">emulate_int_real</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">X86EMUL_CONTINUE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EMULATE_FAIL</span><span class="p">;</span>

	<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">=</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">_eip</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">kvm_rip_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eip</span><span class="p">);</span>
	<span class="n">kvm_set_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="n">NMI_VECTOR</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_inject_realmode_interrupt</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_emulation_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>

	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">insn_emulation_fail</span><span class="p">;</span>
	<span class="n">trace_kvm_emulate_insn_failed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTERNAL_ERROR</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">internal</span><span class="p">.</span><span class="n">suberror</span> <span class="o">=</span> <span class="n">KVM_INTERNAL_ERROR_EMULATION</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">internal</span><span class="p">.</span><span class="n">ndata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">EMULATE_FAIL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">reexecute_instruction</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tdp_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if emulation was due to access to shadowed page table</span>
<span class="cm">	 * and it failed try to unshadow page and re-entetr the</span>
<span class="cm">	 * guest to let CPU execute the instruction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_mmu_unprotect_page_virt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">gpa</span> <span class="o">=</span> <span class="n">kvm_mmu_gva_to_gpa_system</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gpa</span> <span class="o">==</span> <span class="n">UNMAPPED_GVA</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="cm">/* let cpu generate fault */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_error_hva</span><span class="p">(</span><span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">retry_instruction</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr2</span><span class="p">,</span>  <span class="kt">int</span> <span class="n">emulation_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_retry_eip</span><span class="p">,</span> <span class="n">last_retry_addr</span><span class="p">,</span> <span class="n">gpa</span> <span class="o">=</span> <span class="n">cr2</span><span class="p">;</span>

	<span class="n">last_retry_eip</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_retry_eip</span><span class="p">;</span>
	<span class="n">last_retry_addr</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_retry_addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the emulation is caused by #PF and it is non-page_table</span>
<span class="cm">	 * writing instruction, it means the VM-EXIT is caused by shadow</span>
<span class="cm">	 * page protected, we can zap the shadow page and retry this</span>
<span class="cm">	 * instruction directly.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: if the guest uses a non-page-table modifying instruction</span>
<span class="cm">	 * on the PDE that points to the instruction, then we will unmap</span>
<span class="cm">	 * the instruction and go to an infinite loop. So, we cache the</span>
<span class="cm">	 * last retried eip and the last fault address, if we meet the eip</span>
<span class="cm">	 * and the address again, we can break out of the potential infinite</span>
<span class="cm">	 * loop.</span>
<span class="cm">	 */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_retry_eip</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_retry_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">emulation_type</span> <span class="o">&amp;</span> <span class="n">EMULTYPE_RETRY</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_page_table_writing_insn</span><span class="p">(</span><span class="n">ctxt</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">==</span> <span class="n">last_retry_eip</span> <span class="o">&amp;&amp;</span> <span class="n">last_retry_addr</span> <span class="o">==</span> <span class="n">cr2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_retry_eip</span> <span class="o">=</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eip</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_retry_addr</span> <span class="o">=</span> <span class="n">cr2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span><span class="p">)</span>
		<span class="n">gpa</span> <span class="o">=</span> <span class="n">kvm_mmu_gva_to_gpa_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">kvm_mmu_unprotect_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">x86_emulate_instruction</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr2</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">emulation_type</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">insn_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">writeback</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">kvm_clear_exception_queue</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">emulation_type</span> <span class="o">&amp;</span> <span class="n">EMULTYPE_NO_DECODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">init_emulate_ctxt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">interruptibility</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">have_exception</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">perm_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">only_vendor_specific_insn</span>
			<span class="o">=</span> <span class="n">emulation_type</span> <span class="o">&amp;</span> <span class="n">EMULTYPE_TRAP_UD</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">x86_decode_insn</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">insn</span><span class="p">,</span> <span class="n">insn_len</span><span class="p">);</span>

		<span class="n">trace_kvm_emulate_insn_start</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">insn_emulation</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">EMULATION_OK</span><span class="p">)</span>  <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">emulation_type</span> <span class="o">&amp;</span> <span class="n">EMULTYPE_TRAP_UD</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">EMULATE_FAIL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reexecute_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">emulation_type</span> <span class="o">&amp;</span> <span class="n">EMULTYPE_SKIP</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">EMULATE_FAIL</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">handle_emulation_failure</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emulation_type</span> <span class="o">&amp;</span> <span class="n">EMULTYPE_SKIP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_rip_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">_eip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retry_instruction</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">cr2</span><span class="p">,</span> <span class="n">emulation_type</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>

	<span class="cm">/* this is needed for vmware backdoor interface to work since it</span>
<span class="cm">	   changes registers values  during IO operation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_regs_need_sync_from_vcpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_regs_need_sync_from_vcpu</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">restart:</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">x86_emulate_insn</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">EMULATION_INTERCEPTED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">EMULATION_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reexecute_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">handle_emulation_failure</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">have_exception</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inject_emulated_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">in</span><span class="p">)</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">writeback</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">EMULATE_DO_MMIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_is_write</span><span class="p">)</span>
			<span class="n">writeback</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">EMULATE_DO_MMIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">EMULATION_RESTART</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">writeback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">toggle_interruptibility</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">interruptibility</span><span class="p">);</span>
		<span class="n">kvm_set_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eflags</span><span class="p">);</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_regs_need_sync_to_vcpu</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">kvm_rip_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_regs_need_sync_to_vcpu</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">x86_emulate_instruction</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_fast_pio_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">emulator_pio_out_emulated</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">,</span>
					    <span class="n">size</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* do not return to emulator after return from userspace */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_fast_pio_out</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tsc_bad</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">cpu_tsc_khz</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tsc_khz_changed</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpufreq_freqs</span> <span class="o">*</span><span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">khz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
		<span class="n">khz</span> <span class="o">=</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CONSTANT_TSC</span><span class="p">))</span>
		<span class="n">khz</span> <span class="o">=</span> <span class="n">cpufreq_quick_get</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">khz</span><span class="p">)</span>
		<span class="n">khz</span> <span class="o">=</span> <span class="n">tsc_khz</span><span class="p">;</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">cpu_tsc_khz</span><span class="p">,</span> <span class="n">khz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvmclock_cpufreq_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpufreq_freqs</span> <span class="o">*</span><span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">send_ipi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We allow guests to temporarily run on slowing clocks,</span>
<span class="cm">	 * provided we notify them after, or to run on accelerating</span>
<span class="cm">	 * clocks, provided we notify them before.  Thus time never</span>
<span class="cm">	 * goes backwards.</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, we have a problem.  We can&#39;t atomically update</span>
<span class="cm">	 * the frequency of a given CPU from this function; it is</span>
<span class="cm">	 * merely a notifier, which can be called from any CPU.</span>
<span class="cm">	 * Changing the TSC frequency at arbitrary points in time</span>
<span class="cm">	 * requires a recomputation of local variables related to</span>
<span class="cm">	 * the TSC for each VCPU.  We must flag these local variables</span>
<span class="cm">	 * to be updated and be sure the update takes place with the</span>
<span class="cm">	 * new frequency before any guests proceed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Unfortunately, the combination of hotplug CPU and frequency</span>
<span class="cm">	 * change creates an intractable locking scenario; the order</span>
<span class="cm">	 * of when these callouts happen is undefined with respect to</span>
<span class="cm">	 * CPU hotplug, and they can race with each other.  As such,</span>
<span class="cm">	 * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is</span>
<span class="cm">	 * undefined; you can actually have a CPU frequency change take</span>
<span class="cm">	 * place in between the computation of X and the setting of the</span>
<span class="cm">	 * variable.  To protect against this problem, all updates of</span>
<span class="cm">	 * the per_cpu tsc_khz variable are done in an interrupt</span>
<span class="cm">	 * protected IPI, and all callers wishing to update the value</span>
<span class="cm">	 * must wait for a synchronous IPI to complete (which is trivial</span>
<span class="cm">	 * if the caller is on the CPU already).  This establishes the</span>
<span class="cm">	 * necessary total order on variable updates.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that because a guest time update may take place</span>
<span class="cm">	 * anytime after the setting of the VCPU&#39;s request bit, the</span>
<span class="cm">	 * correct TSC value must be set before the request.  However,</span>
<span class="cm">	 * to ensure the update actually makes it to any guest which</span>
<span class="cm">	 * starts running in hardware virtualization between the set</span>
<span class="cm">	 * and the acquisition of the spinlock, we must also ping the</span>
<span class="cm">	 * CPU after setting the request bit.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_PRECHANGE</span> <span class="o">&amp;&amp;</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">old</span> <span class="o">&gt;</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_POSTCHANGE</span> <span class="o">&amp;&amp;</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">old</span> <span class="o">&lt;</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">freq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tsc_khz_changed</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">,</span> <span class="n">vm_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_CLOCK_UPDATE</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span>
				<span class="n">send_ipi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freq</span><span class="o">-&gt;</span><span class="n">old</span> <span class="o">&lt;</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">new</span> <span class="o">&amp;&amp;</span> <span class="n">send_ipi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We upscale the frequency.  Must make the guest</span>
<span class="cm">		 * doesn&#39;t see old kvmclock values while running with</span>
<span class="cm">		 * the new frequency, otherwise we risk the guest sees</span>
<span class="cm">		 * time go backwards.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In case we update the frequency for another cpu</span>
<span class="cm">		 * (which might be in guest context) send an interrupt</span>
<span class="cm">		 * to kick the cpu out of guest context.  Next time</span>
<span class="cm">		 * guest context is entered kvmclock will be updated,</span>
<span class="cm">		 * so the guest will not see stale values.</span>
<span class="cm">		 */</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">freq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tsc_khz_changed</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">kvmclock_cpufreq_notifier_block</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>  <span class="o">=</span> <span class="n">kvmclock_cpufreq_notifier</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvmclock_cpu_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
		<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
			<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tsc_khz_changed</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
			<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tsc_bad</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">kvmclock_cpu_notifier_block</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>  <span class="o">=</span> <span class="n">kvmclock_cpu_notifier</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">-</span><span class="n">INT_MAX</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_timer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">max_tsc_khz</span> <span class="o">=</span> <span class="n">tsc_khz</span><span class="p">;</span>
	<span class="n">register_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvmclock_cpu_notifier_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CONSTANT_TSC</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_CPU_FREQ</span>
		<span class="k">struct</span> <span class="n">cpufreq_policy</span> <span class="n">policy</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">policy</span><span class="p">));</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
		<span class="n">cpufreq_get_policy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">policy</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">policy</span><span class="p">.</span><span class="n">cpuinfo</span><span class="p">.</span><span class="n">max_freq</span><span class="p">)</span>
			<span class="n">max_tsc_khz</span> <span class="o">=</span> <span class="n">policy</span><span class="p">.</span><span class="n">cpuinfo</span><span class="p">.</span><span class="n">max_freq</span><span class="p">;</span>
		<span class="n">put_cpu</span><span class="p">();</span>
<span class="cp">#endif</span>
		<span class="n">cpufreq_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvmclock_cpufreq_notifier_block</span><span class="p">,</span>
					  <span class="n">CPUFREQ_TRANSITION_NOTIFIER</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kvm: max_tsc_khz = %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max_tsc_khz</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tsc_khz_changed</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="p">,</span> <span class="n">current_vcpu</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_is_in_guest</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">current_vcpu</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_is_user_mode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">user_mode</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">current_vcpu</span><span class="p">))</span>
		<span class="n">user_mode</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">current_vcpu</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">user_mode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kvm_get_guest_ip</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">current_vcpu</span><span class="p">))</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">current_vcpu</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_guest_info_callbacks</span> <span class="n">kvm_guest_cbs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">is_in_guest</span>		<span class="o">=</span> <span class="n">kvm_is_in_guest</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_user_mode</span>		<span class="o">=</span> <span class="n">kvm_is_user_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_guest_ip</span>		<span class="o">=</span> <span class="n">kvm_get_guest_ip</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">kvm_before_handle_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">current_vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_before_handle_nmi</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_after_handle_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">current_vcpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_after_handle_nmi</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_set_mmio_spte_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxphyaddr</span> <span class="o">=</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_phys_bits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the reserved bits and the present bit of an paging-structure</span>
<span class="cm">	 * entry to generate page fault with PFER.RSV = 1.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">62</span> <span class="o">-</span> <span class="n">maxphyaddr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">maxphyaddr</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">|=</span> <span class="mi">1ull</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="cm">/*</span>
<span class="cm">	 * If reserved bit is not supported, clear the present bit to disable</span>
<span class="cm">	 * mmio page fault.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxphyaddr</span> <span class="o">==</span> <span class="mi">52</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1ull</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">kvm_mmu_set_mmio_spte_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_x86_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_x86_ops</span> <span class="o">*</span><span class="p">)</span><span class="n">opaque</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: already loaded the other module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">cpu_has_kvm_support</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: no hardware support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disabled_by_bios</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: disabled by bios</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_mmu_module_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">kvm_set_mmio_spte_mask</span><span class="p">();</span>
	<span class="n">kvm_init_msr_list</span><span class="p">();</span>

	<span class="n">kvm_x86_ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">kvm_mmu_set_mask_ptes</span><span class="p">(</span><span class="n">PT_USER_MASK</span><span class="p">,</span> <span class="n">PT_ACCESSED_MASK</span><span class="p">,</span>
			<span class="n">PT_DIRTY_MASK</span><span class="p">,</span> <span class="n">PT64_NX_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">kvm_timer_init</span><span class="p">();</span>

	<span class="n">perf_register_guest_info_callbacks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_guest_cbs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_xsave</span><span class="p">)</span>
		<span class="n">host_xcr0</span> <span class="o">=</span> <span class="n">xgetbv</span><span class="p">(</span><span class="n">XCR_XFEATURE_ENABLED_MASK</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_unregister_guest_info_callbacks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_guest_cbs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CONSTANT_TSC</span><span class="p">))</span>
		<span class="n">cpufreq_unregister_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvmclock_cpufreq_notifier_block</span><span class="p">,</span>
					    <span class="n">CPUFREQ_TRANSITION_NOTIFIER</span><span class="p">);</span>
	<span class="n">unregister_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvmclock_cpu_notifier_block</span><span class="p">);</span>
	<span class="n">kvm_x86_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kvm_mmu_module_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_emulate_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">halt_exits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_HALTED</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_HLT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_emulate_halt</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_hv_hypercall</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">param</span><span class="p">,</span> <span class="n">ingpa</span><span class="p">,</span> <span class="n">outgpa</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">code</span><span class="p">,</span> <span class="n">rep_idx</span><span class="p">,</span> <span class="n">rep_cnt</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">HV_STATUS_SUCCESS</span><span class="p">,</span> <span class="n">rep_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fast</span><span class="p">,</span> <span class="n">longmode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cs_db</span><span class="p">,</span> <span class="n">cs_l</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * hypercall generates UD from non zero cpl and real mode</span>
<span class="cm">	 * per HYPER-V spec</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_protmode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">UD_VECTOR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cs_db_l_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs_db</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs_l</span><span class="p">);</span>
	<span class="n">longmode</span> <span class="o">=</span> <span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cs_l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">longmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">param</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDX</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">ingpa</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RBX</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RCX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">outgpa</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDI</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">param</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RCX</span><span class="p">);</span>
		<span class="n">ingpa</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDX</span><span class="p">);</span>
		<span class="n">outgpa</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R8</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">code</span> <span class="o">=</span> <span class="n">param</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">fast</span> <span class="o">=</span> <span class="p">(</span><span class="n">param</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">rep_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">param</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>
	<span class="n">rep_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">param</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>

	<span class="n">trace_kvm_hv_hypercall</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">fast</span><span class="p">,</span> <span class="n">rep_cnt</span><span class="p">,</span> <span class="n">rep_idx</span><span class="p">,</span> <span class="n">ingpa</span><span class="p">,</span> <span class="n">outgpa</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HV_X64_HV_NOTIFY_LONG_SPIN_WAIT</span>:
		<span class="n">kvm_vcpu_on_spin</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">HV_STATUS_INVALID_HYPERCALL_CODE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">res</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">rep_done</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">longmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDX</span><span class="p">,</span> <span class="n">ret</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">,</span> <span class="n">ret</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_emulate_hypercall</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_hv_hypercall_enabled</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">kvm_hv_hypercall</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">);</span>
	<span class="n">a0</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RBX</span><span class="p">);</span>
	<span class="n">a1</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RCX</span><span class="p">);</span>
	<span class="n">a2</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDX</span><span class="p">);</span>
	<span class="n">a3</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSI</span><span class="p">);</span>

	<span class="n">trace_kvm_hypercall</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">&amp;=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="n">a0</span> <span class="o">&amp;=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="n">a1</span> <span class="o">&amp;=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="n">a2</span> <span class="o">&amp;=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="n">a3</span> <span class="o">&amp;=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">KVM_EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_HC_VAPIC_POLL_IRQ</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">KVM_ENOSYS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">hypercalls</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_emulate_hypercall</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">emulator_fix_hypercall</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">emul_to_vcpu</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">instruction</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rip</span> <span class="o">=</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Blow out the MMU to ensure that no other VCPU has an active mapping</span>
<span class="cm">	 * to ensure that the updated hypercall appears atomically across all</span>
<span class="cm">	 * VCPUs.</span>
<span class="cm">	 */</span>
	<span class="n">kvm_mmu_zap_all</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">patch_hypercall</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">instruction</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">emulator_write_emulated</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">rip</span><span class="p">,</span> <span class="n">instruction</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if userspace requested an interrupt window, and that the</span>
<span class="cm"> * interrupt window is open.</span>
<span class="cm"> *</span>
<span class="cm"> * No need to exit to userspace if we already have an interrupt queued.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dm_request_for_irq_injection</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kvm_cpu_has_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">request_interrupt_window</span> <span class="o">&amp;&amp;</span>
		<span class="n">kvm_arch_interrupt_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">post_kvm_run_save</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">;</span>

	<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">if_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">cr8</span> <span class="o">=</span> <span class="n">kvm_get_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">apic_base</span> <span class="o">=</span> <span class="n">kvm_get_apic_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">ready_for_interrupt_injection</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">ready_for_interrupt_injection</span> <span class="o">=</span>
			<span class="n">kvm_arch_interrupt_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">kvm_cpu_has_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">kvm_event_needs_reinjection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vapic_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_lapic</span> <span class="o">*</span><span class="n">apic</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apic</span> <span class="o">||</span> <span class="o">!</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">vapic_addr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">gfn_to_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">vapic_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">vapic_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vapic_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_lapic</span> <span class="o">*</span><span class="n">apic</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apic</span> <span class="o">||</span> <span class="o">!</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">vapic_addr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">kvm_release_page_dirty</span><span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">vapic_page</span><span class="p">);</span>
	<span class="n">mark_page_dirty</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">vapic_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cr8_intercept</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_irr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">update_cr8_intercept</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">vapic_addr</span><span class="p">)</span>
		<span class="n">max_irr</span> <span class="o">=</span> <span class="n">kvm_lapic_find_highest_irr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">max_irr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_irr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">max_irr</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">tpr</span> <span class="o">=</span> <span class="n">kvm_lapic_get_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">update_cr8_intercept</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">max_irr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inject_pending_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* try to reinject previous events if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_kvm_inj_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span><span class="p">,</span>
					<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">has_error_code</span><span class="p">,</span>
					<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code</span><span class="p">);</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">nr</span><span class="p">,</span>
					  <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">has_error_code</span><span class="p">,</span>
					  <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">error_code</span><span class="p">,</span>
					  <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">reinject</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_injected</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_nmi</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_irq</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* try to inject new event if pending */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">nmi_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_injected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_nmi</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kvm_cpu_has_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">interrupt_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kvm_queue_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_cpu_get_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span>
					    <span class="nb">false</span><span class="p">);</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_irq</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_load_guest_xcr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_read_cr4_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR4_OSXSAVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_xcr0_loaded</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* kvm_set_xcr() also depends on this */</span>
		<span class="n">xsetbv</span><span class="p">(</span><span class="n">XCR_XFEATURE_ENABLED_MASK</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xcr0</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_xcr0_loaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_put_guest_xcr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_xcr0_loaded</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xcr0</span> <span class="o">!=</span> <span class="n">host_xcr0</span><span class="p">)</span>
			<span class="n">xsetbv</span><span class="p">(</span><span class="n">XCR_XFEATURE_ENABLED_MASK</span><span class="p">,</span> <span class="n">host_xcr0</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_xcr0_loaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * x86 is limited to one NMI running, and one NMI pending after it.</span>
<span class="cm">	 * If an NMI is already in progress, limit further NMIs to just one.</span>
<span class="cm">	 * Otherwise, allow two (and we&#39;ll inject the first one immediately).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_nmi_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">||</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_injected</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span> <span class="o">+=</span> <span class="n">atomic_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_queued</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vcpu_enter_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">req_int_win</span> <span class="o">=</span> <span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">request_interrupt_window</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">req_immediate_exit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_MMU_RELOAD</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvm_mmu_unload</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_MIGRATE_TIMER</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span>
			<span class="n">__kvm_migrate_timers</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_CLOCK_UPDATE</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_guest_time_update</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_MMU_SYNC</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvm_mmu_sync_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_TLB_FLUSH</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">tlb_flush</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_REPORT_TPR_ACCESS</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_TPR_ACCESS</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_TRIPLE_FAULT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_SHUTDOWN</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_DEACTIVATE_FPU</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">fpu_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">fpu_deactivate</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_APF_HALT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Page is swapped out. Do synthetic halt */</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">halted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_STEAL_UPDATE</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span>
			<span class="n">record_steal_time</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_NMI</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span>
			<span class="n">process_nmi</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">req_immediate_exit</span> <span class="o">=</span>
			<span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_IMMEDIATE_EXIT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_PMU</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvm_handle_pmu_event</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_PMI</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvm_deliver_pmi</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">)</span> <span class="o">||</span> <span class="n">req_int_win</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inject_pending_event</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

		<span class="cm">/* enable NMI/IRQ window open exits if needed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span><span class="p">)</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">enable_nmi_window</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kvm_cpu_has_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">||</span> <span class="n">req_int_win</span><span class="p">)</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">enable_irq_window</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_lapic_enabled</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">update_cr8_intercept</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">kvm_lapic_sync_to_vapic</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_mmu_reload</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">cancel_injection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">prepare_guest_switch</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">fpu_active</span><span class="p">)</span>
		<span class="n">kvm_load_guest_fpu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_load_guest_xcr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">IN_GUEST_MODE</span><span class="p">;</span>

	<span class="cm">/* We should set -&gt;mode before check -&gt;requests,</span>
<span class="cm">	 * see the comment in make_all_cpus_request.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">EXITING_GUEST_MODE</span> <span class="o">||</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span>
	    <span class="o">||</span> <span class="n">need_resched</span><span class="p">()</span> <span class="o">||</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">OUTSIDE_GUEST_MODE</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">cancel_injection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req_immediate_exit</span><span class="p">)</span>
		<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">kvm_guest_enter</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">switch_db_regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_debugreg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
		<span class="n">set_debugreg</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">eff_db</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">set_debugreg</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">eff_db</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">set_debugreg</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">eff_db</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">set_debugreg</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">eff_db</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trace_kvm_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">);</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the guest has used debug registers, at least dr7</span>
<span class="cm">	 * will be disabled while returning to the host.</span>
<span class="cm">	 * If we don&#39;t have active breakpoints in the host, we don&#39;t</span>
<span class="cm">	 * care about the messed up debug address registers. But if</span>
<span class="cm">	 * we have some of them active, restore the old state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_breakpoint_active</span><span class="p">())</span>
		<span class="n">hw_breakpoint_restore</span><span class="p">();</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_guest_tsc</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">read_l1_tsc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">OUTSIDE_GUEST_MODE</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">exits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must have an instruction between local_irq_enable() and</span>
<span class="cm">	 * kvm_guest_exit(), so the timer interrupt isn&#39;t delayed by</span>
<span class="cm">	 * the interrupt shadow.  The stat.exits increment will do nicely.</span>
<span class="cm">	 * But we need to prevent reordering, hence this barrier():</span>
<span class="cm">	 */</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="n">kvm_guest_exit</span><span class="p">();</span>

	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Profile KVM exit RIPs:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">prof_on</span> <span class="o">==</span> <span class="n">KVM_PROFILING</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rip</span> <span class="o">=</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">profile_hit</span><span class="p">(</span><span class="n">KVM_PROFILING</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_always_catchup</span><span class="p">))</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_CLOCK_UPDATE</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="n">kvm_lapic_sync_from_vapic</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">handle_exit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vcpu_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_SIPI_RECEIVED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;vcpu %d received sipi with vector # %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">sipi_vector</span><span class="p">);</span>
		<span class="n">kvm_lapic_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">vapic_enter</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_RUNNABLE</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">halted</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">vcpu_enter_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>
			<span class="n">kvm_vcpu_block</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kvm_check_request</span><span class="p">(</span><span class="n">KVM_REQ_UNHALT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="k">switch</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">KVM_MP_STATE_HALTED</span>:
					<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span>
						<span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">KVM_MP_STATE_RUNNABLE</span>:
					<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">halted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">KVM_MP_STATE_SIPI_RECEIVED</span>:
				<span class="nl">default:</span>
					<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">KVM_REQ_PENDING_TIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_cpu_has_pending_timer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvm_inject_pending_timer_irqs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dm_request_for_irq_injection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
			<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">request_irq_exits</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kvm_check_async_pf_completion</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
			<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">signal_exits</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>
			<span class="n">kvm_resched</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>

	<span class="n">vapic_exit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Implements the following, as a state machine:</span>
<span class="cm"> *</span>
<span class="cm"> * read:</span>
<span class="cm"> *   for each fragment</span>
<span class="cm"> *     write gpa, len</span>
<span class="cm"> *     exit</span>
<span class="cm"> *     copy data</span>
<span class="cm"> *   execute insn</span>
<span class="cm"> *</span>
<span class="cm"> * write:</span>
<span class="cm"> *   for each fragment</span>
<span class="cm"> *      write gpa, len</span>
<span class="cm"> *      copy data</span>
<span class="cm"> *      exit</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">complete_mmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">run</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmio_fragment</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio</span><span class="p">.</span><span class="n">count</span> <span class="o">||</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_needed</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Complete previous fragment */</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_fragments</span><span class="p">[</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_cur_fragment</span><span class="o">++</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_is_write</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_cur_fragment</span> <span class="o">==</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_nr_fragments</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_is_write</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_read_completed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Initiate next fragment */</span>
		<span class="o">++</span><span class="n">frag</span><span class="p">;</span>
		<span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_MMIO</span><span class="p">;</span>
		<span class="n">run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">gpa</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_is_write</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">is_write</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_is_write</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">EMULTYPE_NO_DECODE</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">srcu_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">EMULATE_DONE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">sigsaved</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk_used_math</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">init_fpu</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">sigset_active</span><span class="p">)</span>
		<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">sigset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_UNINITIALIZED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_vcpu_block</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">KVM_REQ_UNHALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* re-sync apic&#39;s tpr */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_set_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">cr8</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">complete_mmio</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">__vcpu_run</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">post_kvm_run_save</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">sigset_active</span><span class="p">)</span>
		<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_regs_need_sync_to_vcpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are here if userspace calls get_regs() in the middle of</span>
<span class="cm">		 * instruction emulation. Registers state needs to be copied</span>
<span class="cm">		 * back from emulation context to vcpu. Usrapace shouldn&#39;t do</span>
<span class="cm">		 * that usually, but some bad designed PV devices (vmware</span>
<span class="cm">		 * backdoor interface) need this to work</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_regs_need_sync_to_vcpu</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rax</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rbx</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RBX</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcx</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RCX</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rdx</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDX</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rsi</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSI</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rdi</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDI</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rsp</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSP</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RBP</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r8</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R8</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r9</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R9</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r10</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R10</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r11</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R11</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r12</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R12</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r13</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R13</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r14</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R14</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r15</span> <span class="o">=</span> <span class="n">kvm_register_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R15</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rip</span> <span class="o">=</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rflags</span> <span class="o">=</span> <span class="n">kvm_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_regs_need_sync_from_vcpu</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_regs_need_sync_to_vcpu</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RAX</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rax</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RBX</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rbx</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RCX</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcx</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDX</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rdx</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSI</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rsi</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RDI</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rdi</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RSP</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_RBP</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rbp</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R8</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r8</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R9</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r9</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R10</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r10</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R11</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r11</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R12</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r12</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R13</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r13</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R14</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r14</span><span class="p">);</span>
	<span class="n">kvm_register_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_REGS_R15</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r15</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">kvm_rip_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rip</span><span class="p">);</span>
	<span class="n">kvm_set_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">rflags</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_get_cs_db_l_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">db</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_segment</span> <span class="n">cs</span><span class="p">;</span>

	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>
	<span class="o">*</span><span class="n">db</span> <span class="o">=</span> <span class="n">cs</span><span class="p">.</span><span class="n">db</span><span class="p">;</span>
	<span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">cs</span><span class="p">.</span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_get_cs_db_l_bits</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_sregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="o">*</span><span class="n">sregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="n">dt</span><span class="p">;</span>

	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>
	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">ds</span><span class="p">,</span> <span class="n">VCPU_SREG_DS</span><span class="p">);</span>
	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">es</span><span class="p">,</span> <span class="n">VCPU_SREG_ES</span><span class="p">);</span>
	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="n">VCPU_SREG_FS</span><span class="p">);</span>
	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">gs</span><span class="p">,</span> <span class="n">VCPU_SREG_GS</span><span class="p">);</span>
	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">,</span> <span class="n">VCPU_SREG_SS</span><span class="p">);</span>

	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">tr</span><span class="p">,</span> <span class="n">VCPU_SREG_TR</span><span class="p">);</span>
	<span class="n">kvm_get_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">,</span> <span class="n">VCPU_SREG_LDTR</span><span class="p">);</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_idt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">idt</span><span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dt</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">idt</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">dt</span><span class="p">.</span><span class="n">address</span><span class="p">;</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_gdt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">gdt</span><span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dt</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">gdt</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">dt</span><span class="p">.</span><span class="n">address</span><span class="p">;</span>

	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr0</span> <span class="o">=</span> <span class="n">kvm_read_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr2</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr2</span><span class="p">;</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr3</span> <span class="o">=</span> <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr4</span> <span class="o">=</span> <span class="n">kvm_read_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr8</span> <span class="o">=</span> <span class="n">kvm_get_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">efer</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span><span class="p">;</span>
	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">apic_base</span> <span class="o">=</span> <span class="n">kvm_get_apic_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">interrupt_bitmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">interrupt_bitmap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">pending</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">soft</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">nr</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">interrupt_bitmap</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_mpstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_mp_state</span> <span class="o">*</span><span class="n">mp_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mp_state</span><span class="o">-&gt;</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_mpstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_mp_state</span> <span class="o">*</span><span class="n">mp_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">mp_state</span><span class="o">-&gt;</span><span class="n">mp_state</span><span class="p">;</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_task_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tss_selector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idt_index</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">bool</span> <span class="n">has_error_code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">init_emulate_ctxt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">emulator_task_switch</span><span class="p">(</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">tss_selector</span><span class="p">,</span> <span class="n">idt_index</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span>
				   <span class="n">has_error_code</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EMULATE_FAIL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">kvm_rip_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eip</span><span class="p">);</span>
	<span class="n">kvm_set_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ctxt</span><span class="o">-&gt;</span><span class="n">eflags</span><span class="p">);</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EMULATE_DONE</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_task_switch</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_sregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="o">*</span><span class="n">sregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mmu_reset_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pending_vec</span><span class="p">,</span> <span class="n">max_bits</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="n">dt</span><span class="p">;</span>

	<span class="n">dt</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">idt</span><span class="p">.</span><span class="n">limit</span><span class="p">;</span>
	<span class="n">dt</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">idt</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_idt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span>
	<span class="n">dt</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">gdt</span><span class="p">.</span><span class="n">limit</span><span class="p">;</span>
	<span class="n">dt</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">gdt</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_gdt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr2</span> <span class="o">=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr2</span><span class="p">;</span>
	<span class="n">mmu_reset_needed</span> <span class="o">|=</span> <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr3</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr3</span> <span class="o">=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr3</span><span class="p">;</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">VCPU_EXREG_CR3</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">regs_avail</span><span class="p">);</span>

	<span class="n">kvm_set_cr8</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr8</span><span class="p">);</span>

	<span class="n">mmu_reset_needed</span> <span class="o">|=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">!=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">efer</span><span class="p">;</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_efer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">efer</span><span class="p">);</span>
	<span class="n">kvm_set_apic_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">apic_base</span><span class="p">);</span>

	<span class="n">mmu_reset_needed</span> <span class="o">|=</span> <span class="n">kvm_read_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr0</span><span class="p">;</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_cr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr0</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr0</span><span class="p">;</span>

	<span class="n">mmu_reset_needed</span> <span class="o">|=</span> <span class="n">kvm_read_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr4</span><span class="p">;</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_cr4</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cr4</span> <span class="o">&amp;</span> <span class="n">X86_CR4_OSXSAVE</span><span class="p">)</span>
		<span class="n">kvm_update_cpuid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">load_pdptrs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="p">,</span> <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
		<span class="n">mmu_reset_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_reset_needed</span><span class="p">)</span>
		<span class="n">kvm_mmu_reset_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">max_bits</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">interrupt_bitmap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">pending_vec</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span>
		<span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">interrupt_bitmap</span><span class="p">,</span> <span class="n">max_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pending_vec</span> <span class="o">&lt;</span> <span class="n">max_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_queue_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">pending_vec</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Set back pending irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pending_vec</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kvm_set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>
	<span class="n">kvm_set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">ds</span><span class="p">,</span> <span class="n">VCPU_SREG_DS</span><span class="p">);</span>
	<span class="n">kvm_set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">es</span><span class="p">,</span> <span class="n">VCPU_SREG_ES</span><span class="p">);</span>
	<span class="n">kvm_set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="n">VCPU_SREG_FS</span><span class="p">);</span>
	<span class="n">kvm_set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">gs</span><span class="p">,</span> <span class="n">VCPU_SREG_GS</span><span class="p">);</span>
	<span class="n">kvm_set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">ss</span><span class="p">,</span> <span class="n">VCPU_SREG_SS</span><span class="p">);</span>

	<span class="n">kvm_set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">tr</span><span class="p">,</span> <span class="n">VCPU_SREG_TR</span><span class="p">);</span>
	<span class="n">kvm_set_segment</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">,</span> <span class="n">VCPU_SREG_LDTR</span><span class="p">);</span>

	<span class="n">update_cr8_intercept</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/* Older userspace won&#39;t unhalt the vcpu on reset. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vcpu_is_bsp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xfff0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">.</span><span class="n">selector</span> <span class="o">==</span> <span class="mh">0xf000</span> <span class="o">&amp;&amp;</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">.</span><span class="n">base</span> <span class="o">==</span> <span class="mh">0xffff0000</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">is_protmode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">;</span>

	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_guest_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kvm_guest_debug</span> <span class="o">*</span><span class="n">dbg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">KVM_GUESTDBG_INJECT_DB</span> <span class="o">|</span> <span class="n">KVM_GUESTDBG_INJECT_BP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exception</span><span class="p">.</span><span class="n">pending</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_INJECT_DB</span><span class="p">)</span>
			<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">DB_VECTOR</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">kvm_queue_exception</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">BP_VECTOR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read rflags as long as potentially injected trace flags are still</span>
<span class="cm">	 * filtered out.</span>
<span class="cm">	 */</span>
	<span class="n">rflags</span> <span class="o">=</span> <span class="n">kvm_get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">=</span> <span class="n">dbg</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_ENABLE</span><span class="p">))</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_USE_HW_BP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_DB_REGS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">eff_db</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dbg</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">debugreg</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">switch_db_regs</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">debugreg</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">DR7_BP_EN_MASK</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_DB_REGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">eff_db</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">switch_db_regs</span> <span class="o">=</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span> <span class="o">&amp;</span> <span class="n">DR7_BP_EN_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_SINGLESTEP</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">singlestep_rip</span> <span class="o">=</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">get_segment_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Trigger an rflags update that will inject or remove the trace</span>
<span class="cm">	 * flags.</span>
<span class="cm">	 */</span>
	<span class="n">kvm_set_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">rflags</span><span class="p">);</span>

	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_guest_debug</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">dbg</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Translate a guest virtual address to a guest physical address.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_translate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_translation</span> <span class="o">*</span><span class="n">tr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">linear_address</span><span class="p">;</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">gpa</span> <span class="o">=</span> <span class="n">kvm_mmu_gva_to_gpa_system</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">tr</span><span class="o">-&gt;</span><span class="n">physical_address</span> <span class="o">=</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="n">tr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">!=</span> <span class="n">UNMAPPED_GVA</span><span class="p">;</span>
	<span class="n">tr</span><span class="o">-&gt;</span><span class="n">writeable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tr</span><span class="o">-&gt;</span><span class="n">usermode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_fpu</span> <span class="o">*</span><span class="n">fpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i387_fxsave_struct</span> <span class="o">*</span><span class="n">fxsave</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fxsave</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">fpu</span><span class="o">-&gt;</span><span class="n">fpr</span><span class="p">,</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">st_space</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
	<span class="n">fpu</span><span class="o">-&gt;</span><span class="n">fcw</span> <span class="o">=</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">;</span>
	<span class="n">fpu</span><span class="o">-&gt;</span><span class="n">fsw</span> <span class="o">=</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">swd</span><span class="p">;</span>
	<span class="n">fpu</span><span class="o">-&gt;</span><span class="n">ftwx</span> <span class="o">=</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">twd</span><span class="p">;</span>
	<span class="n">fpu</span><span class="o">-&gt;</span><span class="n">last_opcode</span> <span class="o">=</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">fop</span><span class="p">;</span>
	<span class="n">fpu</span><span class="o">-&gt;</span><span class="n">last_ip</span> <span class="o">=</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">rip</span><span class="p">;</span>
	<span class="n">fpu</span><span class="o">-&gt;</span><span class="n">last_dp</span> <span class="o">=</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">rdp</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fpu</span><span class="o">-&gt;</span><span class="n">xmm</span><span class="p">,</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">xmm_space</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">xmm_space</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_fpu</span> <span class="o">*</span><span class="n">fpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i387_fxsave_struct</span> <span class="o">*</span><span class="n">fxsave</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fxsave</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">st_space</span><span class="p">,</span> <span class="n">fpu</span><span class="o">-&gt;</span><span class="n">fpr</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
	<span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">cwd</span> <span class="o">=</span> <span class="n">fpu</span><span class="o">-&gt;</span><span class="n">fcw</span><span class="p">;</span>
	<span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">swd</span> <span class="o">=</span> <span class="n">fpu</span><span class="o">-&gt;</span><span class="n">fsw</span><span class="p">;</span>
	<span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">twd</span> <span class="o">=</span> <span class="n">fpu</span><span class="o">-&gt;</span><span class="n">ftwx</span><span class="p">;</span>
	<span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">fop</span> <span class="o">=</span> <span class="n">fpu</span><span class="o">-&gt;</span><span class="n">last_opcode</span><span class="p">;</span>
	<span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">rip</span> <span class="o">=</span> <span class="n">fpu</span><span class="o">-&gt;</span><span class="n">last_ip</span><span class="p">;</span>
	<span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">rdp</span> <span class="o">=</span> <span class="n">fpu</span><span class="o">-&gt;</span><span class="n">last_dp</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">xmm_space</span><span class="p">,</span> <span class="n">fpu</span><span class="o">-&gt;</span><span class="n">xmm</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">fxsave</span><span class="o">-&gt;</span><span class="n">xmm_space</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fpu_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">fpu_finit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure guest xcr0 is valid for loading</span>
<span class="cm">	 */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xcr0</span> <span class="o">=</span> <span class="n">XSTATE_FP</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr0</span> <span class="o">|=</span> <span class="n">X86_CR0_ET</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fx_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fx_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fpu_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_load_guest_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_fpu_loaded</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore all possible states in the guest,</span>
<span class="cm">	 * and assume host would use all available bits.</span>
<span class="cm">	 * Guest xcr0 would be loaded later.</span>
<span class="cm">	 */</span>
	<span class="n">kvm_put_guest_xcr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_fpu_loaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">unlazy_fpu</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">fpu_restore_checking</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">);</span>
	<span class="n">trace_kvm_fpu</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_put_guest_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_put_guest_xcr0</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_fpu_loaded</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_fpu_loaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fpu_save_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest_fpu</span><span class="p">);</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">fpu_reload</span><span class="p">;</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_DEACTIVATE_FPU</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
	<span class="n">trace_kvm_fpu</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_vcpu_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvmclock_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wbinvd_dirty_mask</span><span class="p">);</span>
	<span class="n">fx_free</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">vcpu_free</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="nf">kvm_arch_vcpu_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_tsc_unstable</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;kvm: SMP vm created on host with unstable TSC; &quot;</span>
		<span class="s">&quot;guest TSC will not be reliable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">vcpu_create</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">.</span><span class="n">have_fixed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_mmu_setup</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_vcpu_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_mmu_unload</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">fx_free</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">vcpu_free</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_queued</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_injected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">switch_db_regs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">db</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">db</span><span class="p">));</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr6</span> <span class="o">=</span> <span class="n">DR6_FIXED_1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dr7</span> <span class="o">=</span> <span class="n">DR7_FIXED_1</span><span class="p">;</span>

	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kvmclock_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">kvm_clear_async_pf_completion_queue</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_async_pf_hash_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">halted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">kvm_pmu_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">vcpu_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_hardware_enable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">garbage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">local_tsc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">max_tsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">stable</span><span class="p">,</span> <span class="n">backwards_tsc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">kvm_shared_msr_cpu_online</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">hardware_enable</span><span class="p">(</span><span class="n">garbage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">local_tsc</span> <span class="o">=</span> <span class="n">native_read_tsc</span><span class="p">();</span>
	<span class="n">stable</span> <span class="o">=</span> <span class="o">!</span><span class="n">check_tsc_unstable</span><span class="p">();</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">,</span> <span class="n">vm_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stable</span> <span class="o">&amp;&amp;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">KVM_REQ_CLOCK_UPDATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stable</span> <span class="o">&amp;&amp;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_host_tsc</span> <span class="o">&gt;</span> <span class="n">local_tsc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">backwards_tsc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_host_tsc</span> <span class="o">&gt;</span> <span class="n">max_tsc</span><span class="p">)</span>
					<span class="n">max_tsc</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_host_tsc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sometimes, even reliable TSCs go backwards.  This happens on</span>
<span class="cm">	 * platforms that reset TSC during suspend or hibernate actions, but</span>
<span class="cm">	 * maintain synchronization.  We must compensate.  Fortunately, we can</span>
<span class="cm">	 * detect that condition here, which happens early in CPU bringup,</span>
<span class="cm">	 * before any KVM threads can be running.  Unfortunately, we can&#39;t</span>
<span class="cm">	 * bring the TSCs fully up to date with real time, as we aren&#39;t yet far</span>
<span class="cm">	 * enough into CPU bringup that we know how much real time has actually</span>
<span class="cm">	 * elapsed; our helper function, get_kernel_ns() will be using boot</span>
<span class="cm">	 * variables that haven&#39;t been updated yet.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So we simply find the maximum observed TSC above, then record the</span>
<span class="cm">	 * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,</span>
<span class="cm">	 * the adjustment will be applied.  Note that we accumulate</span>
<span class="cm">	 * adjustments, in case multiple suspend cycles happen before some VCPU</span>
<span class="cm">	 * gets a chance to run again.  In the event that no KVM threads get a</span>
<span class="cm">	 * chance to run, we will miss the entire elapsed period, as we&#39;ll have</span>
<span class="cm">	 * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may</span>
<span class="cm">	 * loose cycle time.  This isn&#39;t too big a deal, since the loss will be</span>
<span class="cm">	 * uniform across all VCPUs (not to mention the scenario is extremely</span>
<span class="cm">	 * unlikely). It is possible that a second hibernate recovery happens</span>
<span class="cm">	 * much faster than a first, causing the observed TSC here to be</span>
<span class="cm">	 * smaller; this would require additional padding adjustment, which is</span>
<span class="cm">	 * why we set last_host_tsc to the local tsc observed here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * N.B. - this code below runs only on platforms with reliable TSC,</span>
<span class="cm">	 * as that is the only way backwards_tsc is set above.  Also note</span>
<span class="cm">	 * that this runs for ALL vcpus, which is not a bug; all VCPUs should</span>
<span class="cm">	 * have the same delta_cyc adjustment applied if backwards_tsc</span>
<span class="cm">	 * is detected.  Note further, this adjustment is only done once,</span>
<span class="cm">	 * as we reset last_host_tsc on all VCPUs to stop this from being</span>
<span class="cm">	 * called multiple times (one for each physical CPU bringup).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Platforms with unnreliable TSCs don&#39;t have to deal with this, they</span>
<span class="cm">	 * will be compensated by the logic in vcpu_load, which sets the TSC to</span>
<span class="cm">	 * catchup mode.  This will catchup all VCPUs to real time, but cannot</span>
<span class="cm">	 * guarantee that they stay in perfect synchronization.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">backwards_tsc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">delta_cyc</span> <span class="o">=</span> <span class="n">max_tsc</span> <span class="o">-</span> <span class="n">local_tsc</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">,</span> <span class="n">vm_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_offset_adjustment</span> <span class="o">+=</span> <span class="n">delta_cyc</span><span class="p">;</span>
				<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_host_tsc</span> <span class="o">=</span> <span class="n">local_tsc</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * We have to disable TSC offset matching.. if you were</span>
<span class="cm">			 * booting a VM while issuing an S4 host suspend....</span>
<span class="cm">			 * you may have some problem.  Solving this issue is</span>
<span class="cm">			 * left as an exercise to the reader.</span>
<span class="cm">			 */</span>
			<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_tsc_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_tsc_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_hardware_disable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">garbage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">hardware_disable</span><span class="p">(</span><span class="n">garbage</span><span class="p">);</span>
	<span class="n">drop_user_return_notifiers</span><span class="p">(</span><span class="n">garbage</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_hardware_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">hardware_setup</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_hardware_unsetup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">hardware_unsetup</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_check_processor_compat</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rtn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">check_processor_compatibility</span><span class="p">(</span><span class="n">rtn</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">kvm_vcpu_compatible</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">emulate_ctxt</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">emulate_ops</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">)</span> <span class="o">||</span> <span class="n">kvm_vcpu_is_bsp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_UNINITIALIZED</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio_data</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">kvm_set_tsc_khz</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">max_tsc_khz</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_mmu_create</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_free_pio_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_create_lapic</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_mmu_destroy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mce_banks</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">KVM_MAX_MCE_BANKS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
				       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mce_banks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_free_lapic</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mcg_cap</span> <span class="o">=</span> <span class="n">KVM_MAX_MCE_BANKS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wbinvd_dirty_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_free_mce_banks</span><span class="p">;</span>

	<span class="n">kvm_async_pf_hash_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_pmu_init</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail_free_mce_banks:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mce_banks</span><span class="p">);</span>
<span class="nl">fail_free_lapic:</span>
	<span class="n">kvm_free_lapic</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="nl">fail_mmu_destroy:</span>
	<span class="n">kvm_mmu_destroy</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="nl">fail_free_pio_data:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio_data</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_vcpu_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">kvm_pmu_destroy</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mce_banks</span><span class="p">);</span>
	<span class="n">kvm_free_lapic</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
	<span class="n">kvm_mmu_destroy</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pio_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_init_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">assigned_dev_head</span><span class="p">);</span>

	<span class="cm">/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">KVM_USERSPACE_IRQ_SOURCE_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">irq_sources_bitmap</span><span class="p">);</span>

	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tsc_write_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_unload_vcpu_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_mmu_unload</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_free_vcpus</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unpin any mmu pages first.</span>
<span class="cm">	 */</span>
	<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_clear_async_pf_completion_queue</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">kvm_unload_vcpu_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span>
		<span class="n">kvm_arch_vcpu_free</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">vcpus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">online_vcpus</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_sync_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_free_all_assigned_devices</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">kvm_free_pit</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_destroy_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_iommu_unmap_guest</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpic</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vioapic</span><span class="p">);</span>
	<span class="n">kvm_free_vcpus</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">)</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic_access_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_pagetable</span><span class="p">)</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ept_identity_pagetable</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_free_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">free</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">dont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_PAGE_SIZES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dont</span> <span class="o">||</span> <span class="n">free</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dont</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_create_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_PAGE_SIZES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ugfn</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">lpages</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">lpages</span> <span class="o">=</span> <span class="n">gfn_to_index</span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">+</span> <span class="n">npages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">slot</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">vzalloc</span><span class="p">(</span><span class="n">lpages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">KVM_PAGES_PER_HPAGE</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">slot</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">write_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">+</span> <span class="n">npages</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">KVM_PAGES_PER_HPAGE</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">slot</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">lpages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">write_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ugfn</span> <span class="o">=</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">userspace_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the gfn and userspace address are not aligned wrt each</span>
<span class="cm">		 * other, or if explicitly asked to, disable large page</span>
<span class="cm">		 * support for this slot</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">^</span> <span class="n">ugfn</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">KVM_PAGES_PER_HPAGE</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">kvm_largepages_enabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">lpages</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
				<span class="n">slot</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">write_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_NR_PAGE_SIZES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">slot</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_prepare_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">old</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">user_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">npages</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">map_flags</span> <span class="o">=</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">;</span>

	<span class="cm">/* Prevent internal slot pages from being moved by fork()/COW. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">KVM_MEMORY_SLOTS</span><span class="p">)</span>
		<span class="n">map_flags</span> <span class="o">=</span> <span class="n">MAP_SHARED</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">;</span>

	<span class="cm">/*To keep backward compatibility with older userspace,</span>
<span class="cm">	 *x86 needs to hanlde !user_alloc case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">old</span><span class="p">.</span><span class="n">rmap</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">userspace_addr</span><span class="p">;</span>

			<span class="n">userspace_addr</span> <span class="o">=</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						 <span class="n">npages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
						 <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
						 <span class="n">map_flags</span><span class="p">,</span>
						 <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">userspace_addr</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">userspace_addr</span><span class="p">);</span>

			<span class="n">memslot</span><span class="o">-&gt;</span><span class="n">userspace_addr</span> <span class="o">=</span> <span class="n">userspace_addr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_commit_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">old</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">user_alloc</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">nr_mmu_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">npages</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">memory_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_alloc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">old</span><span class="p">.</span><span class="n">user_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">old</span><span class="p">.</span><span class="n">rmap</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">vm_munmap</span><span class="p">(</span><span class="n">old</span><span class="p">.</span><span class="n">userspace_addr</span><span class="p">,</span>
				<span class="n">old</span><span class="p">.</span><span class="n">npages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;kvm_vm_ioctl_set_memory_region: &quot;</span>
			       <span class="s">&quot;failed to munmap memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">n_requested_mmu_pages</span><span class="p">)</span>
		<span class="n">nr_mmu_pages</span> <span class="o">=</span> <span class="n">kvm_mmu_calculate_mmu_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_mmu_pages</span><span class="p">)</span>
		<span class="n">kvm_mmu_change_mmu_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">nr_mmu_pages</span><span class="p">);</span>
	<span class="n">kvm_mmu_slot_remove_write_access</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_flush_shadow</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_mmu_zap_all</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">kvm_reload_remote_mmus</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_runnable</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_RUNNABLE</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">halted</span><span class="p">)</span>
		<span class="o">||</span> <span class="o">!</span><span class="n">list_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">async_pf</span><span class="p">.</span><span class="n">done</span><span class="p">)</span>
		<span class="o">||</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_SIPI_RECEIVED</span>
		<span class="o">||</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nmi_queued</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">kvm_arch_interrupt_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">kvm_cpu_has_interrupt</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_should_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_vcpu_exiting_guest_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">IN_GUEST_MODE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_interrupt_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">interrupt_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">kvm_is_linear_rip</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">linear_rip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">current_rip</span> <span class="o">=</span> <span class="n">kvm_rip_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">get_segment_base</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">VCPU_SREG_CS</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">current_rip</span> <span class="o">==</span> <span class="n">linear_rip</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_is_linear_rip</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kvm_get_rflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rflags</span><span class="p">;</span>

	<span class="n">rflags</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_SINGLESTEP</span><span class="p">)</span>
		<span class="n">rflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_TF</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rflags</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_get_rflags</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_set_rflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">guest_debug</span> <span class="o">&amp;</span> <span class="n">KVM_GUESTDBG_SINGLESTEP</span> <span class="o">&amp;&amp;</span>
	    <span class="n">kvm_is_linear_rip</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">singlestep_rip</span><span class="p">))</span>
		<span class="n">rflags</span> <span class="o">|=</span> <span class="n">X86_EFLAGS_TF</span><span class="p">;</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_rflags</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">rflags</span><span class="p">);</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_EVENT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_set_rflags</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_arch_async_page_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_async_pf</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span> <span class="o">!=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">direct_map</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">is_error_page</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_mmu_reload</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span> <span class="o">&amp;&amp;</span>
	      <span class="n">work</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr3</span> <span class="o">!=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">get_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">gva</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">kvm_async_pf_hash_fn</span><span class="p">(</span><span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hash_32</span><span class="p">(</span><span class="n">gfn</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">order_base_2</span><span class="p">(</span><span class="n">ASYNC_PF_PER_VCPU</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">kvm_async_pf_next_probe</span><span class="p">(</span><span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">ASYNC_PF_PER_VCPU</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_add_async_pf_gfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">key</span> <span class="o">=</span> <span class="n">kvm_async_pf_hash_fn</span><span class="p">(</span><span class="n">gfn</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">kvm_async_pf_next_probe</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">kvm_async_pf_gfn_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span> <span class="o">=</span> <span class="n">kvm_async_pf_hash_fn</span><span class="p">(</span><span class="n">gfn</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">ASYNC_PF_PER_VCPU</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">gfn</span> <span class="o">&amp;&amp;</span>
		      <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">kvm_async_pf_next_probe</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">kvm_find_async_pf_gfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">kvm_async_pf_gfn_slot</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">)]</span> <span class="o">==</span> <span class="n">gfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_del_async_pf_gfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">kvm_async_pf_gfn_slot</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">kvm_async_pf_next_probe</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">kvm_async_pf_hash_fn</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="cm">/*</span>
<span class="cm">			 * k lies cyclically in ]i,j]</span>
<span class="cm">			 * |    i.k.j |</span>
<span class="cm">			 * |....j i.k.| or  |.k..j i...|</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">));</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">gfns</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apf_put_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">return</span> <span class="n">kvm_write_guest_cached</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_async_page_not_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">kvm_async_pf</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">x86_exception</span> <span class="n">fault</span><span class="p">;</span>

	<span class="n">trace_kvm_async_pf_not_present</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">token</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">gva</span><span class="p">);</span>
	<span class="n">kvm_add_async_pf_gfn</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">&amp;</span> <span class="n">KVM_ASYNC_PF_ENABLED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">send_user_only</span> <span class="o">&amp;&amp;</span>
	     <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_APF_HALT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apf_put_user</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">KVM_PV_REASON_PAGE_NOT_PRESENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">PF_VECTOR</span><span class="p">;</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">error_code_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">nested_page_fault</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">token</span><span class="p">;</span>
		<span class="n">kvm_inject_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fault</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_async_page_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kvm_async_pf</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">x86_exception</span> <span class="n">fault</span><span class="p">;</span>

	<span class="n">trace_kvm_async_pf_ready</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">token</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">gva</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_error_page</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span>
		<span class="n">work</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">token</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* broadcast wakeup */</span>
	<span class="k">else</span>
		<span class="n">kvm_del_async_pf_gfn</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">&amp;</span> <span class="n">KVM_ASYNC_PF_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">apf_put_user</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">KVM_PV_REASON_PAGE_READY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">PF_VECTOR</span><span class="p">;</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">error_code_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">nested_page_fault</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">fault</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">token</span><span class="p">;</span>
		<span class="n">kvm_inject_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fault</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">halted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">kvm_arch_can_inject_async_page_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">msr_val</span> <span class="o">&amp;</span> <span class="n">KVM_ASYNC_PF_ENABLED</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">kvm_event_needs_reinjection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">interrupt_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_exit</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_inj_virq</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_page_fault</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_msr</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_cr</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_nested_vmrun</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_nested_vmexit</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_nested_vmexit_inject</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_nested_intr_vmexit</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_invlpga</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_skinit</span><span class="p">);</span>
<span class="n">EXPORT_TRACEPOINT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_nested_intercepts</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
