<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › platform › uv › tlb_uv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tlb_uv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	SGI UltraViolet TLB flush routines.</span>
<span class="cm"> *</span>
<span class="cm"> *	(c) 2008-2011 Cliff Wickman &lt;cpw@sgi.com&gt;, SGI.</span>
<span class="cm"> *</span>
<span class="cm"> *	This code is released under the GNU General Public License version 2 or</span>
<span class="cm"> *	later.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>

<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/uv/uv.h&gt;</span>
<span class="cp">#include &lt;asm/uv/uv_mmrs.h&gt;</span>
<span class="cp">#include &lt;asm/uv/uv_hub.h&gt;</span>
<span class="cp">#include &lt;asm/uv/uv_bau.h&gt;</span>
<span class="cp">#include &lt;asm/apic.h&gt;</span>
<span class="cp">#include &lt;asm/idle.h&gt;</span>
<span class="cp">#include &lt;asm/tsc.h&gt;</span>
<span class="cp">#include &lt;asm/irq_vectors.h&gt;</span>
<span class="cp">#include &lt;asm/timer.h&gt;</span>

<span class="cm">/* timeouts in nanoseconds (indexed by UVH_AGING_PRESCALE_SEL urgency7 30:28) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">timeout_base_ns</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mi">20</span><span class="p">,</span>
		<span class="mi">160</span><span class="p">,</span>
		<span class="mi">1280</span><span class="p">,</span>
		<span class="mi">10240</span><span class="p">,</span>
		<span class="mi">81920</span><span class="p">,</span>
		<span class="mi">655360</span><span class="p">,</span>
		<span class="mi">5242880</span><span class="p">,</span>
		<span class="mi">167772160</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">timeout_us</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nobau</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">baudisabled</span><span class="p">;</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">disable_lock</span><span class="p">;</span>
<span class="k">static</span> <span class="n">cycles_t</span> <span class="n">congested_cycles</span><span class="p">;</span>

<span class="cm">/* tunables: */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_concurr</span>		<span class="o">=</span> <span class="n">MAX_BAU_CONCURRENT</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_concurr_const</span>	<span class="o">=</span> <span class="n">MAX_BAU_CONCURRENT</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">plugged_delay</span>	<span class="o">=</span> <span class="n">PLUGGED_DELAY</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">plugsb4reset</span>		<span class="o">=</span> <span class="n">PLUGSB4RESET</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">timeoutsb4reset</span>	<span class="o">=</span> <span class="n">TIMEOUTSB4RESET</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ipi_reset_limit</span>	<span class="o">=</span> <span class="n">IPI_RESET_LIMIT</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">complete_threshold</span>	<span class="o">=</span> <span class="n">COMPLETE_THRESHOLD</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">congested_respns_us</span>	<span class="o">=</span> <span class="n">CONGESTED_RESPONSE_US</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">congested_reps</span>	<span class="o">=</span> <span class="n">CONGESTED_REPS</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">congested_period</span>	<span class="o">=</span> <span class="n">CONGESTED_PERIOD</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tunables</span> <span class="n">tunables</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="o">&amp;</span><span class="n">max_concurr</span><span class="p">,</span> <span class="n">MAX_BAU_CONCURRENT</span><span class="p">},</span> <span class="cm">/* must be [0] */</span>
	<span class="p">{</span><span class="o">&amp;</span><span class="n">plugged_delay</span><span class="p">,</span> <span class="n">PLUGGED_DELAY</span><span class="p">},</span>
	<span class="p">{</span><span class="o">&amp;</span><span class="n">plugsb4reset</span><span class="p">,</span> <span class="n">PLUGSB4RESET</span><span class="p">},</span>
	<span class="p">{</span><span class="o">&amp;</span><span class="n">timeoutsb4reset</span><span class="p">,</span> <span class="n">TIMEOUTSB4RESET</span><span class="p">},</span>
	<span class="p">{</span><span class="o">&amp;</span><span class="n">ipi_reset_limit</span><span class="p">,</span> <span class="n">IPI_RESET_LIMIT</span><span class="p">},</span>
	<span class="p">{</span><span class="o">&amp;</span><span class="n">complete_threshold</span><span class="p">,</span> <span class="n">COMPLETE_THRESHOLD</span><span class="p">},</span>
	<span class="p">{</span><span class="o">&amp;</span><span class="n">congested_respns_us</span><span class="p">,</span> <span class="n">CONGESTED_RESPONSE_US</span><span class="p">},</span>
	<span class="p">{</span><span class="o">&amp;</span><span class="n">congested_reps</span><span class="p">,</span> <span class="n">CONGESTED_REPS</span><span class="p">},</span>
	<span class="p">{</span><span class="o">&amp;</span><span class="n">congested_period</span><span class="p">,</span> <span class="n">CONGESTED_PERIOD</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">tunables_dir</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">tunables_file</span><span class="p">;</span>

<span class="cm">/* these correspond to the statistics printed by ptc_seq_show() */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stat_description</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;sent:     number of shootdown messages sent&quot;</span><span class="p">,</span>
	<span class="s">&quot;stime:    time spent sending messages&quot;</span><span class="p">,</span>
	<span class="s">&quot;numuvhubs: number of hubs targeted with shootdown&quot;</span><span class="p">,</span>
	<span class="s">&quot;numuvhubs16: number times 16 or more hubs targeted&quot;</span><span class="p">,</span>
	<span class="s">&quot;numuvhubs8: number times 8 or more hubs targeted&quot;</span><span class="p">,</span>
	<span class="s">&quot;numuvhubs4: number times 4 or more hubs targeted&quot;</span><span class="p">,</span>
	<span class="s">&quot;numuvhubs2: number times 2 or more hubs targeted&quot;</span><span class="p">,</span>
	<span class="s">&quot;numuvhubs1: number times 1 hub targeted&quot;</span><span class="p">,</span>
	<span class="s">&quot;numcpus:  number of cpus targeted with shootdown&quot;</span><span class="p">,</span>
	<span class="s">&quot;dto:      number of destination timeouts&quot;</span><span class="p">,</span>
	<span class="s">&quot;retries:  destination timeout retries sent&quot;</span><span class="p">,</span>
	<span class="s">&quot;rok:   :  destination timeouts successfully retried&quot;</span><span class="p">,</span>
	<span class="s">&quot;resetp:   ipi-style resource resets for plugs&quot;</span><span class="p">,</span>
	<span class="s">&quot;resett:   ipi-style resource resets for timeouts&quot;</span><span class="p">,</span>
	<span class="s">&quot;giveup:   fall-backs to ipi-style shootdowns&quot;</span><span class="p">,</span>
	<span class="s">&quot;sto:      number of source timeouts&quot;</span><span class="p">,</span>
	<span class="s">&quot;bz:       number of stay-busy&#39;s&quot;</span><span class="p">,</span>
	<span class="s">&quot;throt:    number times spun in throttle&quot;</span><span class="p">,</span>
	<span class="s">&quot;swack:   image of UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE&quot;</span><span class="p">,</span>
	<span class="s">&quot;recv:     shootdown messages received&quot;</span><span class="p">,</span>
	<span class="s">&quot;rtime:    time spent processing messages&quot;</span><span class="p">,</span>
	<span class="s">&quot;all:      shootdown all-tlb messages&quot;</span><span class="p">,</span>
	<span class="s">&quot;one:      shootdown one-tlb messages&quot;</span><span class="p">,</span>
	<span class="s">&quot;mult:     interrupts that found multiple messages&quot;</span><span class="p">,</span>
	<span class="s">&quot;none:     interrupts that found no messages&quot;</span><span class="p">,</span>
	<span class="s">&quot;retry:    number of retry messages processed&quot;</span><span class="p">,</span>
	<span class="s">&quot;canc:     number messages canceled by retries&quot;</span><span class="p">,</span>
	<span class="s">&quot;nocan:    number retries that found nothing to cancel&quot;</span><span class="p">,</span>
	<span class="s">&quot;reset:    number of ipi-style reset requests processed&quot;</span><span class="p">,</span>
	<span class="s">&quot;rcan:     number messages canceled by reset requests&quot;</span><span class="p">,</span>
	<span class="s">&quot;disable:  number times use of the BAU was disabled&quot;</span><span class="p">,</span>
	<span class="s">&quot;enable:   number times use of the BAU was re-enabled&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">setup_nobau</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nobau</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;nobau&quot;</span><span class="p">,</span> <span class="n">setup_nobau</span><span class="p">);</span>

<span class="cm">/* base pnode in this partition */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">uv_base_pnode</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptc_stats</span><span class="p">,</span> <span class="n">ptcstats</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span><span class="p">,</span> <span class="n">bau_control</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">uv_flush_tlb_mask</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Determine the first node on a uvhub. &#39;Nodes&#39; are used for kernel</span>
<span class="cm"> * memory allocation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">uvhub_to_first_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">uvhub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">uv_node_to_blade_id</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uvhub</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine the apicid of the first cpu on a uvhub.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">uvhub_to_first_apicid</span><span class="p">(</span><span class="kt">int</span> <span class="n">uvhub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uvhub</span> <span class="o">==</span> <span class="n">uv_cpu_to_blade_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free a software acknowledge hardware resource by clearing its Pending</span>
<span class="cm"> * bit. This will return a reply to the sender.</span>
<span class="cm"> * If the message has timed out, a reply has already been sent by the</span>
<span class="cm"> * hardware but the resource has not been released. In that case our</span>
<span class="cm"> * clear of the Timeout bit (as well) will free the resource. No reply will</span>
<span class="cm"> * be sent (the hardware will only do one reply per message).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reply_to_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_desc</span> <span class="o">*</span><span class="n">mdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">do_acknowledge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">canceled</span> <span class="o">&amp;&amp;</span> <span class="n">do_acknowledge</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dw</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">swack_vec</span> <span class="o">&lt;&lt;</span> <span class="n">UV_SW_ACK_NPENDING</span><span class="p">)</span> <span class="o">|</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">swack_vec</span><span class="p">;</span>
		<span class="n">write_mmr_sw_ack</span><span class="p">(</span><span class="n">dw</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">replied_to</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">swack_vec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process the receipt of a RETRY message</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bau_process_retry_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_desc</span> <span class="o">*</span><span class="n">mdp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cancel_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msg_res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">msg2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span><span class="p">;</span>

	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_retries</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * cancel any message from msg+1 to the retry itself</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">msg2</span> <span class="o">=</span> <span class="n">msg</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DEST_Q_SIZE</span><span class="p">;</span> <span class="n">msg2</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg2</span> <span class="o">&gt;</span> <span class="n">mdp</span><span class="o">-&gt;</span><span class="n">queue_last</span><span class="p">)</span>
			<span class="n">msg2</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">-&gt;</span><span class="n">queue_first</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg2</span> <span class="o">==</span> <span class="n">msg</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* same conditions for cancellation as do_reset */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">msg2</span><span class="o">-&gt;</span><span class="n">replied_to</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msg2</span><span class="o">-&gt;</span><span class="n">canceled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">msg2</span><span class="o">-&gt;</span><span class="n">swack_vec</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">msg2</span><span class="o">-&gt;</span><span class="n">swack_vec</span> <span class="o">&amp;</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">swack_vec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">msg2</span><span class="o">-&gt;</span><span class="n">sending_cpu</span> <span class="o">==</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">sending_cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">msg2</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">!=</span> <span class="n">MSG_NOOP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mmr</span> <span class="o">=</span> <span class="n">read_mmr_sw_ack</span><span class="p">();</span>
			<span class="n">msg_res</span> <span class="o">=</span> <span class="n">msg2</span><span class="o">-&gt;</span><span class="n">swack_vec</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is a message retry; clear the resources held</span>
<span class="cm">			 * by the previous message only if they timed out.</span>
<span class="cm">			 * If it has not timed out we have an unexpected</span>
<span class="cm">			 * situation to report.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mmr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">msg_res</span> <span class="o">&lt;&lt;</span> <span class="n">UV_SW_ACK_NPENDING</span><span class="p">))</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mr</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * Is the resource timed out?</span>
<span class="cm">				 * Make everyone ignore the cancelled message.</span>
<span class="cm">				 */</span>
				<span class="n">msg2</span><span class="o">-&gt;</span><span class="n">canceled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_canceled</span><span class="o">++</span><span class="p">;</span>
				<span class="n">cancel_count</span><span class="o">++</span><span class="p">;</span>
				<span class="n">mr</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg_res</span> <span class="o">&lt;&lt;</span> <span class="n">UV_SW_ACK_NPENDING</span><span class="p">)</span> <span class="o">|</span> <span class="n">msg_res</span><span class="p">;</span>
				<span class="n">write_mmr_sw_ack</span><span class="p">(</span><span class="n">mr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cancel_count</span><span class="p">)</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_nocanceled</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do all the things a cpu should do for a TLB shootdown message.</span>
<span class="cm"> * Other cpu&#39;s may come here at the same time for this message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bau_process_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_desc</span> <span class="o">*</span><span class="n">mdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">do_acknowledge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">socket_ack_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">short</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atomic_short</span> <span class="o">*</span><span class="n">asp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">smaster</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">socket_master</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This must be a normal message, or retry of a normal message</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">==</span> <span class="n">TLB_FLUSH_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_flush_tlb</span><span class="p">();</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_alltlb</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__flush_tlb_one</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_onetlb</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_requestee</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * One cpu on each uvhub has the additional job on a RETRY</span>
<span class="cm">	 * of releasing the resource held by the message that is</span>
<span class="cm">	 * being retried.  That message is identified by sending</span>
<span class="cm">	 * cpu number.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">==</span> <span class="n">MSG_RETRY</span> <span class="o">&amp;&amp;</span> <span class="n">bcp</span> <span class="o">==</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_master</span><span class="p">)</span>
		<span class="n">bau_process_retry_msg</span><span class="p">(</span><span class="n">mdp</span><span class="p">,</span> <span class="n">bcp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a swack message, so we have to reply to it.</span>
<span class="cm">	 * Count each responding cpu on the socket. This avoids</span>
<span class="cm">	 * pinging the count&#39;s cache line back and forth between</span>
<span class="cm">	 * the sockets.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smaster</span><span class="o">-&gt;</span><span class="n">socket_acknowledge_count</span><span class="p">[</span><span class="n">mdp</span><span class="o">-&gt;</span><span class="n">msg_slot</span><span class="p">];</span>
	<span class="n">asp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atomic_short</span> <span class="o">*</span><span class="p">)</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">socket_ack_count</span> <span class="o">=</span> <span class="n">atom_asr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">asp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">socket_ack_count</span> <span class="o">==</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cpus_in_socket</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">msg_ack_count</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Both sockets dump their completed count total into</span>
<span class="cm">		 * the message&#39;s count.</span>
<span class="cm">		 */</span>
		<span class="n">smaster</span><span class="o">-&gt;</span><span class="n">socket_acknowledge_count</span><span class="p">[</span><span class="n">mdp</span><span class="o">-&gt;</span><span class="n">msg_slot</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">asp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atomic_short</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">acknowledge_count</span><span class="p">;</span>
		<span class="n">msg_ack_count</span> <span class="o">=</span> <span class="n">atom_asr</span><span class="p">(</span><span class="n">socket_ack_count</span><span class="p">,</span> <span class="n">asp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msg_ack_count</span> <span class="o">==</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cpus_in_uvhub</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * All cpus in uvhub saw it; reply</span>
<span class="cm">			 * (unless we are in the UV2 workaround)</span>
<span class="cm">			 */</span>
			<span class="n">reply_to_message</span><span class="p">(</span><span class="n">mdp</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="n">do_acknowledge</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine the first cpu on a pnode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pnode_to_first_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">smaster</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hub_and_pnode</span> <span class="o">*</span><span class="n">hpp</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smaster</span><span class="o">-&gt;</span><span class="n">thp</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">==</span> <span class="n">hpp</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Last resort when we get a large number of destination timeouts is</span>
<span class="cm"> * to clear resources held by a given cpu.</span>
<span class="cm"> * Do this with IPI so that all messages in the BAU message queue</span>
<span class="cm"> * can be identified by their nonzero swack_vec field.</span>
<span class="cm"> *</span>
<span class="cm"> * This is entered for a single cpu on the uvhub.</span>
<span class="cm"> * The sender want&#39;s this uvhub to free a specific message&#39;s</span>
<span class="cm"> * swack resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_reset</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="k">struct</span> <span class="n">reset_args</span> <span class="o">*</span><span class="n">rap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reset_args</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span><span class="p">;</span>

	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_resets</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re looking for the given sender, and</span>
<span class="cm">	 * will free its swack resource.</span>
<span class="cm">	 * If all cpu&#39;s finally responded after the timeout, its</span>
<span class="cm">	 * message &#39;replied_to&#39; was set.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_first</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DEST_Q_SIZE</span><span class="p">;</span> <span class="n">msg</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msg_res</span><span class="p">;</span>
		<span class="cm">/* do_reset: same conditions for cancellation as</span>
<span class="cm">		   bau_process_retry_msg() */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">replied_to</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">canceled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">sending_cpu</span> <span class="o">==</span> <span class="n">rap</span><span class="o">-&gt;</span><span class="n">sender</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">swack_vec</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">!=</span> <span class="n">MSG_NOOP</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mr</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * make everyone else ignore this message</span>
<span class="cm">			 */</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">canceled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * only reset the resource if it is still pending</span>
<span class="cm">			 */</span>
			<span class="n">mmr</span> <span class="o">=</span> <span class="n">read_mmr_sw_ack</span><span class="p">();</span>
			<span class="n">msg_res</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">swack_vec</span><span class="p">;</span>
			<span class="n">mr</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg_res</span> <span class="o">&lt;&lt;</span> <span class="n">UV_SW_ACK_NPENDING</span><span class="p">)</span> <span class="o">|</span> <span class="n">msg_res</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mmr</span> <span class="o">&amp;</span> <span class="n">msg_res</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_rcanceled</span><span class="o">++</span><span class="p">;</span>
				<span class="n">write_mmr_sw_ack</span><span class="p">(</span><span class="n">mr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use IPI to get all target uvhubs to release resources held by</span>
<span class="cm"> * a given sending cpu number.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_with_ipi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnmask</span> <span class="o">*</span><span class="n">distribution</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">apnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maskbits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sender</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
	<span class="n">cpumask_t</span> <span class="o">*</span><span class="n">mask</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_master</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">smaster</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">socket_master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reset_args</span> <span class="n">reset_args</span><span class="p">;</span>

	<span class="n">reset_args</span><span class="p">.</span><span class="n">sender</span> <span class="o">=</span> <span class="n">sender</span><span class="p">;</span>
	<span class="n">cpus_clear</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="p">);</span>
	<span class="cm">/* find a single cpu for each uvhub in this distribution mask */</span>
	<span class="n">maskbits</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnmask</span><span class="p">)</span> <span class="o">*</span> <span class="n">BITSPERBYTE</span><span class="p">;</span>
	<span class="cm">/* each bit is a pnode relative to the partition base pnode */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pnode</span> <span class="o">&lt;</span> <span class="n">maskbits</span><span class="p">;</span> <span class="n">pnode</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bau_uvhub_isset</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">distribution</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">apnode</span> <span class="o">=</span> <span class="n">pnode</span> <span class="o">+</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">partition_base_pnode</span><span class="p">;</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">pnode_to_first_cpu</span><span class="p">(</span><span class="n">apnode</span><span class="p">,</span> <span class="n">smaster</span><span class="p">);</span>
		<span class="n">cpu_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* IPI all cpus; preemption is already disabled */</span>
	<span class="n">smp_call_function_many</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">do_reset</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reset_args</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cycles_2_us</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">cyc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">us</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">ns</span> <span class="o">=</span>  <span class="p">(</span><span class="n">cyc</span> <span class="o">*</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cyc2ns</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">CYC2NS_SCALE_FACTOR</span><span class="p">;</span>
	<span class="n">us</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">us</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wait for all cpus on this hub to finish their sends and go quiet</span>
<span class="cm"> * leaves uvhub_quiesce set so that no new broadcasts are started by</span>
<span class="cm"> * bau_flush_send_and_wait()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">quiesce_local_uvhub</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atom_asr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atomic_short</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">uvhub_quiesce</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mark this quiet-requestor as done</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">end_uvhub_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atom_asr</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atomic_short</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">uvhub_quiesce</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv1_read_status</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right_shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">descriptor_status</span><span class="p">;</span>

	<span class="n">descriptor_status</span> <span class="o">=</span> <span class="n">uv_read_local_mmr</span><span class="p">(</span><span class="n">mmr_offset</span><span class="p">);</span>
	<span class="n">descriptor_status</span> <span class="o">&gt;&gt;=</span> <span class="n">right_shift</span><span class="p">;</span>
	<span class="n">descriptor_status</span> <span class="o">&amp;=</span> <span class="n">UV_ACT_STATUS_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">descriptor_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for completion of a broadcast software ack message</span>
<span class="cm"> * return COMPLETE, RETRY(PLUGGED or TIMEOUT) or GIVEUP</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uv1_wait_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right_shift</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">try</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">descriptor_status</span><span class="p">;</span>
	<span class="n">cycles_t</span> <span class="n">ttm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span><span class="p">;</span>

	<span class="n">descriptor_status</span> <span class="o">=</span> <span class="n">uv1_read_status</span><span class="p">(</span><span class="n">mmr_offset</span><span class="p">,</span> <span class="n">right_shift</span><span class="p">);</span>
	<span class="cm">/* spin on the status MMR, waiting for it to go idle */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">descriptor_status</span> <span class="o">!=</span> <span class="n">DS_IDLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Our software ack messages may be blocked because</span>
<span class="cm">		 * there are no swack resources available.  As long</span>
<span class="cm">		 * as none of them has timed out hardware will NACK</span>
<span class="cm">		 * our message and its state will stay IDLE.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">descriptor_status</span> <span class="o">==</span> <span class="n">DS_SOURCE_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_stimeout</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">FLUSH_GIVEUP</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">descriptor_status</span> <span class="o">==</span> <span class="n">DS_DESTINATION_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_dtimeout</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ttm</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>

			<span class="cm">/*</span>
<span class="cm">			 * Our retries may be blocked by all destination</span>
<span class="cm">			 * swack resources being consumed, and a timeout</span>
<span class="cm">			 * pending.  In that case hardware returns the</span>
<span class="cm">			 * ERROR that looks like a destination timeout.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cycles_2_us</span><span class="p">(</span><span class="n">ttm</span> <span class="o">-</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">send_message</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">timeout_us</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">conseccompletes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">FLUSH_RETRY_PLUGGED</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">conseccompletes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">FLUSH_RETRY_TIMEOUT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * descriptor_status is still BUSY</span>
<span class="cm">			 */</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">descriptor_status</span> <span class="o">=</span> <span class="n">uv1_read_status</span><span class="p">(</span><span class="n">mmr_offset</span><span class="p">,</span> <span class="n">right_shift</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">conseccompletes</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">FLUSH_COMPLETE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * UV2 has an extra bit of status in the ACTIVATION_STATUS_2 register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv2_read_status</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rshft</span><span class="p">,</span> <span class="kt">int</span> <span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">descriptor_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">descriptor_status2</span><span class="p">;</span>

	<span class="n">descriptor_status</span> <span class="o">=</span> <span class="p">((</span><span class="n">read_lmmr</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rshft</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UV_ACT_STATUS_MASK</span><span class="p">);</span>
	<span class="n">descriptor_status2</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_mmr_uv2_status</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">desc</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1UL</span><span class="p">;</span>
	<span class="n">descriptor_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">descriptor_status</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">descriptor_status2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">descriptor_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return whether the status of the descriptor that is normally used for this</span>
<span class="cm"> * cpu (the one indexed by its hub-relative cpu number) is busy.</span>
<span class="cm"> * The status of the original 32 descriptors is always reflected in the 64</span>
<span class="cm"> * bits of UVH_LB_BAU_SB_ACTIVATION_STATUS_0.</span>
<span class="cm"> * The bit provided by the activation_status_2 register is irrelevant to</span>
<span class="cm"> * the status if it is only being tested for busy or not busy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">normal_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mmr_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">right_shift</span><span class="p">;</span>

	<span class="n">mmr_offset</span> <span class="o">=</span> <span class="n">UVH_LB_BAU_SB_ACTIVATION_STATUS_0</span><span class="p">;</span>
	<span class="n">right_shift</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">*</span> <span class="n">UV_ACT_STATUS_SIZE</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(((((</span><span class="n">read_lmmr</span><span class="p">(</span><span class="n">mmr_offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">right_shift</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">UV_ACT_STATUS_MASK</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">UV2H_DESC_BUSY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Entered when a bau descriptor has gone into a permanent busy wait because</span>
<span class="cm"> * of a hardware bug.</span>
<span class="cm"> * Workaround the bug.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">handle_uv2_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">busy_one</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">selected</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">descriptor_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mmr_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc_old</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc_new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span><span class="p">;</span>
	<span class="n">cycles_t</span> <span class="n">ttm</span><span class="p">;</span>

	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_uv2_wars</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">uvhub_lock</span><span class="p">);</span>
	<span class="cm">/* try for the original first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busy_one</span> <span class="o">!=</span> <span class="n">normal</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">normal_busy</span><span class="p">(</span><span class="n">bcp</span><span class="p">))</span>
			<span class="n">selected</span> <span class="o">=</span> <span class="n">normal</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">selected</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* can&#39;t use the normal, select an alternate */</span>
		<span class="n">mmr_offset</span> <span class="o">=</span> <span class="n">UVH_LB_BAU_SB_ACTIVATION_STATUS_1</span><span class="p">;</span>
		<span class="n">descriptor_status</span> <span class="o">=</span> <span class="n">read_lmmr</span><span class="p">(</span><span class="n">mmr_offset</span><span class="p">);</span>

		<span class="cm">/* scan available descriptors 32-63 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UV_CPUS_PER_AS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">inuse_map</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="p">((</span><span class="n">descriptor_status</span> <span class="o">&gt;&gt;</span>
						<span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">UV_ACT_STATUS_SIZE</span><span class="p">))</span> <span class="o">&amp;</span>
						<span class="n">UV_ACT_STATUS_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">UV2H_DESC_BUSY</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">selected</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">UV_CPUS_PER_AS</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">busy_one</span> <span class="o">!=</span> <span class="n">normal</span><span class="p">)</span>
		<span class="cm">/* mark the busy alternate as not in-use */</span>
		<span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">inuse_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">busy_one</span> <span class="o">-</span> <span class="n">UV_CPUS_PER_AS</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">selected</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* switch to the selected descriptor */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">selected</span> <span class="o">!=</span> <span class="n">normal</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* set the selected alternate as in-use */</span>
			<span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">inuse_map</span> <span class="o">|=</span>
					<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">selected</span> <span class="o">-</span> <span class="n">UV_CPUS_PER_AS</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">selected</span> <span class="o">&gt;</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_uv2_wars_hw</span><span class="p">)</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_uv2_wars_hw</span> <span class="o">=</span> <span class="n">selected</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bau_desc_old</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">descriptor_base</span><span class="p">;</span>
		<span class="n">bau_desc_old</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ITEMS_PER_DESC</span> <span class="o">*</span> <span class="n">busy_one</span><span class="p">);</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span> <span class="o">=</span> <span class="n">selected</span><span class="p">;</span>
		<span class="n">bau_desc_new</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">descriptor_base</span><span class="p">;</span>
		<span class="n">bau_desc_new</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ITEMS_PER_DESC</span> <span class="o">*</span> <span class="n">selected</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bau_desc_new</span> <span class="o">=</span> <span class="o">*</span><span class="n">bau_desc_old</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * All are busy. Wait for the normal one for this cpu to</span>
<span class="cm">		 * free up.</span>
<span class="cm">		 */</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_uv2_war_waits</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">uvhub_lock</span><span class="p">);</span>
		<span class="n">ttm</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">normal_busy</span><span class="p">(</span><span class="n">bcp</span><span class="p">));</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">uvhub_lock</span><span class="p">);</span>
		<span class="cm">/* switch to the original descriptor */</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span> <span class="o">=</span> <span class="n">normal</span><span class="p">;</span>
		<span class="n">bau_desc_old</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">descriptor_base</span><span class="p">;</span>
		<span class="n">bau_desc_old</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ITEMS_PER_DESC</span> <span class="o">*</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span><span class="p">);</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ITEMS_PER_DESC</span> <span class="o">*</span> <span class="n">normal</span><span class="p">);</span>
		<span class="n">bau_desc_new</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">descriptor_base</span><span class="p">;</span>
		<span class="n">bau_desc_new</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ITEMS_PER_DESC</span> <span class="o">*</span> <span class="n">normal</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bau_desc_new</span> <span class="o">=</span> <span class="o">*</span><span class="n">bau_desc_old</span><span class="p">;</span> <span class="cm">/* copy the entire descriptor */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">uvhub_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">FLUSH_RETRY_BUSYBUG</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uv2_wait_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right_shift</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">try</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">descriptor_stat</span><span class="p">;</span>
	<span class="n">cycles_t</span> <span class="n">ttm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">busy_reps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span><span class="p">;</span>

	<span class="n">descriptor_stat</span> <span class="o">=</span> <span class="n">uv2_read_status</span><span class="p">(</span><span class="n">mmr_offset</span><span class="p">,</span> <span class="n">right_shift</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>

	<span class="cm">/* spin on the status MMR, waiting for it to go idle */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">descriptor_stat</span> <span class="o">!=</span> <span class="n">UV2H_DESC_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Our software ack messages may be blocked because</span>
<span class="cm">		 * there are no swack resources available.  As long</span>
<span class="cm">		 * as none of them has timed out hardware will NACK</span>
<span class="cm">		 * our message and its state will stay IDLE.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">descriptor_stat</span> <span class="o">==</span> <span class="n">UV2H_DESC_SOURCE_TIMEOUT</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">descriptor_stat</span> <span class="o">==</span> <span class="n">UV2H_DESC_DEST_PUT_ERR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_stimeout</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">FLUSH_GIVEUP</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">descriptor_stat</span> <span class="o">==</span> <span class="n">UV2H_DESC_DEST_STRONG_NACK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_strongnacks</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">conseccompletes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">FLUSH_GIVEUP</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">descriptor_stat</span> <span class="o">==</span> <span class="n">UV2H_DESC_DEST_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_dtimeout</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">conseccompletes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">FLUSH_RETRY_TIMEOUT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">busy_reps</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">busy_reps</span> <span class="o">&gt;</span> <span class="mi">1000000</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* not to hammer on the clock */</span>
				<span class="n">busy_reps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ttm</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ttm</span> <span class="o">-</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">send_message</span><span class="p">)</span> <span class="o">&gt;</span>
					<span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">clocks_per_100_usec</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">return</span> <span class="n">handle_uv2_busy</span><span class="p">(</span><span class="n">bcp</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * descriptor_stat is still BUSY</span>
<span class="cm">			 */</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">descriptor_stat</span> <span class="o">=</span> <span class="n">uv2_read_status</span><span class="p">(</span><span class="n">mmr_offset</span><span class="p">,</span> <span class="n">right_shift</span><span class="p">,</span>
									<span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">conseccompletes</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">FLUSH_COMPLETE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are 2 status registers; each and array[32] of 2 bits. Set up for</span>
<span class="cm"> * which register to read and position in that register based on cpu in</span>
<span class="cm"> * current hub.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">try</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">right_shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span> <span class="o">&lt;</span> <span class="n">UV_CPUS_PER_AS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmr_offset</span> <span class="o">=</span> <span class="n">UVH_LB_BAU_SB_ACTIVATION_STATUS_0</span><span class="p">;</span>
		<span class="n">right_shift</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">*</span> <span class="n">UV_ACT_STATUS_SIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mmr_offset</span> <span class="o">=</span> <span class="n">UVH_LB_BAU_SB_ACTIVATION_STATUS_1</span><span class="p">;</span>
		<span class="n">right_shift</span> <span class="o">=</span> <span class="p">((</span><span class="n">desc</span> <span class="o">-</span> <span class="n">UV_CPUS_PER_AS</span><span class="p">)</span> <span class="o">*</span> <span class="n">UV_ACT_STATUS_SIZE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">uv1_wait_completion</span><span class="p">(</span><span class="n">bau_desc</span><span class="p">,</span> <span class="n">mmr_offset</span><span class="p">,</span> <span class="n">right_shift</span><span class="p">,</span>
								<span class="n">bcp</span><span class="p">,</span> <span class="n">try</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">uv2_wait_completion</span><span class="p">(</span><span class="n">bau_desc</span><span class="p">,</span> <span class="n">mmr_offset</span><span class="p">,</span> <span class="n">right_shift</span><span class="p">,</span>
								<span class="n">bcp</span><span class="p">,</span> <span class="n">try</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">cycles_t</span> <span class="nf">sec_2_cycles</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ns</span><span class="p">;</span>
	<span class="n">cycles_t</span> <span class="n">cyc</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">sec</span> <span class="o">*</span> <span class="mi">1000000000</span><span class="p">;</span>
	<span class="n">cyc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ns</span> <span class="o">&lt;&lt;</span> <span class="n">CYC2NS_SCALE_FACTOR</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cyc2ns</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">()));</span>
	<span class="k">return</span> <span class="n">cyc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Our retries are blocked by all destination sw ack resources being</span>
<span class="cm"> * in use, and a timeout is pending. In that case hardware immediately</span>
<span class="cm"> * returns the ERROR that looks like a destination timeout.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destination_plugged</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugged_delay</span><span class="p">);</span>
	<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugged_tries</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugged_tries</span> <span class="o">&gt;=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugsb4reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugged_tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">quiesce_local_uvhub</span><span class="p">(</span><span class="n">hmaster</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">reset_with_ipi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bau_desc</span><span class="o">-&gt;</span><span class="n">distribution</span><span class="p">,</span> <span class="n">bcp</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

		<span class="n">end_uvhub_quiesce</span><span class="p">(</span><span class="n">hmaster</span><span class="p">);</span>

		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">ipi_attempts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_resets_plug</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destination_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">max_concurr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">timeout_tries</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">timeout_tries</span> <span class="o">&gt;=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">timeoutsb4reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">timeout_tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">quiesce_local_uvhub</span><span class="p">(</span><span class="n">hmaster</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">reset_with_ipi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bau_desc</span><span class="o">-&gt;</span><span class="n">distribution</span><span class="p">,</span> <span class="n">bcp</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

		<span class="n">end_uvhub_quiesce</span><span class="p">(</span><span class="n">hmaster</span><span class="p">);</span>

		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">ipi_attempts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_resets_timeout</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Completions are taking a very long time due to a congested numalink</span>
<span class="cm"> * network.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_for_congestion</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* let only one cpu do this disabling */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disable_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">baudisabled</span> <span class="o">&amp;&amp;</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">period_requests</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">period_time</span> <span class="o">/</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">period_requests</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">congested_cycles</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">tcpu</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">tbcp</span><span class="p">;</span>
		<span class="cm">/* it becomes this cpu&#39;s job to turn on the use of the</span>
<span class="cm">		   BAU again */</span>
		<span class="n">baudisabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">set_bau_off</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">set_bau_on_time</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">set_bau_on_time</span> <span class="o">+=</span> <span class="n">sec_2_cycles</span><span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cong_period</span><span class="p">);</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_bau_disabled</span><span class="o">++</span><span class="p">;</span>
		<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">tcpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tbcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">tcpu</span><span class="p">);</span>
			<span class="n">tbcp</span><span class="o">-&gt;</span><span class="n">baudisabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disable_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">count_max_concurr</span><span class="p">(</span><span class="kt">int</span> <span class="n">stat</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugged_tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">timeout_tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">!=</span> <span class="n">FLUSH_COMPLETE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">conseccompletes</span> <span class="o">&lt;=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">complete_threshold</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">max_concurr</span> <span class="o">&gt;=</span> <span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">max_concurr_const</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">max_concurr</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">record_send_stats</span><span class="p">(</span><span class="n">cycles_t</span> <span class="n">time1</span><span class="p">,</span> <span class="n">cycles_t</span> <span class="n">time2</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">completion_status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">try</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cycles_t</span> <span class="n">elapsed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time2</span> <span class="o">&gt;</span> <span class="n">time1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">elapsed</span> <span class="o">=</span> <span class="n">time2</span> <span class="o">-</span> <span class="n">time1</span><span class="p">;</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_time</span> <span class="o">+=</span> <span class="n">elapsed</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">completion_status</span> <span class="o">==</span> <span class="n">FLUSH_COMPLETE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">try</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">period_requests</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">period_time</span> <span class="o">+=</span> <span class="n">elapsed</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">elapsed</span> <span class="o">&gt;</span> <span class="n">congested_cycles</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">period_requests</span> <span class="o">&gt;</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cong_reps</span><span class="p">))</span>
				<span class="n">disable_for_congestion</span><span class="p">(</span><span class="n">bcp</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_requestor</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">completion_status</span> <span class="o">==</span> <span class="n">FLUSH_COMPLETE</span> <span class="o">&amp;&amp;</span> <span class="n">try</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_retriesok</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">completion_status</span> <span class="o">==</span> <span class="n">FLUSH_GIVEUP</span><span class="p">)</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_giveup</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Because of a uv1 hardware bug only a limited number of concurrent</span>
<span class="cm"> * requests can be made.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uv1_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">uvhub_lock</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">active_descriptor_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_unless_ge</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">max_concurr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_throttles</span><span class="o">++</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_unless_ge</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">max_concurr</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle the completion status of a message send.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_cmplt</span><span class="p">(</span><span class="kt">int</span> <span class="n">completion_status</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">completion_status</span> <span class="o">==</span> <span class="n">FLUSH_RETRY_PLUGGED</span><span class="p">)</span>
		<span class="n">destination_plugged</span><span class="p">(</span><span class="n">bau_desc</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="n">hmaster</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">completion_status</span> <span class="o">==</span> <span class="n">FLUSH_RETRY_TIMEOUT</span><span class="p">)</span>
		<span class="n">destination_timeout</span><span class="p">(</span><span class="n">bau_desc</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="n">hmaster</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send a broadcast and wait for it to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * The flush_mask contains the cpus the broadcast is to be sent to including</span>
<span class="cm"> * cpus that are on the local uvhub.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if all flushing represented in the mask was done.</span>
<span class="cm"> * Returns 1 if it gives up entirely and the original cpu mask is to be</span>
<span class="cm"> * returned to the kernel.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uv_flush_send_and_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">flush_mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">seq_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">completion_stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uv1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">try</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">cycles_t</span> <span class="n">time1</span><span class="p">;</span>
	<span class="n">cycles_t</span> <span class="n">time2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uv1_bau_msg_header</span> <span class="o">*</span><span class="n">uv1_hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uv2_bau_msg_header</span> <span class="o">*</span><span class="n">uv2_hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">uv1_throttle</span><span class="p">(</span><span class="n">hmaster</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">uvhub_quiesce</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="n">time1</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">bau_desc</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">descriptor_base</span><span class="p">;</span>
		<span class="n">bau_desc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ITEMS_PER_DESC</span> <span class="o">*</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uv1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">uv1_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bau_desc</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">uv1_hdr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">uv2_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bau_desc</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">uv2_hdr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">try</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">completion_stat</span> <span class="o">==</span> <span class="n">FLUSH_RETRY_BUSYBUG</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uv1</span><span class="p">)</span>
				<span class="n">uv1_hdr</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_REGULAR</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">uv2_hdr</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_REGULAR</span><span class="p">;</span>
			<span class="n">seq_number</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">message_number</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uv1</span><span class="p">)</span>
				<span class="n">uv1_hdr</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_RETRY</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">uv2_hdr</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_RETRY</span><span class="p">;</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_retry_messages</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">uv1</span><span class="p">)</span>
			<span class="n">uv1_hdr</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq_number</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">uv2_hdr</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq_number</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">AS_PUSH_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">send_message</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>

		<span class="n">write_mmr_activation</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>

		<span class="n">try</span><span class="o">++</span><span class="p">;</span>
		<span class="n">completion_stat</span> <span class="o">=</span> <span class="n">wait_completion</span><span class="p">(</span><span class="n">bau_desc</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="n">try</span><span class="p">);</span>
		<span class="cm">/* UV2: wait_completion() may change the bcp-&gt;using_desc */</span>

		<span class="n">handle_cmplt</span><span class="p">(</span><span class="n">completion_stat</span><span class="p">,</span> <span class="n">bau_desc</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="n">hmaster</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">ipi_attempts</span> <span class="o">&gt;=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">ipi_reset_limit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">ipi_attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">completion_stat</span> <span class="o">=</span> <span class="n">FLUSH_GIVEUP</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">completion_stat</span> <span class="o">==</span> <span class="n">FLUSH_RETRY_PLUGGED</span><span class="p">)</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">completion_stat</span> <span class="o">==</span> <span class="n">FLUSH_RETRY_BUSYBUG</span><span class="p">)</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">completion_stat</span> <span class="o">==</span> <span class="n">FLUSH_RETRY_TIMEOUT</span><span class="p">));</span>

	<span class="n">time2</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>

	<span class="n">count_max_concurr</span><span class="p">(</span><span class="n">completion_stat</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="n">hmaster</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">uvhub_quiesce</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">active_descriptor_count</span><span class="p">);</span>

	<span class="n">record_send_stats</span><span class="p">(</span><span class="n">time1</span><span class="p">,</span> <span class="n">time2</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">completion_stat</span><span class="p">,</span> <span class="n">try</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">completion_stat</span> <span class="o">==</span> <span class="n">FLUSH_GIVEUP</span><span class="p">)</span>
		<span class="cm">/* FLUSH_GIVEUP will fall back to using IPI&#39;s for tlb flush */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The BAU is disabled. When the disabled time period has expired, the cpu</span>
<span class="cm"> * that disabled it must re-enable it.</span>
<span class="cm"> * Return 0 if it is re-enabled for all cpus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">tbcp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">set_bau_off</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_cycles</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">set_bau_on_time</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_bau_reenabled</span><span class="o">++</span><span class="p">;</span>
			<span class="n">baudisabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">tcpu</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tbcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">tcpu</span><span class="p">);</span>
				<span class="n">tbcp</span><span class="o">-&gt;</span><span class="n">baudisabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">tbcp</span><span class="o">-&gt;</span><span class="n">period_requests</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">tbcp</span><span class="o">-&gt;</span><span class="n">period_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">record_send_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">,</span> <span class="kt">int</span> <span class="n">locals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hubs</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">remotes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_requestor</span><span class="o">++</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntargcpu</span> <span class="o">+=</span> <span class="n">remotes</span> <span class="o">+</span> <span class="n">locals</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntargremotes</span> <span class="o">+=</span> <span class="n">remotes</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarglocals</span> <span class="o">+=</span> <span class="n">locals</span><span class="p">;</span>

	<span class="cm">/* uvhub statistics */</span>
	<span class="n">hubs</span> <span class="o">=</span> <span class="n">bau_uvhub_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bau_desc</span><span class="o">-&gt;</span><span class="n">distribution</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locals</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarglocaluvhub</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntargremoteuvhub</span> <span class="o">+=</span> <span class="p">(</span><span class="n">hubs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntargremoteuvhub</span> <span class="o">+=</span> <span class="n">hubs</span><span class="p">;</span>

	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub</span> <span class="o">+=</span> <span class="n">hubs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hubs</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub16</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hubs</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub8</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hubs</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub4</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hubs</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub2</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub1</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Translate a cpu mask to the uvhub distribution mask in the BAU</span>
<span class="cm"> * activation descriptor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_distrib_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">flush_mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">localsp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">remotesp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hub_and_pnode</span> <span class="o">*</span><span class="n">hpp</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">flush_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The distribution vector is a bit map of pnodes, relative</span>
<span class="cm">		 * to the partition base pnode (and the partition base nasid</span>
<span class="cm">		 * in the header).</span>
<span class="cm">		 * Translate cpu to pnode and hub using a local memory array.</span>
<span class="cm">		 */</span>
		<span class="n">hpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">socket_master</span><span class="o">-&gt;</span><span class="n">thp</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="n">pnode</span> <span class="o">=</span> <span class="n">hpp</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">-</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">partition_base_pnode</span><span class="p">;</span>
		<span class="n">bau_uvhub_set</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bau_desc</span><span class="o">-&gt;</span><span class="n">distribution</span><span class="p">);</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpp</span><span class="o">-&gt;</span><span class="n">uvhub</span> <span class="o">==</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">localsp</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="p">(</span><span class="o">*</span><span class="n">remotesp</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * globally purge translation cache of a virtual address or all TLB&#39;s</span>
<span class="cm"> * @cpumask: mask of all cpu&#39;s in which the address is to be removed</span>
<span class="cm"> * @mm: mm_struct containing virtual address range</span>
<span class="cm"> * @va: virtual address to be removed (or TLB_FLUSH_ALL for all TLB&#39;s on cpu)</span>
<span class="cm"> * @cpu: the current cpu</span>
<span class="cm"> *</span>
<span class="cm"> * This is the entry point for initiating any UV global TLB shootdown.</span>
<span class="cm"> *</span>
<span class="cm"> * Purges the translation caches of all specified processors of the given</span>
<span class="cm"> * virtual address, or purges all TLB&#39;s on specified processors.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller has derived the cpumask from the mm_struct.  This function</span>
<span class="cm"> * is called only if there are bits set in the mask. (e.g. flush_tlb_page())</span>
<span class="cm"> *</span>
<span class="cm"> * The cpumask is converted into a uvhubmask of the uvhubs containing</span>
<span class="cm"> * those cpus.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function should be called with preemption disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL if all remote flushing was done.</span>
<span class="cm"> * Returns pointer to cpumask if some remote flushing remains to be</span>
<span class="cm"> * done.  The returned pointer is valid till preemption is re-enabled.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">uv_flush_tlb_others</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">locals</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remotes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hubs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">flush_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">;</span>

	<span class="cm">/* kernel was booted &#39;nobau&#39; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nobau</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cpumask</span><span class="p">;</span>

	<span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span><span class="p">;</span>

	<span class="cm">/* bau was disabled due to slow response */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">baudisabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_enable</span><span class="p">(</span><span class="n">bcp</span><span class="p">,</span> <span class="n">stat</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">cpumask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each sending cpu has a per-cpu mask which it fills from the caller&#39;s</span>
<span class="cm">	 * cpu mask.  All cpus are converted to uvhubs and copied to the</span>
<span class="cm">	 * activation descriptor.</span>
<span class="cm">	 */</span>
	<span class="n">flush_mask</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="p">)</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">uv_flush_tlb_mask</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="cm">/* don&#39;t actually do a shootdown of the local cpu */</span>
	<span class="n">cpumask_andnot</span><span class="p">(</span><span class="n">flush_mask</span><span class="p">,</span> <span class="n">cpumask</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_isset</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntargself</span><span class="o">++</span><span class="p">;</span>

	<span class="n">bau_desc</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">descriptor_base</span><span class="p">;</span>
	<span class="n">bau_desc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ITEMS_PER_DESC</span> <span class="o">*</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span><span class="p">);</span>
	<span class="n">bau_uvhubs_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bau_desc</span><span class="o">-&gt;</span><span class="n">distribution</span><span class="p">,</span> <span class="n">UV_DISTRIBUTION_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_distrib_bits</span><span class="p">(</span><span class="n">flush_mask</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="n">bau_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">locals</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remotes</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">record_send_statistics</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">locals</span><span class="p">,</span> <span class="n">hubs</span><span class="p">,</span> <span class="n">remotes</span><span class="p">,</span> <span class="n">bau_desc</span><span class="p">);</span>

	<span class="n">bau_desc</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
	<span class="n">bau_desc</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">sending_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * uv_flush_send_and_wait returns 0 if all cpu&#39;s were messaged,</span>
<span class="cm">	 * or 1 if it gave up and the original cpumask should be returned.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uv_flush_send_and_wait</span><span class="p">(</span><span class="n">flush_mask</span><span class="p">,</span> <span class="n">bcp</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">cpumask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search the message queue for any &#39;other&#39; message with the same software</span>
<span class="cm"> * acknowledge resource bit vector.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="nf">find_another_by_swack</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">swack_vec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">msg_next</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg_next</span> <span class="o">&gt;</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_last</span><span class="p">)</span>
		<span class="n">msg_next</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_first</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">msg_next</span><span class="o">-&gt;</span><span class="n">swack_vec</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msg_next</span> <span class="o">!=</span> <span class="n">msg</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_next</span><span class="o">-&gt;</span><span class="n">swack_vec</span> <span class="o">==</span> <span class="n">swack_vec</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">msg_next</span><span class="p">;</span>
		<span class="n">msg_next</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_next</span> <span class="o">&gt;</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_last</span><span class="p">)</span>
			<span class="n">msg_next</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_first</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * UV2 needs to work around a bug in which an arriving message has not</span>
<span class="cm"> * set a bit in the UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE register.</span>
<span class="cm"> * Such a message must be ignored.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">process_uv2_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_desc</span> <span class="o">*</span><span class="n">mdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">swack_vec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">other_msg</span><span class="p">;</span>

	<span class="n">mmr_image</span> <span class="o">=</span> <span class="n">read_mmr_sw_ack</span><span class="p">();</span>
	<span class="n">swack_vec</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">swack_vec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">swack_vec</span> <span class="o">&amp;</span> <span class="n">mmr_image</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This message was assigned a swack resource, but no</span>
<span class="cm">		 * reserved acknowlegment is pending.</span>
<span class="cm">		 * The bug has prevented this message from setting the MMR.</span>
<span class="cm">		 * And no other message has used the same sw_ack resource.</span>
<span class="cm">		 * Do the requested shootdown but do not reply to the msg.</span>
<span class="cm">		 * (the 0 means make no acknowledge)</span>
<span class="cm">		 */</span>
		<span class="n">bau_process_message</span><span class="p">(</span><span class="n">mdp</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some message has set the MMR &#39;pending&#39; bit; it might have been</span>
<span class="cm">	 * another message.  Look for that message.</span>
<span class="cm">	 */</span>
	<span class="n">other_msg</span> <span class="o">=</span> <span class="n">find_another_by_swack</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">swack_vec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other_msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* There is another.  Do not ack the current one. */</span>
		<span class="n">bau_process_message</span><span class="p">(</span><span class="n">mdp</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Let the natural processing of that message acknowledge</span>
<span class="cm">		 * it. Don&#39;t get the processing of sw_ack&#39;s out of order.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no other message using this sw_ack, so it is safe to</span>
<span class="cm">	 * acknowledge it.</span>
<span class="cm">	 */</span>
	<span class="n">bau_process_message</span><span class="p">(</span><span class="n">mdp</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The BAU message interrupt comes here. (registered by set_intr_gate)</span>
<span class="cm"> * See entry_64.S</span>
<span class="cm"> *</span>
<span class="cm"> * We received a broadcast assist message.</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupts are disabled; this interrupt could represent</span>
<span class="cm"> * the receipt of several messages.</span>
<span class="cm"> *</span>
<span class="cm"> * All cores/threads on this hub get this interrupt.</span>
<span class="cm"> * The last one to see it does the software ack.</span>
<span class="cm"> * (the resource will not be freed until noninterruptable cpus see this</span>
<span class="cm"> *  interrupt; hardware may timeout the s/w ack and reply ERROR)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uv_bau_message_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cycles_t</span> <span class="n">time_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msg_desc</span> <span class="n">msgdesc</span><span class="p">;</span>

	<span class="n">ack_APIC_irq</span><span class="p">();</span>
	<span class="n">time_start</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>

	<span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span><span class="p">;</span>

	<span class="n">msgdesc</span><span class="p">.</span><span class="n">queue_first</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_first</span><span class="p">;</span>
	<span class="n">msgdesc</span><span class="p">.</span><span class="n">queue_last</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_last</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bau_msg_head</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">swack_vec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="n">msgdesc</span><span class="p">.</span><span class="n">msg_slot</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">-</span> <span class="n">msgdesc</span><span class="p">.</span><span class="n">queue_first</span><span class="p">;</span>
		<span class="n">msgdesc</span><span class="p">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_version</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">process_uv2_message</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msgdesc</span><span class="p">,</span> <span class="n">bcp</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bau_process_message</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msgdesc</span><span class="p">,</span> <span class="n">bcp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">msg</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">&gt;</span> <span class="n">msgdesc</span><span class="p">.</span><span class="n">queue_last</span><span class="p">)</span>
			<span class="n">msg</span> <span class="o">=</span> <span class="n">msgdesc</span><span class="p">.</span><span class="n">queue_first</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bau_msg_head</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_time</span> <span class="o">+=</span> <span class="p">(</span><span class="n">get_cycles</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_nomsg</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_multmsg</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Each target uvhub (i.e. a uvhub that has cpu&#39;s) needs to have</span>
<span class="cm"> * shootdown message timeouts enabled.  The timeout does not cause</span>
<span class="cm"> * an interrupt, but causes an error message to be returned to</span>
<span class="cm"> * the sender.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">enable_timeouts</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">uvhub</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nuvhubs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">;</span>

	<span class="n">nuvhubs</span> <span class="o">=</span> <span class="n">uv_num_possible_blades</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">uvhub</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uvhub</span> <span class="o">&lt;</span> <span class="n">nuvhubs</span><span class="p">;</span> <span class="n">uvhub</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="n">uvhub</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pnode</span> <span class="o">=</span> <span class="n">uv_blade_to_pnode</span><span class="p">(</span><span class="n">uvhub</span><span class="p">);</span>
		<span class="n">mmr_image</span> <span class="o">=</span> <span class="n">read_mmr_misc_control</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the timeout period and then lock it in, in three</span>
<span class="cm">		 * steps; captures and locks in the period.</span>
<span class="cm">		 *</span>
<span class="cm">		 * To program the period, the SOFT_ACK_MODE must be off.</span>
<span class="cm">		 */</span>
		<span class="n">mmr_image</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">SOFTACK_MSHIFT</span><span class="p">);</span>
		<span class="n">write_mmr_misc_control</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the 4-bit period.</span>
<span class="cm">		 */</span>
		<span class="n">mmr_image</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="mh">0xf</span> <span class="o">&lt;&lt;</span> <span class="n">SOFTACK_PSHIFT</span><span class="p">);</span>
		<span class="n">mmr_image</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SOFTACK_TIMEOUT_PERIOD</span> <span class="o">&lt;&lt;</span> <span class="n">SOFTACK_PSHIFT</span><span class="p">);</span>
		<span class="n">write_mmr_misc_control</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * UV1:</span>
<span class="cm">		 * Subsequent reversals of the timebase bit (3) cause an</span>
<span class="cm">		 * immediate timeout of one or all INTD resources as</span>
<span class="cm">		 * indicated in bits 2:0 (7 causes all of them to timeout).</span>
<span class="cm">		 */</span>
		<span class="n">mmr_image</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">SOFTACK_MSHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_uv2_hub</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">mmr_image</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">UV2_EXT_SHFT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">write_mmr_misc_control</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ptc_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">num_possible_cpus</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ptc_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">num_possible_cpus</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ptc_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">usec_2_cycles</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">microsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">cyc</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">microsec</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">cyc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ns</span> <span class="o">&lt;&lt;</span> <span class="n">CYC2NS_SCALE_FACTOR</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cyc2ns</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">()));</span>
	<span class="k">return</span> <span class="n">cyc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Display the statistics thru /proc/sgi_uv/ptc_statistics</span>
<span class="cm"> * &#39;data&#39; points to the cpu number</span>
<span class="cm"> * Note: see the descriptions in stat_description[].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptc_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">loff_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
			<span class="s">&quot;# cpu sent stime self locals remotes ncpus localhub &quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
			<span class="s">&quot;remotehub numuvhubs numuvhubs16 numuvhubs8 &quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
		    <span class="s">&quot;numuvhubs4 numuvhubs2 numuvhubs1 dto snacks retries rok &quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
			<span class="s">&quot;resetp resett giveup sto bz throt swack recv rtime &quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
			<span class="s">&quot;all one mult none retry canc nocan reset rcan &quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
			<span class="s">&quot;disable enable wars warshw warwaits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="cm">/* source side statistics */</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
			<span class="s">&quot;cpu %d %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld &quot;</span><span class="p">,</span>
			   <span class="n">cpu</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_requestor</span><span class="p">,</span> <span class="n">cycles_2_us</span><span class="p">(</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_time</span><span class="p">),</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntargself</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarglocals</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntargremotes</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntargcpu</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarglocaluvhub</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntargremoteuvhub</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub16</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">&quot;%ld %ld %ld %ld %ld %ld &quot;</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub8</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub4</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub2</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_ntarguvhub1</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_dtimeout</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_strongnacks</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">&quot;%ld %ld %ld %ld %ld %ld %ld %ld &quot;</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_retry_messages</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_retriesok</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_resets_plug</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_resets_timeout</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_giveup</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_stimeout</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_busy</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_throttles</span><span class="p">);</span>

		<span class="cm">/* destination side statistics */</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
			   <span class="s">&quot;%lx %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld &quot;</span><span class="p">,</span>
			   <span class="n">read_gmmr_sw_ack</span><span class="p">(</span><span class="n">uv_cpu_to_pnode</span><span class="p">(</span><span class="n">cpu</span><span class="p">)),</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_requestee</span><span class="p">,</span> <span class="n">cycles_2_us</span><span class="p">(</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_time</span><span class="p">),</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_alltlb</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_onetlb</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_multmsg</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_nomsg</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_retries</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_canceled</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_nocanceled</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_resets</span><span class="p">,</span>
			   <span class="n">stat</span><span class="o">-&gt;</span><span class="n">d_rcanceled</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">&quot;%ld %ld %ld %ld %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_bau_disabled</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_bau_reenabled</span><span class="p">,</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_uv2_wars</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_uv2_wars_hw</span><span class="p">,</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">s_uv2_war_waits</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Display the tunables thru debugfs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">tunables_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">userbuf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;%s %s %s</span><span class="se">\n</span><span class="s">%d %d %d %d %d %d %d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="s">&quot;max_concur plugged_delay plugsb4reset&quot;</span><span class="p">,</span>
		<span class="s">&quot;timeoutsb4reset ipi_reset_limit complete_threshold&quot;</span><span class="p">,</span>
		<span class="s">&quot;congested_response_us congested_reps congested_period&quot;</span><span class="p">,</span>
		<span class="n">max_concurr</span><span class="p">,</span> <span class="n">plugged_delay</span><span class="p">,</span> <span class="n">plugsb4reset</span><span class="p">,</span>
		<span class="n">timeoutsb4reset</span><span class="p">,</span> <span class="n">ipi_reset_limit</span><span class="p">,</span> <span class="n">complete_threshold</span><span class="p">,</span>
		<span class="n">congested_respns_us</span><span class="p">,</span> <span class="n">congested_reps</span><span class="p">,</span> <span class="n">congested_period</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">userbuf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * handle a write to /proc/sgi_uv/ptc_statistics</span>
<span class="cm"> * -1: reset the statistics</span>
<span class="cm"> *  0: display meaning of the statistics</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ptc_proc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">elements</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">input_arg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">optstr</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">optstr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">optstr</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">optstr</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtol</span><span class="p">(</span><span class="n">optstr</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">optstr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">input_arg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">elements</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stat_description</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stat_description</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;# cpu:      cpu number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Sender statistics:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">elements</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat_description</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">input_arg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptc_stats</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">local_atoi</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;</span> <span class="n">name</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;0&#39;</span> <span class="p">...</span> <span class="sc">&#39;9&#39;</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">val</span><span class="o">+</span><span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse the values written to /sys/kernel/debug/sgi_uv/bau_tunables.</span>
<span class="cm"> * Zero values reset them to defaults.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_tunables_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">instr</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tunables</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tunables</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">instr</span> <span class="o">+</span> <span class="n">strspn</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">WHITESPACE</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">strspn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">WHITESPACE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">strcspn</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">WHITESPACE</span><span class="p">);</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;bau tunable error: should be %d values</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">instr</span> <span class="o">+</span> <span class="n">strspn</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">WHITESPACE</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">strspn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">WHITESPACE</span><span class="p">),</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">strcspn</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">WHITESPACE</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">local_atoi</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">max_concurr</span> <span class="o">=</span> <span class="n">MAX_BAU_CONCURRENT</span><span class="p">;</span>
				<span class="n">max_concurr_const</span> <span class="o">=</span> <span class="n">MAX_BAU_CONCURRENT</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cpus_in_uvhub</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
				<span class="s">&quot;Error: BAU max concurrent %d is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">val</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">max_concurr</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="n">max_concurr_const</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="o">*</span><span class="n">tunables</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">tunp</span> <span class="o">=</span> <span class="n">tunables</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">deflt</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="o">*</span><span class="n">tunables</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">tunp</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a write to debugfs. (/sys/kernel/debug/sgi_uv/bau_tunables)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">tunables_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">instr</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">instr</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_tunables_write</span><span class="p">(</span><span class="n">bcp</span><span class="p">,</span> <span class="n">instr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">max_concurr</span> <span class="o">=</span>		<span class="n">max_concurr</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">max_concurr_const</span> <span class="o">=</span>	<span class="n">max_concurr</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugged_delay</span> <span class="o">=</span>		<span class="n">plugged_delay</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugsb4reset</span> <span class="o">=</span>		<span class="n">plugsb4reset</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">timeoutsb4reset</span> <span class="o">=</span>		<span class="n">timeoutsb4reset</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">ipi_reset_limit</span> <span class="o">=</span>		<span class="n">ipi_reset_limit</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">complete_threshold</span> <span class="o">=</span>	<span class="n">complete_threshold</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cong_response_us</span> <span class="o">=</span>		<span class="n">congested_respns_us</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cong_reps</span> <span class="o">=</span>		<span class="n">congested_reps</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cong_period</span> <span class="o">=</span>		<span class="n">congested_period</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">uv_ptc_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">ptc_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>		<span class="o">=</span> <span class="n">ptc_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">ptc_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>		<span class="o">=</span> <span class="n">ptc_seq_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptc_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uv_ptc_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tunables_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_uv_ptc_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">ptc_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">ptc_proc_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tunables_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tunables_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tunables_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tunables_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">uv_ptc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_uv_ptc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_uv_system</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">proc_uv_ptc</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="n">UV_PTC_BASENAME</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">proc_uv_ptc_operations</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_uv_ptc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to create %s proc entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">UV_PTC_BASENAME</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tunables_dir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">UV_BAU_TUNABLES_DIR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tunables_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to create debugfs directory %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">UV_BAU_TUNABLES_DIR</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tunables_file</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">UV_BAU_TUNABLES_FILE</span><span class="p">,</span> <span class="mo">0600</span><span class="p">,</span>
					<span class="n">tunables_dir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tunables_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tunables_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to create debugfs file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">UV_BAU_TUNABLES_FILE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the sending side&#39;s sending buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">activation_descriptor_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base_pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uv1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">dsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bau_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_desc</span> <span class="o">*</span><span class="n">bd2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uv1_bau_msg_header</span> <span class="o">*</span><span class="n">uv1_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uv2_bau_msg_header</span> <span class="o">*</span><span class="n">uv2_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * each bau_desc is 64 bytes; there are 8 (ITEMS_PER_DESC)</span>
<span class="cm">	 * per cpu; and one per cpu on the uvhub (ADP_SZ)</span>
<span class="cm">	 */</span>
	<span class="n">dsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">ADP_SZ</span> <span class="o">*</span> <span class="n">ITEMS_PER_DESC</span><span class="p">;</span>
	<span class="n">bau_desc</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="n">dsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bau_desc</span><span class="p">);</span>

	<span class="n">gpa</span> <span class="o">=</span> <span class="n">uv_gpa</span><span class="p">(</span><span class="n">bau_desc</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">uv_gpa_to_gnode</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">uv_gpa_to_offset</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_uv1_hub</span><span class="p">())</span>
		<span class="n">uv1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* the 14-bit pnode */</span>
	<span class="n">write_mmr_descriptor_base</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">UV_DESC_PSHIFT</span> <span class="o">|</span> <span class="n">m</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initializing all 8 (ITEMS_PER_DESC) descriptors for each</span>
<span class="cm">	 * cpu even though we only use the first one; one descriptor can</span>
<span class="cm">	 * describe a broadcast to 256 uv hubs.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bd2</span> <span class="o">=</span> <span class="n">bau_desc</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ADP_SZ</span> <span class="o">*</span> <span class="n">ITEMS_PER_DESC</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">bd2</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">bd2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_desc</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uv1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uv1_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bd2</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">uv1_hdr</span><span class="p">;</span>
			<span class="n">uv1_hdr</span><span class="o">-&gt;</span><span class="n">swack_flag</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * The base_dest_nasid set in the message header</span>
<span class="cm">			 * is the nasid of the first uvhub in the partition.</span>
<span class="cm">			 * The bit map will indicate destination pnode numbers</span>
<span class="cm">			 * relative to that base. They may not be consecutive</span>
<span class="cm">			 * if nasid striding is being used.</span>
<span class="cm">			 */</span>
			<span class="n">uv1_hdr</span><span class="o">-&gt;</span><span class="n">base_dest_nasid</span> <span class="o">=</span>
						<span class="n">UV_PNODE_TO_NASID</span><span class="p">(</span><span class="n">base_pnode</span><span class="p">);</span>
			<span class="n">uv1_hdr</span><span class="o">-&gt;</span><span class="n">dest_subnodeid</span> <span class="o">=</span>	<span class="n">UV_LB_SUBNODEID</span><span class="p">;</span>
			<span class="n">uv1_hdr</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span>		<span class="n">UV_NET_ENDPOINT_INTD</span><span class="p">;</span>
			<span class="n">uv1_hdr</span><span class="o">-&gt;</span><span class="n">int_both</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * all others need to be set to zero:</span>
<span class="cm">			 *   fairness chaining multilevel count replied_to</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uv2_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bd2</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">uv2_hdr</span><span class="p">;</span>
			<span class="n">uv2_hdr</span><span class="o">-&gt;</span><span class="n">swack_flag</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">;</span>
			<span class="n">uv2_hdr</span><span class="o">-&gt;</span><span class="n">base_dest_nasid</span> <span class="o">=</span>
						<span class="n">UV_PNODE_TO_NASID</span><span class="p">(</span><span class="n">base_pnode</span><span class="p">);</span>
			<span class="n">uv2_hdr</span><span class="o">-&gt;</span><span class="n">dest_subnodeid</span> <span class="o">=</span>	<span class="n">UV_LB_SUBNODEID</span><span class="p">;</span>
			<span class="n">uv2_hdr</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span>		<span class="n">UV_NET_ENDPOINT_INTD</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">!=</span> <span class="n">uv_blade_to_pnode</span><span class="p">(</span><span class="n">uv_cpu_to_blade_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">descriptor_base</span> <span class="o">=</span> <span class="n">bau_desc</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initialize the destination side&#39;s receiving buffers</span>
<span class="cm"> * entered for each uvhub in the partition</span>
<span class="cm"> * - node is first node (kernel memory notion) on the uvhub</span>
<span class="cm"> * - pnode is the uvhub&#39;s physical identifier</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pq_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">plsize</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pn_first</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="n">pqp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">;</span>

	<span class="n">plsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">DEST_Q_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_pq_entry</span><span class="p">);</span>
	<span class="n">vp</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="n">plsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">pqp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">vp</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pqp</span><span class="p">);</span>

	<span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pqp</span> <span class="o">+</span> <span class="mi">31</span><span class="p">;</span>
	<span class="n">pqp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cp</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">!=</span> <span class="n">uv_cpu_to_pnode</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* for every cpu on this pnode: */</span>
		<span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_first</span>	<span class="o">=</span> <span class="n">pqp</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bau_msg_head</span>	<span class="o">=</span> <span class="n">pqp</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_last</span>		<span class="o">=</span> <span class="n">pqp</span> <span class="o">+</span> <span class="p">(</span><span class="n">DEST_Q_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * need the gnode of where the memory was really allocated</span>
<span class="cm">	 */</span>
	<span class="n">pn</span> <span class="o">=</span> <span class="n">uv_gpa_to_gnode</span><span class="p">(</span><span class="n">uv_gpa</span><span class="p">(</span><span class="n">pqp</span><span class="p">));</span>
	<span class="n">first</span> <span class="o">=</span> <span class="n">uv_physnodeaddr</span><span class="p">(</span><span class="n">pqp</span><span class="p">);</span>
	<span class="n">pn_first</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pn</span> <span class="o">&lt;&lt;</span> <span class="n">UV_PAYLOADQ_PNODE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">uv_physnodeaddr</span><span class="p">(</span><span class="n">pqp</span> <span class="o">+</span> <span class="p">(</span><span class="n">DEST_Q_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">write_mmr_payload_first</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">pn_first</span><span class="p">);</span>
	<span class="n">write_mmr_payload_tail</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>
	<span class="n">write_mmr_payload_last</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="n">write_gmmr_sw_ack</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="mh">0xffffUL</span><span class="p">);</span>

	<span class="cm">/* in effect, all msg_type&#39;s are set to MSG_NOOP */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pqp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_pq_entry</span><span class="p">)</span> <span class="o">*</span> <span class="n">DEST_Q_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialization of each UV hub&#39;s structures</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_uvhub</span><span class="p">(</span><span class="kt">int</span> <span class="n">uvhub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base_pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">apicid</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">uvhub_to_first_node</span><span class="p">(</span><span class="n">uvhub</span><span class="p">);</span>
	<span class="n">pnode</span> <span class="o">=</span> <span class="n">uv_blade_to_pnode</span><span class="p">(</span><span class="n">uvhub</span><span class="p">);</span>

	<span class="n">activation_descriptor_init</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pnode</span><span class="p">,</span> <span class="n">base_pnode</span><span class="p">);</span>

	<span class="n">pq_init</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pnode</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The below initialization can&#39;t be in firmware because the</span>
<span class="cm">	 * messaging IRQ will be determined by the OS.</span>
<span class="cm">	 */</span>
	<span class="n">apicid</span> <span class="o">=</span> <span class="n">uvhub_to_first_apicid</span><span class="p">(</span><span class="n">uvhub</span><span class="p">)</span> <span class="o">|</span> <span class="n">uv_apicid_hibits</span><span class="p">;</span>
	<span class="n">write_mmr_data_config</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="p">((</span><span class="n">apicid</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">vector</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We will set BAU_MISC_CONTROL with a timeout period.</span>
<span class="cm"> * But the BIOS has set UVH_AGING_PRESCALE_SEL and UVH_TRANSACTION_TIMEOUT.</span>
<span class="cm"> * So the destination timeout period has to be calculated from them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">calculate_destination_timeout</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mult1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mult2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ts_ns</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_uv1_hub</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">mult1</span> <span class="o">=</span> <span class="n">SOFTACK_TIMEOUT_PERIOD</span> <span class="o">&amp;</span> <span class="n">BAU_MISC_CONTROL_MULT_MASK</span><span class="p">;</span>
		<span class="n">mmr_image</span> <span class="o">=</span> <span class="n">uv_read_local_mmr</span><span class="p">(</span><span class="n">UVH_AGING_PRESCALE_SEL</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">mmr_image</span> <span class="o">&gt;&gt;</span> <span class="n">BAU_URGENCY_7_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BAU_URGENCY_7_MASK</span><span class="p">;</span>
		<span class="n">mmr_image</span> <span class="o">=</span> <span class="n">uv_read_local_mmr</span><span class="p">(</span><span class="n">UVH_TRANSACTION_TIMEOUT</span><span class="p">);</span>
		<span class="n">mult2</span> <span class="o">=</span> <span class="p">(</span><span class="n">mmr_image</span> <span class="o">&gt;&gt;</span> <span class="n">BAU_TRANS_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BAU_TRANS_MASK</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">timeout_base_ns</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">ts_ns</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="n">mult1</span> <span class="o">*</span> <span class="n">mult2</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ts_ns</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* 4 bits  0/1 for 10/80us base, 3 bits of multiplier */</span>
		<span class="n">mmr_image</span> <span class="o">=</span> <span class="n">uv_read_local_mmr</span><span class="p">(</span><span class="n">UVH_LB_BAU_MISC_CONTROL</span><span class="p">);</span>
		<span class="n">mmr_image</span> <span class="o">=</span> <span class="p">(</span><span class="n">mmr_image</span> <span class="o">&amp;</span> <span class="n">UV_SA_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UV_SA_SHFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mmr_image</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">UV2_ACK_UNITS_SHFT</span><span class="p">))</span>
			<span class="n">base</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">base</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">mult1</span> <span class="o">=</span> <span class="n">mmr_image</span> <span class="o">&amp;</span> <span class="n">UV2_ACK_MASK</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mult1</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_per_cpu_tunables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">baudisabled</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">statp</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="cm">/* time interval to catch a hardware stay-busy bug */</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">timeout_interval</span>		<span class="o">=</span> <span class="n">usec_2_cycles</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">timeout_us</span><span class="p">);</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">max_concurr</span>		<span class="o">=</span> <span class="n">max_concurr</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">max_concurr_const</span>		<span class="o">=</span> <span class="n">max_concurr</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugged_delay</span>		<span class="o">=</span> <span class="n">plugged_delay</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">plugsb4reset</span>		<span class="o">=</span> <span class="n">plugsb4reset</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">timeoutsb4reset</span>		<span class="o">=</span> <span class="n">timeoutsb4reset</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">ipi_reset_limit</span>		<span class="o">=</span> <span class="n">ipi_reset_limit</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">complete_threshold</span>		<span class="o">=</span> <span class="n">complete_threshold</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cong_response_us</span>		<span class="o">=</span> <span class="n">congested_respns_us</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cong_reps</span>			<span class="o">=</span> <span class="n">congested_reps</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cong_period</span>		<span class="o">=</span> <span class="n">congested_period</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">clocks_per_100_usec</span> <span class="o">=</span>	<span class="n">usec_2_cycles</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan all cpus to collect blade and socket summaries.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">get_cpu_topology</span><span class="p">(</span><span class="kt">int</span> <span class="n">base_pnode</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">uvhub_desc</span> <span class="o">*</span><span class="n">uvhub_descs</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uvhub_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uvhub</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">socket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uvhub_desc</span> <span class="o">*</span><span class="n">bdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_desc</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">bcp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span><span class="p">));</span>

		<span class="n">pnode</span> <span class="o">=</span> <span class="n">uv_cpu_hub_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pnode</span> <span class="o">-</span> <span class="n">base_pnode</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">UV_DISTRIBUTION_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span>
				<span class="s">&quot;cpu %d pnode %d-%d beyond %d; BAU disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cpu</span><span class="p">,</span> <span class="n">pnode</span><span class="p">,</span> <span class="n">base_pnode</span><span class="p">,</span> <span class="n">UV_DISTRIBUTION_SIZE</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">osnode</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">partition_base_pnode</span> <span class="o">=</span> <span class="n">base_pnode</span><span class="p">;</span>

		<span class="n">uvhub</span> <span class="o">=</span> <span class="n">uv_cpu_hub_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">numa_blade_id</span><span class="p">;</span>
		<span class="o">*</span><span class="p">(</span><span class="n">uvhub_mask</span> <span class="o">+</span> <span class="p">(</span><span class="n">uvhub</span><span class="o">/</span><span class="mi">8</span><span class="p">))</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uvhub</span><span class="o">%</span><span class="mi">8</span><span class="p">));</span>
		<span class="n">bdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uvhub_descs</span><span class="p">[</span><span class="n">uvhub</span><span class="p">];</span>

		<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">num_cpus</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">uvhub</span> <span class="o">=</span> <span class="n">uvhub</span><span class="p">;</span>
		<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">=</span> <span class="n">pnode</span><span class="p">;</span>

		<span class="cm">/* kludge: &#39;assuming&#39; one node per socket, and assuming that</span>
<span class="cm">		   disabling a socket just leaves a gap in node numbers */</span>
		<span class="n">socket</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">osnode</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">socket_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">socket</span><span class="p">);</span>
		<span class="n">sdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">[</span><span class="n">socket</span><span class="p">];</span>
		<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">cpu_number</span><span class="p">[</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">num_cpus</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">num_cpus</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">num_cpus</span> <span class="o">&gt;</span> <span class="n">MAX_CPUS_PER_SOCKET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;%d cpus per socket invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">num_cpus</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Each socket is to get a local array of pnodes/hubs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">make_per_cpu_thp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">smaster</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hpsz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hub_and_pnode</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_possible_cpus</span><span class="p">();</span>

	<span class="n">smaster</span><span class="o">-&gt;</span><span class="n">thp</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="n">hpsz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">smaster</span><span class="o">-&gt;</span><span class="n">osnode</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">smaster</span><span class="o">-&gt;</span><span class="n">thp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hpsz</span><span class="p">);</span>
	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smaster</span><span class="o">-&gt;</span><span class="n">thp</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">pnode</span> <span class="o">=</span> <span class="n">uv_cpu_hub_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
		<span class="n">smaster</span><span class="o">-&gt;</span><span class="n">thp</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">uvhub</span> <span class="o">=</span> <span class="n">uv_cpu_hub_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">numa_blade_id</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Each uvhub is to get a local cpumask.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">make_per_hub_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cpumask_t</span><span class="p">);</span>

	<span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">cpumask</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">hmaster</span><span class="o">-&gt;</span><span class="n">osnode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize all the per_cpu information for the cpu&#39;s on a given socket,</span>
<span class="cm"> * given what has been gathered into the socket_desc struct.</span>
<span class="cm"> * And reports the chosen hub and socket masters back to the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket_desc</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uvhub_desc</span> <span class="o">*</span><span class="n">bdp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">**</span><span class="n">smasterp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">**</span><span class="n">hmasterp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">bcp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">num_cpus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">cpu_number</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">bcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bau_control</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">smasterp</span> <span class="o">=</span> <span class="n">bcp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">hmasterp</span><span class="p">))</span>
				<span class="o">*</span><span class="n">hmasterp</span> <span class="o">=</span> <span class="n">bcp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cpus_in_uvhub</span> <span class="o">=</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">num_cpus</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">cpus_in_socket</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">num_cpus</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">socket_master</span> <span class="o">=</span> <span class="o">*</span><span class="n">smasterp</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub</span> <span class="o">=</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">uvhub</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_uv1_hub</span><span class="p">())</span>
			<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_uv2_hub</span><span class="p">())</span>
			<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;uvhub version not 1 or 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_master</span> <span class="o">=</span> <span class="o">*</span><span class="n">hmasterp</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_cpu</span> <span class="o">=</span> <span class="n">uv_cpu_hub_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">blade_processor_id</span><span class="p">;</span>
		<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">using_desc</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_cpu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_cpu</span> <span class="o">&gt;=</span> <span class="n">MAX_CPUS_PER_UVHUB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;%d cpus per uvhub invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">uvhub_cpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Summarize the blade and socket topology into the per_cpu structures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">summarize_uvhub_sockets</span><span class="p">(</span><span class="kt">int</span> <span class="n">nuvhubs</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">uvhub_desc</span> <span class="o">*</span><span class="n">uvhub_descs</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uvhub_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">socket</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uvhub</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">socket_mask</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">uvhub</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uvhub</span> <span class="o">&lt;</span> <span class="n">nuvhubs</span><span class="p">;</span> <span class="n">uvhub</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">uvhub_desc</span> <span class="o">*</span><span class="n">bdp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">smaster</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">bau_control</span> <span class="o">*</span><span class="n">hmaster</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">uvhub_mask</span> <span class="o">+</span> <span class="p">(</span><span class="n">uvhub</span><span class="o">/</span><span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uvhub</span><span class="o">%</span><span class="mi">8</span><span class="p">))))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">bdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uvhub_descs</span><span class="p">[</span><span class="n">uvhub</span><span class="p">];</span>
		<span class="n">socket_mask</span> <span class="o">=</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">socket_mask</span><span class="p">;</span>
		<span class="n">socket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">socket_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">socket_desc</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">socket_mask</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">[</span><span class="n">socket</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">scan_sock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">bdp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smaster</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hmaster</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">make_per_cpu_thp</span><span class="p">(</span><span class="n">smaster</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">socket</span><span class="o">++</span><span class="p">;</span>
			<span class="n">socket_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">socket_mask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">make_per_hub_cpumask</span><span class="p">(</span><span class="n">hmaster</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initialize the bau_control structure for each cpu</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_per_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">nuvhubs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base_part_pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uvhub_mask</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uvhub_desc</span> <span class="o">*</span><span class="n">uvhub_descs</span><span class="p">;</span>

	<span class="n">timeout_us</span> <span class="o">=</span> <span class="n">calculate_destination_timeout</span><span class="p">();</span>

	<span class="n">vp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nuvhubs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvhub_desc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">uvhub_descs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uvhub_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">vp</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">uvhub_descs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nuvhubs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvhub_desc</span><span class="p">));</span>
	<span class="n">uvhub_mask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="n">nuvhubs</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_cpu_topology</span><span class="p">(</span><span class="n">base_part_pnode</span><span class="p">,</span> <span class="n">uvhub_descs</span><span class="p">,</span> <span class="n">uvhub_mask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">summarize_uvhub_sockets</span><span class="p">(</span><span class="n">nuvhubs</span><span class="p">,</span> <span class="n">uvhub_descs</span><span class="p">,</span> <span class="n">uvhub_mask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">uvhub_descs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">uvhub_mask</span><span class="p">);</span>
	<span class="n">init_per_cpu_tunables</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">uvhub_descs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">uvhub_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialization of BAU-related structures</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">uv_bau_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">uvhub</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nuvhubs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cur_cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vector</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_uv_system</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nobau</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cur_cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">uv_flush_tlb_mask</span><span class="p">,</span> <span class="n">cur_cpu</span><span class="p">);</span>
		<span class="n">zalloc_cpumask_var_node</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cur_cpu</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">nuvhubs</span> <span class="o">=</span> <span class="n">uv_num_possible_blades</span><span class="p">();</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disable_lock</span><span class="p">);</span>
	<span class="n">congested_cycles</span> <span class="o">=</span> <span class="n">usec_2_cycles</span><span class="p">(</span><span class="n">congested_respns_us</span><span class="p">);</span>

	<span class="n">uv_base_pnode</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">uvhub</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uvhub</span> <span class="o">&lt;</span> <span class="n">nuvhubs</span><span class="p">;</span> <span class="n">uvhub</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpus</span> <span class="o">=</span> <span class="n">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="n">uvhub</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpus</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uv_blade_to_pnode</span><span class="p">(</span><span class="n">uvhub</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">uv_base_pnode</span><span class="p">))</span>
			<span class="n">uv_base_pnode</span> <span class="o">=</span> <span class="n">uv_blade_to_pnode</span><span class="p">(</span><span class="n">uvhub</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">enable_timeouts</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_per_cpu</span><span class="p">(</span><span class="n">nuvhubs</span><span class="p">,</span> <span class="n">uv_base_pnode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nobau</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vector</span> <span class="o">=</span> <span class="n">UV_BAU_MESSAGE</span><span class="p">;</span>
	<span class="n">for_each_possible_blade</span><span class="p">(</span><span class="n">uvhub</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="n">uvhub</span><span class="p">))</span>
			<span class="n">init_uvhub</span><span class="p">(</span><span class="n">uvhub</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">uv_base_pnode</span><span class="p">);</span>

	<span class="n">alloc_intr_gate</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">uv_bau_message_intr1</span><span class="p">);</span>

	<span class="n">for_each_possible_blade</span><span class="p">(</span><span class="n">uvhub</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="n">uvhub</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr</span><span class="p">;</span>
			<span class="n">pnode</span> <span class="o">=</span> <span class="n">uv_blade_to_pnode</span><span class="p">(</span><span class="n">uvhub</span><span class="p">);</span>
			<span class="cm">/* INIT the bau */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">;</span>
			<span class="n">write_gmmr_activation</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">mmr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* should be 1 to broadcast to both sockets */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_uv1_hub</span><span class="p">())</span>
				<span class="n">write_mmr_data_broadcast</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">mmr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">uv_bau_init</span><span class="p">);</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">uv_ptc_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
