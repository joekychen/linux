<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › math-emu › fpu_trig.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fpu_trig.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*---------------------------------------------------------------------------+</span>
<span class="cm"> |  fpu_trig.c                                                               |</span>
<span class="cm"> |                                                                           |</span>
<span class="cm"> | Implementation of the FPU &quot;transcendental&quot; functions.                     |</span>
<span class="cm"> |                                                                           |</span>
<span class="cm"> | Copyright (C) 1992,1993,1994,1997,1999                                    |</span>
<span class="cm"> |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |</span>
<span class="cm"> |                       Australia.  E-mail   billm@melbpc.org.au            |</span>
<span class="cm"> |                                                                           |</span>
<span class="cm"> |                                                                           |</span>
<span class="cm"> +---------------------------------------------------------------------------*/</span>

<span class="cp">#include &quot;fpu_system.h&quot;</span>
<span class="cp">#include &quot;exception.h&quot;</span>
<span class="cp">#include &quot;fpu_emu.h&quot;</span>
<span class="cp">#include &quot;status_w.h&quot;</span>
<span class="cp">#include &quot;control_w.h&quot;</span>
<span class="cp">#include &quot;reg_constant.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">rem_kernel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">st0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">st1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="cp">#define BETTER_THAN_486</span>

<span class="cp">#define FCOS  4</span>

<span class="cm">/* Used only by fptan, fsin, fcos, and fsincos. */</span>
<span class="cm">/* This routine produces very accurate results, similar to</span>
<span class="cm">   using a value of pi with more than 128 bits precision. */</span>
<span class="cm">/* Limited measurements show no results worse than 64 bit precision</span>
<span class="cm">   except for the results for arguments close to 2^63, where the</span>
<span class="cm">   precision of the result sometimes degrades to about 63.9 bits */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">trig_arg</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">even</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FPU_REG</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">tmptag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_cw</span> <span class="o">=</span> <span class="n">control_word</span><span class="p">,</span> <span class="n">saved_status</span> <span class="o">=</span> <span class="n">partial_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">st0_tag</span> <span class="o">=</span> <span class="n">TAG_Valid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">63</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">partial_status</span> <span class="o">|=</span> <span class="n">SW_C2</span><span class="p">;</span>	<span class="cm">/* Reduction incomplete. */</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">control_word</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CW_RC</span><span class="p">;</span>
	<span class="n">control_word</span> <span class="o">|=</span> <span class="n">RC_CHOP</span><span class="p">;</span>

	<span class="n">setpositive</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_u_div</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">PR_64_BITS</span> <span class="o">|</span> <span class="n">RC_CHOP</span> <span class="o">|</span> <span class="mh">0x3f</span><span class="p">,</span>
			<span class="n">SIGN_POS</span><span class="p">);</span>

	<span class="n">FPU_round_to_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>	<span class="cm">/* Fortunately, this can&#39;t overflow</span>
<span class="cm">					   to 2^64 */</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rem_kernel</span><span class="p">(</span><span class="n">significand</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">),</span>
			   <span class="o">&amp;</span><span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">),</span>
			   <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">),</span>
			   <span class="n">q</span><span class="p">,</span> <span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">-</span> <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">));</span>
		<span class="n">setexponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">));</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_normalize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">even</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">even</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">st0_tag</span> <span class="o">=</span>
		    <span class="n">FPU_sub</span><span class="p">(</span><span class="n">REV</span> <span class="o">|</span> <span class="n">LOADED</span> <span class="o">|</span> <span class="n">TAG_Valid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">,</span>
			    <span class="n">FULL_PRECISION</span><span class="p">);</span>

<span class="cp">#ifdef BETTER_THAN_486</span>
		<span class="cm">/* So far, the results are exact but based upon a 64 bit</span>
<span class="cm">		   precision approximation to pi/2. The technique used</span>
<span class="cm">		   now is equivalent to using an approximation to pi/2 which</span>
<span class="cm">		   is accurate to about 128 bits. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2extra</span><span class="p">)</span> <span class="o">+</span> <span class="mi">64</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This code gives the effect of having pi/2 to better than</span>
<span class="cm">			   128 bits precision. */</span>

			<span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">setexponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">63</span><span class="p">);</span>
			<span class="n">FPU_normalize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">tmptag</span> <span class="o">=</span>
			    <span class="n">FPU_u_mul</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2extra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span>
				      <span class="n">FULL_PRECISION</span><span class="p">,</span> <span class="n">SIGN_POS</span><span class="p">,</span>
				      <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2extra</span><span class="p">)</span> <span class="o">+</span>
				      <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">));</span>
			<span class="n">setsign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">getsign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2extra</span><span class="p">));</span>
			<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tmptag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FULL_PRECISION</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* CONST_PI2extra is negative, so the result of the addition</span>
<span class="cm">				   can be negative. This means that the argument is actually</span>
<span class="cm">				   in a different quadrant. The correction is always &lt; pi/2,</span>
<span class="cm">				   so it can&#39;t overflow into yet another quadrant. */</span>
				<span class="n">setpositive</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
				<span class="n">q</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* BETTER_THAN_486 */</span><span class="cp"></span>
	<span class="p">}</span>
<span class="cp">#ifdef BETTER_THAN_486</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* So far, the results are exact but based upon a 64 bit</span>
<span class="cm">		   precision approximation to pi/2. The technique used</span>
<span class="cm">		   now is equivalent to using an approximation to pi/2 which</span>
<span class="cm">		   is accurate to about 128 bits. */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2extra</span><span class="p">)</span> <span class="o">+</span> <span class="mi">64</span><span class="p">))</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This code gives the effect of having p/2 to better than</span>
<span class="cm">			   128 bits precision. */</span>

			<span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
			<span class="n">setexponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">63</span><span class="p">);</span>
			<span class="n">FPU_normalize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>	<span class="cm">/* This must return TAG_Valid */</span>
			<span class="n">tmptag</span> <span class="o">=</span>
			    <span class="n">FPU_u_mul</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2extra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span>
				      <span class="n">FULL_PRECISION</span><span class="p">,</span> <span class="n">SIGN_POS</span><span class="p">,</span>
				      <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2extra</span><span class="p">)</span> <span class="o">+</span>
				      <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">));</span>
			<span class="n">setsign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">getsign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2extra</span><span class="p">));</span>
			<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_sub</span><span class="p">(</span><span class="n">LOADED</span> <span class="o">|</span> <span class="p">(</span><span class="n">tmptag</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span>
					  <span class="n">FULL_PRECISION</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">==</span> <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="p">((</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigh</span> <span class="o">&gt;</span> <span class="n">CONST_PI2</span><span class="p">.</span><span class="n">sigh</span><span class="p">)</span>
			     <span class="o">||</span> <span class="p">((</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigh</span> <span class="o">==</span> <span class="n">CONST_PI2</span><span class="p">.</span><span class="n">sigh</span><span class="p">)</span>
				 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigl</span> <span class="o">&gt;</span> <span class="n">CONST_PI2</span><span class="p">.</span><span class="n">sigl</span><span class="p">))))</span> <span class="p">{</span>
				<span class="cm">/* CONST_PI2extra is negative, so the result of the</span>
<span class="cm">				   subtraction can be larger than pi/2. This means</span>
<span class="cm">				   that the argument is actually in a different quadrant.</span>
<span class="cm">				   The correction is always &lt; pi/2, so it can&#39;t overflow</span>
<span class="cm">				   into yet another quadrant. */</span>
				<span class="n">st0_tag</span> <span class="o">=</span>
				    <span class="n">FPU_sub</span><span class="p">(</span><span class="n">REV</span> <span class="o">|</span> <span class="n">LOADED</span> <span class="o">|</span> <span class="n">TAG_Valid</span><span class="p">,</span>
					    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">,</span> <span class="n">FULL_PRECISION</span><span class="p">);</span>
				<span class="n">q</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* BETTER_THAN_486 */</span><span class="cp"></span>

	<span class="n">FPU_settag0</span><span class="p">(</span><span class="n">st0_tag</span><span class="p">);</span>
	<span class="n">control_word</span> <span class="o">=</span> <span class="n">old_cw</span><span class="p">;</span>
	<span class="n">partial_status</span> <span class="o">=</span> <span class="n">saved_status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SW_C2</span><span class="p">;</span>	<span class="cm">/* Reduction complete. */</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="n">even</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a long to register */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">convert_l2reg</span><span class="p">(</span><span class="kt">long</span> <span class="k">const</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">deststnr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">sign</span><span class="p">;</span>
	<span class="n">FPU_REG</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="n">deststnr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FPU_copy_to_regi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_Z</span><span class="p">,</span> <span class="n">TAG_Zero</span><span class="p">,</span> <span class="n">deststnr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sign</span> <span class="o">=</span> <span class="n">SIGN_POS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="n">num</span><span class="p">;</span>
		<span class="n">sign</span> <span class="o">=</span> <span class="n">SIGN_NEG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dest</span><span class="o">-&gt;</span><span class="n">sigh</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">dest</span><span class="o">-&gt;</span><span class="n">sigl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">setexponent16</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_normalize</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="n">FPU_settagi</span><span class="p">(</span><span class="n">deststnr</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="n">setsign</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">single_arg_error</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)</span>
		<span class="n">FPU_stack_underflow</span><span class="p">();</span>	<span class="cm">/* Puts a QNaN in st(0) */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">)</span>
		<span class="n">real_1op_NaN</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>	<span class="cm">/* return with a NaN in st(0) */</span>
<span class="cp">#ifdef PARANOID</span>
	<span class="k">else</span>
		<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_INTERNAL</span> <span class="o">|</span> <span class="mh">0x0112</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* PARANOID */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">single_arg_2_error</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">isNaN</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">st0_tag</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TW_NaN</span>:
		<span class="n">isNaN</span> <span class="o">=</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">==</span> <span class="n">EXP_OVER</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigh</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isNaN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigh</span> <span class="o">&amp;</span> <span class="mh">0x40000000</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* Signaling ? */</span>
			<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_Invalid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">control_word</span> <span class="o">&amp;</span> <span class="n">CW_Invalid</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* The masked response */</span>
				<span class="cm">/* Convert to a QNaN */</span>
				<span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigh</span> <span class="o">|=</span> <span class="mh">0x40000000</span><span class="p">;</span>
				<span class="n">push</span><span class="p">();</span>
				<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isNaN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* A QNaN */</span>
			<span class="n">push</span><span class="p">();</span>
			<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* pseudoNaN or other unsupported */</span>
			<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_Invalid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">control_word</span> <span class="o">&amp;</span> <span class="n">CW_Invalid</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* The masked response */</span>
				<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_QNaN</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
				<span class="n">push</span><span class="p">();</span>
				<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_QNaN</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>		<span class="cm">/* return with a NaN in st(0) */</span>
<span class="cp">#ifdef PARANOID</span>
	<span class="nl">default:</span>
		<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_INTERNAL</span> <span class="o">|</span> <span class="mh">0x0112</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* PARANOID */</span><span class="cp"></span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*---------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">f2xm1</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FPU_REG</span> <span class="n">a</span><span class="p">;</span>

	<span class="n">clear_C1</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For an 80486 FPU, the result is undefined if the arg is &gt;= 1.0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		      <span class="nl">denormal_arg:</span>

			<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>

			<span class="cm">/* poly_2xm1(x) requires 0 &lt; st(0) &lt; 1. */</span>
			<span class="n">poly_2xm1</span><span class="p">(</span><span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">set_precision_flag_up</span><span class="p">();</span>	<span class="cm">/* 80486 appears to always do this */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TW_Denormal</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">denormal_arg</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TW_Infinity</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* -infinity gives -1 (p16-10) */</span>
			<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_1</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
			<span class="n">setnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">single_arg_error</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fptan</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st_new_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">arg_sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="cm">/* Stack underflow has higher priority */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FPU_stack_underflow</span><span class="p">();</span>	<span class="cm">/* Puts a QNaN in st(0) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">control_word</span> <span class="o">&amp;</span> <span class="n">CW_Invalid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">st_new_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">push</span><span class="p">();</span>
			<span class="n">FPU_stack_underflow</span><span class="p">();</span>	<span class="cm">/* Puts a QNaN in the new st(0) */</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">STACK_OVERFLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FPU_stack_overflow</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">40</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">trig_arg</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Operand is out of range */</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">poly_tan</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
			<span class="n">setsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">arg_sign</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">));</span>
			<span class="n">set_precision_flag_up</span><span class="p">();</span>	<span class="cm">/* We do not really know if up or down */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* For a small arg, the result == the argument */</span>
			<span class="cm">/* Underflow may happen */</span>

		      <span class="nl">denormal_arg:</span>

			<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>

			<span class="n">st0_tag</span> <span class="o">=</span>
			    <span class="n">FPU_round</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FULL_PRECISION</span><span class="p">,</span> <span class="n">arg_sign</span><span class="p">);</span>
			<span class="n">FPU_settag0</span><span class="p">(</span><span class="n">st0_tag</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">push</span><span class="p">();</span>
		<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_1</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">push</span><span class="p">();</span>
		<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_1</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
		<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">denormal_arg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The 80486 treats infinity as an invalid operand */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">st_new_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">push</span><span class="p">();</span>
			<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">single_arg_2_error</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fxtract</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st_new_ptr</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">sign</span><span class="p">;</span>
	<span class="k">register</span> <span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st1_ptr</span> <span class="o">=</span> <span class="n">st0_ptr</span><span class="p">;</span>	<span class="cm">/* anticipate */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">STACK_OVERFLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FPU_stack_overflow</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clear_C1</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">e</span><span class="p">;</span>

		<span class="n">push</span><span class="p">();</span>
		<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
		<span class="n">reg_copy</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">st_new_ptr</span><span class="p">);</span>
		<span class="n">setexponent16</span><span class="p">(</span><span class="n">st_new_ptr</span><span class="p">,</span> <span class="n">exponent</span><span class="p">(</span><span class="n">st_new_ptr</span><span class="p">));</span>

	      <span class="nl">denormal_arg:</span>

		<span class="n">e</span> <span class="o">=</span> <span class="n">exponent16</span><span class="p">(</span><span class="n">st_new_ptr</span><span class="p">);</span>
		<span class="n">convert_l2reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">setexponentpos</span><span class="p">(</span><span class="n">st_new_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">setsign</span><span class="p">(</span><span class="n">st_new_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
		<span class="n">FPU_settag0</span><span class="p">(</span><span class="n">TAG_Valid</span><span class="p">);</span>	<span class="cm">/* Needed if arg was a denormal */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">FPU_divide_by_zero</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SIGN_NEG</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">push</span><span class="p">();</span>
		<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_Z</span><span class="p">,</span> <span class="n">TAG_Zero</span><span class="p">);</span>
		<span class="n">setsign</span><span class="p">(</span><span class="n">st_new_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">push</span><span class="p">();</span>
		<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
		<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">st_new_ptr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">denormal_arg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
		<span class="n">setpositive</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
		<span class="n">push</span><span class="p">();</span>
		<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_INF</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
		<span class="n">setsign</span><span class="p">(</span><span class="n">st_new_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">real_1op_NaN</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">push</span><span class="p">();</span>
		<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Is this the correct behaviour? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">control_word</span> <span class="o">&amp;</span> <span class="n">EX_Invalid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">FPU_stack_underflow</span><span class="p">();</span>
			<span class="n">push</span><span class="p">();</span>
			<span class="n">FPU_stack_underflow</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_StackUnder</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef PARANOID</span>
	<span class="k">else</span>
		<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_INTERNAL</span> <span class="o">|</span> <span class="mh">0x119</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* PARANOID */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fdecstp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_C1</span><span class="p">();</span>
	<span class="n">top</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fincstp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_C1</span><span class="p">();</span>
	<span class="n">top</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsqrt_</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">expon</span><span class="p">;</span>

	<span class="n">clear_C1</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_char</span> <span class="n">tag</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* sqrt(negative) is invalid */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* make st(0) in  [1.0 .. 4.0) */</span>
		<span class="n">expon</span> <span class="o">=</span> <span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	      <span class="nl">denormal_arg:</span>

		<span class="n">setexponent16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">expon</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">));</span>

		<span class="cm">/* Do the computation, the sign of the result will be positive. */</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">wm_sqrt</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">control_word</span><span class="p">,</span> <span class="n">SIGN_POS</span><span class="p">);</span>
		<span class="n">addexponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">expon</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">FPU_settag0</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span>
			<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* sqrt(-Infinity) is invalid */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* sqrt(negative) is invalid */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>

		<span class="n">expon</span> <span class="o">=</span> <span class="n">exponent16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">denormal_arg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">single_arg_error</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">frndint_</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">tag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_char</span> <span class="n">sign</span><span class="p">;</span>

	      <span class="nl">denormal_arg:</span>

		<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">63</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Fortunately, this can&#39;t overflow to 2^64 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FPU_round_to_int</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">)))</span>
			<span class="n">set_precision_flag</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">setexponent16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="mi">63</span><span class="p">);</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_normalize</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
		<span class="n">setsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
		<span class="n">FPU_settag0</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">denormal_arg</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">single_arg_error</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsin</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">arg_sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">q</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">40</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">trig_arg</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Operand is out of range */</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">poly_sine</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">changesign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

			<span class="n">setsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">^</span> <span class="n">arg_sign</span><span class="p">);</span>

			<span class="cm">/* We do not really know if up or down */</span>
			<span class="n">set_precision_flag_up</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* For a small arg, the result == the argument */</span>
			<span class="n">set_precision_flag_up</span><span class="p">();</span>	<span class="cm">/* Must be up. */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* For a small arg, the result == the argument */</span>
		<span class="cm">/* Underflow may happen */</span>
		<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>

		<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_round</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FULL_PRECISION</span><span class="p">,</span> <span class="n">arg_sign</span><span class="p">);</span>

		<span class="n">FPU_settag0</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The 80486 treats infinity as an invalid operand */</span>
		<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">single_arg_error</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">f_cos</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">st0_sign</span><span class="p">;</span>

	<span class="n">st0_sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">q</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">40</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">((</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">significand</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;=</span>
				    <span class="mh">0xc90fdaa22168c234LL</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">poly_cos</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

				<span class="cm">/* We do not really know if up or down */</span>
				<span class="n">set_precision_flag_down</span><span class="p">();</span>

				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">trig_arg</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">FCOS</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">poly_sine</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
					<span class="n">changesign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

				<span class="cm">/* We do not really know if up or down */</span>
				<span class="n">set_precision_flag_down</span><span class="p">();</span>

				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Operand is out of range */</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		      <span class="nl">denormal_arg:</span>

			<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_1</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
<span class="cp">#ifdef PECULIAR_486</span>
			<span class="n">set_precision_flag_down</span><span class="p">();</span>	<span class="cm">/* 80486 appears to do this. */</span>
<span class="cp">#else</span>
			<span class="n">set_precision_flag_up</span><span class="p">();</span>	<span class="cm">/* Must be up. */</span>
<span class="cp">#endif </span><span class="cm">/* PECULIAR_486 */</span><span class="cp"></span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_1</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
		<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">denormal_arg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The 80486 treats infinity as an invalid operand */</span>
		<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">single_arg_error</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>	<span class="cm">/* requires st0_ptr == &amp;st(0) */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fcos</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">f_cos</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsincos</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st_new_ptr</span><span class="p">;</span>
	<span class="n">FPU_REG</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">tag</span><span class="p">;</span>

	<span class="cm">/* Stack underflow has higher priority */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FPU_stack_underflow</span><span class="p">();</span>	<span class="cm">/* Puts a QNaN in st(0) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">control_word</span> <span class="o">&amp;</span> <span class="n">CW_Invalid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">st_new_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">push</span><span class="p">();</span>
			<span class="n">FPU_stack_underflow</span><span class="p">();</span>	<span class="cm">/* Puts a QNaN in the new st(0) */</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">STACK_OVERFLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FPU_stack_overflow</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">st0_tag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">single_arg_2_error</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">TW_NaN</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The 80486 treats infinity as an invalid operand */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Masked response */</span>
			<span class="n">push</span><span class="p">();</span>
			<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reg_copy</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsin</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">push</span><span class="p">();</span>
		<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">);</span>
		<span class="n">f_cos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">st0_tag</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* An error, so restore st(0) */</span>
		<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*---------------------------------------------------------------------------*/</span>
<span class="cm">/* The following all require two arguments: st(0) and st(1) */</span>

<span class="cm">/* A lean, mean kernel for the fprem instructions. This relies upon</span>
<span class="cm">   the division and rounding to an integer in do_fprem giving an</span>
<span class="cm">   exact result. Because of this, rem_kernel() needs to deal only with</span>
<span class="cm">   the least significant 64 bits, the more significant bits of the</span>
<span class="cm">   result must be zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rem_kernel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">st0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">st1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>

	<span class="n">x</span> <span class="o">=</span> <span class="n">st0</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* Do the required multiplication and subtraction in the one operation */</span>

	<span class="cm">/* lsw x -= lsw st1 * lsw q */</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;mull %4; subl %%eax,%0; sbbl %%edx,%1&quot;</span><span class="o">:</span><span class="s">&quot;=m&quot;</span>
		      <span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="s">&quot;=m&quot;</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
		      <span class="s">&quot;=a&quot;</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
		      <span class="o">:</span><span class="s">&quot;2&quot;</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="s">&quot;m&quot;</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">q</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
		      <span class="o">:</span><span class="s">&quot;%dx&quot;</span><span class="p">);</span>
	<span class="cm">/* msw x -= msw st1 * lsw q */</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;mull %3; subl %%eax,%0&quot;</span><span class="o">:</span><span class="s">&quot;=m&quot;</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
		      <span class="s">&quot;=a&quot;</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
		      <span class="o">:</span><span class="s">&quot;1&quot;</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span> <span class="s">&quot;m&quot;</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">q</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
		      <span class="o">:</span><span class="s">&quot;%dx&quot;</span><span class="p">);</span>
	<span class="cm">/* msw x -= lsw st1 * msw q */</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;mull %3; subl %%eax,%0&quot;</span><span class="o">:</span><span class="s">&quot;=m&quot;</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
		      <span class="s">&quot;=a&quot;</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
		      <span class="o">:</span><span class="s">&quot;1&quot;</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="s">&quot;m&quot;</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">q</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
		      <span class="o">:</span><span class="s">&quot;%dx&quot;</span><span class="p">);</span>

	<span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remainder of st(0) / st(1) */</span>
<span class="cm">/* This routine produces exact results, i.e. there is never any</span>
<span class="cm">   rounding or truncation, etc of the result. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_fprem</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">round</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st1_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">u_char</span> <span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_gettagi</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">st0_tag</span> <span class="o">^</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">^</span> <span class="n">TAG_Valid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">FPU_REG</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">st0</span><span class="p">,</span> <span class="n">st1</span><span class="p">;</span>
		<span class="n">u_char</span> <span class="n">st0_sign</span><span class="p">,</span> <span class="n">st1_sign</span><span class="p">;</span>
		<span class="n">u_char</span> <span class="n">tmptag</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">old_cw</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">expdif</span><span class="p">;</span>
		<span class="kt">long</span> <span class="kt">long</span> <span class="n">q</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">saved_status</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cc</span><span class="p">;</span>

	      <span class="nl">fprem_valid:</span>
		<span class="cm">/* Convert registers for internal use. */</span>
		<span class="n">st0_sign</span> <span class="o">=</span> <span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st0</span><span class="p">);</span>
		<span class="n">st1_sign</span> <span class="o">=</span> <span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st1</span><span class="p">);</span>
		<span class="n">expdif</span> <span class="o">=</span> <span class="n">exponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st0</span><span class="p">)</span> <span class="o">-</span> <span class="n">exponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">);</span>

		<span class="n">old_cw</span> <span class="o">=</span> <span class="n">control_word</span><span class="p">;</span>
		<span class="n">cc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* We want the status following the denorm tests, but don&#39;t want</span>
<span class="cm">		   the status changed by the arithmetic operations. */</span>
		<span class="n">saved_status</span> <span class="o">=</span> <span class="n">partial_status</span><span class="p">;</span>
		<span class="n">control_word</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CW_RC</span><span class="p">;</span>
		<span class="n">control_word</span> <span class="o">|=</span> <span class="n">RC_CHOP</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">expdif</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This should be the most common case */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">expdif</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u_char</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">st0_sign</span> <span class="o">^</span> <span class="n">st1_sign</span><span class="p">;</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_u_div</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span>
						<span class="n">PR_64_BITS</span> <span class="o">|</span> <span class="n">RC_CHOP</span> <span class="o">|</span> <span class="mh">0x3f</span><span class="p">,</span>
						<span class="n">sign</span><span class="p">);</span>
				<span class="n">setsign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">FPU_round_to_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>	<span class="cm">/* Fortunately, this can&#39;t</span>
<span class="cm">									   overflow to 2^64 */</span>
					<span class="n">q</span> <span class="o">=</span> <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>

					<span class="n">rem_kernel</span><span class="p">(</span><span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st0</span><span class="p">),</span>
						   <span class="o">&amp;</span><span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">),</span>
						   <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">),</span>
						   <span class="n">q</span><span class="p">,</span> <span class="n">expdif</span><span class="p">);</span>

					<span class="n">setexponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">exponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">));</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">reg_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
					<span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">round</span> <span class="o">==</span> <span class="n">RC_RND</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">sigh</span> <span class="o">&amp;</span> <span class="mh">0xc0000000</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* We may need to subtract st(1) once more,</span>
<span class="cm">					   to get a result &lt;= 1/2 of st(1). */</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
					<span class="n">expdif</span> <span class="o">=</span>
					    <span class="n">exponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">)</span> <span class="o">-</span> <span class="n">exponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">expdif</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">expdif</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
							<span class="n">x</span> <span class="o">=</span> <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">)</span> <span class="o">-</span>
							    <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
						<span class="k">else</span>	<span class="cm">/* expdif is 1 */</span>
							<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">)</span>
							     <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
							    <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span> <span class="o">||</span>
						    <span class="cm">/* or equi-distant (from 0 &amp; st(1)) and q is odd */</span>
						    <span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span>
						     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
							<span class="n">st0_sign</span> <span class="o">=</span> <span class="o">!</span><span class="n">st0_sign</span><span class="p">;</span>
							<span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
							<span class="n">q</span><span class="o">++</span><span class="p">;</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span>
					<span class="n">cc</span> <span class="o">|=</span> <span class="n">SW_C0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
					<span class="n">cc</span> <span class="o">|=</span> <span class="n">SW_C3</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">cc</span> <span class="o">|=</span> <span class="n">SW_C1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">control_word</span> <span class="o">=</span> <span class="n">old_cw</span><span class="p">;</span>
				<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* There is a large exponent difference ( &gt;= 64 ) */</span>
			<span class="cm">/* To make much sense, the code in this section should</span>
<span class="cm">			   be done at high precision. */</span>
			<span class="kt">int</span> <span class="n">exp_1</span><span class="p">,</span> <span class="n">N</span><span class="p">;</span>
			<span class="n">u_char</span> <span class="n">sign</span><span class="p">;</span>

			<span class="cm">/* prevent overflow here */</span>
			<span class="cm">/* N is &#39;a number between 32 and 63&#39; (p26-113) */</span>
			<span class="n">reg_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">tmptag</span> <span class="o">=</span> <span class="n">st0_tag</span><span class="p">;</span>
			<span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">expdif</span> <span class="o">&amp;</span> <span class="mh">0x0000001f</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">;</span>	<span class="cm">/* This choice gives results</span>
<span class="cm">							   identical to an AMD 486 */</span>
			<span class="n">setexponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
			<span class="n">exp_1</span> <span class="o">=</span> <span class="n">exponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">);</span>
			<span class="n">setexponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">expdif</span> <span class="o">-=</span> <span class="n">N</span><span class="p">;</span>

			<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="o">^</span> <span class="n">st1_sign</span><span class="p">;</span>
			<span class="n">tag</span> <span class="o">=</span>
			    <span class="n">FPU_u_div</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span>
				      <span class="n">PR_64_BITS</span> <span class="o">|</span> <span class="n">RC_CHOP</span> <span class="o">|</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
			<span class="n">setsign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>

			<span class="n">FPU_round_to_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>	<span class="cm">/* Fortunately, this can&#39;t</span>
<span class="cm">							   overflow to 2^64 */</span>

			<span class="n">rem_kernel</span><span class="p">(</span><span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st0</span><span class="p">),</span>
				   <span class="o">&amp;</span><span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">),</span>
				   <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st1</span><span class="p">),</span>
				   <span class="n">significand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">),</span> <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span>
			    <span class="p">);</span>
			<span class="n">setexponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">exp_1</span> <span class="o">+</span> <span class="n">expdif</span><span class="p">);</span>

			<span class="cm">/* It is possible for the operation to be complete here.</span>
<span class="cm">			   What does the IEEE standard say? The Intel 80486 manual</span>
<span class="cm">			   implies that the operation will never be completed at this</span>
<span class="cm">			   point, and the behaviour of a real 80486 confirms this.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">sigh</span> <span class="o">|</span> <span class="n">tmp</span><span class="p">.</span><span class="n">sigl</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* The result is zero */</span>
				<span class="n">control_word</span> <span class="o">=</span> <span class="n">old_cw</span><span class="p">;</span>
				<span class="n">partial_status</span> <span class="o">=</span> <span class="n">saved_status</span><span class="p">;</span>
				<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_Z</span><span class="p">,</span> <span class="n">TAG_Zero</span><span class="p">);</span>
				<span class="n">setsign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st0</span><span class="p">,</span> <span class="n">st0_sign</span><span class="p">);</span>
<span class="cp">#ifdef PECULIAR_486</span>
				<span class="n">setcc</span><span class="p">(</span><span class="n">SW_C2</span><span class="p">);</span>
<span class="cp">#else</span>
				<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* PECULIAR_486 */</span><span class="cp"></span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cc</span> <span class="o">=</span> <span class="n">SW_C2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">control_word</span> <span class="o">=</span> <span class="n">old_cw</span><span class="p">;</span>
		<span class="n">partial_status</span> <span class="o">=</span> <span class="n">saved_status</span><span class="p">;</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_normalize_nuo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">reg_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>

		<span class="cm">/* The only condition to be looked for is underflow,</span>
<span class="cm">		   and it can occur here only if underflow is unmasked. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">exponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">EXP_UNDER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">TAG_Zero</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">control_word</span> <span class="o">&amp;</span> <span class="n">CW_Underflow</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">setcc</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">arith_underflow</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
			<span class="n">setsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_sign</span><span class="p">);</span>
			<span class="n">FPU_settag0</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">exponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXP_UNDER</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">stdexp</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
			<span class="n">setsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_sign</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tag</span> <span class="o">=</span>
			    <span class="n">FPU_round</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FULL_PRECISION</span><span class="p">,</span> <span class="n">st0_sign</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">FPU_settag0</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
		<span class="n">setcc</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fprem_valid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FPU_stack_underflow</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* fprem(?,0) always invalid */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* fprem(Valid,Zero) is invalid */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">!=</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
			     <span class="o">||</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">))</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* fprem(Valid,Infinity) is o.k. */</span>
				<span class="n">setcc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">!=</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* fprem(Infinity,?) is invalid */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* One of the registers must contain a NaN if we got here. */</span>

<span class="cp">#ifdef PARANOID</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">!=</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">!=</span> <span class="n">TW_NaN</span><span class="p">))</span>
		<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_INTERNAL</span> <span class="o">|</span> <span class="mh">0x118</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* PARANOID */</span><span class="cp"></span>

	<span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">st1_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">st1_ptr</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* ST(1) &lt;- ST(1) * log ST;  pop ST */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fyl2x</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st1_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">exponent</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_gettagi</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">u_char</span> <span class="n">sign</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">e</span><span class="p">,</span> <span class="n">tag</span><span class="p">;</span>

	<span class="n">clear_C1</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">))</span> <span class="p">{</span>
	      <span class="nl">both_valid:</span>
		<span class="cm">/* Both regs are Valid or Denormal */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signpositive</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
				<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="cm">/* Convert st(0) for internal use. */</span>
				<span class="n">setexponent16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigh</span> <span class="o">==</span> <span class="mh">0x80000000</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Special case. The result can be precise. */</span>
				<span class="n">u_char</span> <span class="n">esign</span><span class="p">;</span>
				<span class="n">e</span> <span class="o">=</span> <span class="n">exponent16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">exponent</span><span class="p">.</span><span class="n">sigh</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
					<span class="n">esign</span> <span class="o">=</span> <span class="n">SIGN_POS</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">exponent</span><span class="p">.</span><span class="n">sigh</span> <span class="o">=</span> <span class="o">-</span><span class="n">e</span><span class="p">;</span>
					<span class="n">esign</span> <span class="o">=</span> <span class="n">SIGN_NEG</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">exponent</span><span class="p">.</span><span class="n">sigl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">setexponent16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="n">FPU_normalize_nuo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exponent</span><span class="p">);</span>
				<span class="n">stdexp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exponent</span><span class="p">);</span>
				<span class="n">setsign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exponent</span><span class="p">,</span> <span class="n">esign</span><span class="p">);</span>
				<span class="n">tag</span> <span class="o">=</span>
				    <span class="n">FPU_mul</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exponent</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FULL_PRECISION</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">FPU_settagi</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* The usual case */</span>
				<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
					<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">st1_ptr</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="cm">/* Convert st(1) for internal use. */</span>
					<span class="n">setexponent16</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span>
						      <span class="n">exponent</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">));</span>
				<span class="n">poly_l2</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st1_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* negative */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">FPU_pop</span><span class="p">();</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FPU_stack_underflow_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">&lt;=</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">&lt;=</span> <span class="n">TW_Denormal</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Both args zero is invalid */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">u_char</span> <span class="n">sign</span><span class="p">;</span>
				<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">)</span> <span class="o">^</span> <span class="n">SIGN_NEG</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">FPU_divide_by_zero</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sign</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>

				<span class="n">setsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* st(1) contains zero, st(0) valid &lt;&gt; 0 */</span>
			<span class="cm">/* Zero is the valid answer */</span>
			<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* log(negative) */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
				   <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">sign</span> <span class="o">^=</span> <span class="n">SIGN_NEG</span><span class="p">;</span>

				<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_Z</span><span class="p">,</span> <span class="n">TAG_Zero</span><span class="p">);</span>
				<span class="n">setsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* One or both operands are denormals. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">both_valid</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* One or both arg must be an infinity */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* log(-infinity) or 0*log(infinity) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">u_char</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_INF</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
			<span class="n">setsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* st(1) must be infinity here */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">))</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">signpositive</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigh</span> <span class="o">==</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* st(0) holds 1.0 */</span>
				<span class="cm">/* infinity*log(1) */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* else st(0) is positive and &gt; 1.0 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* st(0) is positive and &lt; 1.0 */</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="n">changesign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* st(0) must be zero or negative */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This should be invalid, but a real 80486 is happy with it. */</span>

<span class="cp">#ifndef PECULIAR_486</span>
			<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">FPU_divide_by_zero</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sign</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* PECULIAR_486 */</span><span class="cp"></span>

			<span class="n">changesign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* log(negative) */</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">FPU_pop</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fpatan</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st1_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">u_char</span> <span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_gettagi</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>

	<span class="n">clear_C1</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">st0_tag</span> <span class="o">^</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">^</span> <span class="n">TAG_Valid</span><span class="p">)))</span> <span class="p">{</span>
	      <span class="nl">valid_atan:</span>

		<span class="n">poly_atan</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="n">st1_ptr</span><span class="p">,</span> <span class="n">st1_tag</span><span class="p">);</span>

		<span class="n">FPU_pop</span><span class="p">();</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">valid_atan</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FPU_stack_underflow_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">FPU_pop</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u_char</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">signpositive</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI4</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">setpositive</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
					<span class="n">tag</span> <span class="o">=</span>
					    <span class="n">FPU_u_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">,</span>
						      <span class="n">st1_ptr</span><span class="p">,</span> <span class="n">FULL_PRECISION</span><span class="p">,</span>
						      <span class="n">SIGN_POS</span><span class="p">,</span>
						      <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI4</span><span class="p">),</span>
						      <span class="n">exponent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">));</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">FPU_settagi</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
					<span class="k">return</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">signpositive</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_Z</span><span class="p">,</span> <span class="n">TAG_Zero</span><span class="p">);</span>
					<span class="n">setsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>	<span class="cm">/* An 80486 preserves the sign */</span>
					<span class="n">FPU_pop</span><span class="p">();</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* st(1) is infinity, st(0) not infinity */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">setsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* st(0) must be valid or zero */</span>
		<span class="n">u_char</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signpositive</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* An 80486 preserves the sign */</span>
			<span class="n">FPU_pop</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
		<span class="n">setsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* st(1) must be TAG_Valid here */</span>
		<span class="n">u_char</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_PI2</span><span class="p">,</span> <span class="n">TAG_Valid</span><span class="p">);</span>
		<span class="n">setsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef PARANOID</span>
	<span class="k">else</span>
		<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_INTERNAL</span> <span class="o">|</span> <span class="mh">0x125</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* PARANOID */</span><span class="cp"></span>

	<span class="n">FPU_pop</span><span class="p">();</span>
	<span class="n">set_precision_flag_up</span><span class="p">();</span>	<span class="cm">/* We do not really know if up or down */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fprem</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_fprem</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="n">RC_CHOP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fprem1</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_fprem</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="n">RC_RND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fyl2xp1</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">sign</span><span class="p">,</span> <span class="n">sign1</span><span class="p">;</span>
	<span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st1_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_gettagi</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">clear_C1</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">st0_tag</span> <span class="o">^</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">^</span> <span class="n">TAG_Valid</span><span class="p">)))</span> <span class="p">{</span>
	      <span class="nl">valid_yl2xp1:</span>

		<span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
		<span class="n">sign1</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

		<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
		<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">poly_l2p1</span><span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="n">sign1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">st1_ptr</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">FPU_pop</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">valid_yl2xp1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FPU_stack_underflow_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">st1_tag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TW_Denormal</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TAG_Zero</span>:
		<span class="k">case</span> <span class="n">TAG_Valid</span>:
			<span class="n">setsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">^</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">));</span>
			<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_Infinity</span>:
			<span class="cm">/* Infinity*log(1) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_NaN</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
<span class="cp">#ifdef PARANOID</span>
			<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_INTERNAL</span> <span class="o">|</span> <span class="mh">0x116</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* PARANOID */</span><span class="cp"></span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">st1_tag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TAG_Zero</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* st(0) holds &lt;= -1.0 */</span>
<span class="cp">#ifdef PECULIAR_486		</span><span class="cm">/* Stupid 80486 doesn&#39;t worry about log(negative). */</span><span class="cp"></span>
					<span class="n">changesign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
<span class="cp">#else</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* PECULIAR_486 */</span><span class="cp"></span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
					   <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">changesign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
				   <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_Infinity</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="p">((</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigh</span> <span class="o">==</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				      <span class="p">(</span><span class="n">st0_ptr</span><span class="o">-&gt;</span><span class="n">sigl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* st(0) holds &lt; -1.0 */</span>
<span class="cp">#ifdef PECULIAR_486		</span><span class="cm">/* Stupid 80486 doesn&#39;t worry about log(negative). */</span><span class="cp"></span>
					<span class="n">changesign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
<span class="cp">#else</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
						<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* PECULIAR_486 */</span><span class="cp"></span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
					   <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">changesign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
				   <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_NaN</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_tag</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifndef PECULIAR_486</span>
			<span class="cm">/* This should have higher priority than denormals, but... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* log(-infinity) */</span>
				<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* PECULIAR_486 */</span><span class="cp"></span>
			<span class="k">if</span> <span class="p">((</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
<span class="cp">#ifdef PECULIAR_486</span>
			<span class="cm">/* Denormal operands actually get higher priority */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* log(-infinity) */</span>
				<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* PECULIAR_486 */</span><span class="cp"></span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* log(infinity) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arith_invalid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* st(1) must be valid here. */</span>

		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* The Manual says that log(Infinity) is invalid, but a real</span>
<span class="cm">		   80486 sensibly says that it is o.k. */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">u_char</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>
			<span class="n">FPU_copy_to_reg1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_INF</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
			<span class="n">setsign</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef PARANOID</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_INTERNAL</span> <span class="o">|</span> <span class="mh">0x117</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* PARANOID */</span><span class="cp"></span>

	<span class="n">FPU_pop</span><span class="p">();</span>
	<span class="k">return</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fscale</span><span class="p">(</span><span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">st0_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FPU_REG</span> <span class="o">*</span><span class="n">st1_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">u_char</span> <span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_gettagi</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">old_cw</span> <span class="o">=</span> <span class="n">control_word</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">getsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

	<span class="n">clear_C1</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">st0_tag</span> <span class="o">^</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">^</span> <span class="n">TAG_Valid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">scale</span><span class="p">;</span>
		<span class="n">FPU_REG</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/* Convert register for internal use. */</span>
		<span class="n">setexponent16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">exponent</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">));</span>

	      <span class="nl">valid_scale:</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* 2^31 is far too large, would require 2^(2^30) or 2^(-2^30) */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">signpositive</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_Overflow</span><span class="p">);</span>
				<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_INF</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_Underflow</span><span class="p">);</span>
				<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_Z</span><span class="p">,</span> <span class="n">TAG_Zero</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">setsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">control_word</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CW_RC</span><span class="p">;</span>
		<span class="n">control_word</span> <span class="o">|=</span> <span class="n">RC_CHOP</span><span class="p">;</span>
		<span class="n">reg_copy</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">FPU_round_to_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">st1_tag</span><span class="p">);</span>	<span class="cm">/* This can never overflow here */</span>
		<span class="n">control_word</span> <span class="o">=</span> <span class="n">old_cw</span><span class="p">;</span>
		<span class="n">scale</span> <span class="o">=</span> <span class="n">signnegative</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">tmp</span><span class="p">.</span><span class="n">sigl</span> <span class="o">:</span> <span class="n">tmp</span><span class="p">.</span><span class="n">sigl</span><span class="p">;</span>
		<span class="n">scale</span> <span class="o">+=</span> <span class="n">exponent16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>

		<span class="n">setexponent16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">scale</span><span class="p">);</span>

		<span class="cm">/* Use FPU_round() to properly detect under/overflow etc */</span>
		<span class="n">FPU_round</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">control_word</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st0_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Special</span><span class="p">)</span>
		<span class="n">st1_tag</span> <span class="o">=</span> <span class="n">FPU_Special</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Valid</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">st1_tag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TAG_Valid</span>:
			<span class="cm">/* st(0) must be a denormal */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="n">FPU_to_exp16</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>	<span class="cm">/* Will not be left on stack */</span>
			<span class="k">goto</span> <span class="n">valid_scale</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TAG_Zero</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
				<span class="n">denormal_operand</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_Denormal</span>:
			<span class="n">denormal_operand</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_Infinity</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Denormal</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">denormal_operand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">signpositive</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">))</span>
				<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_INF</span><span class="p">,</span> <span class="n">TAG_Special</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">FPU_copy_to_reg0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONST_Z</span><span class="p">,</span> <span class="n">TAG_Zero</span><span class="p">);</span>
			<span class="n">setsign</span><span class="p">(</span><span class="n">st0_ptr</span><span class="p">,</span> <span class="n">sign</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_NaN</span>:
			<span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">st1_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">st1_tag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TAG_Valid</span>:
		<span class="k">case</span> <span class="n">TAG_Zero</span>:
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_Denormal</span>:
			<span class="n">denormal_operand</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_Infinity</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">signpositive</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">))</span>
				<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* Zero scaled by +Infinity */</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_NaN</span>:
			<span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">st1_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_Infinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">st1_tag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TAG_Valid</span>:
		<span class="k">case</span> <span class="n">TAG_Zero</span>:
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_Denormal</span>:
			<span class="n">denormal_operand</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_Infinity</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">signnegative</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">))</span>
				<span class="n">arith_invalid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* Infinity scaled by -Infinity */</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TW_NaN</span>:
			<span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">st1_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TW_NaN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">!=</span> <span class="n">TAG_Empty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">real_2op_NaN</span><span class="p">(</span><span class="n">st1_ptr</span><span class="p">,</span> <span class="n">st1_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">st0_ptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef PARANOID</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">st0_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st1_tag</span> <span class="o">==</span> <span class="n">TAG_Empty</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">EXCEPTION</span><span class="p">(</span><span class="n">EX_INTERNAL</span> <span class="o">|</span> <span class="mh">0x115</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* At least one of st(0), st(1) must be empty */</span>
	<span class="n">FPU_stack_underflow</span><span class="p">();</span>

<span class="p">}</span>

<span class="cm">/*---------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="n">FUNC_ST0</span> <span class="k">const</span> <span class="n">trig_table_a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">f2xm1</span><span class="p">,</span> <span class="n">fyl2x</span><span class="p">,</span> <span class="n">fptan</span><span class="p">,</span> <span class="n">fpatan</span><span class="p">,</span>
	<span class="n">fxtract</span><span class="p">,</span> <span class="n">fprem1</span><span class="p">,</span> <span class="p">(</span><span class="n">FUNC_ST0</span><span class="p">)</span> <span class="n">fdecstp</span><span class="p">,</span> <span class="p">(</span><span class="n">FUNC_ST0</span><span class="p">)</span> <span class="n">fincstp</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">FPU_triga</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="n">trig_table_a</span><span class="p">[</span><span class="n">FPU_rm</span><span class="p">])</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">FPU_gettag0</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">FUNC_ST0</span> <span class="k">const</span> <span class="n">trig_table_b</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">fprem</span><span class="p">,</span> <span class="n">fyl2xp1</span><span class="p">,</span> <span class="n">fsqrt_</span><span class="p">,</span> <span class="n">fsincos</span><span class="p">,</span> <span class="n">frndint_</span><span class="p">,</span> <span class="n">fscale</span><span class="p">,</span> <span class="p">(</span><span class="n">FUNC_ST0</span><span class="p">)</span> <span class="n">fsin</span><span class="p">,</span> <span class="n">fcos</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">FPU_trigb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="n">trig_table_b</span><span class="p">[</span><span class="n">FPU_rm</span><span class="p">])</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">FPU_gettag0</span><span class="p">());</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
