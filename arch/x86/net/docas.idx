f | bpf_jit_comp.c | s | 18K | 627 | Jan Seiffert | kaffeemonster@googlemail.com | 1333490501 |  | bpf jit: Let the x86 jit handle negative offsets  Now the helper function from filter.c for negative offsets is exported, it can be used it in the jit to handle negative offsets.  First modify the asm load helper functions to handle: - know positive offsets - know negative offsets - any offset  then the compiler can be modified to explicitly use these helper when appropriate.  This fixes the case of a negative X register and allows to lift the restriction that bpf programs with negative offsets can't be jited.  Signed-of-by: Jan Seiffert <kaffeemonster@googlemail.com> Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | bpf_jit.S | g | 4.1K |  | Jan Seiffert | kaffeemonster@googlemail.com | 1333490501 |  | bpf jit: Let the x86 jit handle negative offsets  Now the helper function from filter.c for negative offsets is exported, it can be used it in the jit to handle negative offsets.  First modify the asm load helper functions to handle: - know positive offsets - know negative offsets - any offset  then the compiler can be modified to explicitly use these helper when appropriate.  This fixes the case of a negative X register and allows to lift the restriction that bpf programs with negative offsets can't be jited.  Signed-of-by: Jan Seiffert <kaffeemonster@googlemail.com> Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Signed-off-by: David S. Miller <davem@davemloft.net>
f | Makefile | g | 86B |  | Eric Dumazet | eric.dumazet@gmail.com | 1303970708 |  | net: filter: Just In Time compiler for x86-64  In order to speedup packet filtering, here is an implementation of a JIT compiler for x86_64  It is disabled by default, and must be enabled by the admin.  echo 1 >/proc/sys/net/core/bpf_jit_enable  It uses module_alloc() and module_free() to get memory in the 2GB text kernel range since we call helpers functions from the generated code.  EAX : BPF A accumulator EBX : BPF X accumulator RDI : pointer to skb   (first argument given to JIT function) RBP : frame pointer (even if CONFIG_FRAME_POINTER=n) r9d : skb->len - skb->data_len (headlen) r8  : skb->data  To get a trace of generated code, use :  echo 2 >/proc/sys/net/core/bpf_jit_enable  Example of generated code :  # tcpdump -p -n -s 0 -i eth1 host 192.168.20.0/24  flen=18 proglen=147 pass=3 image=ffffffffa00b5000 JIT code: ffffffffa00b5000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 60 JIT code: ffffffffa00b5010: 44 2b 4f 64 4c 8b 87 b8 00 00 00 be 0c 00 00 00 JIT code: ffffffffa00b5020: e8 24 7b f7 e0 3d 00 08 00 00 75 28 be 1a 00 00 JIT code: ffffffffa00b5030: 00 e8 fe 7a f7 e0 24 00 3d 00 14 a8 c0 74 49 be JIT code: ffffffffa00b5040: 1e 00 00 00 e8 eb 7a f7 e0 24 00 3d 00 14 a8 c0 JIT code: ffffffffa00b5050: 74 36 eb 3b 3d 06 08 00 00 74 07 3d 35 80 00 00 JIT code: ffffffffa00b5060: 75 2d be 1c 00 00 00 e8 c8 7a f7 e0 24 00 3d 00 JIT code: ffffffffa00b5070: 14 a8 c0 74 13 be 26 00 00 00 e8 b5 7a f7 e0 24 JIT code: ffffffffa00b5080: 00 3d 00 14 a8 c0 75 07 b8 ff ff 00 00 eb 02 31 JIT code: ffffffffa00b5090: c0 c9 c3  BPF program is 144 bytes long, so native program is almost same size ;)  (000) ldh      [12] (001) jeq      #0x800           jt 2    jf 8 (002) ld       [26] (003) and      #0xffffff00 (004) jeq      #0xc0a81400      jt 16   jf 5 (005) ld       [30] (006) and      #0xffffff00 (007) jeq      #0xc0a81400      jt 16   jf 17 (008) jeq      #0x806           jt 10   jf 9 (009) jeq      #0x8035          jt 10   jf 17 (010) ld       [28] (011) and      #0xffffff00 (012) jeq      #0xc0a81400      jt 16   jf 13 (013) ld       [38] (014) and      #0xffffff00 (015) jeq      #0xc0a81400      jt 16   jf 17 (016) ret      #65535 (017) ret      #0  Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com> Cc: Arnaldo Carvalho de Melo <acme@infradead.org> Cc: Ben Hutchings <bhutchings@solarflare.com> Cc: Hagen Paul Pfeifer <hagen@jauu.net> Signed-off-by: David S. Miller <davem@davemloft.net>
