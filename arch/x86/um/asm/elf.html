<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › um › asm › elf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>elf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2000 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)</span>
<span class="cm"> * Licensed under the GPL</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __UM_ELF_X86_H</span>
<span class="cp">#define __UM_ELF_X86_H</span>

<span class="cp">#include &lt;asm/user.h&gt;</span>
<span class="cp">#include &quot;skas.h&quot;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>

<span class="cp">#define R_386_NONE	0</span>
<span class="cp">#define R_386_32	1</span>
<span class="cp">#define R_386_PC32	2</span>
<span class="cp">#define R_386_GOT32	3</span>
<span class="cp">#define R_386_PLT32	4</span>
<span class="cp">#define R_386_COPY	5</span>
<span class="cp">#define R_386_GLOB_DAT	6</span>
<span class="cp">#define R_386_JMP_SLOT	7</span>
<span class="cp">#define R_386_RELATIVE	8</span>
<span class="cp">#define R_386_GOTOFF	9</span>
<span class="cp">#define R_386_GOTPC	10</span>
<span class="cp">#define R_386_NUM	11</span>

<span class="cm">/*</span>
<span class="cm"> * This is used to ensure we don&#39;t load something for the wrong architecture.</span>
<span class="cm"> */</span>
<span class="cp">#define elf_check_arch(x) \</span>
<span class="cp">	(((x)-&gt;e_machine == EM_386) || ((x)-&gt;e_machine == EM_486))</span>

<span class="cp">#define ELF_CLASS	ELFCLASS32</span>
<span class="cp">#define ELF_DATA        ELFDATA2LSB</span>
<span class="cp">#define ELF_ARCH        EM_386</span>

<span class="cp">#define ELF_PLAT_INIT(regs, load_addr) do { \</span>
<span class="cp">	PT_REGS_BX(regs) = 0; \</span>
<span class="cp">	PT_REGS_CX(regs) = 0; \</span>
<span class="cp">	PT_REGS_DX(regs) = 0; \</span>
<span class="cp">	PT_REGS_SI(regs) = 0; \</span>
<span class="cp">	PT_REGS_DI(regs) = 0; \</span>
<span class="cp">	PT_REGS_BP(regs) = 0; \</span>
<span class="cp">	PT_REGS_AX(regs) = 0; \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Shamelessly stolen from include/asm-i386/elf.h */</span>

<span class="cp">#define ELF_CORE_COPY_REGS(pr_reg, regs) do {	\</span>
<span class="cp">	pr_reg[0] = PT_REGS_BX(regs);		\</span>
<span class="cp">	pr_reg[1] = PT_REGS_CX(regs);		\</span>
<span class="cp">	pr_reg[2] = PT_REGS_DX(regs);		\</span>
<span class="cp">	pr_reg[3] = PT_REGS_SI(regs);		\</span>
<span class="cp">	pr_reg[4] = PT_REGS_DI(regs);		\</span>
<span class="cp">	pr_reg[5] = PT_REGS_BP(regs);		\</span>
<span class="cp">	pr_reg[6] = PT_REGS_AX(regs);		\</span>
<span class="cp">	pr_reg[7] = PT_REGS_DS(regs);		\</span>
<span class="cp">	pr_reg[8] = PT_REGS_ES(regs);		\</span>
<span class="cp">	</span><span class="cm">/* fake once used fs and gs selectors? */</span><span class="cp">	\</span>
<span class="cp">	pr_reg[9] = PT_REGS_DS(regs);		\</span>
<span class="cp">	pr_reg[10] = PT_REGS_DS(regs);		\</span>
<span class="cp">	pr_reg[11] = PT_REGS_SYSCALL_NR(regs);	\</span>
<span class="cp">	pr_reg[12] = PT_REGS_IP(regs);		\</span>
<span class="cp">	pr_reg[13] = PT_REGS_CS(regs);		\</span>
<span class="cp">	pr_reg[14] = PT_REGS_EFLAGS(regs);	\</span>
<span class="cp">	pr_reg[15] = PT_REGS_SP(regs);		\</span>
<span class="cp">	pr_reg[16] = PT_REGS_SS(regs);		\</span>
<span class="cp">} while (0);</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">elf_aux_platform</span><span class="p">;</span>
<span class="cp">#define ELF_PLATFORM (elf_aux_platform)</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vsyscall_ehdr</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vsyscall_end</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kernel_vsyscall</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the range that is readable by user mode, and things</span>
<span class="cm"> * acting like user mode such as get_user_pages.</span>
<span class="cm"> */</span>
<span class="cp">#define FIXADDR_USER_START      vsyscall_ehdr</span>
<span class="cp">#define FIXADDR_USER_END        vsyscall_end</span>


<span class="cm">/*</span>
<span class="cm"> * Architecture-neutral AT_ values in 0-17, leave some room</span>
<span class="cm"> * for more of them, start the x86-specific ones at 32.</span>
<span class="cm"> */</span>
<span class="cp">#define AT_SYSINFO		32</span>
<span class="cp">#define AT_SYSINFO_EHDR		33</span>

<span class="cp">#define ARCH_DLINFO						\</span>
<span class="cp">do {								\</span>
<span class="cp">	if ( vsyscall_ehdr ) {					\</span>
<span class="cp">		NEW_AUX_ENT(AT_SYSINFO,	__kernel_vsyscall);	\</span>
<span class="cp">		NEW_AUX_ENT(AT_SYSINFO_EHDR, vsyscall_ehdr);	\</span>
<span class="cp">	}							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#else</span>

<span class="cm">/* x86-64 relocation types, taken from asm-x86_64/elf.h */</span>
<span class="cp">#define R_X86_64_NONE		0	</span><span class="cm">/* No reloc */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_64		1	</span><span class="cm">/* Direct 64 bit  */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_PC32		2	</span><span class="cm">/* PC relative 32 bit signed */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_GOT32		3	</span><span class="cm">/* 32 bit GOT entry */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_PLT32		4	</span><span class="cm">/* 32 bit PLT address */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_COPY		5	</span><span class="cm">/* Copy symbol at runtime */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_GLOB_DAT	6	</span><span class="cm">/* Create GOT entry */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_JUMP_SLOT	7	</span><span class="cm">/* Create PLT entry */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_RELATIVE	8	</span><span class="cm">/* Adjust by program base */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_GOTPCREL	9	</span><span class="cm">/* 32 bit signed pc relative</span>
<span class="cm">					   offset to GOT */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_32		10	</span><span class="cm">/* Direct 32 bit zero extended */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_32S		11	</span><span class="cm">/* Direct 32 bit sign extended */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_16		12	</span><span class="cm">/* Direct 16 bit zero extended */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_PC16		13	</span><span class="cm">/* 16 bit sign extended pc relative */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_8		14	</span><span class="cm">/* Direct 8 bit sign extended  */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_PC8		15	</span><span class="cm">/* 8 bit sign extended pc relative */</span><span class="cp"></span>

<span class="cp">#define R_X86_64_NUM		16</span>

<span class="cm">/*</span>
<span class="cm"> * This is used to ensure we don&#39;t load something for the wrong architecture.</span>
<span class="cm"> */</span>
<span class="cp">#define elf_check_arch(x) \</span>
<span class="cp">	((x)-&gt;e_machine == EM_X86_64)</span>

<span class="cp">#define ELF_CLASS	ELFCLASS64</span>
<span class="cp">#define ELF_DATA        ELFDATA2LSB</span>
<span class="cp">#define ELF_ARCH        EM_X86_64</span>

<span class="cp">#define ELF_PLAT_INIT(regs, load_addr)    do { \</span>
<span class="cp">	PT_REGS_BX(regs) = 0; \</span>
<span class="cp">	PT_REGS_CX(regs) = 0; \</span>
<span class="cp">	PT_REGS_DX(regs) = 0; \</span>
<span class="cp">	PT_REGS_SI(regs) = 0; \</span>
<span class="cp">	PT_REGS_DI(regs) = 0; \</span>
<span class="cp">	PT_REGS_BP(regs) = 0; \</span>
<span class="cp">	PT_REGS_AX(regs) = 0; \</span>
<span class="cp">	PT_REGS_R8(regs) = 0; \</span>
<span class="cp">	PT_REGS_R9(regs) = 0; \</span>
<span class="cp">	PT_REGS_R10(regs) = 0; \</span>
<span class="cp">	PT_REGS_R11(regs) = 0; \</span>
<span class="cp">	PT_REGS_R12(regs) = 0; \</span>
<span class="cp">	PT_REGS_R13(regs) = 0; \</span>
<span class="cp">	PT_REGS_R14(regs) = 0; \</span>
<span class="cp">	PT_REGS_R15(regs) = 0; \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define ELF_CORE_COPY_REGS(pr_reg, _regs)		\</span>
<span class="cp">	(pr_reg)[0] = (_regs)-&gt;regs.gp[0];			\</span>
<span class="cp">	(pr_reg)[1] = (_regs)-&gt;regs.gp[1];			\</span>
<span class="cp">	(pr_reg)[2] = (_regs)-&gt;regs.gp[2];			\</span>
<span class="cp">	(pr_reg)[3] = (_regs)-&gt;regs.gp[3];			\</span>
<span class="cp">	(pr_reg)[4] = (_regs)-&gt;regs.gp[4];			\</span>
<span class="cp">	(pr_reg)[5] = (_regs)-&gt;regs.gp[5];			\</span>
<span class="cp">	(pr_reg)[6] = (_regs)-&gt;regs.gp[6];			\</span>
<span class="cp">	(pr_reg)[7] = (_regs)-&gt;regs.gp[7];			\</span>
<span class="cp">	(pr_reg)[8] = (_regs)-&gt;regs.gp[8];			\</span>
<span class="cp">	(pr_reg)[9] = (_regs)-&gt;regs.gp[9];			\</span>
<span class="cp">	(pr_reg)[10] = (_regs)-&gt;regs.gp[10];			\</span>
<span class="cp">	(pr_reg)[11] = (_regs)-&gt;regs.gp[11];			\</span>
<span class="cp">	(pr_reg)[12] = (_regs)-&gt;regs.gp[12];			\</span>
<span class="cp">	(pr_reg)[13] = (_regs)-&gt;regs.gp[13];			\</span>
<span class="cp">	(pr_reg)[14] = (_regs)-&gt;regs.gp[14];			\</span>
<span class="cp">	(pr_reg)[15] = (_regs)-&gt;regs.gp[15];			\</span>
<span class="cp">	(pr_reg)[16] = (_regs)-&gt;regs.gp[16];			\</span>
<span class="cp">	(pr_reg)[17] = (_regs)-&gt;regs.gp[17];			\</span>
<span class="cp">	(pr_reg)[18] = (_regs)-&gt;regs.gp[18];			\</span>
<span class="cp">	(pr_reg)[19] = (_regs)-&gt;regs.gp[19];			\</span>
<span class="cp">	(pr_reg)[20] = (_regs)-&gt;regs.gp[20];			\</span>
<span class="cp">	(pr_reg)[21] = current-&gt;thread.arch.fs;			\</span>
<span class="cp">	(pr_reg)[22] = 0;					\</span>
<span class="cp">	(pr_reg)[23] = 0;					\</span>
<span class="cp">	(pr_reg)[24] = 0;					\</span>
<span class="cp">	(pr_reg)[25] = 0;					\</span>
<span class="cp">	(pr_reg)[26] = 0;</span>

<span class="cp">#define ELF_PLATFORM &quot;x86_64&quot;</span>

<span class="cm">/* No user-accessible fixmap addresses, i.e. vsyscall */</span>
<span class="cp">#define FIXADDR_USER_START      0</span>
<span class="cp">#define FIXADDR_USER_END        0</span>

<span class="cp">#define ARCH_HAS_SETUP_ADDITIONAL_PAGES 1</span>
<span class="k">struct</span> <span class="n">linux_binprm</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">arch_setup_additional_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">uses_interp</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">um_vdso_addr</span><span class="p">;</span>
<span class="cp">#define AT_SYSINFO_EHDR 33</span>
<span class="cp">#define ARCH_DLINFO	NEW_AUX_ENT(AT_SYSINFO_EHDR, um_vdso_addr)</span>

<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_greg_t</span><span class="p">;</span>

<span class="cp">#define ELF_NGREG (sizeof (struct user_regs_struct) / sizeof(elf_greg_t))</span>
<span class="k">typedef</span> <span class="n">elf_greg_t</span> <span class="n">elf_gregset_t</span><span class="p">[</span><span class="n">ELF_NGREG</span><span class="p">];</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">user_i387_struct</span> <span class="n">elf_fpregset_t</span><span class="p">;</span>

<span class="cp">#define task_pt_regs(t) (&amp;(t)-&gt;thread.regs)</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">elf_core_copy_fpregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">elf_fpregset_t</span> <span class="o">*</span><span class="n">fpu</span><span class="p">);</span>

<span class="cp">#define ELF_CORE_COPY_FPREGS(t, fpu) elf_core_copy_fpregs(t, fpu)</span>

<span class="cp">#define ELF_EXEC_PAGESIZE 4096</span>

<span class="cp">#define ELF_ET_DYN_BASE (2 * TASK_SIZE / 3)</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">elf_aux_hwcap</span><span class="p">;</span>
<span class="cp">#define ELF_HWCAP (elf_aux_hwcap)</span>

<span class="cp">#define SET_PERSONALITY(ex) do ; while(0)</span>
<span class="cp">#define __HAVE_ARCH_GATE_AREA 1</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
