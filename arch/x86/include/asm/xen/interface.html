<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › xen › interface.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>interface.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * arch-x86_32.h</span>
<span class="cm"> *</span>
<span class="cm"> * Guest OS interface to x86 Xen.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004, K A Fraser</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_X86_XEN_INTERFACE_H</span>
<span class="cp">#define _ASM_X86_XEN_INTERFACE_H</span>

<span class="cp">#ifdef __XEN__</span>
<span class="cp">#define __DEFINE_GUEST_HANDLE(name, type) \</span>
<span class="cp">    typedef struct { type *p; } __guest_handle_ ## name</span>
<span class="cp">#else</span>
<span class="cp">#define __DEFINE_GUEST_HANDLE(name, type) \</span>
<span class="cp">    typedef type * __guest_handle_ ## name</span>
<span class="cp">#endif</span>

<span class="cp">#define DEFINE_GUEST_HANDLE_STRUCT(name) \</span>
<span class="cp">	__DEFINE_GUEST_HANDLE(name, struct name)</span>
<span class="cp">#define DEFINE_GUEST_HANDLE(name) __DEFINE_GUEST_HANDLE(name, name)</span>
<span class="cp">#define GUEST_HANDLE(name)        __guest_handle_ ## name</span>

<span class="cp">#ifdef __XEN__</span>
<span class="cp">#if defined(__i386__)</span>
<span class="cp">#define set_xen_guest_handle(hnd, val)			\</span>
<span class="cp">	do {						\</span>
<span class="cp">		if (sizeof(hnd) == 8)			\</span>
<span class="cp">			*(uint64_t *)&amp;(hnd) = 0;	\</span>
<span class="cp">		(hnd).p = val;				\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#elif defined(__x86_64__)</span>
<span class="cp">#define set_xen_guest_handle(hnd, val)	do { (hnd).p = val; } while (0)</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="cp">#if defined(__i386__)</span>
<span class="cp">#define set_xen_guest_handle(hnd, val)			\</span>
<span class="cp">	do {						\</span>
<span class="cp">		if (sizeof(hnd) == 8)			\</span>
<span class="cp">			*(uint64_t *)&amp;(hnd) = 0;	\</span>
<span class="cp">		(hnd) = val;				\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#elif defined(__x86_64__)</span>
<span class="cp">#define set_xen_guest_handle(hnd, val)	do { (hnd) = val; } while (0)</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cm">/* Guest handles for primitive C types. */</span>
<span class="n">__DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="n">uchar</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>
<span class="n">__DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span>  <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">__DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="n">ulong</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="n">DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
<span class="n">DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
<span class="n">DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span>
<span class="n">DEFINE_GUEST_HANDLE</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef HYPERVISOR_VIRT_START</span>
<span class="cp">#define HYPERVISOR_VIRT_START mk_unsigned_long(__HYPERVISOR_VIRT_START)</span>
<span class="cp">#endif</span>

<span class="cp">#define MACH2PHYS_VIRT_START  mk_unsigned_long(__MACH2PHYS_VIRT_START)</span>
<span class="cp">#define MACH2PHYS_VIRT_END    mk_unsigned_long(__MACH2PHYS_VIRT_END)</span>
<span class="cp">#define MACH2PHYS_NR_ENTRIES  ((MACH2PHYS_VIRT_END-MACH2PHYS_VIRT_START)&gt;&gt;__MACH2PHYS_SHIFT)</span>

<span class="cm">/* Maximum number of virtual CPUs in multi-processor guests. */</span>
<span class="cp">#define MAX_VIRT_CPUS 32</span>

<span class="cm">/*</span>
<span class="cm"> * SEGMENT DESCRIPTOR TABLES</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * A number of GDT entries are reserved by Xen. These are not situated at the</span>
<span class="cm"> * start of the GDT because some stupid OSes export hard-coded selector values</span>
<span class="cm"> * in their ABI. These hard-coded values are always near the start of the GDT,</span>
<span class="cm"> * so Xen places itself out of the way, at the far end of the GDT.</span>
<span class="cm"> */</span>
<span class="cp">#define FIRST_RESERVED_GDT_PAGE  14</span>
<span class="cp">#define FIRST_RESERVED_GDT_BYTE  (FIRST_RESERVED_GDT_PAGE * 4096)</span>
<span class="cp">#define FIRST_RESERVED_GDT_ENTRY (FIRST_RESERVED_GDT_BYTE / 8)</span>

<span class="cm">/*</span>
<span class="cm"> * Send an array of these to HYPERVISOR_set_trap_table()</span>
<span class="cm"> * The privilege level specifies which modes may enter a trap via a software</span>
<span class="cm"> * interrupt. On x86/64, since rings 1 and 2 are unavailable, we allocate</span>
<span class="cm"> * privilege levels as follows:</span>
<span class="cm"> *  Level == 0: No one may enter</span>
<span class="cm"> *  Level == 1: Kernel may enter</span>
<span class="cm"> *  Level == 2: Kernel may enter</span>
<span class="cm"> *  Level == 3: Everyone may enter</span>
<span class="cm"> */</span>
<span class="cp">#define TI_GET_DPL(_ti)		((_ti)-&gt;flags &amp; 3)</span>
<span class="cp">#define TI_GET_IF(_ti)		((_ti)-&gt;flags &amp; 4)</span>
<span class="cp">#define TI_SET_DPL(_ti, _dpl)	((_ti)-&gt;flags |= (_dpl))</span>
<span class="cp">#define TI_SET_IF(_ti, _if)	((_ti)-&gt;flags |= ((!!(_if))&lt;&lt;2))</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">trap_info</span> <span class="p">{</span>
    <span class="kt">uint8_t</span>       <span class="n">vector</span><span class="p">;</span>  <span class="cm">/* exception vector                              */</span>
    <span class="kt">uint8_t</span>       <span class="n">flags</span><span class="p">;</span>   <span class="cm">/* 0-3: privilege level; 4: clear event enable?  */</span>
    <span class="kt">uint16_t</span>      <span class="n">cs</span><span class="p">;</span>      <span class="cm">/* code selector                                 */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span> <span class="cm">/* code offset                                   */</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">trap_info</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">arch_shared_info</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pfn</span><span class="p">;</span>                  <span class="cm">/* max pfn that appears in table */</span>
    <span class="cm">/* Frame containing list of mfns containing list of mfns containing p2m. */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn_to_mfn_frame_list_list</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nmi_reason</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif	</span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cp">#include &quot;interface_32.h&quot;</span>
<span class="cp">#else</span>
<span class="cp">#include &quot;interface_64.h&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cm">/*</span>
<span class="cm"> * The following is all CPU context. Note that the fpu_ctxt block is filled</span>
<span class="cm"> * in by FXSAVE if the CPU has feature FXSR; otherwise FSAVE is used.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vcpu_guest_context</span> <span class="p">{</span>
    <span class="cm">/* FPU registers come first so they can be aligned for FXSAVE/FXRSTOR. */</span>
    <span class="k">struct</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">x</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span> <span class="p">}</span> <span class="n">fpu_ctxt</span><span class="p">;</span>       <span class="cm">/* User-level FPU registers     */</span>
<span class="cp">#define VGCF_I387_VALID (1&lt;&lt;0)</span>
<span class="cp">#define VGCF_HVM_GUEST  (1&lt;&lt;1)</span>
<span class="cp">#define VGCF_IN_KERNEL  (1&lt;&lt;2)</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>                    <span class="cm">/* VGCF_* flags                 */</span>
    <span class="k">struct</span> <span class="n">cpu_user_regs</span> <span class="n">user_regs</span><span class="p">;</span>         <span class="cm">/* User-level CPU registers     */</span>
    <span class="k">struct</span> <span class="n">trap_info</span> <span class="n">trap_ctxt</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>        <span class="cm">/* Virtual IDT                  */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ldt_base</span><span class="p">,</span> <span class="n">ldt_ents</span><span class="p">;</span>       <span class="cm">/* LDT (linear address, # ents) */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gdt_frames</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">gdt_ents</span><span class="p">;</span> <span class="cm">/* GDT (machine frames, # ents) */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_ss</span><span class="p">,</span> <span class="n">kernel_sp</span><span class="p">;</span>     <span class="cm">/* Virtual TSS (only SS1/SP1)   */</span>
    <span class="cm">/* NB. User pagetable on x86/64 is placed in ctrlreg[1]. */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctrlreg</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>               <span class="cm">/* CR0-CR7 (control registers)  */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">debugreg</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>              <span class="cm">/* DB0-DB7 (debug registers)    */</span>
<span class="cp">#ifdef __i386__</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event_callback_cs</span><span class="p">;</span>        <span class="cm">/* CS:EIP of event callback     */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event_callback_eip</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">failsafe_callback_cs</span><span class="p">;</span>     <span class="cm">/* CS:EIP of failsafe callback  */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">failsafe_callback_eip</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event_callback_eip</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">failsafe_callback_eip</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">syscall_callback_eip</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_assist</span><span class="p">;</span>                <span class="cm">/* VMASST_TYPE_* bitmap */</span>
<span class="cp">#ifdef __x86_64__</span>
    <span class="cm">/* Segment base addresses. */</span>
    <span class="kt">uint64_t</span>      <span class="n">fs_base</span><span class="p">;</span>
    <span class="kt">uint64_t</span>      <span class="n">gs_base_kernel</span><span class="p">;</span>
    <span class="kt">uint64_t</span>      <span class="n">gs_base_user</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="n">DEFINE_GUEST_HANDLE_STRUCT</span><span class="p">(</span><span class="n">vcpu_guest_context</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Prefix forces emulation of some non-trapping instructions.</span>
<span class="cm"> * Currently only CPUID.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __ASSEMBLY__</span>
<span class="cp">#define XEN_EMULATE_PREFIX .byte 0x0f,0x0b,0x78,0x65,0x6e ;</span>
<span class="cp">#define XEN_CPUID          XEN_EMULATE_PREFIX cpuid</span>
<span class="cp">#else</span>
<span class="cp">#define XEN_EMULATE_PREFIX &quot;.byte 0x0f,0x0b,0x78,0x65,0x6e ; &quot;</span>
<span class="cp">#define XEN_CPUID          XEN_EMULATE_PREFIX &quot;cpuid&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_XEN_INTERFACE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
