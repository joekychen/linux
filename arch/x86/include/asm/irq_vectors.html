<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › irq_vectors.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>irq_vectors.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_X86_IRQ_VECTORS_H</span>
<span class="cp">#define _ASM_X86_IRQ_VECTORS_H</span>

<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cm">/*</span>
<span class="cm"> * Linux IRQ vector layout.</span>
<span class="cm"> *</span>
<span class="cm"> * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can</span>
<span class="cm"> * be defined by Linux. They are used as a jump table by the CPU when a</span>
<span class="cm"> * given vector is triggered - by a CPU-external, CPU-internal or</span>
<span class="cm"> * software-triggered event.</span>
<span class="cm"> *</span>
<span class="cm"> * Linux sets the kernel code address each entry jumps to early during</span>
<span class="cm"> * bootup, and never changes them. This is the general layout of the</span>
<span class="cm"> * IDT entries:</span>
<span class="cm"> *</span>
<span class="cm"> *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events</span>
<span class="cm"> *  Vectors  32 ... 127 : device interrupts</span>
<span class="cm"> *  Vector  128         : legacy int80 syscall interface</span>
<span class="cm"> *  Vectors 129 ... INVALIDATE_TLB_VECTOR_START-1 except 204 : device interrupts</span>
<span class="cm"> *  Vectors INVALIDATE_TLB_VECTOR_START ... 255 : special interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * 64-bit x86 has per CPU IDT tables, 32-bit has one shared IDT table.</span>
<span class="cm"> *</span>
<span class="cm"> * This file enumerates the exact layout of them:</span>
<span class="cm"> */</span>

<span class="cp">#define NMI_VECTOR			0x02</span>
<span class="cp">#define MCE_VECTOR			0x12</span>

<span class="cm">/*</span>
<span class="cm"> * IDT vectors usable for external interrupt sources start at 0x20.</span>
<span class="cm"> * (0x80 is the syscall vector, 0x30-0x3f are for ISA)</span>
<span class="cm"> */</span>
<span class="cp">#define FIRST_EXTERNAL_VECTOR		0x20</span>
<span class="cm">/*</span>
<span class="cm"> * We start allocating at 0x21 to spread out vectors evenly between</span>
<span class="cm"> * priority levels. (0x80 is the syscall vector)</span>
<span class="cm"> */</span>
<span class="cp">#define VECTOR_OFFSET_START		1</span>

<span class="cm">/*</span>
<span class="cm"> * Reserve the lowest usable vector (and hence lowest priority)  0x20 for</span>
<span class="cm"> * triggering cleanup after irq migration. 0x21-0x2f will still be used</span>
<span class="cm"> * for device interrupts.</span>
<span class="cm"> */</span>
<span class="cp">#define IRQ_MOVE_CLEANUP_VECTOR		FIRST_EXTERNAL_VECTOR</span>

<span class="cp">#define IA32_SYSCALL_VECTOR		0x80</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cp"># define SYSCALL_VECTOR			0x80</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Vectors 0x30-0x3f are used for ISA interrupts.</span>
<span class="cm"> *   round up to the next 16-vector boundary</span>
<span class="cm"> */</span>
<span class="cp">#define IRQ0_VECTOR			((FIRST_EXTERNAL_VECTOR + 16) &amp; ~15)</span>

<span class="cp">#define IRQ1_VECTOR			(IRQ0_VECTOR +  1)</span>
<span class="cp">#define IRQ2_VECTOR			(IRQ0_VECTOR +  2)</span>
<span class="cp">#define IRQ3_VECTOR			(IRQ0_VECTOR +  3)</span>
<span class="cp">#define IRQ4_VECTOR			(IRQ0_VECTOR +  4)</span>
<span class="cp">#define IRQ5_VECTOR			(IRQ0_VECTOR +  5)</span>
<span class="cp">#define IRQ6_VECTOR			(IRQ0_VECTOR +  6)</span>
<span class="cp">#define IRQ7_VECTOR			(IRQ0_VECTOR +  7)</span>
<span class="cp">#define IRQ8_VECTOR			(IRQ0_VECTOR +  8)</span>
<span class="cp">#define IRQ9_VECTOR			(IRQ0_VECTOR +  9)</span>
<span class="cp">#define IRQ10_VECTOR			(IRQ0_VECTOR + 10)</span>
<span class="cp">#define IRQ11_VECTOR			(IRQ0_VECTOR + 11)</span>
<span class="cp">#define IRQ12_VECTOR			(IRQ0_VECTOR + 12)</span>
<span class="cp">#define IRQ13_VECTOR			(IRQ0_VECTOR + 13)</span>
<span class="cp">#define IRQ14_VECTOR			(IRQ0_VECTOR + 14)</span>
<span class="cp">#define IRQ15_VECTOR			(IRQ0_VECTOR + 15)</span>

<span class="cm">/*</span>
<span class="cm"> * Special IRQ vectors used by the SMP architecture, 0xf0-0xff</span>
<span class="cm"> *</span>
<span class="cm"> *  some of the following vectors are &#39;rare&#39;, they are merged</span>
<span class="cm"> *  into a single vector (CALL_FUNCTION_VECTOR) to save vector space.</span>
<span class="cm"> *  TLB, reschedule and local APIC vectors are performance-critical.</span>
<span class="cm"> */</span>

<span class="cp">#define SPURIOUS_APIC_VECTOR		0xff</span>
<span class="cm">/*</span>
<span class="cm"> * Sanity check</span>
<span class="cm"> */</span>
<span class="cp">#if ((SPURIOUS_APIC_VECTOR &amp; 0x0F) != 0x0F)</span>
<span class="cp"># error SPURIOUS_APIC_VECTOR definition error</span>
<span class="cp">#endif</span>

<span class="cp">#define ERROR_APIC_VECTOR		0xfe</span>
<span class="cp">#define RESCHEDULE_VECTOR		0xfd</span>
<span class="cp">#define CALL_FUNCTION_VECTOR		0xfc</span>
<span class="cp">#define CALL_FUNCTION_SINGLE_VECTOR	0xfb</span>
<span class="cp">#define THERMAL_APIC_VECTOR		0xfa</span>
<span class="cp">#define THRESHOLD_APIC_VECTOR		0xf9</span>
<span class="cp">#define REBOOT_VECTOR			0xf8</span>

<span class="cm">/*</span>
<span class="cm"> * Generic system vector for platform specific use</span>
<span class="cm"> */</span>
<span class="cp">#define X86_PLATFORM_IPI_VECTOR		0xf7</span>

<span class="cm">/*</span>
<span class="cm"> * IRQ work vector:</span>
<span class="cm"> */</span>
<span class="cp">#define IRQ_WORK_VECTOR			0xf6</span>

<span class="cp">#define UV_BAU_MESSAGE			0xf5</span>

<span class="cm">/* Xen vector callback to receive events in a HVM domain */</span>
<span class="cp">#define XEN_HVM_EVTCHN_CALLBACK		0xf3</span>

<span class="cm">/*</span>
<span class="cm"> * Local APIC timer IRQ vector is on a different priority level,</span>
<span class="cm"> * to work around the &#39;lost local interrupt if more than 2 IRQ</span>
<span class="cm"> * sources per level&#39; errata.</span>
<span class="cm"> */</span>
<span class="cp">#define LOCAL_TIMER_VECTOR		0xef</span>

<span class="cm">/* up to 32 vectors used for spreading out TLB flushes: */</span>
<span class="cp">#if NR_CPUS &lt;= 32</span>
<span class="cp"># define NUM_INVALIDATE_TLB_VECTORS	(NR_CPUS)</span>
<span class="cp">#else</span>
<span class="cp"># define NUM_INVALIDATE_TLB_VECTORS	(32)</span>
<span class="cp">#endif</span>

<span class="cp">#define INVALIDATE_TLB_VECTOR_END	(0xee)</span>
<span class="cp">#define INVALIDATE_TLB_VECTOR_START	\</span>
<span class="cp">	(INVALIDATE_TLB_VECTOR_END-NUM_INVALIDATE_TLB_VECTORS+1)</span>

<span class="cp">#define NR_VECTORS			 256</span>

<span class="cp">#define FPU_IRQ				  13</span>

<span class="cp">#define	FIRST_VM86_IRQ			   3</span>
<span class="cp">#define LAST_VM86_IRQ			  15</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">invalid_vm86_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq</span> <span class="o">&lt;</span> <span class="n">FIRST_VM86_IRQ</span> <span class="o">||</span> <span class="n">irq</span> <span class="o">&gt;</span> <span class="n">LAST_VM86_IRQ</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Size the maximum number of interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * If the irq_desc[] array has a sparse layout, we can size things</span>
<span class="cm"> * generously - it scales up linearly with the maximum number of CPUs,</span>
<span class="cm"> * and the maximum number of IO-APICs, whichever is higher.</span>
<span class="cm"> *</span>
<span class="cm"> * In other cases we size more conservatively, to not create too large</span>
<span class="cm"> * static arrays.</span>
<span class="cm"> */</span>

<span class="cp">#define NR_IRQS_LEGACY			  16</span>

<span class="cp">#define IO_APIC_VECTOR_LIMIT		( 32 * MAX_IO_APICS )</span>

<span class="cp">#ifdef CONFIG_X86_IO_APIC</span>
<span class="cp"># define CPU_VECTOR_LIMIT		(64 * NR_CPUS)</span>
<span class="cp"># define NR_IRQS					\</span>
<span class="cp">	(CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT ?	\</span>
<span class="cp">		(NR_VECTORS + CPU_VECTOR_LIMIT)  :	\</span>
<span class="cp">		(NR_VECTORS + IO_APIC_VECTOR_LIMIT))</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_X86_IO_APIC: */</span><span class="cp"></span>
<span class="cp"># define NR_IRQS			NR_IRQS_LEGACY</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_IRQ_VECTORS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
