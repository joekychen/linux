<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › alternative.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>alternative.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_X86_ALTERNATIVE_H</span>
<span class="cp">#define _ASM_X86_ALTERNATIVE_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;asm/asm.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Alternative inline assembly for SMP.</span>
<span class="cm"> *</span>
<span class="cm"> * The LOCK_PREFIX macro defined here replaces the LOCK and</span>
<span class="cm"> * LOCK_PREFIX macros used everywhere in the source tree.</span>
<span class="cm"> *</span>
<span class="cm"> * SMP alternatives use the same data structures as the other</span>
<span class="cm"> * alternatives and the X86_FEATURE_UP flag to indicate the case of a</span>
<span class="cm"> * UP system running a SMP kernel.  The existing apply_alternatives()</span>
<span class="cm"> * works fine for patching a SMP kernel for UP.</span>
<span class="cm"> *</span>
<span class="cm"> * The SMP alternative tables can be kept after boot and contain both</span>
<span class="cm"> * UP and SMP versions of the instructions to allow switching back to</span>
<span class="cm"> * SMP at runtime, when hotplugging in a new CPU, which is especially</span>
<span class="cm"> * useful in virtualized environments.</span>
<span class="cm"> *</span>
<span class="cm"> * The very common lock prefix is handled as special case in a</span>
<span class="cm"> * separate table which is a pure address list without replacement ptr</span>
<span class="cm"> * and size information.  That keeps the table sizes small.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#define LOCK_PREFIX_HERE \</span>
<span class="cp">		&quot;.section .smp_locks,\&quot;a\&quot;\n&quot;	\</span>
<span class="cp">		&quot;.balign 4\n&quot;			\</span>
<span class="cp">		&quot;.long 671f - .\n&quot; </span><span class="cm">/* offset */</span><span class="cp">	\</span>
<span class="cp">		&quot;.previous\n&quot;			\</span>
<span class="cp">		&quot;671:&quot;</span>

<span class="cp">#define LOCK_PREFIX LOCK_PREFIX_HERE &quot;\n\tlock; &quot;</span>

<span class="cp">#else </span><span class="cm">/* ! CONFIG_SMP */</span><span class="cp"></span>
<span class="cp">#define LOCK_PREFIX_HERE &quot;&quot;</span>
<span class="cp">#define LOCK_PREFIX &quot;&quot;</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">alt_instr</span> <span class="p">{</span>
	<span class="n">s32</span> <span class="n">instr_offset</span><span class="p">;</span>	<span class="cm">/* original instruction */</span>
	<span class="n">s32</span> <span class="n">repl_offset</span><span class="p">;</span>	<span class="cm">/* offset to replacement instruction */</span>
	<span class="n">u16</span> <span class="n">cpuid</span><span class="p">;</span>		<span class="cm">/* cpuid bit set for replacement */</span>
	<span class="n">u8</span>  <span class="n">instrlen</span><span class="p">;</span>		<span class="cm">/* length of original instruction */</span>
	<span class="n">u8</span>  <span class="n">replacementlen</span><span class="p">;</span>	<span class="cm">/* length of new instruction, &lt;= instrlen */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">alternative_instructions</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">apply_alternatives</span><span class="p">(</span><span class="k">struct</span> <span class="n">alt_instr</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="k">struct</span> <span class="n">alt_instr</span> <span class="o">*</span><span class="n">end</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">alternatives_smp_module_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">locks</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">locks_end</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">text_end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">alternatives_smp_module_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">alternatives_smp_switch</span><span class="p">(</span><span class="kt">int</span> <span class="n">smp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">alternatives_text_reserved</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">skip_smp_alternatives</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">alternatives_smp_module_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					       <span class="kt">void</span> <span class="o">*</span><span class="n">locks</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">locks_end</span><span class="p">,</span>
					       <span class="kt">void</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">text_end</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">alternatives_smp_module_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">alternatives_smp_switch</span><span class="p">(</span><span class="kt">int</span> <span class="n">smp</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">alternatives_text_reserved</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/* alternative assembly primitive: */</span>
<span class="cp">#define ALTERNATIVE(oldinstr, newinstr, feature)			\</span>
<span class="cp">									\</span>
<span class="cp">      &quot;661:\n\t&quot; oldinstr &quot;\n662:\n&quot;					\</span>
<span class="cp">      &quot;.section .altinstructions,\&quot;a\&quot;\n&quot;				\</span>
<span class="cp">      &quot;	 .long 661b - .\n&quot;			</span><span class="cm">/* label           */</span><span class="cp">	\</span>
<span class="cp">      &quot;	 .long 663f - .\n&quot;			</span><span class="cm">/* new instruction */</span><span class="cp">	\</span>
<span class="cp">      &quot;	 .word &quot; __stringify(feature) &quot;\n&quot;	</span><span class="cm">/* feature bit     */</span><span class="cp">	\</span>
<span class="cp">      &quot;	 .byte 662b-661b\n&quot;			</span><span class="cm">/* sourcelen       */</span><span class="cp">	\</span>
<span class="cp">      &quot;	 .byte 664f-663f\n&quot;			</span><span class="cm">/* replacementlen  */</span><span class="cp">	\</span>
<span class="cp">      &quot;.previous\n&quot;							\</span>
<span class="cp">      &quot;.section .discard,\&quot;aw\&quot;,@progbits\n&quot;				\</span>
<span class="cp">      &quot;	 .byte 0xff + (664f-663f) - (662b-661b)\n&quot; </span><span class="cm">/* rlen &lt;= slen */</span><span class="cp">	\</span>
<span class="cp">      &quot;.previous\n&quot;							\</span>
<span class="cp">      &quot;.section .altinstr_replacement, \&quot;ax\&quot;\n&quot;			\</span>
<span class="cp">      &quot;663:\n\t&quot; newinstr &quot;\n664:\n&quot;		</span><span class="cm">/* replacement     */</span><span class="cp">	\</span>
<span class="cp">      &quot;.previous&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * This must be included *after* the definition of ALTERNATIVE due to</span>
<span class="cm"> * &lt;asm/arch_hweight.h&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;asm/cpufeature.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Alternative instructions for different CPU types or capabilities.</span>
<span class="cm"> *</span>
<span class="cm"> * This allows to use optimized instructions even on generic binary</span>
<span class="cm"> * kernels.</span>
<span class="cm"> *</span>
<span class="cm"> * length of oldinstr must be longer or equal the length of newinstr</span>
<span class="cm"> * It can be padded with nops as needed.</span>
<span class="cm"> *</span>
<span class="cm"> * For non barrier like inlines please define new variants</span>
<span class="cm"> * without volatile and memory clobber.</span>
<span class="cm"> */</span>
<span class="cp">#define alternative(oldinstr, newinstr, feature)			\</span>
<span class="cp">	asm volatile (ALTERNATIVE(oldinstr, newinstr, feature) : : : &quot;memory&quot;)</span>

<span class="cm">/*</span>
<span class="cm"> * Alternative inline assembly with input.</span>
<span class="cm"> *</span>
<span class="cm"> * Pecularities:</span>
<span class="cm"> * No memory clobber here.</span>
<span class="cm"> * Argument numbers start with 1.</span>
<span class="cm"> * Best is to use constraints that are fixed size (like (%1) ... &quot;r&quot;)</span>
<span class="cm"> * If you use variable sized constraints like &quot;m&quot; or &quot;g&quot; in the</span>
<span class="cm"> * replacement make sure to pad to the worst case length.</span>
<span class="cm"> * Leaving an unused argument 0 to keep API compatibility.</span>
<span class="cm"> */</span>
<span class="cp">#define alternative_input(oldinstr, newinstr, feature, input...)	\</span>
<span class="cp">	asm volatile (ALTERNATIVE(oldinstr, newinstr, feature)		\</span>
<span class="cp">		: : &quot;i&quot; (0), ## input)</span>

<span class="cm">/* Like alternative_input, but with a single output argument */</span>
<span class="cp">#define alternative_io(oldinstr, newinstr, feature, output, input...)	\</span>
<span class="cp">	asm volatile (ALTERNATIVE(oldinstr, newinstr, feature)		\</span>
<span class="cp">		: output : &quot;i&quot; (0), ## input)</span>

<span class="cm">/* Like alternative_io, but for replacing a direct call with another one. */</span>
<span class="cp">#define alternative_call(oldfunc, newfunc, feature, output, input...)	\</span>
<span class="cp">	asm volatile (ALTERNATIVE(&quot;call %P[old]&quot;, &quot;call %P[new]&quot;, feature) \</span>
<span class="cp">		: output : [old] &quot;i&quot; (oldfunc), [new] &quot;i&quot; (newfunc), ## input)</span>

<span class="cm">/*</span>
<span class="cm"> * use this macro(s) if you need more than one output parameter</span>
<span class="cm"> * in alternative_io</span>
<span class="cm"> */</span>
<span class="cp">#define ASM_OUTPUT2(a...) a</span>

<span class="cm">/*</span>
<span class="cm"> * use this macro if you need clobbers but no inputs in</span>
<span class="cm"> * alternative_{input,io,call}()</span>
<span class="cm"> */</span>
<span class="cp">#define ASM_NO_INPUT_CLOBBER(clbr...) &quot;i&quot; (0) : clbr</span>

<span class="k">struct</span> <span class="n">paravirt_patch_site</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PARAVIRT</span>
<span class="kt">void</span> <span class="n">apply_paravirt</span><span class="p">(</span><span class="k">struct</span> <span class="n">paravirt_patch_site</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">paravirt_patch_site</span> <span class="o">*</span><span class="n">end</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apply_paravirt</span><span class="p">(</span><span class="k">struct</span> <span class="n">paravirt_patch_site</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">paravirt_patch_site</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{}</span>
<span class="cp">#define __parainstructions	NULL</span>
<span class="cp">#define __parainstructions_end	NULL</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">text_poke_early</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opcode</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Clear and restore the kernel write-protection flag on the local CPU.</span>
<span class="cm"> * Allows the kernel to edit read-only pages.</span>
<span class="cm"> * Side-effect: any interrupt handler running between save and restore will have</span>
<span class="cm"> * the ability to write to read-only pages.</span>
<span class="cm"> *</span>
<span class="cm"> * Warning:</span>
<span class="cm"> * Code patching in the UP case is safe if NMIs and MCE handlers are stopped and</span>
<span class="cm"> * no thread can be preempted in the instructions being modified (no iret to an</span>
<span class="cm"> * invalid instruction possible) or if the instructions are changed from a</span>
<span class="cm"> * consistent state to another consistent state atomically.</span>
<span class="cm"> * More care must be taken when modifying code in the SMP case because of</span>
<span class="cm"> * Intel&#39;s errata. text_poke_smp() takes care that errata, but still</span>
<span class="cm"> * doesn&#39;t support NMI/MCE handler code modifying.</span>
<span class="cm"> * On the local CPU you need to be protected again NMI or MCE handlers seeing an</span>
<span class="cm"> * inconsistent instruction while you patch.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">text_poke_param</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opcode</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">text_poke</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opcode</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">text_poke_smp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opcode</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">text_poke_smp_batch</span><span class="p">(</span><span class="k">struct</span> <span class="n">text_poke_param</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_ALTERNATIVE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
