<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › uv › uv_bau.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>uv_bau.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * SGI UV Broadcast Assist Unit definitions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008-2011 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_X86_UV_UV_BAU_H</span>
<span class="cp">#define _ASM_X86_UV_UV_BAU_H</span>

<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#define BITSPERBYTE 8</span>

<span class="cm">/*</span>
<span class="cm"> * Broadcast Assist Unit messaging structures</span>
<span class="cm"> *</span>
<span class="cm"> * Selective Broadcast activations are induced by software action</span>
<span class="cm"> * specifying a particular 8-descriptor &quot;set&quot; via a 6-bit index written</span>
<span class="cm"> * to an MMR.</span>
<span class="cm"> * Thus there are 64 unique 512-byte sets of SB descriptors - one set for</span>
<span class="cm"> * each 6-bit index value. These descriptor sets are mapped in sequence</span>
<span class="cm"> * starting with set 0 located at the address specified in the</span>
<span class="cm"> * BAU_SB_DESCRIPTOR_BASE register, set 1 is located at BASE + 512,</span>
<span class="cm"> * set 2 is at BASE + 2*512, set 3 at BASE + 3*512, and so on.</span>
<span class="cm"> *</span>
<span class="cm"> * We will use one set for sending BAU messages from each of the</span>
<span class="cm"> * cpu&#39;s on the uvhub.</span>
<span class="cm"> *</span>
<span class="cm"> * TLB shootdown will use the first of the 8 descriptors of each set.</span>
<span class="cm"> * Each of the descriptors is 64 bytes in size (8*64 = 512 bytes in a set).</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_CPUS_PER_UVHUB		64</span>
<span class="cp">#define MAX_CPUS_PER_SOCKET		32</span>
<span class="cp">#define ADP_SZ				64 </span><span class="cm">/* hardware-provided max. */</span><span class="cp"></span>
<span class="cp">#define UV_CPUS_PER_AS			32 </span><span class="cm">/* hardware-provided max. */</span><span class="cp"></span>
<span class="cp">#define ITEMS_PER_DESC			8</span>
<span class="cm">/* the &#39;throttle&#39; to prevent the hardware stay-busy bug */</span>
<span class="cp">#define MAX_BAU_CONCURRENT		3</span>
<span class="cp">#define UV_ACT_STATUS_MASK		0x3</span>
<span class="cp">#define UV_ACT_STATUS_SIZE		2</span>
<span class="cp">#define UV_DISTRIBUTION_SIZE		256</span>
<span class="cp">#define UV_SW_ACK_NPENDING		8</span>
<span class="cp">#define UV1_NET_ENDPOINT_INTD		0x38</span>
<span class="cp">#define UV2_NET_ENDPOINT_INTD		0x28</span>
<span class="cp">#define UV_NET_ENDPOINT_INTD		(is_uv1_hub() ?			\</span>
<span class="cp">			UV1_NET_ENDPOINT_INTD : UV2_NET_ENDPOINT_INTD)</span>
<span class="cp">#define UV_DESC_PSHIFT			49</span>
<span class="cp">#define UV_PAYLOADQ_PNODE_SHIFT		49</span>
<span class="cp">#define UV_PTC_BASENAME			&quot;sgi_uv/ptc_statistics&quot;</span>
<span class="cp">#define UV_BAU_BASENAME			&quot;sgi_uv/bau_tunables&quot;</span>
<span class="cp">#define UV_BAU_TUNABLES_DIR		&quot;sgi_uv&quot;</span>
<span class="cp">#define UV_BAU_TUNABLES_FILE		&quot;bau_tunables&quot;</span>
<span class="cp">#define WHITESPACE			&quot; \t\n&quot;</span>
<span class="cp">#define uv_mmask			((1UL &lt;&lt; uv_hub_info-&gt;m_val) - 1)</span>
<span class="cp">#define uv_physnodeaddr(x)		((__pa((unsigned long)(x)) &amp; uv_mmask))</span>
<span class="cp">#define cpubit_isset(cpu, bau_local_cpumask) \</span>
<span class="cp">	test_bit((cpu), (bau_local_cpumask).bits)</span>

<span class="cm">/* [19:16] SOFT_ACK timeout period  19: 1 is urgency 7  17:16 1 is multiplier */</span>
<span class="cm">/*</span>
<span class="cm"> * UV2: Bit 19 selects between</span>
<span class="cm"> *  (0): 10 microsecond timebase and</span>
<span class="cm"> *  (1): 80 microseconds</span>
<span class="cm"> *  we&#39;re using 560us, similar to UV1: 65 units of 10us</span>
<span class="cm"> */</span>
<span class="cp">#define UV1_INTD_SOFT_ACK_TIMEOUT_PERIOD (9UL)</span>
<span class="cp">#define UV2_INTD_SOFT_ACK_TIMEOUT_PERIOD (15UL)</span>

<span class="cp">#define UV_INTD_SOFT_ACK_TIMEOUT_PERIOD	(is_uv1_hub() ?			\</span>
<span class="cp">		UV1_INTD_SOFT_ACK_TIMEOUT_PERIOD :			\</span>
<span class="cp">		UV2_INTD_SOFT_ACK_TIMEOUT_PERIOD)</span>

<span class="cp">#define BAU_MISC_CONTROL_MULT_MASK	3</span>

<span class="cp">#define UVH_AGING_PRESCALE_SEL		0x000000b000UL</span>
<span class="cm">/* [30:28] URGENCY_7  an index into a table of times */</span>
<span class="cp">#define BAU_URGENCY_7_SHIFT		28</span>
<span class="cp">#define BAU_URGENCY_7_MASK		7</span>

<span class="cp">#define UVH_TRANSACTION_TIMEOUT		0x000000b200UL</span>
<span class="cm">/* [45:40] BAU - BAU transaction timeout select - a multiplier */</span>
<span class="cp">#define BAU_TRANS_SHIFT			40</span>
<span class="cp">#define BAU_TRANS_MASK			0x3f</span>

<span class="cm">/*</span>
<span class="cm"> * shorten some awkward names</span>
<span class="cm"> */</span>
<span class="cp">#define AS_PUSH_SHIFT UVH_LB_BAU_SB_ACTIVATION_CONTROL_PUSH_SHFT</span>
<span class="cp">#define SOFTACK_MSHIFT UVH_LB_BAU_MISC_CONTROL_ENABLE_INTD_SOFT_ACK_MODE_SHFT</span>
<span class="cp">#define SOFTACK_PSHIFT UVH_LB_BAU_MISC_CONTROL_INTD_SOFT_ACK_TIMEOUT_PERIOD_SHFT</span>
<span class="cp">#define SOFTACK_TIMEOUT_PERIOD UV_INTD_SOFT_ACK_TIMEOUT_PERIOD</span>
<span class="cp">#define write_gmmr	uv_write_global_mmr64</span>
<span class="cp">#define write_lmmr	uv_write_local_mmr</span>
<span class="cp">#define read_lmmr	uv_read_local_mmr</span>
<span class="cp">#define read_gmmr	uv_read_global_mmr64</span>

<span class="cm">/*</span>
<span class="cm"> * bits in UVH_LB_BAU_SB_ACTIVATION_STATUS_0/1</span>
<span class="cm"> */</span>
<span class="cp">#define DS_IDLE				0</span>
<span class="cp">#define DS_ACTIVE			1</span>
<span class="cp">#define DS_DESTINATION_TIMEOUT		2</span>
<span class="cp">#define DS_SOURCE_TIMEOUT		3</span>
<span class="cm">/*</span>
<span class="cm"> * bits put together from HRP_LB_BAU_SB_ACTIVATION_STATUS_0/1/2</span>
<span class="cm"> * values 1 and 3 will not occur</span>
<span class="cm"> *        Decoded meaning              ERROR  BUSY    AUX ERR</span>
<span class="cm"> * -------------------------------     ----   -----   -------</span>
<span class="cm"> * IDLE                                 0       0        0</span>
<span class="cm"> * BUSY (active)                        0       1        0</span>
<span class="cm"> * SW Ack Timeout (destination)         1       0        0</span>
<span class="cm"> * SW Ack INTD rejected (strong NACK)   1       0        1</span>
<span class="cm"> * Source Side Time Out Detected        1       1        0</span>
<span class="cm"> * Destination Side PUT Failed          1       1        1</span>
<span class="cm"> */</span>
<span class="cp">#define UV2H_DESC_IDLE			0</span>
<span class="cp">#define UV2H_DESC_BUSY			2</span>
<span class="cp">#define UV2H_DESC_DEST_TIMEOUT		4</span>
<span class="cp">#define UV2H_DESC_DEST_STRONG_NACK	5</span>
<span class="cp">#define UV2H_DESC_SOURCE_TIMEOUT	6</span>
<span class="cp">#define UV2H_DESC_DEST_PUT_ERR		7</span>

<span class="cm">/*</span>
<span class="cm"> * delay for &#39;plugged&#39; timeout retries, in microseconds</span>
<span class="cm"> */</span>
<span class="cp">#define PLUGGED_DELAY			10</span>

<span class="cm">/*</span>
<span class="cm"> * threshholds at which to use IPI to free resources</span>
<span class="cm"> */</span>
<span class="cm">/* after this # consecutive &#39;plugged&#39; timeouts, use IPI to release resources */</span>
<span class="cp">#define PLUGSB4RESET			100</span>
<span class="cm">/* after this many consecutive timeouts, use IPI to release resources */</span>
<span class="cp">#define TIMEOUTSB4RESET			1</span>
<span class="cm">/* at this number uses of IPI to release resources, giveup the request */</span>
<span class="cp">#define IPI_RESET_LIMIT			1</span>
<span class="cm">/* after this # consecutive successes, bump up the throttle if it was lowered */</span>
<span class="cp">#define COMPLETE_THRESHOLD		5</span>

<span class="cp">#define UV_LB_SUBNODEID			0x10</span>

<span class="cm">/* these two are the same for UV1 and UV2: */</span>
<span class="cp">#define UV_SA_SHFT UVH_LB_BAU_MISC_CONTROL_INTD_SOFT_ACK_TIMEOUT_PERIOD_SHFT</span>
<span class="cp">#define UV_SA_MASK UVH_LB_BAU_MISC_CONTROL_INTD_SOFT_ACK_TIMEOUT_PERIOD_MASK</span>
<span class="cm">/* 4 bits of software ack period */</span>
<span class="cp">#define UV2_ACK_MASK			0x7UL</span>
<span class="cp">#define UV2_ACK_UNITS_SHFT		3</span>
<span class="cp">#define UV2_EXT_SHFT UV2H_LB_BAU_MISC_CONTROL_ENABLE_EXTENDED_SB_STATUS_SHFT</span>

<span class="cm">/*</span>
<span class="cm"> * number of entries in the destination side payload queue</span>
<span class="cm"> */</span>
<span class="cp">#define DEST_Q_SIZE			20</span>
<span class="cm">/*</span>
<span class="cm"> * number of destination side software ack resources</span>
<span class="cm"> */</span>
<span class="cp">#define DEST_NUM_RESOURCES		8</span>
<span class="cm">/*</span>
<span class="cm"> * completion statuses for sending a TLB flush message</span>
<span class="cm"> */</span>
<span class="cp">#define FLUSH_RETRY_PLUGGED		1</span>
<span class="cp">#define FLUSH_RETRY_TIMEOUT		2</span>
<span class="cp">#define FLUSH_GIVEUP			3</span>
<span class="cp">#define FLUSH_COMPLETE			4</span>
<span class="cp">#define FLUSH_RETRY_BUSYBUG		5</span>

<span class="cm">/*</span>
<span class="cm"> * tuning the action when the numalink network is extremely delayed</span>
<span class="cm"> */</span>
<span class="cp">#define CONGESTED_RESPONSE_US		1000	</span><span class="cm">/* &#39;long&#39; response time, in</span>
<span class="cm">						   microseconds */</span><span class="cp"></span>
<span class="cp">#define CONGESTED_REPS			10	</span><span class="cm">/* long delays averaged over</span>
<span class="cm">						   this many broadcasts */</span><span class="cp"></span>
<span class="cp">#define CONGESTED_PERIOD		30	</span><span class="cm">/* time for the bau to be</span>
<span class="cm">						   disabled, in seconds */</span><span class="cp"></span>
<span class="cm">/* see msg_type: */</span>
<span class="cp">#define MSG_NOOP			0</span>
<span class="cp">#define MSG_REGULAR			1</span>
<span class="cp">#define MSG_RETRY			2</span>

<span class="cm">/*</span>
<span class="cm"> * Distribution: 32 bytes (256 bits) (bytes 0-0x1f of descriptor)</span>
<span class="cm"> * If the &#39;multilevel&#39; flag in the header portion of the descriptor</span>
<span class="cm"> * has been set to 0, then endpoint multi-unicast mode is selected.</span>
<span class="cm"> * The distribution specification (32 bytes) is interpreted as a 256-bit</span>
<span class="cm"> * distribution vector. Adjacent bits correspond to consecutive even numbered</span>
<span class="cm"> * nodeIDs. The result of adding the index of a given bit to the 15-bit</span>
<span class="cm"> * &#39;base_dest_nasid&#39; field of the header corresponds to the</span>
<span class="cm"> * destination nodeID associated with that specified bit.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnmask</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bits</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">UV_DISTRIBUTION_SIZE</span><span class="p">)];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * mask of cpu&#39;s on a uvhub</span>
<span class="cm"> * (during initialization we need to check that unsigned long has</span>
<span class="cm"> *  enough bits for max. cpu&#39;s per uvhub)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bau_local_cpumask</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bits</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Payload: 16 bytes (128 bits) (bytes 0x20-0x2f of descriptor)</span>
<span class="cm"> * only 12 bytes (96 bits) of the payload area are usable.</span>
<span class="cm"> * An additional 3 bytes (bits 27:4) of the header address are carried</span>
<span class="cm"> * to the next bytes of the destination payload queue.</span>
<span class="cm"> * And an additional 2 bytes of the header Suppl_A field are also</span>
<span class="cm"> * carried to the destination payload queue.</span>
<span class="cm"> * But the first byte of the Suppl_A becomes bits 127:120 (the 16th byte)</span>
<span class="cm"> * of the destination payload queue, which is written by the hardware</span>
<span class="cm"> * with the s/w ack resource bit vector.</span>
<span class="cm"> * [ effective message contents (16 bytes (128 bits) maximum), not counting</span>
<span class="cm"> *   the s/w ack bit vector  ]</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The payload is software-defined for INTD transactions</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bau_msg_payload</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">address</span><span class="p">;</span>		<span class="cm">/* signifies a page or all</span>
<span class="cm">						   TLB&#39;s of the cpu */</span>
	<span class="cm">/* 64 bits */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">sending_cpu</span><span class="p">;</span>		<span class="cm">/* filled in by sender */</span>
	<span class="cm">/* 16 bits */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">acknowledge_count</span><span class="p">;</span>	<span class="cm">/* filled in by destination */</span>
	<span class="cm">/* 16 bits */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">reserved1</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>		<span class="cm">/* not usable */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * UV1 Message header:  16 bytes (128 bits) (bytes 0x30-0x3f of descriptor)</span>
<span class="cm"> * see table 4.2.3.0.1 in broacast_assist spec.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uv1_bau_msg_header</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">dest_subnodeid</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>	<span class="cm">/* must be 0x10, for the LB */</span>
	<span class="cm">/* bits 5:0 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">base_dest_nasid</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>	<span class="cm">/* nasid of the first bit */</span>
	<span class="cm">/* bits 20:6 */</span>				<span class="cm">/* in uvhub map */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">command</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>		<span class="cm">/* message type */</span>
	<span class="cm">/* bits 28:21 */</span>
	<span class="cm">/* 0x38: SN3net EndPoint Message */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="cm">/* bits 31:29 */</span>
	<span class="cm">/* int will align on 32 bits */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_2</span><span class="o">:</span><span class="mi">9</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="cm">/* bits 40:32 */</span>
	<span class="cm">/* Suppl_A is 56-41 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">sequence</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>		<span class="cm">/* message sequence number */</span>
	<span class="cm">/* bits 56:41 */</span>			<span class="cm">/* becomes bytes 16-17 of msg */</span>
						<span class="cm">/* Address field (96:57) is</span>
<span class="cm">						   never used as an address</span>
<span class="cm">						   (these are address bits</span>
<span class="cm">						   42:3) */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_3</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="cm">/* bit 57 */</span>
	<span class="cm">/* address bits 27:4 are payload */</span>
	<span class="cm">/* these next 24  (58-81) bits become bytes 12-14 of msg */</span>
	<span class="cm">/* bits 65:58 land in byte 12 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">replied_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* sent as 0 by the source to</span>
<span class="cm">						   byte 12 */</span>
	<span class="cm">/* bit 58 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">msg_type</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* software type of the</span>
<span class="cm">						   message */</span>
	<span class="cm">/* bits 61:59 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">canceled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* message canceled, resource</span>
<span class="cm">						   is to be freed*/</span>
	<span class="cm">/* bit 62 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_1a</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="cm">/* bit 63 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_1b</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="cm">/* bits 65:64 */</span>

	<span class="cm">/* bits 73:66 land in byte 13 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_1ca</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="cm">/* bits 71:66 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_1c</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="cm">/* bits 73:72 */</span>

	<span class="cm">/* bits 81:74 land in byte 14 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_1d</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="cm">/* bits 79:74 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_1e</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="cm">/* bits 81:80 */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_4</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="cm">/* bits 88:82 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">swack_flag</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* software acknowledge flag */</span>
	<span class="cm">/* bit 89 */</span>
						<span class="cm">/* INTD trasactions at</span>
<span class="cm">						   destination are to wait for</span>
<span class="cm">						   software acknowledge */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_5</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="cm">/* bits 95:90 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_6</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="cm">/* bits 100:96 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">int_both</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* if 1, interrupt both sockets</span>
<span class="cm">						   on the uvhub */</span>
	<span class="cm">/* bit 101*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">fairness</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* usually zero */</span>
	<span class="cm">/* bits 104:102 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">multilevel</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* multi-level multicast</span>
<span class="cm">						   format */</span>
	<span class="cm">/* bit 105 */</span>
	<span class="cm">/* 0 for TLB: endpoint multi-unicast messages */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">chaining</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* next descriptor is part of</span>
<span class="cm">						   this activation*/</span>
	<span class="cm">/* bit 106 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_7</span><span class="o">:</span><span class="mi">21</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="cm">/* bits 127:107 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * UV2 Message header:  16 bytes (128 bits) (bytes 0x30-0x3f of descriptor)</span>
<span class="cm"> * see figure 9-2 of harp_sys.pdf</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uv2_bau_msg_header</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">base_dest_nasid</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>	<span class="cm">/* nasid of the first bit */</span>
	<span class="cm">/* bits 14:0 */</span>				<span class="cm">/* in uvhub map */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">dest_subnodeid</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>	<span class="cm">/* must be 0x10, for the LB */</span>
	<span class="cm">/* bits 19:15 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="cm">/* bit 20 */</span>
	<span class="cm">/* Address bits 59:21 */</span>
	<span class="cm">/* bits 25:2 of address (44:21) are payload */</span>
	<span class="cm">/* these next 24 bits become bytes 12-14 of msg */</span>
	<span class="cm">/* bits 28:21 land in byte 12 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">replied_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* sent as 0 by the source to</span>
<span class="cm">						   byte 12 */</span>
	<span class="cm">/* bit 21 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">msg_type</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* software type of the</span>
<span class="cm">						   message */</span>
	<span class="cm">/* bits 24:22 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">canceled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* message canceled, resource</span>
<span class="cm">						   is to be freed*/</span>
	<span class="cm">/* bit 25 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="cm">/* bits 28:26 */</span>

	<span class="cm">/* bits 36:29 land in byte 13 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_2a</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_2b</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="cm">/* bits 36:29 */</span>

	<span class="cm">/* bits 44:37 land in byte 14 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">payload_3</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>		<span class="cm">/* not currently used */</span>
	<span class="cm">/* bits 44:37 */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_2</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>		<span class="cm">/* reserved */</span>
	<span class="cm">/* bits 51:45 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">swack_flag</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* software acknowledge flag */</span>
	<span class="cm">/* bit 52 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_3a</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_3b</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_3c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_3d</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* must be zero */</span>
	<span class="cm">/* bits 74:53 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">fairness</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* usually zero */</span>
	<span class="cm">/* bits 77:75 */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">sequence</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>		<span class="cm">/* message sequence number */</span>
	<span class="cm">/* bits 93:78  Suppl_A  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">chaining</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* next descriptor is part of</span>
<span class="cm">						   this activation*/</span>
	<span class="cm">/* bit 94 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">multilevel</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* multi-level multicast</span>
<span class="cm">						   format */</span>
	<span class="cm">/* bit 95 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rsvd_4</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>		<span class="cm">/* ordered / source node /</span>
<span class="cm">						   source subnode / aging</span>
<span class="cm">						   must be zero */</span>
	<span class="cm">/* bits 119:96 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">command</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>		<span class="cm">/* message type */</span>
	<span class="cm">/* bits 127:120 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The activation descriptor:</span>
<span class="cm"> * The format of the message to send, plus all accompanying control</span>
<span class="cm"> * Should be 64 bytes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bau_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnmask</span>				<span class="n">distribution</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * message template, consisting of header and payload:</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="n">bau_msg_header</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">uv1_bau_msg_header</span>	<span class="n">uv1_hdr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">uv2_bau_msg_header</span>	<span class="n">uv2_hdr</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">header</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bau_msg_payload</span>			<span class="n">payload</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* UV1:</span>
<span class="cm"> *   -payload--    ---------header------</span>
<span class="cm"> *   bytes 0-11    bits 41-56  bits 58-81</span>
<span class="cm"> *       A           B  (2)      C (3)</span>
<span class="cm"> *</span>
<span class="cm"> *            A/B/C are moved to:</span>
<span class="cm"> *       A            C          B</span>
<span class="cm"> *   bytes 0-11  bytes 12-14  bytes 16-17  (byte 15 filled in by hw as vector)</span>
<span class="cm"> *   ------------payload queue-----------</span>
<span class="cm"> */</span>
<span class="cm">/* UV2:</span>
<span class="cm"> *   -payload--    ---------header------</span>
<span class="cm"> *   bytes 0-11    bits 70-78  bits 21-44</span>
<span class="cm"> *       A           B  (2)      C (3)</span>
<span class="cm"> *</span>
<span class="cm"> *            A/B/C are moved to:</span>
<span class="cm"> *       A            C          B</span>
<span class="cm"> *   bytes 0-11  bytes 12-14  bytes 16-17  (byte 15 filled in by hw as vector)</span>
<span class="cm"> *   ------------payload queue-----------</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The payload queue on the destination side is an array of these.</span>
<span class="cm"> * With BAU_MISC_CONTROL set for software acknowledge mode, the messages</span>
<span class="cm"> * are 32 bytes (2 micropackets) (256 bits) in length, but contain only 17</span>
<span class="cm"> * bytes of usable data, including the sw ack vector in byte 15 (bits 127:120)</span>
<span class="cm"> * (12 bytes come from bau_msg_payload, 3 from payload_1, 2 from</span>
<span class="cm"> *  swack_vec and payload_2)</span>
<span class="cm"> * &quot;Enabling Software Acknowledgment mode (see Section 4.3.3 Software</span>
<span class="cm"> *  Acknowledge Processing) also selects 32 byte (17 bytes usable) payload</span>
<span class="cm"> *  operation.&quot;</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bau_pq_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">address</span><span class="p">;</span>	<span class="cm">/* signifies a page or all TLB&#39;s</span>
<span class="cm">					   of the cpu */</span>
	<span class="cm">/* 64 bits, bytes 0-7 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">sending_cpu</span><span class="p">;</span>	<span class="cm">/* cpu that sent the message */</span>
	<span class="cm">/* 16 bits, bytes 8-9 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">acknowledge_count</span><span class="p">;</span> <span class="cm">/* filled in by destination */</span>
	<span class="cm">/* 16 bits, bytes 10-11 */</span>
	<span class="cm">/* these next 3 bytes come from bits 58-81 of the message header */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">replied_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* sent as 0 by the source */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">msg_type</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>	<span class="cm">/* software message type */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">canceled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* sent as 0 by the source */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">unused1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>	<span class="cm">/* not currently using */</span>
	<span class="cm">/* byte 12 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">unused2a</span><span class="p">;</span>	<span class="cm">/* not currently using */</span>
	<span class="cm">/* byte 13 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">unused2</span><span class="p">;</span>	<span class="cm">/* not currently using */</span>
	<span class="cm">/* byte 14 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">swack_vec</span><span class="p">;</span>	<span class="cm">/* filled in by the hardware */</span>
	<span class="cm">/* byte 15 (bits 127:120) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">sequence</span><span class="p">;</span>	<span class="cm">/* message sequence number */</span>
	<span class="cm">/* bytes 16-17 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">unused4</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* not currently using bytes 18-19 */</span>
	<span class="cm">/* bytes 18-19 */</span>
	<span class="kt">int</span>		<span class="n">number_of_cpus</span><span class="p">;</span>	<span class="cm">/* filled in at destination */</span>
	<span class="cm">/* 32 bits, bytes 20-23 (aligned) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">unused5</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* not using */</span>
	<span class="cm">/* bytes 24-31 */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">msg_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span>	<span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">msg_slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span>	<span class="o">*</span><span class="n">queue_first</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span>	<span class="o">*</span><span class="n">queue_last</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">reset_args</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">sender</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is allocated per_cpu for UV TLB shootdown statistics.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="p">{</span>
	<span class="cm">/* sender statistics */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_giveup</span><span class="p">;</span>		<span class="cm">/* number of fall backs to</span>
<span class="cm">						   IPI-style flushes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_requestor</span><span class="p">;</span>		<span class="cm">/* number of shootdown</span>
<span class="cm">						   requests */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_stimeout</span><span class="p">;</span>		<span class="cm">/* source side timeouts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_dtimeout</span><span class="p">;</span>		<span class="cm">/* destination side timeouts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_strongnacks</span><span class="p">;</span>		<span class="cm">/* number of strong nack&#39;s */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_time</span><span class="p">;</span>			<span class="cm">/* time spent in sending side */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_retriesok</span><span class="p">;</span>		<span class="cm">/* successful retries */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntargcpu</span><span class="p">;</span>		<span class="cm">/* total number of cpu&#39;s</span>
<span class="cm">						   targeted */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntargself</span><span class="p">;</span>		<span class="cm">/* times the sending cpu was</span>
<span class="cm">						   targeted */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntarglocals</span><span class="p">;</span>		<span class="cm">/* targets of cpus on the local</span>
<span class="cm">						   blade */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntargremotes</span><span class="p">;</span>		<span class="cm">/* targets of cpus on remote</span>
<span class="cm">						   blades */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntarglocaluvhub</span><span class="p">;</span>	<span class="cm">/* targets of the local hub */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntargremoteuvhub</span><span class="p">;</span>	<span class="cm">/* remotes hubs targeted */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntarguvhub</span><span class="p">;</span>		<span class="cm">/* total number of uvhubs</span>
<span class="cm">						   targeted */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntarguvhub16</span><span class="p">;</span>		<span class="cm">/* number of times target</span>
<span class="cm">						   hubs &gt;= 16*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntarguvhub8</span><span class="p">;</span>		<span class="cm">/* number of times target</span>
<span class="cm">						   hubs &gt;= 8 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntarguvhub4</span><span class="p">;</span>		<span class="cm">/* number of times target</span>
<span class="cm">						   hubs &gt;= 4 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntarguvhub2</span><span class="p">;</span>		<span class="cm">/* number of times target</span>
<span class="cm">						   hubs &gt;= 2 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_ntarguvhub1</span><span class="p">;</span>		<span class="cm">/* number of times target</span>
<span class="cm">						   hubs == 1 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_resets_plug</span><span class="p">;</span>		<span class="cm">/* ipi-style resets from plug</span>
<span class="cm">						   state */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_resets_timeout</span><span class="p">;</span>	<span class="cm">/* ipi-style resets from</span>
<span class="cm">						   timeouts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_busy</span><span class="p">;</span>			<span class="cm">/* status stayed busy past</span>
<span class="cm">						   s/w timer */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_throttles</span><span class="p">;</span>		<span class="cm">/* waits in throttle */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_retry_messages</span><span class="p">;</span>	<span class="cm">/* retry broadcasts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_bau_reenabled</span><span class="p">;</span>	<span class="cm">/* for bau enable/disable */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_bau_disabled</span><span class="p">;</span>		<span class="cm">/* for bau enable/disable */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_uv2_wars</span><span class="p">;</span>		<span class="cm">/* uv2 workaround, perm. busy */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_uv2_wars_hw</span><span class="p">;</span>		<span class="cm">/* uv2 workaround, hiwater */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">s_uv2_war_waits</span><span class="p">;</span>	<span class="cm">/* uv2 workaround, long waits */</span>
	<span class="cm">/* destination statistics */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_alltlb</span><span class="p">;</span>		<span class="cm">/* times all tlb&#39;s on this</span>
<span class="cm">						   cpu were flushed */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_onetlb</span><span class="p">;</span>		<span class="cm">/* times just one tlb on this</span>
<span class="cm">						   cpu was flushed */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_multmsg</span><span class="p">;</span>		<span class="cm">/* interrupts with multiple</span>
<span class="cm">						   messages */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_nomsg</span><span class="p">;</span>		<span class="cm">/* interrupts with no message */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_time</span><span class="p">;</span>			<span class="cm">/* time spent on destination</span>
<span class="cm">						   side */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_requestee</span><span class="p">;</span>		<span class="cm">/* number of messages</span>
<span class="cm">						   processed */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_retries</span><span class="p">;</span>		<span class="cm">/* number of retry messages</span>
<span class="cm">						   processed */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_canceled</span><span class="p">;</span>		<span class="cm">/* number of messages canceled</span>
<span class="cm">						   by retries */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_nocanceled</span><span class="p">;</span>		<span class="cm">/* retries that found nothing</span>
<span class="cm">						   to cancel */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_resets</span><span class="p">;</span>		<span class="cm">/* number of ipi-style requests</span>
<span class="cm">						   processed */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">d_rcanceled</span><span class="p">;</span>		<span class="cm">/* number of messages canceled</span>
<span class="cm">						   by resets */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tunables</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">tunp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">deflt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hub_and_pnode</span> <span class="p">{</span>
	<span class="kt">short</span>			<span class="n">uvhub</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">pnode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">socket_desc</span> <span class="p">{</span>
	<span class="kt">short</span>			<span class="n">num_cpus</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">cpu_number</span><span class="p">[</span><span class="n">MAX_CPUS_PER_SOCKET</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">uvhub_desc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">socket_mask</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">num_cpus</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">uvhub</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">pnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_desc</span>	<span class="n">socket</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * one per-cpu; to locate the software tables</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bau_control</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bau_desc</span>		<span class="o">*</span><span class="n">descriptor_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span>	<span class="o">*</span><span class="n">queue_first</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span>	<span class="o">*</span><span class="n">queue_last</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_pq_entry</span>	<span class="o">*</span><span class="n">bau_msg_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span>	<span class="o">*</span><span class="n">uvhub_master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bau_control</span>	<span class="o">*</span><span class="n">socket_master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span>	<span class="o">*</span><span class="n">statp</span><span class="p">;</span>
	<span class="n">cpumask_t</span>		<span class="o">*</span><span class="n">cpumask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">timeout_interval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">set_bau_on_time</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">active_descriptor_count</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">plugged_tries</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">timeout_tries</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ipi_attempts</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">conseccompletes</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">baudisabled</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">set_bau_off</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">cpu</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">osnode</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">uvhub_cpu</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">uvhub</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">uvhub_version</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">cpus_in_socket</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">cpus_in_uvhub</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">partition_base_pnode</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">using_desc</span><span class="p">;</span> <span class="cm">/* an index, like uvhub_cpu */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">inuse_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">message_number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">uvhub_quiesce</span><span class="p">;</span>
	<span class="kt">short</span>			<span class="n">socket_acknowledge_count</span><span class="p">[</span><span class="n">DEST_Q_SIZE</span><span class="p">];</span>
	<span class="n">cycles_t</span>		<span class="n">send_message</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">uvhub_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">queue_lock</span><span class="p">;</span>
	<span class="cm">/* tunables */</span>
	<span class="kt">int</span>			<span class="n">max_concurr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_concurr_const</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">plugged_delay</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">plugsb4reset</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">timeoutsb4reset</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ipi_reset_limit</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">complete_threshold</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cong_response_us</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cong_reps</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cong_period</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">clocks_per_100_usec</span><span class="p">;</span>
	<span class="n">cycles_t</span>		<span class="n">period_time</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">period_requests</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hub_and_pnode</span>	<span class="o">*</span><span class="n">thp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">read_mmr_uv2_status</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_lmmr</span><span class="p">(</span><span class="n">UV2H_LB_BAU_SB_ACTIVATION_STATUS_2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_mmr_data_broadcast</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_BAU_DATA_BROADCAST</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_mmr_descriptor_base</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_LB_BAU_SB_DESCRIPTOR_BASE</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_mmr_activation</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lmmr</span><span class="p">(</span><span class="n">UVH_LB_BAU_SB_ACTIVATION_CONTROL</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_gmmr_activation</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_LB_BAU_SB_ACTIVATION_CONTROL</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_mmr_payload_first</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_LB_BAU_INTD_PAYLOAD_QUEUE_FIRST</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_mmr_payload_tail</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_LB_BAU_INTD_PAYLOAD_QUEUE_TAIL</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_mmr_payload_last</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_LB_BAU_INTD_PAYLOAD_QUEUE_LAST</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_mmr_misc_control</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmr_image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_LB_BAU_MISC_CONTROL</span><span class="p">,</span> <span class="n">mmr_image</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">read_mmr_misc_control</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_LB_BAU_MISC_CONTROL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_mmr_sw_ack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uv_write_local_mmr</span><span class="p">(</span><span class="n">UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE_ALIAS</span><span class="p">,</span> <span class="n">mr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_gmmr_sw_ack</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE_ALIAS</span><span class="p">,</span> <span class="n">mr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">read_mmr_sw_ack</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_lmmr</span><span class="p">(</span><span class="n">UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">read_gmmr_sw_ack</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_gmmr</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_mmr_data_config</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uv_write_global_mmr64</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_BAU_DATA_CONFIG</span><span class="p">,</span> <span class="n">mr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bau_uvhub_isset</span><span class="p">(</span><span class="kt">int</span> <span class="n">uvhub</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnmask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">constant_test_bit</span><span class="p">(</span><span class="n">uvhub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bau_uvhub_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnmask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bau_uvhubs_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnmask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bau_uvhub_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnmask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_weight</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">UV_DISTRIBUTION_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bau_cpubits_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">bau_local_cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">uv_bau_message_intr1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">uv_bau_timeout_intr1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">atomic_short</span> <span class="p">{</span>
	<span class="kt">short</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * atomic_read_short - read a short atomic variable</span>
<span class="cm"> * @v: pointer of type atomic_short</span>
<span class="cm"> *</span>
<span class="cm"> * Atomically reads the value of @v.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">atomic_read_short</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">atomic_short</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * atom_asr - add and return a short int</span>
<span class="cm"> * @i: short value to add</span>
<span class="cm"> * @v: pointer of type atomic_short</span>
<span class="cm"> *</span>
<span class="cm"> * Atomically adds @i to @v and returns @i + @v</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">atom_asr</span><span class="p">(</span><span class="kt">short</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">atomic_short</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * conditionally add 1 to *v, unless *v is &gt;= u</span>
<span class="cm"> * return 0 if we cannot add 1 to *v because it is &gt;= u</span>
<span class="cm"> * return 1 if we can add 1 to *v because it is &lt; u</span>
<span class="cm"> * the add is atomic</span>
<span class="cm"> *</span>
<span class="cm"> * This is close to atomic_add_unless(), but this allows the &#39;u&#39; value</span>
<span class="cm"> * to be lowered below the current &#39;v&#39;.  atomic_add_unless can only stop</span>
<span class="cm"> * on equal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">atomic_inc_unless_ge</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_UV_UV_BAU_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
