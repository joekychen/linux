<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › uv › uv_hub.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>uv_hub.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * SGI UV architectural definitions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2010 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_X86_UV_UV_HUB_H</span>
<span class="cp">#define _ASM_X86_UV_UV_HUB_H</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cp">#include &lt;linux/numa.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/percpu.h&gt;</span>
<span class="cp">#include &lt;asm/uv/uv_mmrs.h&gt;</span>
<span class="cp">#include &lt;asm/irq_vectors.h&gt;</span>
<span class="cp">#include &lt;asm/io_apic.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * Addressing Terminology</span>
<span class="cm"> *</span>
<span class="cm"> *	M       - The low M bits of a physical address represent the offset</span>
<span class="cm"> *		  into the blade local memory. RAM memory on a blade is physically</span>
<span class="cm"> *		  contiguous (although various IO spaces may punch holes in</span>
<span class="cm"> *		  it)..</span>
<span class="cm"> *</span>
<span class="cm"> *	N	- Number of bits in the node portion of a socket physical</span>
<span class="cm"> *		  address.</span>
<span class="cm"> *</span>
<span class="cm"> *	NASID   - network ID of a router, Mbrick or Cbrick. Nasid values of</span>
<span class="cm"> *		  routers always have low bit of 1, C/MBricks have low bit</span>
<span class="cm"> *		  equal to 0. Most addressing macros that target UV hub chips</span>
<span class="cm"> *		  right shift the NASID by 1 to exclude the always-zero bit.</span>
<span class="cm"> *		  NASIDs contain up to 15 bits.</span>
<span class="cm"> *</span>
<span class="cm"> *	GNODE   - NASID right shifted by 1 bit. Most mmrs contain gnodes instead</span>
<span class="cm"> *		  of nasids.</span>
<span class="cm"> *</span>
<span class="cm"> *	PNODE   - the low N bits of the GNODE. The PNODE is the most useful variant</span>
<span class="cm"> *		  of the nasid for socket usage.</span>
<span class="cm"> *</span>
<span class="cm"> *	GPA	- (global physical address) a socket physical address converted</span>
<span class="cm"> *		  so that it can be used by the GRU as a global address. Socket</span>
<span class="cm"> *		  physical addresses 1) need additional NASID (node) bits added</span>
<span class="cm"> *		  to the high end of the address, and 2) unaliased if the</span>
<span class="cm"> *		  partition does not have a physical address 0. In addition, on</span>
<span class="cm"> *		  UV2 rev 1, GPAs need the gnode left shifted to bits 39 or 40.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  NumaLink Global Physical Address Format:</span>
<span class="cm"> *  +--------------------------------+---------------------+</span>
<span class="cm"> *  |00..000|      GNODE             |      NodeOffset     |</span>
<span class="cm"> *  +--------------------------------+---------------------+</span>
<span class="cm"> *          |&lt;-------53 - M bits ---&gt;|&lt;--------M bits -----&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	M - number of node offset bits (35 .. 40)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  Memory/UV-HUB Processor Socket Address Format:</span>
<span class="cm"> *  +----------------+---------------+---------------------+</span>
<span class="cm"> *  |00..000000000000|   PNODE       |      NodeOffset     |</span>
<span class="cm"> *  +----------------+---------------+---------------------+</span>
<span class="cm"> *                   &lt;--- N bits ---&gt;|&lt;--------M bits -----&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	M - number of node offset bits (35 .. 40)</span>
<span class="cm"> *	N - number of PNODE bits (0 .. 10)</span>
<span class="cm"> *</span>
<span class="cm"> *		Note: M + N cannot currently exceed 44 (x86_64) or 46 (IA64).</span>
<span class="cm"> *		The actual values are configuration dependent and are set at</span>
<span class="cm"> *		boot time. M &amp; N values are set by the hardware/BIOS at boot.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * APICID format</span>
<span class="cm"> *	NOTE!!!!!! This is the current format of the APICID. However, code</span>
<span class="cm"> *	should assume that this will change in the future. Use functions</span>
<span class="cm"> *	in this file for all APICID bit manipulations and conversion.</span>
<span class="cm"> *</span>
<span class="cm"> *		1111110000000000</span>
<span class="cm"> *		5432109876543210</span>
<span class="cm"> *		pppppppppplc0cch	Nehalem-EX (12 bits in hdw reg)</span>
<span class="cm"> *		ppppppppplcc0cch	Westmere-EX (12 bits in hdw reg)</span>
<span class="cm"> *		pppppppppppcccch	SandyBridge (15 bits in hdw reg)</span>
<span class="cm"> *		sssssssssss</span>
<span class="cm"> *</span>
<span class="cm"> *			p  = pnode bits</span>
<span class="cm"> *			l =  socket number on board</span>
<span class="cm"> *			c  = core</span>
<span class="cm"> *			h  = hyperthread</span>
<span class="cm"> *			s  = bits that are in the SOCKET_ID CSR</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Processor may support fewer bits in the APICID register. The ACPI</span>
<span class="cm"> *	      tables hold all 16 bits. Software needs to be aware of this.</span>
<span class="cm"> *</span>
<span class="cm"> *	      Unless otherwise specified, all references to APICID refer to</span>
<span class="cm"> *	      the FULL value contained in ACPI tables, not the subset in the</span>
<span class="cm"> *	      processor APICID register.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Maximum number of bricks in all partitions and in all coherency domains.</span>
<span class="cm"> * This is the total number of bricks accessible in the numalink fabric. It</span>
<span class="cm"> * includes all C &amp; M bricks. Routers are NOT included.</span>
<span class="cm"> *</span>
<span class="cm"> * This value is also the value of the maximum number of non-router NASIDs</span>
<span class="cm"> * in the numalink fabric.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: a brick may contain 1 or 2 OS nodes. Don&#39;t get these confused.</span>
<span class="cm"> */</span>
<span class="cp">#define UV_MAX_NUMALINK_BLADES	16384</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of C/Mbricks within a software SSI (hardware may support</span>
<span class="cm"> * more).</span>
<span class="cm"> */</span>
<span class="cp">#define UV_MAX_SSI_BLADES	256</span>

<span class="cm">/*</span>
<span class="cm"> * The largest possible NASID of a C or M brick (+ 2)</span>
<span class="cm"> */</span>
<span class="cp">#define UV_MAX_NASID_VALUE	(UV_MAX_NUMALINK_BLADES * 2)</span>

<span class="k">struct</span> <span class="n">uv_scir_s</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">last</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">idle_on</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">idle_off</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">enabled</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The following defines attributes of the HUB chip. These attributes are</span>
<span class="cm"> * frequently referenced and are kept in the per-cpu data areas of each cpu.</span>
<span class="cm"> * They are kept together in a struct to minimize cache misses.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uv_hub_info_s</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">global_mmr_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">gpa_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gnode_extra</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">hub_revision</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">apic_pnode_shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">m_shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">n_lshift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">gnode_upper</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lowmem_remap_top</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lowmem_remap_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">pnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">pnode_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">coherency_domain_number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">numa_blade_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">blade_processor_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">m_val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">n_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uv_scir_s</span>	<span class="n">scir</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">uv_hub_info_s</span><span class="p">,</span> <span class="n">__uv_hub_info</span><span class="p">);</span>
<span class="cp">#define uv_hub_info		(&amp;__get_cpu_var(__uv_hub_info))</span>
<span class="cp">#define uv_cpu_hub_info(cpu)	(&amp;per_cpu(__uv_hub_info, cpu))</span>

<span class="cm">/*</span>
<span class="cm"> * Hub revisions less than UV2_HUB_REVISION_BASE are UV1 hubs. All UV2</span>
<span class="cm"> * hubs have revision numbers greater than or equal to UV2_HUB_REVISION_BASE.</span>
<span class="cm"> * This is a software convention - NOT the hardware revision numbers in</span>
<span class="cm"> * the hub chip.</span>
<span class="cm"> */</span>
<span class="cp">#define UV1_HUB_REVISION_BASE		1</span>
<span class="cp">#define UV2_HUB_REVISION_BASE		3</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_uv1_hub</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">hub_revision</span> <span class="o">&lt;</span> <span class="n">UV2_HUB_REVISION_BASE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_uv2_hub</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">hub_revision</span> <span class="o">&gt;=</span> <span class="n">UV2_HUB_REVISION_BASE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_uv2_1_hub</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">hub_revision</span> <span class="o">==</span> <span class="n">UV2_HUB_REVISION_BASE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_uv2_2_hub</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">hub_revision</span> <span class="o">==</span> <span class="n">UV2_HUB_REVISION_BASE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">union</span> <span class="n">uvh_apicid</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span>       <span class="n">v</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uvh_apicid_s</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">local_apic_mask</span>  <span class="o">:</span> <span class="mi">24</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">local_apic_shift</span> <span class="o">:</span>  <span class="mi">5</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">unused1</span>          <span class="o">:</span>  <span class="mi">3</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">pnode_mask</span>       <span class="o">:</span> <span class="mi">24</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">pnode_shift</span>      <span class="o">:</span>  <span class="mi">5</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">unused2</span>          <span class="o">:</span>  <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Local &amp; Global MMR space macros.</span>
<span class="cm"> *	Note: macros are intended to be used ONLY by inline functions</span>
<span class="cm"> *	in this file - not by other kernel code.</span>
<span class="cm"> *		n -  NASID (full 15-bit global nasid)</span>
<span class="cm"> *		g -  GNODE (full 15-bit global nasid, right shifted 1)</span>
<span class="cm"> *		p -  PNODE (local part of nsids, right shifted 1)</span>
<span class="cm"> */</span>
<span class="cp">#define UV_NASID_TO_PNODE(n)		(((n) &gt;&gt; 1) &amp; uv_hub_info-&gt;pnode_mask)</span>
<span class="cp">#define UV_PNODE_TO_GNODE(p)		((p) |uv_hub_info-&gt;gnode_extra)</span>
<span class="cp">#define UV_PNODE_TO_NASID(p)		(UV_PNODE_TO_GNODE(p) &lt;&lt; 1)</span>

<span class="cp">#define UV1_LOCAL_MMR_BASE		0xf4000000UL</span>
<span class="cp">#define UV1_GLOBAL_MMR32_BASE		0xf8000000UL</span>
<span class="cp">#define UV1_LOCAL_MMR_SIZE		(64UL * 1024 * 1024)</span>
<span class="cp">#define UV1_GLOBAL_MMR32_SIZE		(64UL * 1024 * 1024)</span>

<span class="cp">#define UV2_LOCAL_MMR_BASE		0xfa000000UL</span>
<span class="cp">#define UV2_GLOBAL_MMR32_BASE		0xfc000000UL</span>
<span class="cp">#define UV2_LOCAL_MMR_SIZE		(32UL * 1024 * 1024)</span>
<span class="cp">#define UV2_GLOBAL_MMR32_SIZE		(32UL * 1024 * 1024)</span>

<span class="cp">#define UV_LOCAL_MMR_BASE		(is_uv1_hub() ? UV1_LOCAL_MMR_BASE     \</span>
<span class="cp">						: UV2_LOCAL_MMR_BASE)</span>
<span class="cp">#define UV_GLOBAL_MMR32_BASE		(is_uv1_hub() ? UV1_GLOBAL_MMR32_BASE  \</span>
<span class="cp">						: UV2_GLOBAL_MMR32_BASE)</span>
<span class="cp">#define UV_LOCAL_MMR_SIZE		(is_uv1_hub() ? UV1_LOCAL_MMR_SIZE :   \</span>
<span class="cp">						UV2_LOCAL_MMR_SIZE)</span>
<span class="cp">#define UV_GLOBAL_MMR32_SIZE		(is_uv1_hub() ? UV1_GLOBAL_MMR32_SIZE :\</span>
<span class="cp">						UV2_GLOBAL_MMR32_SIZE)</span>
<span class="cp">#define UV_GLOBAL_MMR64_BASE		(uv_hub_info-&gt;global_mmr_base)</span>

<span class="cp">#define UV_GLOBAL_GRU_MMR_BASE		0x4000000</span>

<span class="cp">#define UV_GLOBAL_MMR32_PNODE_SHIFT	15</span>
<span class="cp">#define UV_GLOBAL_MMR64_PNODE_SHIFT	26</span>

<span class="cp">#define UV_GLOBAL_MMR32_PNODE_BITS(p)	((p) &lt;&lt; (UV_GLOBAL_MMR32_PNODE_SHIFT))</span>

<span class="cp">#define UV_GLOBAL_MMR64_PNODE_BITS(p)					\</span>
<span class="cp">	(((unsigned long)(p)) &lt;&lt; UV_GLOBAL_MMR64_PNODE_SHIFT)</span>

<span class="cp">#define UVH_APICID		0x002D0E00L</span>
<span class="cp">#define UV_APIC_PNODE_SHIFT	6</span>

<span class="cp">#define UV_APICID_HIBIT_MASK	0xffff0000</span>

<span class="cm">/* Local Bus from cpu&#39;s perspective */</span>
<span class="cp">#define LOCAL_BUS_BASE		0x1c00000</span>
<span class="cp">#define LOCAL_BUS_SIZE		(4 * 1024 * 1024)</span>

<span class="cm">/*</span>
<span class="cm"> * System Controller Interface Reg</span>
<span class="cm"> *</span>
<span class="cm"> * Note there are NO leds on a UV system.  This register is only</span>
<span class="cm"> * used by the system controller to monitor system-wide operation.</span>
<span class="cm"> * There are 64 regs per node.  With Nahelem cpus (2 cores per node,</span>
<span class="cm"> * 8 cpus per core, 2 threads per cpu) there are 32 cpu threads on</span>
<span class="cm"> * a node.</span>
<span class="cm"> *</span>
<span class="cm"> * The window is located at top of ACPI MMR space</span>
<span class="cm"> */</span>
<span class="cp">#define SCIR_WINDOW_COUNT	64</span>
<span class="cp">#define SCIR_LOCAL_MMR_BASE	(LOCAL_BUS_BASE + \</span>
<span class="cp">				 LOCAL_BUS_SIZE - \</span>
<span class="cp">				 SCIR_WINDOW_COUNT)</span>

<span class="cp">#define SCIR_CPU_HEARTBEAT	0x01	</span><span class="cm">/* timer interrupt */</span><span class="cp"></span>
<span class="cp">#define SCIR_CPU_ACTIVITY	0x02	</span><span class="cm">/* not idle */</span><span class="cp"></span>
<span class="cp">#define SCIR_CPU_HB_INTERVAL	(HZ)	</span><span class="cm">/* once per second */</span><span class="cp"></span>

<span class="cm">/* Loop through all installed blades */</span>
<span class="cp">#define for_each_possible_blade(bid)		\</span>
<span class="cp">	for ((bid) = 0; (bid) &lt; uv_num_possible_blades(); (bid)++)</span>

<span class="cm">/*</span>
<span class="cm"> * Macros for converting between kernel virtual addresses, socket local physical</span>
<span class="cm"> * addresses, and UV global physical addresses.</span>
<span class="cm"> *	Note: use the standard __pa() &amp; __va() macros for converting</span>
<span class="cm"> *	      between socket virtual and socket physical addresses.</span>
<span class="cm"> */</span>

<span class="cm">/* socket phys RAM --&gt; UV global physical address */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_soc_phys_ram_to_gpa</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">lowmem_remap_top</span><span class="p">)</span>
		<span class="n">paddr</span> <span class="o">|=</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">lowmem_remap_base</span><span class="p">;</span>
	<span class="n">paddr</span> <span class="o">|=</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">gnode_upper</span><span class="p">;</span>
	<span class="n">paddr</span> <span class="o">=</span> <span class="p">((</span><span class="n">paddr</span> <span class="o">&lt;&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_shift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_shift</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_val</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">n_lshift</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">paddr</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* socket virtual --&gt; UV global physical address */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_gpa</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_soc_phys_ram_to_gpa</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Top two bits indicate the requested address is in MMR space.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">uv_gpa_in_mmr_space</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="mi">62</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* UV global physical address --&gt; socket phys RAM */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_gpa_to_soc_phys_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remap_base</span> <span class="o">=</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">lowmem_remap_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remap_top</span> <span class="o">=</span>  <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">lowmem_remap_top</span><span class="p">;</span>

	<span class="n">gpa</span> <span class="o">=</span> <span class="p">((</span><span class="n">gpa</span> <span class="o">&lt;&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_shift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_shift</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">n_lshift</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_val</span><span class="p">);</span>
	<span class="n">paddr</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&amp;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">gpa_mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;=</span> <span class="n">remap_base</span> <span class="o">&amp;&amp;</span> <span class="n">paddr</span> <span class="o">&lt;</span> <span class="n">remap_base</span> <span class="o">+</span> <span class="n">remap_top</span><span class="p">)</span>
		<span class="n">paddr</span> <span class="o">-=</span> <span class="n">remap_base</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">paddr</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* gpa -&gt; pnode */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_gpa_to_gnode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">n_lshift</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* gpa -&gt; pnode */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_gpa_to_pnode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">n_val</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">uv_gpa_to_gnode</span><span class="p">(</span><span class="n">gpa</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">n_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* gpa -&gt; node offset*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_gpa_to_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">gpa</span> <span class="o">&lt;&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_shift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_shift</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pnode, offset --&gt; socket virtual */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">uv_pnode_offset_to_vaddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pnode</span> <span class="o">&lt;&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_val</span><span class="p">)</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Extract a PNODE from an APICID (full apicid, not processor subset)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_apicid_to_pnode</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">apicid</span> <span class="o">&gt;&gt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">apic_pnode_shift</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert an apicid to the socket number on the blade</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_apicid_to_socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_uv1_hub</span><span class="p">())</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">apicid</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">apic_pnode_shift</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Access global MMRs using the low memory MMR32 space. This region supports</span>
<span class="cm"> * faster MMR access but not all MMRs are accessible in this space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">uv_global_mmr32_address</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">UV_GLOBAL_MMR32_BASE</span> <span class="o">|</span>
		       <span class="n">UV_GLOBAL_MMR32_PNODE_BITS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_write_global_mmr32</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uv_global_mmr32_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_read_global_mmr32</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readq</span><span class="p">(</span><span class="n">uv_global_mmr32_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Access Global MMR space using the MMR space located at the top of physical</span>
<span class="cm"> * memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">uv_global_mmr64_address</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">UV_GLOBAL_MMR64_BASE</span> <span class="o">|</span>
		    <span class="n">UV_GLOBAL_MMR64_PNODE_BITS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_write_global_mmr64</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uv_global_mmr64_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_read_global_mmr64</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readq</span><span class="p">(</span><span class="n">uv_global_mmr64_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Global MMR space addresses when referenced by the GRU. (GRU does</span>
<span class="cm"> * NOT use socket addressing).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_global_gru_mmr_address</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">UV_GLOBAL_GRU_MMR_BASE</span> <span class="o">|</span> <span class="n">offset</span> <span class="o">|</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pnode</span> <span class="o">&lt;&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_write_global_mmr8</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uv_global_mmr64_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">uv_read_global_mmr8</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">uv_global_mmr64_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Access hub local MMRs. Faster than using global space but only local MMRs</span>
<span class="cm"> * are accessible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">uv_local_mmr_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">UV_LOCAL_MMR_BASE</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_read_local_mmr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readq</span><span class="p">(</span><span class="n">uv_local_mmr_address</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_write_local_mmr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uv_local_mmr_address</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">uv_read_local_mmr8</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">uv_local_mmr_address</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_write_local_mmr8</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">uv_local_mmr_address</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Structures and definitions for converting between cpu, node, pnode, and blade</span>
<span class="cm"> * numbers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uv_blade_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">nr_possible_cpus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">nr_online_cpus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">pnode</span><span class="p">;</span>
	<span class="kt">short</span>		<span class="n">memory_nid</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	<span class="n">nmi_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">nmi_count</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">uv_blade_info</span> <span class="o">*</span><span class="n">uv_blade_info</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">short</span> <span class="o">*</span><span class="n">uv_node_to_blade</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">short</span> <span class="o">*</span><span class="n">uv_cpu_to_blade</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">short</span> <span class="n">uv_possible_blades</span><span class="p">;</span>

<span class="cm">/* Blade-local cpu number of current cpu. Numbered 0 .. &lt;# cpus on the blade&gt; */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_blade_processor_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">blade_processor_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Blade number of current cpu. Numnbered 0 .. &lt;#blades -1&gt; */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_numa_blade_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">numa_blade_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a cpu number to the the UV blade number */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_cpu_to_blade_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_cpu_to_blade</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Convert linux node number to the UV blade number */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_node_to_blade_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_node_to_blade</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Convert a blade id to the PNODE of the blade */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_blade_to_pnode</span><span class="p">(</span><span class="kt">int</span> <span class="n">bid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_blade_info</span><span class="p">[</span><span class="n">bid</span><span class="p">].</span><span class="n">pnode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Nid of memory node on blade. -1 if no blade-local memory */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_blade_to_memory_nid</span><span class="p">(</span><span class="kt">int</span> <span class="n">bid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_blade_info</span><span class="p">[</span><span class="n">bid</span><span class="p">].</span><span class="n">memory_nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determine the number of possible cpus on a blade */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="kt">int</span> <span class="n">bid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_blade_info</span><span class="p">[</span><span class="n">bid</span><span class="p">].</span><span class="n">nr_possible_cpus</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determine the number of online cpus on a blade */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_blade_nr_online_cpus</span><span class="p">(</span><span class="kt">int</span> <span class="n">bid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_blade_info</span><span class="p">[</span><span class="n">bid</span><span class="p">].</span><span class="n">nr_online_cpus</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a cpu id to the PNODE of the blade containing the cpu */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_cpu_to_pnode</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_blade_info</span><span class="p">[</span><span class="n">uv_cpu_to_blade_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">)].</span><span class="n">pnode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a linux node number to the PNODE of the blade */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_node_to_pnode</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_blade_info</span><span class="p">[</span><span class="n">uv_node_to_blade_id</span><span class="p">(</span><span class="n">nid</span><span class="p">)].</span><span class="n">pnode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Maximum possible number of blades */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_num_possible_blades</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_possible_blades</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update SCIR state */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_set_scir_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">scir</span><span class="p">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">scir</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
		<span class="n">uv_write_local_mmr8</span><span class="p">(</span><span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">scir</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_scir_offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SCIR_LOCAL_MMR_BASE</span> <span class="o">|</span> <span class="p">(</span><span class="n">apicid</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_set_cpu_scir_bits</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uv_cpu_hub_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">scir</span><span class="p">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uv_write_global_mmr8</span><span class="p">(</span><span class="n">uv_cpu_to_pnode</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
				<span class="n">uv_cpu_hub_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">scir</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">uv_cpu_hub_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">scir</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uv_apicid_hibits</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_hub_ipi_value</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apicid</span> <span class="o">|=</span> <span class="n">uv_apicid_hibits</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">UVH_IPI_INT_SEND_SHFT</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">apicid</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">UVH_IPI_INT_APIC_ID_SHFT</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">mode</span> <span class="o">&lt;&lt;</span> <span class="n">UVH_IPI_INT_DELIVERY_MODE_SHFT</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">vector</span> <span class="o">&lt;&lt;</span> <span class="n">UVH_IPI_INT_VECTOR_SHFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_hub_send_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apicid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmode</span> <span class="o">=</span> <span class="n">dest_Fixed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vector</span> <span class="o">==</span> <span class="n">NMI_VECTOR</span><span class="p">)</span>
		<span class="n">dmode</span> <span class="o">=</span> <span class="n">dest_NMI</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">uv_hub_ipi_value</span><span class="p">(</span><span class="n">apicid</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">dmode</span><span class="p">);</span>
	<span class="n">uv_write_global_mmr64</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">UVH_IPI_INT</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the minimum revision number of the hub chips within the partition.</span>
<span class="cm"> *     1 - UV1 rev 1.0 initial silicon</span>
<span class="cm"> *     2 - UV1 rev 2.0 production silicon</span>
<span class="cm"> *     3 - UV2 rev 1.0 initial silicon</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_get_min_hub_revision_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">hub_revision</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _ASM_X86_UV_UV_HUB_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
