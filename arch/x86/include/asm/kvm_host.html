<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › kvm_host.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>kvm_host.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Kernel-based Virtual Machine driver for Linux</span>
<span class="cm"> *</span>
<span class="cm"> * This header defines architecture specific interfaces, x86 version</span>
<span class="cm"> *</span>
<span class="cm"> * This work is licensed under the terms of the GNU GPL, version 2.  See</span>
<span class="cm"> * the COPYING file in the top-level directory.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_X86_KVM_HOST_H</span>
<span class="cp">#define _ASM_X86_KVM_HOST_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &lt;linux/tracepoint.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/irq_work.h&gt;</span>

<span class="cp">#include &lt;linux/kvm.h&gt;</span>
<span class="cp">#include &lt;linux/kvm_para.h&gt;</span>
<span class="cp">#include &lt;linux/kvm_types.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>

<span class="cp">#include &lt;asm/pvclock-abi.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/mtrr.h&gt;</span>
<span class="cp">#include &lt;asm/msr-index.h&gt;</span>
<span class="cp">#include &lt;asm/asm.h&gt;</span>

<span class="cp">#define KVM_MAX_VCPUS 254</span>
<span class="cp">#define KVM_SOFT_MAX_VCPUS 160</span>
<span class="cp">#define KVM_MEMORY_SLOTS 32</span>
<span class="cm">/* memory slots that does not exposed to userspace */</span>
<span class="cp">#define KVM_PRIVATE_MEM_SLOTS 4</span>
<span class="cp">#define KVM_MEM_SLOTS_NUM (KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)</span>

<span class="cp">#define KVM_MMIO_SIZE 16</span>

<span class="cp">#define KVM_PIO_PAGE_OFFSET 1</span>
<span class="cp">#define KVM_COALESCED_MMIO_PAGE_OFFSET 2</span>

<span class="cp">#define CR0_RESERVED_BITS                                               \</span>
<span class="cp">	(~(unsigned long)(X86_CR0_PE | X86_CR0_MP | X86_CR0_EM | X86_CR0_TS \</span>
<span class="cp">			  | X86_CR0_ET | X86_CR0_NE | X86_CR0_WP | X86_CR0_AM \</span>
<span class="cp">			  | X86_CR0_NW | X86_CR0_CD | X86_CR0_PG))</span>

<span class="cp">#define CR3_PAE_RESERVED_BITS ((X86_CR3_PWT | X86_CR3_PCD) - 1)</span>
<span class="cp">#define CR3_NONPAE_RESERVED_BITS ((PAGE_SIZE-1) &amp; ~(X86_CR3_PWT | X86_CR3_PCD))</span>
<span class="cp">#define CR3_L_MODE_RESERVED_BITS (CR3_NONPAE_RESERVED_BITS |	\</span>
<span class="cp">				  0xFFFFFF0000000000ULL)</span>
<span class="cp">#define CR4_RESERVED_BITS                                               \</span>
<span class="cp">	(~(unsigned long)(X86_CR4_VME | X86_CR4_PVI | X86_CR4_TSD | X86_CR4_DE\</span>
<span class="cp">			  | X86_CR4_PSE | X86_CR4_PAE | X86_CR4_MCE     \</span>
<span class="cp">			  | X86_CR4_PGE | X86_CR4_PCE | X86_CR4_OSFXSR  \</span>
<span class="cp">			  | X86_CR4_OSXSAVE | X86_CR4_SMEP | X86_CR4_RDWRGSFS \</span>
<span class="cp">			  | X86_CR4_OSXMMEXCPT | X86_CR4_VMXE))</span>

<span class="cp">#define CR8_RESERVED_BITS (~(unsigned long)X86_CR8_TPR)</span>



<span class="cp">#define INVALID_PAGE (~(hpa_t)0)</span>
<span class="cp">#define VALID_PAGE(x) ((x) != INVALID_PAGE)</span>

<span class="cp">#define UNMAPPED_GVA (~(gpa_t)0)</span>

<span class="cm">/* KVM Hugepage definitions for x86 */</span>
<span class="cp">#define KVM_NR_PAGE_SIZES	3</span>
<span class="cp">#define KVM_HPAGE_GFN_SHIFT(x)	(((x) - 1) * 9)</span>
<span class="cp">#define KVM_HPAGE_SHIFT(x)	(PAGE_SHIFT + KVM_HPAGE_GFN_SHIFT(x))</span>
<span class="cp">#define KVM_HPAGE_SIZE(x)	(1UL &lt;&lt; KVM_HPAGE_SHIFT(x))</span>
<span class="cp">#define KVM_HPAGE_MASK(x)	(~(KVM_HPAGE_SIZE(x) - 1))</span>
<span class="cp">#define KVM_PAGES_PER_HPAGE(x)	(KVM_HPAGE_SIZE(x) / PAGE_SIZE)</span>

<span class="cp">#define DE_VECTOR 0</span>
<span class="cp">#define DB_VECTOR 1</span>
<span class="cp">#define BP_VECTOR 3</span>
<span class="cp">#define OF_VECTOR 4</span>
<span class="cp">#define BR_VECTOR 5</span>
<span class="cp">#define UD_VECTOR 6</span>
<span class="cp">#define NM_VECTOR 7</span>
<span class="cp">#define DF_VECTOR 8</span>
<span class="cp">#define TS_VECTOR 10</span>
<span class="cp">#define NP_VECTOR 11</span>
<span class="cp">#define SS_VECTOR 12</span>
<span class="cp">#define GP_VECTOR 13</span>
<span class="cp">#define PF_VECTOR 14</span>
<span class="cp">#define MF_VECTOR 16</span>
<span class="cp">#define MC_VECTOR 18</span>

<span class="cp">#define SELECTOR_TI_MASK (1 &lt;&lt; 2)</span>
<span class="cp">#define SELECTOR_RPL_MASK 0x03</span>

<span class="cp">#define IOPL_SHIFT 12</span>

<span class="cp">#define KVM_PERMILLE_MMU_PAGES 20</span>
<span class="cp">#define KVM_MIN_ALLOC_MMU_PAGES 64</span>
<span class="cp">#define KVM_MMU_HASH_SHIFT 10</span>
<span class="cp">#define KVM_NUM_MMU_PAGES (1 &lt;&lt; KVM_MMU_HASH_SHIFT)</span>
<span class="cp">#define KVM_MIN_FREE_MMU_PAGES 5</span>
<span class="cp">#define KVM_REFILL_PAGES 25</span>
<span class="cp">#define KVM_MAX_CPUID_ENTRIES 80</span>
<span class="cp">#define KVM_NR_FIXED_MTRR_REGION 88</span>
<span class="cp">#define KVM_NR_VAR_MTRR 8</span>

<span class="cp">#define ASYNC_PF_PER_VCPU 64</span>

<span class="k">extern</span> <span class="n">raw_spinlock_t</span> <span class="n">kvm_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">vm_list</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kvm</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kvm_async_pf</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">kvm_reg</span> <span class="p">{</span>
	<span class="n">VCPU_REGS_RAX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VCPU_REGS_RCX</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">VCPU_REGS_RDX</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">VCPU_REGS_RBX</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">VCPU_REGS_RSP</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">VCPU_REGS_RBP</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">VCPU_REGS_RSI</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">VCPU_REGS_RDI</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">VCPU_REGS_R8</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">VCPU_REGS_R9</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">VCPU_REGS_R10</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">VCPU_REGS_R11</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">VCPU_REGS_R12</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">VCPU_REGS_R13</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">VCPU_REGS_R14</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">VCPU_REGS_R15</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="n">VCPU_REGS_RIP</span><span class="p">,</span>
	<span class="n">NR_VCPU_REGS</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">kvm_reg_ex</span> <span class="p">{</span>
	<span class="n">VCPU_EXREG_PDPTR</span> <span class="o">=</span> <span class="n">NR_VCPU_REGS</span><span class="p">,</span>
	<span class="n">VCPU_EXREG_CR3</span><span class="p">,</span>
	<span class="n">VCPU_EXREG_RFLAGS</span><span class="p">,</span>
	<span class="n">VCPU_EXREG_CPL</span><span class="p">,</span>
	<span class="n">VCPU_EXREG_SEGMENTS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">VCPU_SREG_ES</span><span class="p">,</span>
	<span class="n">VCPU_SREG_CS</span><span class="p">,</span>
	<span class="n">VCPU_SREG_SS</span><span class="p">,</span>
	<span class="n">VCPU_SREG_DS</span><span class="p">,</span>
	<span class="n">VCPU_SREG_FS</span><span class="p">,</span>
	<span class="n">VCPU_SREG_GS</span><span class="p">,</span>
	<span class="n">VCPU_SREG_TR</span><span class="p">,</span>
	<span class="n">VCPU_SREG_LDTR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#include &lt;asm/kvm_emulate.h&gt;</span>

<span class="cp">#define KVM_NR_MEM_OBJS 40</span>

<span class="cp">#define KVM_NR_DB_REGS	4</span>

<span class="cp">#define DR6_BD		(1 &lt;&lt; 13)</span>
<span class="cp">#define DR6_BS		(1 &lt;&lt; 14)</span>
<span class="cp">#define DR6_FIXED_1	0xffff0ff0</span>
<span class="cp">#define DR6_VOLATILE	0x0000e00f</span>

<span class="cp">#define DR7_BP_EN_MASK	0x000000ff</span>
<span class="cp">#define DR7_GE		(1 &lt;&lt; 9)</span>
<span class="cp">#define DR7_GD		(1 &lt;&lt; 13)</span>
<span class="cp">#define DR7_FIXED_1	0x00000400</span>
<span class="cp">#define DR7_VOLATILE	0xffff23ff</span>

<span class="cm">/* apic attention bits */</span>
<span class="cp">#define KVM_APIC_CHECK_VAPIC	0</span>

<span class="cm">/*</span>
<span class="cm"> * We don&#39;t want allocation failures within the mmu code, so we preallocate</span>
<span class="cm"> * enough memory for a single page fault in a cache.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nobjs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">objects</span><span class="p">[</span><span class="n">KVM_NR_MEM_OBJS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * kvm_mmu_page_role, below, is defined as:</span>
<span class="cm"> *</span>
<span class="cm"> *   bits 0:3 - total guest paging levels (2-4, or zero for real mode)</span>
<span class="cm"> *   bits 4:7 - page table level for this shadow (1-4)</span>
<span class="cm"> *   bits 8:9 - page table quadrant for 2-level guests</span>
<span class="cm"> *   bit   16 - direct mapping of virtual to physical mapping at gfn</span>
<span class="cm"> *              used for real mode and two-dimensional paging</span>
<span class="cm"> *   bits 17:19 - common access permissions for all ptes in this shadow page</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">word</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">level</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">cr4_pae</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">quadrant</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">pad_for_nice_hex_output</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">direct</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">access</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">invalid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">nxe</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">cr0_wp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">smep_andnot_wp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hash_link</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following two entries are used to key the shadow page in the</span>
<span class="cm">	 * hash table.</span>
<span class="cm">	 */</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="n">role</span><span class="p">;</span>

	<span class="n">u64</span> <span class="o">*</span><span class="n">spt</span><span class="p">;</span>
	<span class="cm">/* hold the gfn of each spte inside spt */</span>
	<span class="n">gfn_t</span> <span class="o">*</span><span class="n">gfns</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * One bit set per slot which has memory</span>
<span class="cm">	 * in this shadow page.</span>
<span class="cm">	 */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">slot_bitmap</span><span class="p">,</span> <span class="n">KVM_MEM_SLOTS_NUM</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">unsync</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">root_count</span><span class="p">;</span>          <span class="cm">/* Currently serving as active root */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unsync_children</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ptes</span><span class="p">;</span>	<span class="cm">/* Reverse mapping for parent_pte */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">unsync_child_bitmap</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="kt">int</span> <span class="n">clear_spte_count</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">int</span> <span class="n">write_flooding_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_pio_request</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">in</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * x86 supports 3 paging modes (4-level 64-bit, 3-level 64-bit, and 2-level</span>
<span class="cm"> * 32-bit).  The kvm_mmu structure abstracts the details of the current mmu</span>
<span class="cm"> * mode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">new_cr3</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_cr3</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">root</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_cr3</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">get_pdptr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">page_fault</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">u32</span> <span class="n">err</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">prefault</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">inject_page_fault</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">gpa_t</span> <span class="p">(</span><span class="o">*</span><span class="n">gva_to_gpa</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">u32</span> <span class="n">access</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">);</span>
	<span class="n">gpa_t</span> <span class="p">(</span><span class="o">*</span><span class="n">translate_gpa</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">access</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">invlpg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">update_pte</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pte</span><span class="p">);</span>
	<span class="n">hpa_t</span> <span class="n">root_hpa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">root_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shadow_root_level</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="n">base_role</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">direct_map</span><span class="p">;</span>

	<span class="n">u64</span> <span class="o">*</span><span class="n">pae_root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">lm_root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>

	<span class="n">bool</span> <span class="n">nx</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">pdptrs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* pae */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">pmc_type</span> <span class="p">{</span>
	<span class="n">KVM_PMC_GP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">KVM_PMC_FIXED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_pmc</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">pmc_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">counter</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">eventsel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">perf_event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_pmu</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">nr_arch_gp_counters</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nr_arch_fixed_counters</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">available_event_types</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">fixed_ctr_ctrl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">global_ctrl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">global_status</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">global_ovf_ctrl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">counter_bitmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">global_ctrl_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">version</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_pmc</span> <span class="n">gp_counters</span><span class="p">[</span><span class="n">X86_PMC_MAX_GENERIC</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">kvm_pmc</span> <span class="n">fixed_counters</span><span class="p">[</span><span class="n">X86_PMC_MAX_FIXED</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">irq_work</span> <span class="n">irq_work</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">reprogram_pmi</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_vcpu_arch</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * rip and regs accesses must go through</span>
<span class="cm">	 * kvm_{register,rip}_{read,write} functions.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regs</span><span class="p">[</span><span class="n">NR_VCPU_REGS</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">regs_avail</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">regs_dirty</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr0_guest_owned_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr4_guest_owned_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr8</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hflags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">apic_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_lapic</span> <span class="o">*</span><span class="n">apic</span><span class="p">;</span>    <span class="cm">/* kernel irqchip context */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">apic_attention</span><span class="p">;</span>
	<span class="kt">int32_t</span> <span class="n">apic_arb_prio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mp_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sipi_vector</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ia32_misc_enable_msr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">tpr_access_reporting</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Paging state of the vcpu</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the vcpu runs in guest mode with two level paging this still saves</span>
<span class="cm">	 * the paging mode of the l1 guest. This context is always used to</span>
<span class="cm">	 * handle faults.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="n">mmu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Paging state of an L2 guest (used for nested npt)</span>
<span class="cm">	 *</span>
<span class="cm">	 * This context will save all necessary information to walk page tables</span>
<span class="cm">	 * of the an L2 guest. This context is only initialized for page table</span>
<span class="cm">	 * walking and not for faulting since we never handle l2 page faults on</span>
<span class="cm">	 * the host.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="n">nested_mmu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pointer to the mmu context currently used for</span>
<span class="cm">	 * gva_to_gpa translations.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">walk_mmu</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="n">mmu_pte_list_desc_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="n">mmu_page_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="n">mmu_page_header_cache</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">fpu</span> <span class="n">guest_fpu</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">xcr0</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">kvm_pio_request</span> <span class="n">pio</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pio_data</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">event_exit_inst_len</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">kvm_queued_exception</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">pending</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">has_error_code</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">reinject</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">nr</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">exception</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">kvm_queued_interrupt</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">pending</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">soft</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">nr</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">interrupt</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">halt_request</span><span class="p">;</span> <span class="cm">/* real mode on Intel only */</span>

	<span class="kt">int</span> <span class="n">cpuid_nent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="n">cpuid_entries</span><span class="p">[</span><span class="n">KVM_MAX_CPUID_ENTRIES</span><span class="p">];</span>
	<span class="cm">/* emulate context */</span>

	<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="n">emulate_ctxt</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">emulate_regs_need_sync_to_vcpu</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">emulate_regs_need_sync_from_vcpu</span><span class="p">;</span>

	<span class="n">gpa_t</span> <span class="n">time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvclock_vcpu_time_info</span> <span class="n">hv_clock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hw_tsc_khz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">time_page</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">msr_val</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">last_steal</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">accum_steal</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">gfn_to_hva_cache</span> <span class="n">stime</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_steal_time</span> <span class="n">steal</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">st</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">last_guest_tsc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_kernel_ns</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_host_tsc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tsc_offset_adjustment</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">this_tsc_nsec</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">this_tsc_write</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">this_tsc_generation</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">tsc_catchup</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">tsc_always_catchup</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">virtual_tsc_shift</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">virtual_tsc_mult</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">virtual_tsc_khz</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">nmi_queued</span><span class="p">;</span>  <span class="cm">/* unprocessed asynchronous NMIs */</span>
	<span class="kt">unsigned</span> <span class="n">nmi_pending</span><span class="p">;</span> <span class="cm">/* NMI queued after currently running handler */</span>
	<span class="n">bool</span> <span class="n">nmi_injected</span><span class="p">;</span>    <span class="cm">/* Trying to inject an NMI this entry */</span>

	<span class="k">struct</span> <span class="n">mtrr_state_type</span> <span class="n">mtrr_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pat</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">switch_db_regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">db</span><span class="p">[</span><span class="n">KVM_NR_DB_REGS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dr6</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dr7</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eff_db</span><span class="p">[</span><span class="n">KVM_NR_DB_REGS</span><span class="p">];</span>

	<span class="n">u64</span> <span class="n">mcg_cap</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mcg_status</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mcg_ctl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">mce_banks</span><span class="p">;</span>

	<span class="cm">/* Cache MMIO info */</span>
	<span class="n">u64</span> <span class="n">mmio_gva</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">access</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">mmio_gfn</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">kvm_pmu</span> <span class="n">pmu</span><span class="p">;</span>

	<span class="cm">/* used for guest single stepping over the given code position */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">singlestep_rip</span><span class="p">;</span>

	<span class="cm">/* fields used by HYPER-V emulation */</span>
	<span class="n">u64</span> <span class="n">hv_vapic</span><span class="p">;</span>

	<span class="n">cpumask_var_t</span> <span class="n">wbinvd_dirty_mask</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_retry_eip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_retry_addr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">halted</span><span class="p">;</span>
		<span class="n">gfn_t</span> <span class="n">gfns</span><span class="p">[</span><span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">ASYNC_PF_PER_VCPU</span><span class="p">)];</span>
		<span class="k">struct</span> <span class="n">gfn_to_hva_cache</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">msr_val</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">send_user_only</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">apf</span><span class="p">;</span>

	<span class="cm">/* OSVW MSRs (AMD only) */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">osvw</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_lpage_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rmap_pde</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_arch_memory_slot</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_lpage_info</span> <span class="o">*</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">KVM_NR_PAGE_SIZES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_arch</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_used_mmu_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_requested_mmu_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_max_mmu_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">indirect_shadow_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">mmu_page_hash</span><span class="p">[</span><span class="n">KVM_NUM_MMU_PAGES</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hash table of struct kvm_mmu_page.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">active_mmu_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">assigned_dev_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">iommu_domain</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iommu_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_pic</span> <span class="o">*</span><span class="n">vpic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_ioapic</span> <span class="o">*</span><span class="n">vioapic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_pit</span> <span class="o">*</span><span class="n">vpit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vapics_in_nmi_mode</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tss_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">apic_access_page</span><span class="p">;</span>

	<span class="n">gpa_t</span> <span class="n">wall_clock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">ept_identity_pagetable</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ept_identity_pagetable_done</span><span class="p">;</span>
	<span class="n">gpa_t</span> <span class="n">ept_identity_map_addr</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_sources_bitmap</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">kvmclock_offset</span><span class="p">;</span>
	<span class="n">raw_spinlock_t</span> <span class="n">tsc_write_lock</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_tsc_nsec</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_tsc_write</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_tsc_khz</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cur_tsc_nsec</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cur_tsc_write</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cur_tsc_offset</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">cur_tsc_generation</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">kvm_xen_hvm_config</span> <span class="n">xen_hvm_config</span><span class="p">;</span>

	<span class="cm">/* fields used by HYPER-V emulation */</span>
	<span class="n">u64</span> <span class="n">hv_guest_os_id</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hv_hypercall</span><span class="p">;</span>

	<span class="cp">#ifdef CONFIG_KVM_MMU_AUDIT</span>
	<span class="kt">int</span> <span class="n">audit_point</span><span class="p">;</span>
	<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_vm_stat</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">mmu_shadow_zapped</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmu_pte_write</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmu_pte_updated</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmu_pde_zapped</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmu_flooded</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmu_recycled</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmu_cache_miss</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmu_unsync</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">remote_tlb_flush</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lpages</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_vcpu_stat</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">pf_fixed</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pf_guest</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tlb_flush</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">invlpg</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">exits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">io_exits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mmio_exits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">signal_exits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_window_exits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nmi_window_exits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">halt_exits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">halt_wakeup</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">request_irq_exits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_exits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">host_state_reload</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">efer_reload</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fpu_reload</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">insn_emulation</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">insn_emulation_fail</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hypercalls</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_injections</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nmi_injections</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">x86_instruction_info</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">kvm_x86_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_has_kvm_support</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>          <span class="cm">/* __init */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">disabled_by_bios</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>             <span class="cm">/* __init */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hardware_enable</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hardware_disable</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">check_processor_compatibility</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rtn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hardware_setup</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>               <span class="cm">/* __init */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hardware_unsetup</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>            <span class="cm">/* __exit */</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_has_accelerated_tpr</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cpuid_update</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/* Create, but do not attach this VCPU */</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">vcpu_create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">id</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">vcpu_free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">vcpu_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare_guest_switch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">vcpu_load</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">vcpu_put</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_guest_debug</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_guest_debug</span> <span class="o">*</span><span class="n">dbg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_msr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_msr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">get_segment_base</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_segment</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kvm_segment</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_cpl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_segment</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kvm_segment</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_cs_db_l_bits</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">db</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">decache_cr0_guest_bits</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">decache_cr3</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">decache_cr4_guest_bits</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_cr0</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr0</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_cr3</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_cr4</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr4</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_efer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">efer</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_idt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_idt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_gdt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_gdt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_dr7</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cache_reg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">kvm_reg</span> <span class="n">reg</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_rflags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_rflags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rflags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fpu_activate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fpu_deactivate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tlb_flush</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">run</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">handle_exit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">skip_emulated_instruction</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_interrupt_shadow</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">get_interrupt_shadow</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">patch_hypercall</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hypercall_addr</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_nmi</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">queue_exception</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">has_error_code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">reinject</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cancel_injection</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">interrupt_allowed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nmi_allowed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">get_nmi_mask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_nmi_mask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">masked</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">enable_nmi_window</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">enable_irq_window</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">update_cr8_intercept</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tpr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_tss_addr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_tdp_level</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">get_mt_mask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_mmio</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_lpage_level</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">rdtscp_supported</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">adjust_tsc_offset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">s64</span> <span class="n">adjustment</span><span class="p">,</span> <span class="n">bool</span> <span class="n">host</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_tdp_cr3</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_supported_cpuid</span><span class="p">)(</span><span class="n">u32</span> <span class="n">func</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>

	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">has_wbinvd_exit</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_tsc_khz</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">user_tsc_khz</span><span class="p">,</span> <span class="n">bool</span> <span class="n">scale</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_tsc_offset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">compute_tsc_offset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">target_tsc</span><span class="p">);</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">read_l1_tsc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_exit_info</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">info1</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">info2</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_intercept</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">x86_instruction_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">x86_intercept_stage</span> <span class="n">stage</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_arch_async_pf</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">token</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">direct_map</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kvm_x86_ops</span> <span class="o">*</span><span class="n">kvm_x86_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">adjust_tsc_offset_guest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					   <span class="n">s64</span> <span class="n">adjustment</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">adjust_tsc_offset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">adjustment</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">adjust_tsc_offset_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">s64</span> <span class="n">adjustment</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">adjust_tsc_offset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">adjustment</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">kvm_mmu_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_mmu_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_mmu_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_mmu_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_set_mask_ptes</span><span class="p">(</span><span class="n">u64</span> <span class="n">user_mask</span><span class="p">,</span> <span class="n">u64</span> <span class="n">accessed_mask</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">dirty_mask</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nx_mask</span><span class="p">,</span> <span class="n">u64</span> <span class="n">x_mask</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_mmu_reset_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_slot_remove_write_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_write_protect_pt_masked</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span>
				     <span class="n">gfn_t</span> <span class="n">gfn_offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_zap_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kvm_mmu_calculate_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_change_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kvm_nr_mmu_pages</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">load_pdptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">mmu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">emulator_write_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">kvm_get_guest_memory_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">tdp_enabled</span><span class="p">;</span>

<span class="n">u64</span> <span class="n">vcpu_tsc_khz</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="cm">/* control of guest tsc rate supported? */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">kvm_has_tsc_control</span><span class="p">;</span>
<span class="cm">/* minimum supported tsc_khz for guests */</span>
<span class="k">extern</span> <span class="n">u32</span>  <span class="n">kvm_min_guest_tsc_khz</span><span class="p">;</span>
<span class="cm">/* maximum supported tsc_khz for guests */</span>
<span class="k">extern</span> <span class="n">u32</span>  <span class="n">kvm_max_guest_tsc_khz</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">emulation_result</span> <span class="p">{</span>
	<span class="n">EMULATE_DONE</span><span class="p">,</span>       <span class="cm">/* no further processing */</span>
	<span class="n">EMULATE_DO_MMIO</span><span class="p">,</span>      <span class="cm">/* kvm_run filled with mmio request */</span>
	<span class="n">EMULATE_FAIL</span><span class="p">,</span>         <span class="cm">/* can&#39;t emulate this instruction */</span>
<span class="p">};</span>

<span class="cp">#define EMULTYPE_NO_DECODE	    (1 &lt;&lt; 0)</span>
<span class="cp">#define EMULTYPE_TRAP_UD	    (1 &lt;&lt; 1)</span>
<span class="cp">#define EMULTYPE_SKIP		    (1 &lt;&lt; 2)</span>
<span class="cp">#define EMULTYPE_RETRY		    (1 &lt;&lt; 3)</span>
<span class="kt">int</span> <span class="n">x86_emulate_instruction</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr2</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">emulation_type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">insn_len</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">emulate_instruction</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">emulation_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x86_emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">emulation_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">kvm_enable_efer_bits</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_get_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">kvm_fast_pio_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_emulate_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_emulate_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_emulate_wbinvd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_get_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_segment</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_load_segment_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">selector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_task_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tss_selector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idt_index</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">bool</span> <span class="n">has_error_code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_set_cr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr0</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_cr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_cr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr4</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_cr8</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_get_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kvm_get_cr8</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_lmsw</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msw</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_get_cs_db_l_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">db</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_xcr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">xcr</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_get_msr_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_set_msr_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kvm_get_rflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_set_rflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rflags</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">kvm_rdpmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_queue_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_queue_exception_e</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_requeue_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_requeue_exception_e</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_inject_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_read_guest_page_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">mmu</span><span class="p">,</span>
			    <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">access</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_propagate_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">kvm_require_cpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">required_cpl</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_pic_set_irq</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_inject_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">fx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_mmu_flush_tlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_pte_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_mmu_unprotect_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_mmu_unprotect_page_virt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__kvm_mmu_free_some_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_mmu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_unload</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_sync_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="n">gpa_t</span> <span class="n">translate_nested_gpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">access</span><span class="p">);</span>
<span class="n">gpa_t</span> <span class="n">kvm_mmu_gva_to_gpa_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">);</span>
<span class="n">gpa_t</span> <span class="n">kvm_mmu_gva_to_gpa_fetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">);</span>
<span class="n">gpa_t</span> <span class="n">kvm_mmu_gva_to_gpa_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">);</span>
<span class="n">gpa_t</span> <span class="n">kvm_mmu_gva_to_gpa_system</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_emulate_hypercall</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_mmu_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">insn_len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_mmu_invlpg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_enable_tdp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_disable_tdp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">complete_pio</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">kvm_check_iopl</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gpa_t</span> <span class="nf">translate_gpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gpa</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="nf">page_header</span><span class="p">(</span><span class="n">hpa_t</span> <span class="n">shadow_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">shadow_page</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="p">)</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">kvm_read_ldt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">ldt</span><span class="p">;</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;sldt %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=g&quot;</span><span class="p">(</span><span class="n">ldt</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ldt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_load_ldt</span><span class="p">(</span><span class="n">u16</span> <span class="n">sel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;lldt %0&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;rm&quot;</span><span class="p">(</span><span class="n">sel</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">read_msr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">get_rdx_init_val</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mh">0x600</span><span class="p">;</span> <span class="cm">/* P6 family */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_inject_gp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_queue_exception_e</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">GP_VECTOR</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define TSS_IOPB_BASE_OFFSET 0x66</span>
<span class="cp">#define TSS_BASE_SIZE 0x68</span>
<span class="cp">#define TSS_IOPB_SIZE (65536 / 8)</span>
<span class="cp">#define TSS_REDIRECTION_SIZE (256 / 8)</span>
<span class="cp">#define RMODE_TSS_SIZE							\</span>
<span class="cp">	(TSS_BASE_SIZE + TSS_REDIRECTION_SIZE + TSS_IOPB_SIZE + 1)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TASK_SWITCH_CALL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">TASK_SWITCH_IRET</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">TASK_SWITCH_JMP</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">TASK_SWITCH_GATE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define HF_GIF_MASK		(1 &lt;&lt; 0)</span>
<span class="cp">#define HF_HIF_MASK		(1 &lt;&lt; 1)</span>
<span class="cp">#define HF_VINTR_MASK		(1 &lt;&lt; 2)</span>
<span class="cp">#define HF_NMI_MASK		(1 &lt;&lt; 3)</span>
<span class="cp">#define HF_IRET_MASK		(1 &lt;&lt; 4)</span>
<span class="cp">#define HF_GUEST_MASK		(1 &lt;&lt; 5) </span><span class="cm">/* VCPU is in guest-mode */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Hardware virtualization extension instructions may fault if a</span>
<span class="cm"> * reboot turns off virtualization while processes are running.</span>
<span class="cm"> * Trap the fault and ignore the instruction if that happens.</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">kvm_spurious_fault</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">kvm_rebooting</span><span class="p">;</span>

<span class="cp">#define ____kvm_handle_fault_on_reboot(insn, cleanup_insn)	\</span>
<span class="cp">	&quot;666: &quot; insn &quot;\n\t&quot; \</span>
<span class="cp">	&quot;668: \n\t&quot;                           \</span>
<span class="cp">	&quot;.pushsection .fixup, \&quot;ax\&quot; \n&quot; \</span>
<span class="cp">	&quot;667: \n\t&quot; \</span>
<span class="cp">	cleanup_insn &quot;\n\t&quot;		      \</span>
<span class="cp">	&quot;cmpb $0, kvm_rebooting \n\t&quot;	      \</span>
<span class="cp">	&quot;jne 668b \n\t&quot;      		      \</span>
<span class="cp">	__ASM_SIZE(push) &quot; $666b \n\t&quot;	      \</span>
<span class="cp">	&quot;call kvm_spurious_fault \n\t&quot;	      \</span>
<span class="cp">	&quot;.popsection \n\t&quot; \</span>
<span class="cp">	_ASM_EXTABLE(666b, 667b)</span>

<span class="cp">#define __kvm_handle_fault_on_reboot(insn)		\</span>
<span class="cp">	____kvm_handle_fault_on_reboot(insn, &quot;&quot;)</span>

<span class="cp">#define KVM_ARCH_WANT_MMU_NOTIFIER</span>
<span class="kt">int</span> <span class="n">kvm_unmap_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_age_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_test_age_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_set_spte_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cpuid_maxphyaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_cpu_has_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_arch_interrupt_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_cpu_get_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_define_shared_msr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_set_shared_msr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">);</span>

<span class="n">bool</span> <span class="n">kvm_is_linear_rip</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">linear_rip</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_arch_async_page_not_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">kvm_async_pf</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_async_page_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kvm_async_pf</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_arch_async_page_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kvm_async_pf</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">kvm_arch_can_inject_async_page_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">kvm_find_async_pf_gfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_complete_insn_gp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kvm_is_in_guest</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">kvm_pmu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_pmu_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_pmu_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_pmu_cpuid_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">kvm_pmu_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_pmu_get_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_pmu_set_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kvm_pmu_read_pmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pmc</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_handle_pmu_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kvm_deliver_pmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_KVM_HOST_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
