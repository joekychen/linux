<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › apic.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>apic.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_X86_APIC_H</span>
<span class="cp">#define _ASM_X86_APIC_H</span>

<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>

<span class="cp">#include &lt;asm/alternative.h&gt;</span>
<span class="cp">#include &lt;asm/cpufeature.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/apicdef.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/fixmap.h&gt;</span>
<span class="cp">#include &lt;asm/mpspec.h&gt;</span>
<span class="cp">#include &lt;asm/msr.h&gt;</span>

<span class="cp">#define ARCH_APICTIMER_STOPS_ON_C3	1</span>

<span class="cm">/*</span>
<span class="cm"> * Debugging macros</span>
<span class="cm"> */</span>
<span class="cp">#define APIC_QUIET   0</span>
<span class="cp">#define APIC_VERBOSE 1</span>
<span class="cp">#define APIC_DEBUG   2</span>

<span class="cm">/*</span>
<span class="cm"> * Define the default level of output to be very little</span>
<span class="cm"> * This can be turned up by using apic=verbose for more</span>
<span class="cm"> * information and apic=debug for _lots_ of information.</span>
<span class="cm"> * apic_verbosity is defined in apic.c</span>
<span class="cm"> */</span>
<span class="cp">#define apic_printk(v, s, a...) do {       \</span>
<span class="cp">		if ((v) &lt;= apic_verbosity) \</span>
<span class="cp">			printk(s, ##a);    \</span>
<span class="cp">	} while (0)</span>


<span class="cp">#if defined(CONFIG_X86_LOCAL_APIC) &amp;&amp; defined(CONFIG_X86_32)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">generic_apic_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">generic_apic_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_verbosity</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">local_apic_timer_c2_ok</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">disable_apic</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lapic_timer_frequency</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__inquire_remote_apic</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__inquire_remote_apic</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">default_inquire_remote_apic</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic_verbosity</span> <span class="o">&gt;=</span> <span class="n">APIC_DEBUG</span><span class="p">)</span>
		<span class="n">__inquire_remote_apic</span><span class="p">(</span><span class="n">apicid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * With 82489DX we can&#39;t rely on apic feature bit</span>
<span class="cm"> * retrieved via cpuid but still have to deal with</span>
<span class="cm"> * such an apic chip so we assume that SMP configuration</span>
<span class="cm"> * is found from MP table (64bit case uses ACPI mostly</span>
<span class="cm"> * which set smp presence flag as well so we are safe</span>
<span class="cm"> * to use this helper too).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">apic_from_smp_config</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smp_found_config</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">disable_apic</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Basic functions accessing APICs.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PARAVIRT</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">is_vsmp_box</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_vsmp_box</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xapic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">safe_xapic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xapic_icr_write</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">setup_profiling_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_apic_mem_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">APIC_BASE</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">alternative_io</span><span class="p">(</span><span class="s">&quot;movl %0, %1&quot;</span><span class="p">,</span> <span class="s">&quot;xchgl %0, %1&quot;</span><span class="p">,</span> <span class="n">X86_FEATURE_11AP</span><span class="p">,</span>
		       <span class="n">ASM_OUTPUT2</span><span class="p">(</span><span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)),</span>
		       <span class="n">ASM_OUTPUT2</span><span class="p">(</span><span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">native_apic_mem_read</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">APIC_BASE</span> <span class="o">+</span> <span class="n">reg</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">native_apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">native_safe_apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">native_apic_icr_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">native_apic_icr_read</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">x2apic_mode</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_X2APIC</span>
<span class="cm">/*</span>
<span class="cm"> * Make previous memory operations globally visible before</span>
<span class="cm"> * sending the IPI through x2apic wrmsr. We need a serializing instruction or</span>
<span class="cm"> * mfence for this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x2apic_wrmsr_fence</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;mfence&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_apic_msr_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="n">APIC_DFR</span> <span class="o">||</span> <span class="n">reg</span> <span class="o">==</span> <span class="n">APIC_ID</span> <span class="o">||</span> <span class="n">reg</span> <span class="o">==</span> <span class="n">APIC_LDR</span> <span class="o">||</span>
	    <span class="n">reg</span> <span class="o">==</span> <span class="n">APIC_LVR</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">wrmsr</span><span class="p">(</span><span class="n">APIC_BASE_MSR</span> <span class="o">+</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_apic_msr_eoi_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wrmsr</span><span class="p">(</span><span class="n">APIC_BASE_MSR</span> <span class="o">+</span> <span class="p">(</span><span class="n">APIC_EOI</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">),</span> <span class="n">APIC_EOI_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">native_apic_msr_read</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">msr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="n">APIC_DFR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">APIC_BASE_MSR</span> <span class="o">+</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">),</span> <span class="n">msr</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">msr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_x2apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* no need to wait for icr idle in x2apic */</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">native_safe_x2apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* no need to wait for icr idle in x2apic */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_x2apic_icr_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">APIC_BASE_MSR</span> <span class="o">+</span> <span class="p">(</span><span class="n">APIC_ICR</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">),</span> <span class="p">((</span><span class="n">__u64</span><span class="p">)</span> <span class="n">id</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span> <span class="o">|</span> <span class="n">low</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">native_x2apic_icr_read</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">APIC_BASE_MSR</span> <span class="o">+</span> <span class="p">(</span><span class="n">APIC_ICR</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">x2apic_phys</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">x2apic_preenabled</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">check_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">enable_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">x2apic_icr_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">x2apic_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">msr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_x2apic</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">X2APIC_ENABLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define x2apic_supported()	(cpu_has_x2apic)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x2apic_force_phys</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x2apic_phys</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disable_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enable_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">x2apic_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x2apic_force_phys</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#define	nox2apic	0</span>
<span class="cp">#define	x2apic_preenabled 0</span>
<span class="cp">#define	x2apic_supported()	0</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">enable_IR_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_physical_broadcast</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">lapic_get_maxlvt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clear_local_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">connect_bsp_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disconnect_bsp_APIC</span><span class="p">(</span><span class="kt">int</span> <span class="n">virt_wire_setup</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disable_local_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lapic_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">verify_local_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sync_Arb_IDs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_bsp_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">setup_local_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">end_local_APIC_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bsp_end_local_APIC_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_apic_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">register_lapic_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">setup_boot_APIC_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">setup_secondary_APIC_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">APIC_init_uniprocessor</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">apic_force_enable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * On 32bit this is mach-xxx local</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">apic_is_clustered_box</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">apic_is_clustered_box</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">setup_APIC_eilvt</span><span class="p">(</span><span class="n">u8</span> <span class="n">lvt_off</span><span class="p">,</span> <span class="n">u8</span> <span class="n">vector</span><span class="p">,</span> <span class="n">u8</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_X86_LOCAL_APIC */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lapic_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#define local_apic_timer_c2_ok		1</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_apic_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disable_local_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp"># define setup_boot_APIC_clock x86_init_noop</span>
<span class="cp"># define setup_secondary_APIC_clock x86_init_noop</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_X86_LOCAL_APIC */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cp">#define	SET_APIC_ID(x)		(apic-&gt;set_apic_id(x))</span>
<span class="cp">#else</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright 2004 James Cleverdon, IBM.</span>
<span class="cm"> * Subject to the GNU Public License, v.2</span>
<span class="cm"> *</span>
<span class="cm"> * Generic APIC sub-arch data struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Hacked for x86-64 by James Cleverdon from i386 architecture code by</span>
<span class="cm"> * Martin Bligh, Andi Kleen, James Bottomley, John Stultz, and</span>
<span class="cm"> * James Cleverdon.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">apic</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">acpi_madt_oem_check</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">oem_id</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oem_table_id</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">apic_id_valid</span><span class="p">)(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">apic_id_registered</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="n">u32</span> <span class="n">irq_delivery_mode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_dest_mode</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">target_cpus</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">disable_esr</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">dest_logical</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">check_apicid_used</span><span class="p">)(</span><span class="n">physid_mask_t</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apicid</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">check_apicid_present</span><span class="p">)(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">vector_allocation_domain</span><span class="p">)(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">retmask</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init_apic_ldr</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ioapic_phys_id_map</span><span class="p">)(</span><span class="n">physid_mask_t</span> <span class="o">*</span><span class="n">phys_map</span><span class="p">,</span> <span class="n">physid_mask_t</span> <span class="o">*</span><span class="n">retmap</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_apic_routing</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">multi_timer_check</span><span class="p">)(</span><span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_present_to_apicid</span><span class="p">)(</span><span class="kt">int</span> <span class="n">mps_cpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">apicid_to_cpu_present</span><span class="p">)(</span><span class="kt">int</span> <span class="n">phys_apicid</span><span class="p">,</span> <span class="n">physid_mask_t</span> <span class="o">*</span><span class="n">retmap</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_portio_remap</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_phys_apicid_present</span><span class="p">)(</span><span class="kt">int</span> <span class="n">phys_apicid</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">enable_apic_mode</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">phys_pkg_id</span><span class="p">)(</span><span class="kt">int</span> <span class="n">cpuid_apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index_msb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When one of the next two hooks returns 1 the apic</span>
<span class="cm">	 * is switched to this. Essentially they are additional</span>
<span class="cm">	 * probe functions:</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mps_oem_check</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mpc_table</span> <span class="o">*</span><span class="n">mpc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oem</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">productid</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_apic_id</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">set_apic_id</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">apic_id_mask</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_mask_to_apicid</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_mask_to_apicid_and</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">,</span>
					       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">andmask</span><span class="p">);</span>

	<span class="cm">/* ipi */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_IPI_mask</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_IPI_mask_allbutself</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">vector</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_IPI_allbutself</span><span class="p">)(</span><span class="kt">int</span> <span class="n">vector</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_IPI_all</span><span class="p">)(</span><span class="kt">int</span> <span class="n">vector</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">send_IPI_self</span><span class="p">)(</span><span class="kt">int</span> <span class="n">vector</span><span class="p">);</span>

	<span class="cm">/* wakeup_secondary_cpu */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">wakeup_secondary_cpu</span><span class="p">)(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_eip</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">trampoline_phys_low</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trampoline_phys_high</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_for_init_deassert</span><span class="p">)(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">deassert</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">smp_callin_clear_local_apic</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">inquire_remote_apic</span><span class="p">)(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">);</span>

	<span class="cm">/* apic ops */</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">v</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * -&gt;eoi_write() has the same signature as -&gt;write().</span>
<span class="cm">	 *</span>
<span class="cm">	 * Drivers can support both -&gt;eoi_write() and -&gt;write() by passing the same</span>
<span class="cm">	 * callback value. Kernel can override -&gt;eoi_write() and fall back</span>
<span class="cm">	 * on write for EOI.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">eoi_write</span><span class="p">)(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">icr_read</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">icr_write</span><span class="p">)(</span><span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">high</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_icr_idle</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">safe_wait_icr_idle</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/*</span>
<span class="cm">	 * Called very early during boot from get_smp_config().  It should</span>
<span class="cm">	 * return the logical apicid.  x86_[bios]_cpu_to_apicid is</span>
<span class="cm">	 * initialized before this function is called.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If logical apicid can&#39;t be determined that early, the function</span>
<span class="cm">	 * may return BAD_APICID.  Logical apicid will be configured after</span>
<span class="cm">	 * init_apic_ldr() while bringing up CPUs.  Note that NUMA affinity</span>
<span class="cm">	 * won&#39;t be applied properly during early boot in this case.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">x86_32_early_logical_apicid</span><span class="p">)(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Optional method called from setup_local_APIC() after logical</span>
<span class="cm">	 * apicid is guaranteed to be known to initialize apicid -&gt; node</span>
<span class="cm">	 * mapping if NUMA initialization hasn&#39;t done so already.  Don&#39;t</span>
<span class="cm">	 * add new users.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">x86_32_numa_cpu_node</span><span class="p">)(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Pointer to the local APIC driver in use on this system (there&#39;s</span>
<span class="cm"> * always just one such driver in use - the kernel decides via an</span>
<span class="cm"> * early probing process which one it picks - and then sticks to it):</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">apic</span> <span class="o">*</span><span class="n">apic</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * APIC drivers are probed based on how they are listed in the .apicdrivers</span>
<span class="cm"> * section. So the order is important and enforced by the ordering</span>
<span class="cm"> * of different apic driver files in the Makefile.</span>
<span class="cm"> *</span>
<span class="cm"> * For the files having two apic drivers, we use apic_drivers()</span>
<span class="cm"> * to enforce the order with in them.</span>
<span class="cm"> */</span>
<span class="cp">#define apic_driver(sym)					\</span>
<span class="cp">	static struct apic *__apicdrivers_##sym __used		\</span>
<span class="cp">	__aligned(sizeof(struct apic *))			\</span>
<span class="cp">	__section(.apicdrivers) = { &amp;sym }</span>

<span class="cp">#define apic_drivers(sym1, sym2)					\</span>
<span class="cp">	static struct apic *__apicdrivers_##sym1##sym2[2] __used	\</span>
<span class="cp">	__aligned(sizeof(struct apic *))				\</span>
<span class="cp">	__section(.apicdrivers) = { &amp;sym1, &amp;sym2 }</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">apic</span> <span class="o">*</span><span class="n">__apicdrivers</span><span class="p">[],</span> <span class="o">*</span><span class="n">__apicdrivers_end</span><span class="p">[];</span>

<span class="cm">/*</span>
<span class="cm"> * APIC functionality to boot other CPUs - only used on SMP:</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">init_deasserted</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wakeup_secondary_cpu_via_nmi</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_eip</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">apic_read</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apic_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apic_eoi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">eoi_write</span><span class="p">(</span><span class="n">APIC_EOI</span><span class="p">,</span> <span class="n">APIC_EOI_ACK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">apic_icr_read</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">icr_read</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apic_icr_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">icr_write</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">wait_icr_idle</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">safe_apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">safe_wait_icr_idle</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_X86_LOCAL_APIC */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">apic_read</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apic_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apic_eoi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">apic_icr_read</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apic_icr_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">safe_apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_LOCAL_APIC */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ack_APIC_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * ack_APIC_irq() actually gets compiled as a single instruction</span>
<span class="cm">	 * ... yummie.</span>
<span class="cm">	 */</span>
	<span class="n">apic_eoi</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">default_get_apic_id</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ver</span> <span class="o">=</span> <span class="n">GET_APIC_VERSION</span><span class="p">(</span><span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVR</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">APIC_XAPIC</span><span class="p">(</span><span class="n">ver</span><span class="p">)</span> <span class="o">||</span> <span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_EXTD_APICID</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Warm reset vector default position:</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_TRAMPOLINE_PHYS_LOW		0x467</span>
<span class="cp">#define DEFAULT_TRAMPOLINE_PHYS_HIGH		0x469</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">default_acpi_madt_oem_check</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">apic_send_IPI_self</span><span class="p">(</span><span class="kt">int</span> <span class="n">vector</span><span class="p">);</span>

<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">x2apic_extra_bits</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">default_cpu_present_to_apicid</span><span class="p">(</span><span class="kt">int</span> <span class="n">mps_cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">default_check_phys_apicid_present</span><span class="p">(</span><span class="kt">int</span> <span class="n">phys_apicid</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">default_wait_for_init_deassert</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">deassert</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="n">deassert</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">generic_bigsmp_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>

<span class="cp">#include &lt;asm/smp.h&gt;</span>

<span class="cp">#define APIC_DFR_VALUE	(APIC_DFR_FLAT)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">default_target_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">return</span> <span class="n">cpu_online_mask</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">DECLARE_EARLY_PER_CPU</span><span class="p">(</span><span class="n">u16</span><span class="p">,</span> <span class="n">x86_bios_cpu_apicid</span><span class="p">);</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">read_apic_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">get_apic_id</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">default_apic_id_valid</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">apicid</span> <span class="o">&lt;</span> <span class="mi">255</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">default_setup_apic_routing</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">apic</span> <span class="n">apic_noop</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">noop_x86_32_early_logical_apicid</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">BAD_APICID</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up the logical destination ID.</span>
<span class="cm"> *</span>
<span class="cm"> * Intel recommends to set DFR, LDR and TPR before enabling</span>
<span class="cm"> * an APIC.  See e.g. &quot;AP-388 82489DX User&#39;s Manual&quot; (Intel</span>
<span class="cm"> * document number 292116).  So here it goes...</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">default_init_apic_ldr</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">default_apic_id_registered</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">physid_isset</span><span class="p">(</span><span class="n">read_apic_id</span><span class="p">(),</span> <span class="n">phys_cpu_present_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">default_phys_pkg_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpuid_apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index_msb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpuid_apic</span> <span class="o">&gt;&gt;</span> <span class="n">index_msb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">default_cpu_mask_to_apicid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">cpumask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">APIC_ALL_CPUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">default_cpu_mask_to_apicid_and</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">andmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask1</span> <span class="o">=</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">cpumask</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask2</span> <span class="o">=</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">andmask</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask3</span> <span class="o">=</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">mask1</span> <span class="o">&amp;</span> <span class="n">mask2</span> <span class="o">&amp;</span> <span class="n">mask3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">default_check_apicid_used</span><span class="p">(</span><span class="n">physid_mask_t</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">physid_isset</span><span class="p">(</span><span class="n">apicid</span><span class="p">,</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">default_check_apicid_present</span><span class="p">(</span><span class="kt">int</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">physid_isset</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">phys_cpu_present_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">default_ioapic_phys_id_map</span><span class="p">(</span><span class="n">physid_mask_t</span> <span class="o">*</span><span class="n">phys_map</span><span class="p">,</span> <span class="n">physid_mask_t</span> <span class="o">*</span><span class="n">retmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">retmap</span> <span class="o">=</span> <span class="o">*</span><span class="n">phys_map</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__default_cpu_present_to_apicid</span><span class="p">(</span><span class="kt">int</span> <span class="n">mps_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mps_cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_present</span><span class="p">(</span><span class="n">mps_cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">x86_bios_cpu_apicid</span><span class="p">,</span> <span class="n">mps_cpu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">BAD_APICID</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">__default_check_phys_apicid_present</span><span class="p">(</span><span class="kt">int</span> <span class="n">phys_apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">physid_isset</span><span class="p">(</span><span class="n">phys_apicid</span><span class="p">,</span> <span class="n">phys_cpu_present_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">default_cpu_present_to_apicid</span><span class="p">(</span><span class="kt">int</span> <span class="n">mps_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__default_cpu_present_to_apicid</span><span class="p">(</span><span class="n">mps_cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">default_check_phys_apicid_present</span><span class="p">(</span><span class="kt">int</span> <span class="n">phys_apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__default_check_phys_apicid_present</span><span class="p">(</span><span class="n">phys_apicid</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">default_cpu_present_to_apicid</span><span class="p">(</span><span class="kt">int</span> <span class="n">mps_cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">default_check_phys_apicid_present</span><span class="p">(</span><span class="kt">int</span> <span class="n">phys_apicid</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_LOCAL_APIC */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_APIC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
