<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › paravirt_types.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>paravirt_types.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_X86_PARAVIRT_TYPES_H</span>
<span class="cp">#define _ASM_X86_PARAVIRT_TYPES_H</span>

<span class="cm">/* Bitmask of what can be clobbered: usually at least eax. */</span>
<span class="cp">#define CLBR_NONE 0</span>
<span class="cp">#define CLBR_EAX  (1 &lt;&lt; 0)</span>
<span class="cp">#define CLBR_ECX  (1 &lt;&lt; 1)</span>
<span class="cp">#define CLBR_EDX  (1 &lt;&lt; 2)</span>
<span class="cp">#define CLBR_EDI  (1 &lt;&lt; 3)</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cm">/* CLBR_ANY should match all regs platform has. For i386, that&#39;s just it */</span>
<span class="cp">#define CLBR_ANY  ((1 &lt;&lt; 4) - 1)</span>

<span class="cp">#define CLBR_ARG_REGS	(CLBR_EAX | CLBR_EDX | CLBR_ECX)</span>
<span class="cp">#define CLBR_RET_REG	(CLBR_EAX | CLBR_EDX)</span>
<span class="cp">#define CLBR_SCRATCH	(0)</span>
<span class="cp">#else</span>
<span class="cp">#define CLBR_RAX  CLBR_EAX</span>
<span class="cp">#define CLBR_RCX  CLBR_ECX</span>
<span class="cp">#define CLBR_RDX  CLBR_EDX</span>
<span class="cp">#define CLBR_RDI  CLBR_EDI</span>
<span class="cp">#define CLBR_RSI  (1 &lt;&lt; 4)</span>
<span class="cp">#define CLBR_R8   (1 &lt;&lt; 5)</span>
<span class="cp">#define CLBR_R9   (1 &lt;&lt; 6)</span>
<span class="cp">#define CLBR_R10  (1 &lt;&lt; 7)</span>
<span class="cp">#define CLBR_R11  (1 &lt;&lt; 8)</span>

<span class="cp">#define CLBR_ANY  ((1 &lt;&lt; 9) - 1)</span>

<span class="cp">#define CLBR_ARG_REGS	(CLBR_RDI | CLBR_RSI | CLBR_RDX | \</span>
<span class="cp">			 CLBR_RCX | CLBR_R8 | CLBR_R9)</span>
<span class="cp">#define CLBR_RET_REG	(CLBR_RAX)</span>
<span class="cp">#define CLBR_SCRATCH	(CLBR_R10 | CLBR_R11)</span>

<span class="cp">#endif </span><span class="cm">/* X86_64 */</span><span class="cp"></span>

<span class="cp">#define CLBR_CALLEE_SAVE ((CLBR_ARG_REGS | CLBR_SCRATCH) &amp; ~CLBR_RET_REG)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#include &lt;asm/desc_defs.h&gt;</span>
<span class="cp">#include &lt;asm/kmap_types.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable_types.h&gt;</span>

<span class="k">struct</span> <span class="n">page</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">thread_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">desc_ptr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">tss_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">desc_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cpumask</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper type for pointers to code which uses the non-standard</span>
<span class="cm"> * calling convention.  See PV_CALL_SAVE_REGS_THUNK below.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* general info */</span>
<span class="k">struct</span> <span class="n">pv_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kernel_rpl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shared_kernel_pmd</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">u16</span> <span class="n">extra_user_64bit_cs</span><span class="p">;</span>  <span class="cm">/* __USER_CS if none */</span>
<span class="cp">#endif</span>

	<span class="kt">int</span> <span class="n">paravirt_enabled</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pv_init_ops</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Patch may replace one of the defined code sequences with</span>
<span class="cm">	 * arbitrary code, subject to the same register constraints.</span>
<span class="cm">	 * This generally means the code is not free to clobber any</span>
<span class="cm">	 * registers other than EAX.  The patch function should return</span>
<span class="cm">	 * the number of bytes of code generated, as we nop pad the</span>
<span class="cm">	 * rest in generic code.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="p">(</span><span class="o">*</span><span class="n">patch</span><span class="p">)(</span><span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">clobber</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">insnbuf</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">pv_lazy_ops</span> <span class="p">{</span>
	<span class="cm">/* Set deferred update mode, used for batching operations. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">enter</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">leave</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pv_time_ops</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">sched_clock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">steal_clock</span><span class="p">)(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_tsc_khz</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pv_cpu_ops</span> <span class="p">{</span>
	<span class="cm">/* hooks for various privileged instructions */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_debugreg</span><span class="p">)(</span><span class="kt">int</span> <span class="n">regno</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_debugreg</span><span class="p">)(</span><span class="kt">int</span> <span class="n">regno</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">clts</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">read_cr0</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_cr0</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">read_cr4_safe</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">read_cr4</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_cr4</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">read_cr8</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_cr8</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Segment descriptor handling */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">load_tr_desc</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">load_gdt</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">load_idt</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">store_gdt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">store_idt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_ldt</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">entries</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">store_tr</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">load_tls</span><span class="p">)(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">load_gs_index</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_ldt_entry</span><span class="p">)(</span><span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">ldt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entrynum</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_gdt_entry</span><span class="p">)(</span><span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">entrynum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_idt_entry</span><span class="p">)(</span><span class="n">gate_desc</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">entrynum</span><span class="p">,</span> <span class="k">const</span> <span class="n">gate_desc</span> <span class="o">*</span><span class="n">gate</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">alloc_ldt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">ldt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">entries</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_ldt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">ldt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">entries</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">load_sp0</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">tss</span><span class="p">,</span> <span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_iopl_mask</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="n">mask</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wbinvd</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">io_delay</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* cpuid emulation, mostly so that caps bits can be disabled */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cpuid</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">edx</span><span class="p">);</span>

	<span class="cm">/* MSR, PMC and TSR operations.</span>
<span class="cm">	   err = 0/-EFAULT.  wrmsr returns 0/-EFAULT. */</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">read_msr</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rdmsr_regs</span><span class="p">)(</span><span class="n">u32</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_msr</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">low</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">high</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">wrmsr_regs</span><span class="p">)(</span><span class="n">u32</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">read_tsc</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">read_pmc</span><span class="p">)(</span><span class="kt">int</span> <span class="n">counter</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">read_tscp</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">aux</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Atomically enable interrupts and return to userspace.  This</span>
<span class="cm">	 * is only ever used to return to 32-bit processes; in a</span>
<span class="cm">	 * 64-bit kernel, it&#39;s used for 32-on-64 compat processes, but</span>
<span class="cm">	 * never native 64-bit processes.  (Jump, not call.)</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_enable_sysexit</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Switch to usermode gs and return to 64-bit usermode using</span>
<span class="cm">	 * sysret.  Only used in 64-bit kernels to return to 64-bit</span>
<span class="cm">	 * processes.  Usermode register state, including %rsp, must</span>
<span class="cm">	 * already be restored.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">usergs_sysret64</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Switch to usermode gs and return to 32-bit usermode using</span>
<span class="cm">	 * sysret.  Used to return to 32-on-64 compat processes.</span>
<span class="cm">	 * Other usermode register state, including %esp, must already</span>
<span class="cm">	 * be restored.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">usergs_sysret32</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* Normal iret.  Jump to this with the standard iret stack</span>
<span class="cm">	   frame set up. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">iret</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">swapgs</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">start_context_switch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">end_context_switch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pv_irq_ops</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get/set interrupt state.  save_fl and restore_fl are only</span>
<span class="cm">	 * expected to use X86_EFLAGS_IF; all other bits</span>
<span class="cm">	 * returned from save_fl are undefined, and may be ignored by</span>
<span class="cm">	 * restore_fl.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: These functions callers expect the callee to preserve</span>
<span class="cm">	 * more registers than the standard C calling convention.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">save_fl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">restore_fl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">irq_disable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">irq_enable</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">safe_halt</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">halt</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">adjust_exception_frame</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pv_apic_ops</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">startup_ipi_hook</span><span class="p">)(</span><span class="kt">int</span> <span class="n">phys_apicid</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_eip</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_esp</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pv_mmu_ops</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">read_cr2</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_cr2</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">read_cr3</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_cr3</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hooks for intercepting the creation/use/destruction of an</span>
<span class="cm">	 * mm_struct.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">activate_mm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dup_mmap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exit_mmap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>


	<span class="cm">/* TLB operations */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush_tlb_user</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush_tlb_kernel</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush_tlb_single</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush_tlb_others</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">);</span>

	<span class="cm">/* Hooks for allocating and freeing a pagetable top-level */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">pgd_alloc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pgd_free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hooks for allocating/releasing pagetable pages when they&#39;re</span>
<span class="cm">	 * attached to a pagetable</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">alloc_pte</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">alloc_pmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">alloc_pud</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_pte</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_pmd</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_pud</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>

	<span class="cm">/* Pagetable manipulation functions */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_pte</span><span class="p">)(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_pte_at</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			   <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_pmd</span><span class="p">)(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">pmdval</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_pmd_at</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			   <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">pmdval</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pte_update</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			   <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pte_update_defer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pmd_update</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			   <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pmd_update_defer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">);</span>

	<span class="n">pte_t</span> <span class="p">(</span><span class="o">*</span><span class="n">ptep_modify_prot_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptep_modify_prot_commit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">pte_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">make_pte</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">pgd_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">make_pgd</span><span class="p">;</span>

<span class="cp">#if PAGETABLE_LEVELS &gt;= 3</span>
<span class="cp">#ifdef CONFIG_X86_PAE</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_pte_atomic</span><span class="p">)(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pte_clear</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			  <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pmd_clear</span><span class="p">)(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_X86_PAE */</span><span class="cp"></span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_pud</span><span class="p">)(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pudp</span><span class="p">,</span> <span class="n">pud_t</span> <span class="n">pudval</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">pmd_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">make_pmd</span><span class="p">;</span>

<span class="cp">#if PAGETABLE_LEVELS == 4</span>
	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">pud_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">paravirt_callee_save</span> <span class="n">make_pud</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_pgd</span><span class="p">)(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pudp</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="n">pgdval</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* PAGETABLE_LEVELS == 4 */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* PAGETABLE_LEVELS &gt;= 3 */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">pv_lazy_ops</span> <span class="n">lazy_mode</span><span class="p">;</span>

	<span class="cm">/* dom0 ops */</span>

	<span class="cm">/* Sometimes the physical address is a pfn, and sometimes its</span>
<span class="cm">	   an mfn.  We can tell which is which from the index. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_fixmap</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="cm">/* enum fixed_addresses */</span> <span class="n">idx</span><span class="p">,</span>
			   <span class="n">phys_addr_t</span> <span class="n">phys</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">arch_spinlock</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pv_lock_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">spin_is_locked</span><span class="p">)(</span><span class="k">struct</span> <span class="n">arch_spinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">spin_is_contended</span><span class="p">)(</span><span class="k">struct</span> <span class="n">arch_spinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">spin_lock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">arch_spinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">spin_lock_flags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">arch_spinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">spin_trylock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">arch_spinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">spin_unlock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">arch_spinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* This contains all the paravirt structures: we get a convenient</span>
<span class="cm"> * number for each function using the offset which we use to indicate</span>
<span class="cm"> * what to patch. */</span>
<span class="k">struct</span> <span class="n">paravirt_patch_template</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pv_init_ops</span> <span class="n">pv_init_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pv_time_ops</span> <span class="n">pv_time_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pv_cpu_ops</span> <span class="n">pv_cpu_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pv_irq_ops</span> <span class="n">pv_irq_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pv_apic_ops</span> <span class="n">pv_apic_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pv_mmu_ops</span> <span class="n">pv_mmu_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pv_lock_ops</span> <span class="n">pv_lock_ops</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pv_info</span> <span class="n">pv_info</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pv_init_ops</span> <span class="n">pv_init_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pv_time_ops</span> <span class="n">pv_time_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pv_cpu_ops</span> <span class="n">pv_cpu_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pv_irq_ops</span> <span class="n">pv_irq_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pv_apic_ops</span> <span class="n">pv_apic_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pv_mmu_ops</span> <span class="n">pv_mmu_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pv_lock_ops</span> <span class="n">pv_lock_ops</span><span class="p">;</span>

<span class="cp">#define PARAVIRT_PATCH(x)					\</span>
<span class="cp">	(offsetof(struct paravirt_patch_template, x) / sizeof(void *))</span>

<span class="cp">#define paravirt_type(op)				\</span>
<span class="cp">	[paravirt_typenum] &quot;i&quot; (PARAVIRT_PATCH(op)),	\</span>
<span class="cp">	[paravirt_opptr] &quot;i&quot; (&amp;(op))</span>
<span class="cp">#define paravirt_clobber(clobber)		\</span>
<span class="cp">	[paravirt_clobber] &quot;i&quot; (clobber)</span>

<span class="cm">/*</span>
<span class="cm"> * Generate some code, and mark it as patchable by the</span>
<span class="cm"> * apply_paravirt() alternate instruction patcher.</span>
<span class="cm"> */</span>
<span class="cp">#define _paravirt_alt(insn_string, type, clobber)	\</span>
<span class="cp">	&quot;771:\n\t&quot; insn_string &quot;\n&quot; &quot;772:\n&quot;		\</span>
<span class="cp">	&quot;.pushsection .parainstructions,\&quot;a\&quot;\n&quot;	\</span>
<span class="cp">	_ASM_ALIGN &quot;\n&quot;					\</span>
<span class="cp">	_ASM_PTR &quot; 771b\n&quot;				\</span>
<span class="cp">	&quot;  .byte &quot; type &quot;\n&quot;				\</span>
<span class="cp">	&quot;  .byte 772b-771b\n&quot;				\</span>
<span class="cp">	&quot;  .short &quot; clobber &quot;\n&quot;			\</span>
<span class="cp">	&quot;.popsection\n&quot;</span>

<span class="cm">/* Generate patchable code, with the default asm parameters. */</span>
<span class="cp">#define paravirt_alt(insn_string)					\</span>
<span class="cp">	_paravirt_alt(insn_string, &quot;%c[paravirt_typenum]&quot;, &quot;%c[paravirt_clobber]&quot;)</span>

<span class="cm">/* Simple instruction patching code. */</span>
<span class="cp">#define DEF_NATIVE(ops, name, code) 					\</span>
<span class="cp">	extern const char start_##ops##_##name[], end_##ops##_##name[];	\</span>
<span class="cp">	asm(&quot;start_&quot; #ops &quot;_&quot; #name &quot;: &quot; code &quot;; end_&quot; #ops &quot;_&quot; #name &quot;:&quot;)</span>

<span class="kt">unsigned</span> <span class="n">paravirt_patch_nop</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">paravirt_patch_ident_32</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">insnbuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">paravirt_patch_ident_64</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">insnbuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">paravirt_patch_ignore</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">paravirt_patch_call</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">insnbuf</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tgt_clobbers</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">site_clobbers</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">paravirt_patch_jmp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">insnbuf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">paravirt_patch_default</span><span class="p">(</span><span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">clobbers</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">insnbuf</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="n">paravirt_patch_insns</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">insnbuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="n">native_patch</span><span class="p">(</span><span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">clobbers</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ibuf</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">paravirt_disable_iospace</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This generates an indirect call based on the operation type number.</span>
<span class="cm"> * The type number, computed in PARAVIRT_PATCH, is derived from the</span>
<span class="cm"> * offset into the paravirt_patch_template structure, and can therefore be</span>
<span class="cm"> * freely converted back into a structure offset.</span>
<span class="cm"> */</span>
<span class="cp">#define PARAVIRT_CALL	&quot;call *%c[paravirt_opptr];&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * These macros are intended to wrap calls through one of the paravirt</span>
<span class="cm"> * ops structs, so that they can be later identified and patched at</span>
<span class="cm"> * runtime.</span>
<span class="cm"> *</span>
<span class="cm"> * Normally, a call to a pv_op function is a simple indirect call:</span>
<span class="cm"> * (pv_op_struct.operations)(args...).</span>
<span class="cm"> *</span>
<span class="cm"> * Unfortunately, this is a relatively slow operation for modern CPUs,</span>
<span class="cm"> * because it cannot necessarily determine what the destination</span>
<span class="cm"> * address is.  In this case, the address is a runtime constant, so at</span>
<span class="cm"> * the very least we can patch the call to e a simple direct call, or</span>
<span class="cm"> * ideally, patch an inline implementation into the callsite.  (Direct</span>
<span class="cm"> * calls are essentially free, because the call and return addresses</span>
<span class="cm"> * are completely predictable.)</span>
<span class="cm"> *</span>
<span class="cm"> * For i386, these macros rely on the standard gcc &quot;regparm(3)&quot; calling</span>
<span class="cm"> * convention, in which the first three arguments are placed in %eax,</span>
<span class="cm"> * %edx, %ecx (in that order), and the remaining arguments are placed</span>
<span class="cm"> * on the stack.  All caller-save registers (eax,edx,ecx) are expected</span>
<span class="cm"> * to be modified (either clobbered or used for return values).</span>
<span class="cm"> * X86_64, on the other hand, already specifies a register-based calling</span>
<span class="cm"> * conventions, returning at %rax, with parameteres going on %rdi, %rsi,</span>
<span class="cm"> * %rdx, and %rcx. Note that for this reason, x86_64 does not need any</span>
<span class="cm"> * special handling for dealing with 4 arguments, unlike i386.</span>
<span class="cm"> * However, x86_64 also have to clobber all caller saved registers, which</span>
<span class="cm"> * unfortunately, are quite a bit (r8 - r11)</span>
<span class="cm"> *</span>
<span class="cm"> * The call instruction itself is marked by placing its start address</span>
<span class="cm"> * and size into the .parainstructions section, so that</span>
<span class="cm"> * apply_paravirt() in arch/i386/kernel/alternative.c can do the</span>
<span class="cm"> * appropriate patching under the control of the backend pv_init_ops</span>
<span class="cm"> * implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * Unfortunately there&#39;s no way to get gcc to generate the args setup</span>
<span class="cm"> * for the call, and then allow the call itself to be generated by an</span>
<span class="cm"> * inline asm.  Because of this, we must do the complete arg setup and</span>
<span class="cm"> * return value handling from within these macros.  This is fairly</span>
<span class="cm"> * cumbersome.</span>
<span class="cm"> *</span>
<span class="cm"> * There are 5 sets of PVOP_* macros for dealing with 0-4 arguments.</span>
<span class="cm"> * It could be extended to more arguments, but there would be little</span>
<span class="cm"> * to be gained from that.  For each number of arguments, there are</span>
<span class="cm"> * the two VCALL and CALL variants for void and non-void functions.</span>
<span class="cm"> *</span>
<span class="cm"> * When there is a return value, the invoker of the macro must specify</span>
<span class="cm"> * the return type.  The macro then uses sizeof() on that type to</span>
<span class="cm"> * determine whether its a 32 or 64 bit value, and places the return</span>
<span class="cm"> * in the right register(s) (just %eax for 32-bit, and %edx:%eax for</span>
<span class="cm"> * 64-bit). For x86_64 machines, it just returns at %rax regardless of</span>
<span class="cm"> * the return value size.</span>
<span class="cm"> *</span>
<span class="cm"> * 64-bit arguments are passed as a pair of adjacent 32-bit arguments</span>
<span class="cm"> * i386 also passes 64-bit arguments as a pair of adjacent 32-bit arguments</span>
<span class="cm"> * in low,high order</span>
<span class="cm"> *</span>
<span class="cm"> * Small structures are passed and returned in registers.  The macro</span>
<span class="cm"> * calling convention can&#39;t directly deal with this, so the wrapper</span>
<span class="cm"> * functions must do this.</span>
<span class="cm"> *</span>
<span class="cm"> * These PVOP_* macros are only defined within this header.  This</span>
<span class="cm"> * means that all uses must be wrapped in inline functions.  This also</span>
<span class="cm"> * makes sure the incoming and outgoing types are always correct.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cp">#define PVOP_VCALL_ARGS				\</span>
<span class="cp">	unsigned long __eax = __eax, __edx = __edx, __ecx = __ecx</span>
<span class="cp">#define PVOP_CALL_ARGS			PVOP_VCALL_ARGS</span>

<span class="cp">#define PVOP_CALL_ARG1(x)		&quot;a&quot; ((unsigned long)(x))</span>
<span class="cp">#define PVOP_CALL_ARG2(x)		&quot;d&quot; ((unsigned long)(x))</span>
<span class="cp">#define PVOP_CALL_ARG3(x)		&quot;c&quot; ((unsigned long)(x))</span>

<span class="cp">#define PVOP_VCALL_CLOBBERS		&quot;=a&quot; (__eax), &quot;=d&quot; (__edx),	\</span>
<span class="cp">					&quot;=c&quot; (__ecx)</span>
<span class="cp">#define PVOP_CALL_CLOBBERS		PVOP_VCALL_CLOBBERS</span>

<span class="cp">#define PVOP_VCALLEE_CLOBBERS		&quot;=a&quot; (__eax), &quot;=d&quot; (__edx)</span>
<span class="cp">#define PVOP_CALLEE_CLOBBERS		PVOP_VCALLEE_CLOBBERS</span>

<span class="cp">#define EXTRA_CLOBBERS</span>
<span class="cp">#define VEXTRA_CLOBBERS</span>
<span class="cp">#else  </span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>
<span class="cm">/* [re]ax isn&#39;t an arg, but the return val */</span>
<span class="cp">#define PVOP_VCALL_ARGS					\</span>
<span class="cp">	unsigned long __edi = __edi, __esi = __esi,	\</span>
<span class="cp">		__edx = __edx, __ecx = __ecx, __eax = __eax</span>
<span class="cp">#define PVOP_CALL_ARGS		PVOP_VCALL_ARGS</span>

<span class="cp">#define PVOP_CALL_ARG1(x)		&quot;D&quot; ((unsigned long)(x))</span>
<span class="cp">#define PVOP_CALL_ARG2(x)		&quot;S&quot; ((unsigned long)(x))</span>
<span class="cp">#define PVOP_CALL_ARG3(x)		&quot;d&quot; ((unsigned long)(x))</span>
<span class="cp">#define PVOP_CALL_ARG4(x)		&quot;c&quot; ((unsigned long)(x))</span>

<span class="cp">#define PVOP_VCALL_CLOBBERS	&quot;=D&quot; (__edi),				\</span>
<span class="cp">				&quot;=S&quot; (__esi), &quot;=d&quot; (__edx),		\</span>
<span class="cp">				&quot;=c&quot; (__ecx)</span>
<span class="cp">#define PVOP_CALL_CLOBBERS	PVOP_VCALL_CLOBBERS, &quot;=a&quot; (__eax)</span>

<span class="cm">/* void functions are still allowed [re]ax for scratch */</span>
<span class="cp">#define PVOP_VCALLEE_CLOBBERS	&quot;=a&quot; (__eax)</span>
<span class="cp">#define PVOP_CALLEE_CLOBBERS	PVOP_VCALLEE_CLOBBERS</span>

<span class="cp">#define EXTRA_CLOBBERS	 , &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;</span>
<span class="cp">#define VEXTRA_CLOBBERS	 , &quot;rax&quot;, &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_X86_32 */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PARAVIRT_DEBUG</span>
<span class="cp">#define PVOP_TEST_NULL(op)	BUG_ON(op == NULL)</span>
<span class="cp">#else</span>
<span class="cp">#define PVOP_TEST_NULL(op)	((void)op)</span>
<span class="cp">#endif</span>

<span class="cp">#define ____PVOP_CALL(rettype, op, clbr, call_clbr, extra_clbr,		\</span>
<span class="cp">		      pre, post, ...)					\</span>
<span class="cp">	({								\</span>
<span class="cp">		rettype __ret;						\</span>
<span class="cp">		PVOP_CALL_ARGS;						\</span>
<span class="cp">		PVOP_TEST_NULL(op);					\</span>
<span class="cp">		</span><span class="cm">/* This is 32-bit specific, but is okay in 64-bit */</span><span class="cp">	\</span>
<span class="cp">		</span><span class="cm">/* since this condition will never hold */</span><span class="cp">		\</span>
<span class="cp">		if (sizeof(rettype) &gt; sizeof(unsigned long)) {		\</span>
<span class="cp">			asm volatile(pre				\</span>
<span class="cp">				     paravirt_alt(PARAVIRT_CALL)	\</span>
<span class="cp">				     post				\</span>
<span class="cp">				     : call_clbr			\</span>
<span class="cp">				     : paravirt_type(op),		\</span>
<span class="cp">				       paravirt_clobber(clbr),		\</span>
<span class="cp">				       ##__VA_ARGS__			\</span>
<span class="cp">				     : &quot;memory&quot;, &quot;cc&quot; extra_clbr);	\</span>
<span class="cp">			__ret = (rettype)((((u64)__edx) &lt;&lt; 32) | __eax); \</span>
<span class="cp">		} else {						\</span>
<span class="cp">			asm volatile(pre				\</span>
<span class="cp">				     paravirt_alt(PARAVIRT_CALL)	\</span>
<span class="cp">				     post				\</span>
<span class="cp">				     : call_clbr			\</span>
<span class="cp">				     : paravirt_type(op),		\</span>
<span class="cp">				       paravirt_clobber(clbr),		\</span>
<span class="cp">				       ##__VA_ARGS__			\</span>
<span class="cp">				     : &quot;memory&quot;, &quot;cc&quot; extra_clbr);	\</span>
<span class="cp">			__ret = (rettype)__eax;				\</span>
<span class="cp">		}							\</span>
<span class="cp">		__ret;							\</span>
<span class="cp">	})</span>

<span class="cp">#define __PVOP_CALL(rettype, op, pre, post, ...)			\</span>
<span class="cp">	____PVOP_CALL(rettype, op, CLBR_ANY, PVOP_CALL_CLOBBERS,	\</span>
<span class="cp">		      EXTRA_CLOBBERS, pre, post, ##__VA_ARGS__)</span>

<span class="cp">#define __PVOP_CALLEESAVE(rettype, op, pre, post, ...)			\</span>
<span class="cp">	____PVOP_CALL(rettype, op.func, CLBR_RET_REG,			\</span>
<span class="cp">		      PVOP_CALLEE_CLOBBERS, ,				\</span>
<span class="cp">		      pre, post, ##__VA_ARGS__)</span>


<span class="cp">#define ____PVOP_VCALL(op, clbr, call_clbr, extra_clbr, pre, post, ...)	\</span>
<span class="cp">	({								\</span>
<span class="cp">		PVOP_VCALL_ARGS;					\</span>
<span class="cp">		PVOP_TEST_NULL(op);					\</span>
<span class="cp">		asm volatile(pre					\</span>
<span class="cp">			     paravirt_alt(PARAVIRT_CALL)		\</span>
<span class="cp">			     post					\</span>
<span class="cp">			     : call_clbr				\</span>
<span class="cp">			     : paravirt_type(op),			\</span>
<span class="cp">			       paravirt_clobber(clbr),			\</span>
<span class="cp">			       ##__VA_ARGS__				\</span>
<span class="cp">			     : &quot;memory&quot;, &quot;cc&quot; extra_clbr);		\</span>
<span class="cp">	})</span>

<span class="cp">#define __PVOP_VCALL(op, pre, post, ...)				\</span>
<span class="cp">	____PVOP_VCALL(op, CLBR_ANY, PVOP_VCALL_CLOBBERS,		\</span>
<span class="cp">		       VEXTRA_CLOBBERS,					\</span>
<span class="cp">		       pre, post, ##__VA_ARGS__)</span>

<span class="cp">#define __PVOP_VCALLEESAVE(op, pre, post, ...)				\</span>
<span class="cp">	____PVOP_VCALL(op.func, CLBR_RET_REG,				\</span>
<span class="cp">		      PVOP_VCALLEE_CLOBBERS, ,				\</span>
<span class="cp">		      pre, post, ##__VA_ARGS__)</span>



<span class="cp">#define PVOP_CALL0(rettype, op)						\</span>
<span class="cp">	__PVOP_CALL(rettype, op, &quot;&quot;, &quot;&quot;)</span>
<span class="cp">#define PVOP_VCALL0(op)							\</span>
<span class="cp">	__PVOP_VCALL(op, &quot;&quot;, &quot;&quot;)</span>

<span class="cp">#define PVOP_CALLEE0(rettype, op)					\</span>
<span class="cp">	__PVOP_CALLEESAVE(rettype, op, &quot;&quot;, &quot;&quot;)</span>
<span class="cp">#define PVOP_VCALLEE0(op)						\</span>
<span class="cp">	__PVOP_VCALLEESAVE(op, &quot;&quot;, &quot;&quot;)</span>


<span class="cp">#define PVOP_CALL1(rettype, op, arg1)					\</span>
<span class="cp">	__PVOP_CALL(rettype, op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1))</span>
<span class="cp">#define PVOP_VCALL1(op, arg1)						\</span>
<span class="cp">	__PVOP_VCALL(op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1))</span>

<span class="cp">#define PVOP_CALLEE1(rettype, op, arg1)					\</span>
<span class="cp">	__PVOP_CALLEESAVE(rettype, op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1))</span>
<span class="cp">#define PVOP_VCALLEE1(op, arg1)						\</span>
<span class="cp">	__PVOP_VCALLEESAVE(op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1))</span>


<span class="cp">#define PVOP_CALL2(rettype, op, arg1, arg2)				\</span>
<span class="cp">	__PVOP_CALL(rettype, op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1),		\</span>
<span class="cp">		    PVOP_CALL_ARG2(arg2))</span>
<span class="cp">#define PVOP_VCALL2(op, arg1, arg2)					\</span>
<span class="cp">	__PVOP_VCALL(op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1),			\</span>
<span class="cp">		     PVOP_CALL_ARG2(arg2))</span>

<span class="cp">#define PVOP_CALLEE2(rettype, op, arg1, arg2)				\</span>
<span class="cp">	__PVOP_CALLEESAVE(rettype, op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1),	\</span>
<span class="cp">			  PVOP_CALL_ARG2(arg2))</span>
<span class="cp">#define PVOP_VCALLEE2(op, arg1, arg2)					\</span>
<span class="cp">	__PVOP_VCALLEESAVE(op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1),		\</span>
<span class="cp">			   PVOP_CALL_ARG2(arg2))</span>


<span class="cp">#define PVOP_CALL3(rettype, op, arg1, arg2, arg3)			\</span>
<span class="cp">	__PVOP_CALL(rettype, op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1),		\</span>
<span class="cp">		    PVOP_CALL_ARG2(arg2), PVOP_CALL_ARG3(arg3))</span>
<span class="cp">#define PVOP_VCALL3(op, arg1, arg2, arg3)				\</span>
<span class="cp">	__PVOP_VCALL(op, &quot;&quot;, &quot;&quot;, PVOP_CALL_ARG1(arg1),			\</span>
<span class="cp">		     PVOP_CALL_ARG2(arg2), PVOP_CALL_ARG3(arg3))</span>

<span class="cm">/* This is the only difference in x86_64. We can make it much simpler */</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cp">#define PVOP_CALL4(rettype, op, arg1, arg2, arg3, arg4)			\</span>
<span class="cp">	__PVOP_CALL(rettype, op,					\</span>
<span class="cp">		    &quot;push %[_arg4];&quot;, &quot;lea 4(%%esp),%%esp;&quot;,		\</span>
<span class="cp">		    PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2),		\</span>
<span class="cp">		    PVOP_CALL_ARG3(arg3), [_arg4] &quot;mr&quot; ((u32)(arg4)))</span>
<span class="cp">#define PVOP_VCALL4(op, arg1, arg2, arg3, arg4)				\</span>
<span class="cp">	__PVOP_VCALL(op,						\</span>
<span class="cp">		    &quot;push %[_arg4];&quot;, &quot;lea 4(%%esp),%%esp;&quot;,		\</span>
<span class="cp">		    &quot;0&quot; ((u32)(arg1)), &quot;1&quot; ((u32)(arg2)),		\</span>
<span class="cp">		    &quot;2&quot; ((u32)(arg3)), [_arg4] &quot;mr&quot; ((u32)(arg4)))</span>
<span class="cp">#else</span>
<span class="cp">#define PVOP_CALL4(rettype, op, arg1, arg2, arg3, arg4)			\</span>
<span class="cp">	__PVOP_CALL(rettype, op, &quot;&quot;, &quot;&quot;,				\</span>
<span class="cp">		    PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2),		\</span>
<span class="cp">		    PVOP_CALL_ARG3(arg3), PVOP_CALL_ARG4(arg4))</span>
<span class="cp">#define PVOP_VCALL4(op, arg1, arg2, arg3, arg4)				\</span>
<span class="cp">	__PVOP_VCALL(op, &quot;&quot;, &quot;&quot;,					\</span>
<span class="cp">		     PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2),	\</span>
<span class="cp">		     PVOP_CALL_ARG3(arg3), PVOP_CALL_ARG4(arg4))</span>
<span class="cp">#endif</span>

<span class="cm">/* Lazy mode for batching updates / context switch */</span>
<span class="k">enum</span> <span class="n">paravirt_lazy_mode</span> <span class="p">{</span>
	<span class="n">PARAVIRT_LAZY_NONE</span><span class="p">,</span>
	<span class="n">PARAVIRT_LAZY_MMU</span><span class="p">,</span>
	<span class="n">PARAVIRT_LAZY_CPU</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">paravirt_lazy_mode</span> <span class="n">paravirt_get_lazy_mode</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">paravirt_start_context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">paravirt_end_context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">paravirt_enter_lazy_mmu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">paravirt_leave_lazy_mmu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">_paravirt_nop</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">_paravirt_ident_32</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
<span class="n">u64</span> <span class="n">_paravirt_ident_64</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

<span class="cp">#define paravirt_nop	((void *)_paravirt_nop)</span>

<span class="cm">/* These all sit in the .parainstructions section to tell us what to patch. */</span>
<span class="k">struct</span> <span class="n">paravirt_patch_site</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">instr</span><span class="p">;</span> 		<span class="cm">/* original instructions */</span>
	<span class="n">u8</span> <span class="n">instrtype</span><span class="p">;</span>		<span class="cm">/* type of this instruction */</span>
	<span class="n">u8</span> <span class="n">len</span><span class="p">;</span>			<span class="cm">/* length of original instruction */</span>
	<span class="n">u16</span> <span class="n">clobbers</span><span class="p">;</span>		<span class="cm">/* what registers you may clobber */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">paravirt_patch_site</span> <span class="n">__parainstructions</span><span class="p">[],</span>
	<span class="n">__parainstructions_end</span><span class="p">[];</span>

<span class="cp">#endif	</span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* _ASM_X86_PARAVIRT_TYPES_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
