<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › perf_event.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>perf_event.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_X86_PERF_EVENT_H</span>
<span class="cp">#define _ASM_X86_PERF_EVENT_H</span>

<span class="cm">/*</span>
<span class="cm"> * Performance event hw details:</span>
<span class="cm"> */</span>

<span class="cp">#define X86_PMC_MAX_GENERIC				       32</span>
<span class="cp">#define X86_PMC_MAX_FIXED					3</span>

<span class="cp">#define X86_PMC_IDX_GENERIC				        0</span>
<span class="cp">#define X86_PMC_IDX_FIXED				       32</span>
<span class="cp">#define X86_PMC_IDX_MAX					       64</span>

<span class="cp">#define MSR_ARCH_PERFMON_PERFCTR0			      0xc1</span>
<span class="cp">#define MSR_ARCH_PERFMON_PERFCTR1			      0xc2</span>

<span class="cp">#define MSR_ARCH_PERFMON_EVENTSEL0			     0x186</span>
<span class="cp">#define MSR_ARCH_PERFMON_EVENTSEL1			     0x187</span>

<span class="cp">#define ARCH_PERFMON_EVENTSEL_EVENT			0x000000FFULL</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_UMASK			0x0000FF00ULL</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_USR			(1ULL &lt;&lt; 16)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_OS			(1ULL &lt;&lt; 17)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_EDGE			(1ULL &lt;&lt; 18)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_PIN_CONTROL		(1ULL &lt;&lt; 19)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_INT			(1ULL &lt;&lt; 20)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_ANY			(1ULL &lt;&lt; 21)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_ENABLE			(1ULL &lt;&lt; 22)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_INV			(1ULL &lt;&lt; 23)</span>
<span class="cp">#define ARCH_PERFMON_EVENTSEL_CMASK			0xFF000000ULL</span>

<span class="cp">#define AMD_PERFMON_EVENTSEL_GUESTONLY			(1ULL &lt;&lt; 40)</span>
<span class="cp">#define AMD_PERFMON_EVENTSEL_HOSTONLY			(1ULL &lt;&lt; 41)</span>

<span class="cp">#define AMD64_EVENTSEL_EVENT	\</span>
<span class="cp">	(ARCH_PERFMON_EVENTSEL_EVENT | (0x0FULL &lt;&lt; 32))</span>
<span class="cp">#define INTEL_ARCH_EVENT_MASK	\</span>
<span class="cp">	(ARCH_PERFMON_EVENTSEL_UMASK | ARCH_PERFMON_EVENTSEL_EVENT)</span>

<span class="cp">#define X86_RAW_EVENT_MASK		\</span>
<span class="cp">	(ARCH_PERFMON_EVENTSEL_EVENT |	\</span>
<span class="cp">	 ARCH_PERFMON_EVENTSEL_UMASK |	\</span>
<span class="cp">	 ARCH_PERFMON_EVENTSEL_EDGE  |	\</span>
<span class="cp">	 ARCH_PERFMON_EVENTSEL_INV   |	\</span>
<span class="cp">	 ARCH_PERFMON_EVENTSEL_CMASK)</span>
<span class="cp">#define AMD64_RAW_EVENT_MASK		\</span>
<span class="cp">	(X86_RAW_EVENT_MASK          |  \</span>
<span class="cp">	 AMD64_EVENTSEL_EVENT)</span>
<span class="cp">#define AMD64_NUM_COUNTERS				4</span>
<span class="cp">#define AMD64_NUM_COUNTERS_F15H				6</span>
<span class="cp">#define AMD64_NUM_COUNTERS_MAX				AMD64_NUM_COUNTERS_F15H</span>

<span class="cp">#define ARCH_PERFMON_UNHALTED_CORE_CYCLES_SEL		0x3c</span>
<span class="cp">#define ARCH_PERFMON_UNHALTED_CORE_CYCLES_UMASK		(0x00 &lt;&lt; 8)</span>
<span class="cp">#define ARCH_PERFMON_UNHALTED_CORE_CYCLES_INDEX		0</span>
<span class="cp">#define ARCH_PERFMON_UNHALTED_CORE_CYCLES_PRESENT \</span>
<span class="cp">		(1 &lt;&lt; (ARCH_PERFMON_UNHALTED_CORE_CYCLES_INDEX))</span>

<span class="cp">#define ARCH_PERFMON_BRANCH_MISSES_RETIRED		6</span>
<span class="cp">#define ARCH_PERFMON_EVENTS_COUNT			7</span>

<span class="cm">/*</span>
<span class="cm"> * Intel &quot;Architectural Performance Monitoring&quot; CPUID</span>
<span class="cm"> * detection/enumeration details:</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">cpuid10_eax</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">version_id</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_counters</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit_width</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask_length</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">split</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">full</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">cpuid10_ebx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_unhalted_core_cycles</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_instructions_retired</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_unhalted_reference_cycles</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_llc_reference</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_llc_misses</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_branch_instruction_retired</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_branch_misses_retired</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">split</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">full</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">cpuid10_edx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_counters_fixed</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit_width_fixed</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">19</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">split</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">full</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">x86_pmu_capability</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">version</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">num_counters_gp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">num_counters_fixed</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">bit_width_gp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">bit_width_fixed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">events_mask</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">events_mask_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Fixed-purpose performance events:</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * All 3 fixed-mode PMCs are configured via this single MSR:</span>
<span class="cm"> */</span>
<span class="cp">#define MSR_ARCH_PERFMON_FIXED_CTR_CTRL	0x38d</span>

<span class="cm">/*</span>
<span class="cm"> * The counts are available in three separate MSRs:</span>
<span class="cm"> */</span>

<span class="cm">/* Instr_Retired.Any: */</span>
<span class="cp">#define MSR_ARCH_PERFMON_FIXED_CTR0	0x309</span>
<span class="cp">#define X86_PMC_IDX_FIXED_INSTRUCTIONS	(X86_PMC_IDX_FIXED + 0)</span>

<span class="cm">/* CPU_CLK_Unhalted.Core: */</span>
<span class="cp">#define MSR_ARCH_PERFMON_FIXED_CTR1	0x30a</span>
<span class="cp">#define X86_PMC_IDX_FIXED_CPU_CYCLES	(X86_PMC_IDX_FIXED + 1)</span>

<span class="cm">/* CPU_CLK_Unhalted.Ref: */</span>
<span class="cp">#define MSR_ARCH_PERFMON_FIXED_CTR2	0x30b</span>
<span class="cp">#define X86_PMC_IDX_FIXED_REF_CYCLES	(X86_PMC_IDX_FIXED + 2)</span>
<span class="cp">#define X86_PMC_MSK_FIXED_REF_CYCLES	(1ULL &lt;&lt; X86_PMC_IDX_FIXED_REF_CYCLES)</span>

<span class="cm">/*</span>
<span class="cm"> * We model BTS tracing as another fixed-mode PMC.</span>
<span class="cm"> *</span>
<span class="cm"> * We choose a value in the middle of the fixed event range, since lower</span>
<span class="cm"> * values are used by actual fixed events and higher values are used</span>
<span class="cm"> * to indicate other overflow conditions in the PERF_GLOBAL_STATUS msr.</span>
<span class="cm"> */</span>
<span class="cp">#define X86_PMC_IDX_FIXED_BTS				(X86_PMC_IDX_FIXED + 16)</span>

<span class="cm">/*</span>
<span class="cm"> * IBS cpuid feature detection</span>
<span class="cm"> */</span>

<span class="cp">#define IBS_CPUID_FEATURES		0x8000001b</span>

<span class="cm">/*</span>
<span class="cm"> * Same bit mask as for IBS cpuid feature flags (Fn8000_001B_EAX), but</span>
<span class="cm"> * bit 0 is used to indicate the existence of IBS.</span>
<span class="cm"> */</span>
<span class="cp">#define IBS_CAPS_AVAIL			(1U&lt;&lt;0)</span>
<span class="cp">#define IBS_CAPS_FETCHSAM		(1U&lt;&lt;1)</span>
<span class="cp">#define IBS_CAPS_OPSAM			(1U&lt;&lt;2)</span>
<span class="cp">#define IBS_CAPS_RDWROPCNT		(1U&lt;&lt;3)</span>
<span class="cp">#define IBS_CAPS_OPCNT			(1U&lt;&lt;4)</span>
<span class="cp">#define IBS_CAPS_BRNTRGT		(1U&lt;&lt;5)</span>
<span class="cp">#define IBS_CAPS_OPCNTEXT		(1U&lt;&lt;6)</span>
<span class="cp">#define IBS_CAPS_RIPINVALIDCHK		(1U&lt;&lt;7)</span>

<span class="cp">#define IBS_CAPS_DEFAULT		(IBS_CAPS_AVAIL		\</span>
<span class="cp">					 | IBS_CAPS_FETCHSAM	\</span>
<span class="cp">					 | IBS_CAPS_OPSAM)</span>

<span class="cm">/*</span>
<span class="cm"> * IBS APIC setup</span>
<span class="cm"> */</span>
<span class="cp">#define IBSCTL				0x1cc</span>
<span class="cp">#define IBSCTL_LVT_OFFSET_VALID		(1ULL&lt;&lt;8)</span>
<span class="cp">#define IBSCTL_LVT_OFFSET_MASK		0x0F</span>

<span class="cm">/* ibs fetch bits/masks */</span>
<span class="cp">#define IBS_FETCH_RAND_EN	(1ULL&lt;&lt;57)</span>
<span class="cp">#define IBS_FETCH_VAL		(1ULL&lt;&lt;49)</span>
<span class="cp">#define IBS_FETCH_ENABLE	(1ULL&lt;&lt;48)</span>
<span class="cp">#define IBS_FETCH_CNT		0xFFFF0000ULL</span>
<span class="cp">#define IBS_FETCH_MAX_CNT	0x0000FFFFULL</span>

<span class="cm">/* ibs op bits/masks */</span>
<span class="cm">/* lower 4 bits of the current count are ignored: */</span>
<span class="cp">#define IBS_OP_CUR_CNT		(0xFFFF0ULL&lt;&lt;32)</span>
<span class="cp">#define IBS_OP_CNT_CTL		(1ULL&lt;&lt;19)</span>
<span class="cp">#define IBS_OP_VAL		(1ULL&lt;&lt;18)</span>
<span class="cp">#define IBS_OP_ENABLE		(1ULL&lt;&lt;17)</span>
<span class="cp">#define IBS_OP_MAX_CNT		0x0000FFFFULL</span>
<span class="cp">#define IBS_OP_MAX_CNT_EXT	0x007FFFFFULL	</span><span class="cm">/* not a register bit mask */</span><span class="cp"></span>
<span class="cp">#define IBS_RIP_INVALID		(1ULL&lt;&lt;38)</span>

<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">get_ibs_caps</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">get_ibs_caps</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PERF_EVENTS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">perf_events_lapic_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Abuse bit 3 of the cpu eflags register to indicate proper PEBS IP fixups.</span>
<span class="cm"> * This flag is otherwise unused and ABI specified to be 0, so nobody should</span>
<span class="cm"> * care what we do with it.</span>
<span class="cm"> */</span>
<span class="cp">#define PERF_EFLAGS_EXACT	(1UL &lt;&lt; 3)</span>

<span class="k">struct</span> <span class="n">pt_regs</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">perf_instruction_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">perf_misc_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="cp">#define perf_misc_flags(regs)	perf_misc_flags(regs)</span>

<span class="cp">#include &lt;asm/stacktrace.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * We abuse bit 3 from flags to pass exact information, see perf_misc_flags</span>
<span class="cm"> * and the comment with PERF_EFLAGS_EXACT.</span>
<span class="cm"> */</span>
<span class="cp">#define perf_arch_fetch_caller_regs(regs, __ip)		{	\</span>
<span class="cp">	(regs)-&gt;ip = (__ip);					\</span>
<span class="cp">	(regs)-&gt;bp = caller_frame_pointer();			\</span>
<span class="cp">	(regs)-&gt;cs = __KERNEL_CS;				\</span>
<span class="cp">	regs-&gt;flags = 0;					\</span>
<span class="cp">	asm volatile(						\</span>
<span class="cp">		_ASM_MOV &quot;%%&quot;_ASM_SP &quot;, %0\n&quot;			\</span>
<span class="cp">		: &quot;=m&quot; ((regs)-&gt;sp)				\</span>
<span class="cp">		:: &quot;memory&quot;					\</span>
<span class="cp">	);							\</span>
<span class="cp">}</span>

<span class="k">struct</span> <span class="n">perf_guest_switch_msr</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">msr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">host</span><span class="p">,</span> <span class="n">guest</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">perf_guest_switch_msr</span> <span class="o">*</span><span class="n">perf_guest_get_msrs</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">nr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">perf_get_x86_pmu_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_pmu_capability</span> <span class="o">*</span><span class="n">cap</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">perf_guest_switch_msr</span> <span class="o">*</span><span class="nf">perf_guest_get_msrs</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_get_x86_pmu_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_pmu_capability</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cap</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_events_lapic_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>	<span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_PERF_EVENTS) &amp;&amp; defined(CONFIG_CPU_SUP_AMD)</span>
 <span class="k">extern</span> <span class="kt">void</span> <span class="n">amd_pmu_enable_virt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="kt">void</span> <span class="n">amd_pmu_disable_virt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
 <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">amd_pmu_enable_virt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
 <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">amd_pmu_disable_virt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_PERF_EVENT_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
