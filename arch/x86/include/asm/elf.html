<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › elf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>elf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_X86_ELF_H</span>
<span class="cp">#define _ASM_X86_ELF_H</span>

<span class="cm">/*</span>
<span class="cm"> * ELF register definitions..</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>

<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/user.h&gt;</span>
<span class="cp">#include &lt;asm/auxvec.h&gt;</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_greg_t</span><span class="p">;</span>

<span class="cp">#define ELF_NGREG (sizeof(struct user_regs_struct) / sizeof(elf_greg_t))</span>
<span class="k">typedef</span> <span class="n">elf_greg_t</span> <span class="n">elf_gregset_t</span><span class="p">[</span><span class="n">ELF_NGREG</span><span class="p">];</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">user_i387_struct</span> <span class="n">elf_fpregset_t</span><span class="p">;</span>

<span class="cp">#ifdef __i386__</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">user_fxsr_struct</span> <span class="n">elf_fpxregset_t</span><span class="p">;</span>

<span class="cp">#define R_386_NONE	0</span>
<span class="cp">#define R_386_32	1</span>
<span class="cp">#define R_386_PC32	2</span>
<span class="cp">#define R_386_GOT32	3</span>
<span class="cp">#define R_386_PLT32	4</span>
<span class="cp">#define R_386_COPY	5</span>
<span class="cp">#define R_386_GLOB_DAT	6</span>
<span class="cp">#define R_386_JMP_SLOT	7</span>
<span class="cp">#define R_386_RELATIVE	8</span>
<span class="cp">#define R_386_GOTOFF	9</span>
<span class="cp">#define R_386_GOTPC	10</span>
<span class="cp">#define R_386_NUM	11</span>

<span class="cm">/*</span>
<span class="cm"> * These are used to set parameters in the core dumps.</span>
<span class="cm"> */</span>
<span class="cp">#define ELF_CLASS	ELFCLASS32</span>
<span class="cp">#define ELF_DATA	ELFDATA2LSB</span>
<span class="cp">#define ELF_ARCH	EM_386</span>

<span class="cp">#else</span>

<span class="cm">/* x86-64 relocation types */</span>
<span class="cp">#define R_X86_64_NONE		0	</span><span class="cm">/* No reloc */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_64		1	</span><span class="cm">/* Direct 64 bit  */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_PC32		2	</span><span class="cm">/* PC relative 32 bit signed */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_GOT32		3	</span><span class="cm">/* 32 bit GOT entry */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_PLT32		4	</span><span class="cm">/* 32 bit PLT address */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_COPY		5	</span><span class="cm">/* Copy symbol at runtime */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_GLOB_DAT	6	</span><span class="cm">/* Create GOT entry */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_JUMP_SLOT	7	</span><span class="cm">/* Create PLT entry */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_RELATIVE	8	</span><span class="cm">/* Adjust by program base */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_GOTPCREL	9	</span><span class="cm">/* 32 bit signed pc relative</span>
<span class="cm">					   offset to GOT */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_32		10	</span><span class="cm">/* Direct 32 bit zero extended */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_32S		11	</span><span class="cm">/* Direct 32 bit sign extended */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_16		12	</span><span class="cm">/* Direct 16 bit zero extended */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_PC16		13	</span><span class="cm">/* 16 bit sign extended pc relative */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_8		14	</span><span class="cm">/* Direct 8 bit sign extended  */</span><span class="cp"></span>
<span class="cp">#define R_X86_64_PC8		15	</span><span class="cm">/* 8 bit sign extended pc relative */</span><span class="cp"></span>

<span class="cp">#define R_X86_64_NUM		16</span>

<span class="cm">/*</span>
<span class="cm"> * These are used to set parameters in the core dumps.</span>
<span class="cm"> */</span>
<span class="cp">#define ELF_CLASS	ELFCLASS64</span>
<span class="cp">#define ELF_DATA	ELFDATA2LSB</span>
<span class="cp">#define ELF_ARCH	EM_X86_64</span>

<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/vdso.h&gt;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vdso_enabled</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is used to ensure we don&#39;t load something for the wrong architecture.</span>
<span class="cm"> */</span>
<span class="cp">#define elf_check_arch_ia32(x) \</span>
<span class="cp">	(((x)-&gt;e_machine == EM_386) || ((x)-&gt;e_machine == EM_486))</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>

<span class="cp">#define elf_check_arch(x)	elf_check_arch_ia32(x)</span>

<span class="cm">/* SVR4/i386 ABI (pages 3-31, 3-32) says that when the program starts %edx</span>
<span class="cm">   contains a pointer to a function which might be registered using `atexit&#39;.</span>
<span class="cm">   This provides a mean for the dynamic linker to call DT_FINI functions for</span>
<span class="cm">   shared libraries that have been loaded before the code runs.</span>

<span class="cm">   A value of 0 tells we have no such handler.</span>

<span class="cm">   We might as well make sure everything else is cleared too (except for %esp),</span>
<span class="cm">   just to make things more deterministic.</span>
<span class="cm"> */</span>
<span class="cp">#define ELF_PLAT_INIT(_r, load_addr)		\</span>
<span class="cp">	do {					\</span>
<span class="cp">	_r-&gt;bx = 0; _r-&gt;cx = 0; _r-&gt;dx = 0;	\</span>
<span class="cp">	_r-&gt;si = 0; _r-&gt;di = 0; _r-&gt;bp = 0;	\</span>
<span class="cp">	_r-&gt;ax = 0;				\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * regs is struct pt_regs, pr_reg is elf_gregset_t (which is</span>
<span class="cm"> * now struct_user_regs, they are different)</span>
<span class="cm"> */</span>

<span class="cp">#define ELF_CORE_COPY_REGS_COMMON(pr_reg, regs)	\</span>
<span class="cp">do {						\</span>
<span class="cp">	pr_reg[0] = regs-&gt;bx;			\</span>
<span class="cp">	pr_reg[1] = regs-&gt;cx;			\</span>
<span class="cp">	pr_reg[2] = regs-&gt;dx;			\</span>
<span class="cp">	pr_reg[3] = regs-&gt;si;			\</span>
<span class="cp">	pr_reg[4] = regs-&gt;di;			\</span>
<span class="cp">	pr_reg[5] = regs-&gt;bp;			\</span>
<span class="cp">	pr_reg[6] = regs-&gt;ax;			\</span>
<span class="cp">	pr_reg[7] = regs-&gt;ds &amp; 0xffff;		\</span>
<span class="cp">	pr_reg[8] = regs-&gt;es &amp; 0xffff;		\</span>
<span class="cp">	pr_reg[9] = regs-&gt;fs &amp; 0xffff;		\</span>
<span class="cp">	pr_reg[11] = regs-&gt;orig_ax;		\</span>
<span class="cp">	pr_reg[12] = regs-&gt;ip;			\</span>
<span class="cp">	pr_reg[13] = regs-&gt;cs &amp; 0xffff;		\</span>
<span class="cp">	pr_reg[14] = regs-&gt;flags;		\</span>
<span class="cp">	pr_reg[15] = regs-&gt;sp;			\</span>
<span class="cp">	pr_reg[16] = regs-&gt;ss &amp; 0xffff;		\</span>
<span class="cp">} while (0);</span>

<span class="cp">#define ELF_CORE_COPY_REGS(pr_reg, regs)	\</span>
<span class="cp">do {						\</span>
<span class="cp">	ELF_CORE_COPY_REGS_COMMON(pr_reg, regs);\</span>
<span class="cp">	pr_reg[10] = get_user_gs(regs);		\</span>
<span class="cp">} while (0);</span>

<span class="cp">#define ELF_CORE_COPY_KERNEL_REGS(pr_reg, regs)	\</span>
<span class="cp">do {						\</span>
<span class="cp">	ELF_CORE_COPY_REGS_COMMON(pr_reg, regs);\</span>
<span class="cp">	savesegment(gs, pr_reg[10]);		\</span>
<span class="cp">} while (0);</span>

<span class="cp">#define ELF_PLATFORM	(utsname()-&gt;machine)</span>
<span class="cp">#define set_personality_64bit()	do { } while (0)</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_X86_32 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This is used to ensure we don&#39;t load something for the wrong architecture.</span>
<span class="cm"> */</span>
<span class="cp">#define elf_check_arch(x)			\</span>
<span class="cp">	((x)-&gt;e_machine == EM_X86_64)</span>

<span class="cp">#define compat_elf_check_arch(x)		\</span>
<span class="cp">	(elf_check_arch_ia32(x) || (x)-&gt;e_machine == EM_X86_64)</span>

<span class="cp">#if __USER32_DS != __USER_DS</span>
<span class="cp"># error &quot;The following code assumes __USER32_DS == __USER_DS&quot;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">elf_common_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">ds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ax</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">bx</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cx</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">si</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">di</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r8</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r9</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r10</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r11</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r12</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r13</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r14</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r15</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">fs</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">gs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">fsindex</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">gsindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">ds</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">es</span> <span class="o">=</span> <span class="n">ds</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ELF_PLAT_INIT(_r, load_addr)			\</span>
<span class="cp">	elf_common_init(&amp;current-&gt;thread, _r, 0)</span>

<span class="cp">#define	COMPAT_ELF_PLAT_INIT(regs, load_addr)		\</span>
<span class="cp">	elf_common_init(&amp;current-&gt;thread, regs, __USER_DS)</span>

<span class="kt">void</span> <span class="n">start_thread_ia32</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new_ip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new_sp</span><span class="p">);</span>
<span class="cp">#define compat_start_thread start_thread_ia32</span>

<span class="kt">void</span> <span class="n">set_personality_ia32</span><span class="p">(</span><span class="n">bool</span><span class="p">);</span>
<span class="cp">#define COMPAT_SET_PERSONALITY(ex)			\</span>
<span class="cp">	set_personality_ia32((ex).e_machine == EM_X86_64)</span>

<span class="cp">#define COMPAT_ELF_PLATFORM			(&quot;i686&quot;)</span>

<span class="cm">/*</span>
<span class="cm"> * regs is struct pt_regs, pr_reg is elf_gregset_t (which is</span>
<span class="cm"> * now struct_user_regs, they are different). Assumes current is the process</span>
<span class="cm"> * getting dumped.</span>
<span class="cm"> */</span>

<span class="cp">#define ELF_CORE_COPY_REGS(pr_reg, regs)			\</span>
<span class="cp">do {								\</span>
<span class="cp">	unsigned v;						\</span>
<span class="cp">	(pr_reg)[0] = (regs)-&gt;r15;				\</span>
<span class="cp">	(pr_reg)[1] = (regs)-&gt;r14;				\</span>
<span class="cp">	(pr_reg)[2] = (regs)-&gt;r13;				\</span>
<span class="cp">	(pr_reg)[3] = (regs)-&gt;r12;				\</span>
<span class="cp">	(pr_reg)[4] = (regs)-&gt;bp;				\</span>
<span class="cp">	(pr_reg)[5] = (regs)-&gt;bx;				\</span>
<span class="cp">	(pr_reg)[6] = (regs)-&gt;r11;				\</span>
<span class="cp">	(pr_reg)[7] = (regs)-&gt;r10;				\</span>
<span class="cp">	(pr_reg)[8] = (regs)-&gt;r9;				\</span>
<span class="cp">	(pr_reg)[9] = (regs)-&gt;r8;				\</span>
<span class="cp">	(pr_reg)[10] = (regs)-&gt;ax;				\</span>
<span class="cp">	(pr_reg)[11] = (regs)-&gt;cx;				\</span>
<span class="cp">	(pr_reg)[12] = (regs)-&gt;dx;				\</span>
<span class="cp">	(pr_reg)[13] = (regs)-&gt;si;				\</span>
<span class="cp">	(pr_reg)[14] = (regs)-&gt;di;				\</span>
<span class="cp">	(pr_reg)[15] = (regs)-&gt;orig_ax;				\</span>
<span class="cp">	(pr_reg)[16] = (regs)-&gt;ip;				\</span>
<span class="cp">	(pr_reg)[17] = (regs)-&gt;cs;				\</span>
<span class="cp">	(pr_reg)[18] = (regs)-&gt;flags;				\</span>
<span class="cp">	(pr_reg)[19] = (regs)-&gt;sp;				\</span>
<span class="cp">	(pr_reg)[20] = (regs)-&gt;ss;				\</span>
<span class="cp">	(pr_reg)[21] = current-&gt;thread.fs;			\</span>
<span class="cp">	(pr_reg)[22] = current-&gt;thread.gs;			\</span>
<span class="cp">	asm(&quot;movl %%ds,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[23] = v;	\</span>
<span class="cp">	asm(&quot;movl %%es,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[24] = v;	\</span>
<span class="cp">	asm(&quot;movl %%fs,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[25] = v;	\</span>
<span class="cp">	asm(&quot;movl %%gs,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[26] = v;	\</span>
<span class="cp">} while (0);</span>

<span class="cm">/* I&#39;m not sure if we can use &#39;-&#39; here */</span>
<span class="cp">#define ELF_PLATFORM       (&quot;x86_64&quot;)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_personality_64bit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_vsyscall32</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">force_personality32</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_X86_32 */</span><span class="cp"></span>

<span class="cp">#define CORE_DUMP_USE_REGSET</span>
<span class="cp">#define ELF_EXEC_PAGESIZE	4096</span>

<span class="cm">/* This is the location that an ET_DYN program is loaded if exec&#39;ed.  Typical</span>
<span class="cm">   use of this is to invoke &quot;./ld.so someprog&quot; to test out a new version of</span>
<span class="cm">   the loader.  We need to make sure that it is out of the way of the program</span>
<span class="cm">   that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */</span>

<span class="cp">#define ELF_ET_DYN_BASE		(TASK_SIZE / 3 * 2)</span>

<span class="cm">/* This yields a mask that user programs can use to figure out what</span>
<span class="cm">   instruction set this CPU supports.  This could be done in user space,</span>
<span class="cm">   but it&#39;s not easy, and we&#39;ve already done it here.  */</span>

<span class="cp">#define ELF_HWCAP		(boot_cpu_data.x86_capability[0])</span>

<span class="cm">/* This yields a string that ld.so will use to load implementation</span>
<span class="cm">   specific libraries for optimization.  This is more specific in</span>
<span class="cm">   intent than poking at uname or /proc/cpuinfo.</span>

<span class="cm">   For the moment, we have only optimizations for the Intel generations,</span>
<span class="cm">   but that could change... */</span>

<span class="cp">#define SET_PERSONALITY(ex) set_personality_64bit()</span>

<span class="cm">/*</span>
<span class="cm"> * An executable for which elf_read_implies_exec() returns TRUE will</span>
<span class="cm"> * have the READ_IMPLIES_EXEC personality flag set automatically.</span>
<span class="cm"> */</span>
<span class="cp">#define elf_read_implies_exec(ex, executable_stack)	\</span>
<span class="cp">	(executable_stack != EXSTACK_DISABLE_X)</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>

<span class="cp">#define	ARCH_DLINFO_IA32(vdso_enabled)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (vdso_enabled) {						\</span>
<span class="cp">		NEW_AUX_ENT(AT_SYSINFO,	VDSO_ENTRY);			\</span>
<span class="cp">		NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_CURRENT_BASE);	\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#ifdef CONFIG_X86_32</span>

<span class="cp">#define STACK_RND_MASK (0x7ff)</span>

<span class="cp">#define VDSO_HIGH_BASE		(__fix_to_virt(FIX_VDSO))</span>

<span class="cp">#define ARCH_DLINFO		ARCH_DLINFO_IA32(vdso_enabled)</span>

<span class="cm">/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_X86_32 */</span><span class="cp"></span>

<span class="cp">#define VDSO_HIGH_BASE		0xffffe000U </span><span class="cm">/* CONFIG_COMPAT_VDSO address */</span><span class="cp"></span>

<span class="cm">/* 1GB for 64bit, 8MB for 32bit */</span>
<span class="cp">#define STACK_RND_MASK (test_thread_flag(TIF_ADDR32) ? 0x7ff : 0x3fffff)</span>

<span class="cp">#define ARCH_DLINFO							\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (vdso_enabled)						\</span>
<span class="cp">		NEW_AUX_ENT(AT_SYSINFO_EHDR,				\</span>
<span class="cp">			    (unsigned long)current-&gt;mm-&gt;context.vdso);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define ARCH_DLINFO_X32							\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (vdso_enabled)						\</span>
<span class="cp">		NEW_AUX_ENT(AT_SYSINFO_EHDR,				\</span>
<span class="cp">			    (unsigned long)current-&gt;mm-&gt;context.vdso);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define AT_SYSINFO		32</span>

<span class="cp">#define COMPAT_ARCH_DLINFO						\</span>
<span class="cp">if (test_thread_flag(TIF_X32))						\</span>
<span class="cp">	ARCH_DLINFO_X32;						\</span>
<span class="cp">else									\</span>
<span class="cp">	ARCH_DLINFO_IA32(sysctl_vsyscall32)</span>

<span class="cp">#define COMPAT_ELF_ET_DYN_BASE	(TASK_UNMAPPED_BASE + 0x1000000)</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_X86_32 */</span><span class="cp"></span>

<span class="cp">#define VDSO_CURRENT_BASE	((unsigned long)current-&gt;mm-&gt;context.vdso)</span>

<span class="cp">#define VDSO_ENTRY							\</span>
<span class="cp">	((unsigned long)VDSO32_SYMBOL(VDSO_CURRENT_BASE, vsyscall))</span>

<span class="k">struct</span> <span class="n">linux_binprm</span><span class="p">;</span>

<span class="cp">#define ARCH_HAS_SETUP_ADDITIONAL_PAGES 1</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">arch_setup_additional_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">uses_interp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">x32_setup_additional_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">uses_interp</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">syscall32_setup_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exstack</span><span class="p">);</span>
<span class="cp">#define compat_arch_setup_additional_pages	syscall32_setup_pages</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arch_randomize_brk</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#define arch_randomize_brk arch_randomize_brk</span>

<span class="cm">/*</span>
<span class="cm"> * True on X86_32 or when emulating IA32 on X86_64</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmap_is_ia32</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_IA32_EMULATION</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_ADDR32</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The first two values are special, do not change. See align_addr() */</span>
<span class="k">enum</span> <span class="n">align_flags</span> <span class="p">{</span>
	<span class="n">ALIGN_VA_32</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">ALIGN_VA_64</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">ALIGN_VDSO</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">ALIGN_TOPDOWN</span>	<span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">va_alignment</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">va_alignment</span> <span class="n">va_align</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">align_flags</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* _ASM_X86_ELF_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
