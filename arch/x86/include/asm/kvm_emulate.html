<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › kvm_emulate.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>kvm_emulate.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * x86_emulate.h</span>
<span class="cm"> *</span>
<span class="cm"> * Generic x86 (32-bit and 64-bit) instruction decoder and emulator.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2005 Keir Fraser</span>
<span class="cm"> *</span>
<span class="cm"> * From: xen-unstable 10676:af9809f51f81a3c43f276f00c81a52ef558afda4</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_X86_KVM_X86_EMULATE_H</span>
<span class="cp">#define _ASM_X86_KVM_X86_EMULATE_H</span>

<span class="cp">#include &lt;asm/desc_defs.h&gt;</span>

<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">x86_intercept</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">x86_intercept_stage</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">x86_exception</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">vector</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">error_code_valid</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">nested_page_fault</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">address</span><span class="p">;</span> <span class="cm">/* cr2 or nested page fault gpa */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This struct is used to carry enough information from the instruction</span>
<span class="cm"> * decoder to main KVM so that a decision can be made whether the</span>
<span class="cm"> * instruction needs to be intercepted or not.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">x86_instruction_info</span> <span class="p">{</span>
	<span class="n">u8</span>  <span class="n">intercept</span><span class="p">;</span>          <span class="cm">/* which intercept                      */</span>
	<span class="n">u8</span>  <span class="n">rep_prefix</span><span class="p">;</span>         <span class="cm">/* rep prefix?                          */</span>
	<span class="n">u8</span>  <span class="n">modrm_mod</span><span class="p">;</span>		<span class="cm">/* mod part of modrm			*/</span>
	<span class="n">u8</span>  <span class="n">modrm_reg</span><span class="p">;</span>          <span class="cm">/* index of register used               */</span>
	<span class="n">u8</span>  <span class="n">modrm_rm</span><span class="p">;</span>		<span class="cm">/* rm part of modrm			*/</span>
	<span class="n">u64</span> <span class="n">src_val</span><span class="p">;</span>            <span class="cm">/* value of source operand              */</span>
	<span class="n">u8</span>  <span class="n">src_bytes</span><span class="p">;</span>          <span class="cm">/* size of source operand               */</span>
	<span class="n">u8</span>  <span class="n">dst_bytes</span><span class="p">;</span>          <span class="cm">/* size of destination operand          */</span>
	<span class="n">u8</span>  <span class="n">ad_bytes</span><span class="p">;</span>           <span class="cm">/* size of src/dst address              */</span>
	<span class="n">u64</span> <span class="n">next_rip</span><span class="p">;</span>           <span class="cm">/* rip following the instruction        */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * x86_emulate_ops:</span>
<span class="cm"> *</span>
<span class="cm"> * These operations represent the instruction emulator&#39;s interface to memory.</span>
<span class="cm"> * There are two categories of operation: those that act on ordinary memory</span>
<span class="cm"> * regions (*_std), and those that act on memory regions known to require</span>
<span class="cm"> * special treatment or emulation (*_emulated).</span>
<span class="cm"> *</span>
<span class="cm"> * The emulator assumes that an instruction accesses only one &#39;emulated memory&#39;</span>
<span class="cm"> * location, that this location is the given linear faulting address (cr2), and</span>
<span class="cm"> * that this is one of the instruction&#39;s data operands. Instruction fetches and</span>
<span class="cm"> * stack operations are assumed never to access emulated memory. The emulator</span>
<span class="cm"> * automatically deduces which operand of a string-move operation is accessing</span>
<span class="cm"> * emulated memory, and assumes that the other operand accesses normal memory.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *  1. The emulator isn&#39;t very smart about emulated vs. standard memory.</span>
<span class="cm"> *     &#39;Emulated memory&#39; access addresses should be checked for sanity.</span>
<span class="cm"> *     &#39;Normal memory&#39; accesses may fault, and the caller must arrange to</span>
<span class="cm"> *     detect and handle reentrancy into the emulator via recursive faults.</span>
<span class="cm"> *     Accesses may be unaligned and may cross page boundaries.</span>
<span class="cm"> *  2. If the access fails (cannot emulate, or a standard access faults) then</span>
<span class="cm"> *     it is up to the memop to propagate the fault to the guest VM via</span>
<span class="cm"> *     some out-of-band mechanism, unknown to the emulator. The memop signals</span>
<span class="cm"> *     failure by returning X86EMUL_PROPAGATE_FAULT to the emulator, which will</span>
<span class="cm"> *     then immediately bail.</span>
<span class="cm"> *  3. Valid access sizes are 1, 2, 4 and 8 bytes. On x86/32 systems only</span>
<span class="cm"> *     cmpxchg8b_emulated need support 8-byte accesses.</span>
<span class="cm"> *  4. The emulator cannot handle 64-bit mode emulation on an x86/32 system.</span>
<span class="cm"> */</span>
<span class="cm">/* Access completed successfully: continue emulation as normal. */</span>
<span class="cp">#define X86EMUL_CONTINUE        0</span>
<span class="cm">/* Access is unhandleable: bail from emulation and return error to caller. */</span>
<span class="cp">#define X86EMUL_UNHANDLEABLE    1</span>
<span class="cm">/* Terminate emulation but return success to the caller. */</span>
<span class="cp">#define X86EMUL_PROPAGATE_FAULT 2 </span><span class="cm">/* propagate a generated fault to guest */</span><span class="cp"></span>
<span class="cp">#define X86EMUL_RETRY_INSTR     3 </span><span class="cm">/* retry the instruction for some reason */</span><span class="cp"></span>
<span class="cp">#define X86EMUL_CMPXCHG_FAILED  4 </span><span class="cm">/* cmpxchg did not see expected value */</span><span class="cp"></span>
<span class="cp">#define X86EMUL_IO_NEEDED       5 </span><span class="cm">/* IO is needed to complete emulation */</span><span class="cp"></span>
<span class="cp">#define X86EMUL_INTERCEPTED     6 </span><span class="cm">/* Intercepted by nested VMCB/VMCS */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">x86_emulate_ops</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * read_std: Read bytes of standard (non-emulated/special) memory.</span>
<span class="cm">	 *           Used for descriptor reading.</span>
<span class="cm">	 *  @addr:  [IN ] Linear address from which to read.</span>
<span class="cm">	 *  @val:   [OUT] Value read from memory, zero-extended to &#39;u_long&#39;.</span>
<span class="cm">	 *  @bytes: [IN ] Number of bytes to read from memory.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_std</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * write_std: Write bytes of standard (non-emulated/special) memory.</span>
<span class="cm">	 *            Used for descriptor writing.</span>
<span class="cm">	 *  @addr:  [IN ] Linear address to which to write.</span>
<span class="cm">	 *  @val:   [OUT] Value write to memory, zero-extended to &#39;u_long&#39;.</span>
<span class="cm">	 *  @bytes: [IN ] Number of bytes to write to memory.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_std</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * fetch: Read bytes of standard (non-emulated/special) memory.</span>
<span class="cm">	 *        Used for instruction fetch.</span>
<span class="cm">	 *  @addr:  [IN ] Linear address from which to read.</span>
<span class="cm">	 *  @val:   [OUT] Value read from memory, zero-extended to &#39;u_long&#39;.</span>
<span class="cm">	 *  @bytes: [IN ] Number of bytes to read from memory.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fetch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * read_emulated: Read bytes from emulated/special memory area.</span>
<span class="cm">	 *  @addr:  [IN ] Linear address from which to read.</span>
<span class="cm">	 *  @val:   [OUT] Value read from memory, zero-extended to &#39;u_long&#39;.</span>
<span class="cm">	 *  @bytes: [IN ] Number of bytes to read from memory.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_emulated</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * write_emulated: Write bytes to emulated/special memory area.</span>
<span class="cm">	 *  @addr:  [IN ] Linear address to which to write.</span>
<span class="cm">	 *  @val:   [IN ] Value to write to memory (low-order bytes used as</span>
<span class="cm">	 *                required).</span>
<span class="cm">	 *  @bytes: [IN ] Number of bytes to write to memory.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_emulated</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * cmpxchg_emulated: Emulate an atomic (LOCKed) CMPXCHG operation on an</span>
<span class="cm">	 *                   emulated/special memory area.</span>
<span class="cm">	 *  @addr:  [IN ] Linear address to access.</span>
<span class="cm">	 *  @old:   [IN ] Value expected to be current at @addr.</span>
<span class="cm">	 *  @new:   [IN ] Value to write to @addr.</span>
<span class="cm">	 *  @bytes: [IN ] Number of bytes to access using CMPXCHG.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cmpxchg_emulated</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">invlpg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">addr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pio_in_emulated</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pio_out_emulated</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">get_segment</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">selector</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">base3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_segment</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">u16</span> <span class="n">selector</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">base3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_cached_segment_base</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">seg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_gdt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_idt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_gdt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_idt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dt</span><span class="p">);</span>
	<span class="n">ulong</span> <span class="p">(</span><span class="o">*</span><span class="n">get_cr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_cr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cr</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_rflags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cpl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_dr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="n">ulong</span> <span class="o">*</span><span class="n">dest</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_dr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_msr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_msr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">msr_index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_pmc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pmc</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">pdata</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">halt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wbinvd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fix_hypercall</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_fpu</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span> <span class="cm">/* disables preempt */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_fpu</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span> <span class="cm">/* reenables preempt */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">intercept</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">x86_instruction_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">x86_intercept_stage</span> <span class="n">stage</span><span class="p">);</span>

	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">get_cpuid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">edx</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">u32</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">vector_size</span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span> <span class="n">sse128_t</span><span class="p">;</span>

<span class="cm">/* Type, address-of, and value of an instruction&#39;s operand. */</span>
<span class="k">struct</span> <span class="n">operand</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">OP_REG</span><span class="p">,</span> <span class="n">OP_MEM</span><span class="p">,</span> <span class="n">OP_IMM</span><span class="p">,</span> <span class="n">OP_XMM</span><span class="p">,</span> <span class="n">OP_MM</span><span class="p">,</span> <span class="n">OP_NONE</span> <span class="p">}</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_val</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">orig_val64</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">segmented_address</span> <span class="p">{</span>
			<span class="n">ulong</span> <span class="n">ea</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">seg</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">mem</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">xmm</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">mm</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">val64</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">valptr</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">sse128_t</span> <span class="n">vec_val</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">mm_val</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fetch_cache</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">read_cache</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">x86_emulate_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="cm">/* Register state before/after emulation. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eip</span><span class="p">;</span> <span class="cm">/* eip before instruction emulation */</span>
	<span class="cm">/* Emulated execution mode, represented by an X86EMUL_MODE value. */</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/* interruptibility state, as a result of execution of STI or MOV SS */</span>
	<span class="kt">int</span> <span class="n">interruptibility</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">guest_mode</span><span class="p">;</span> <span class="cm">/* guest running a nested guest */</span>
	<span class="n">bool</span> <span class="n">perm_ok</span><span class="p">;</span> <span class="cm">/* do not check permissions if true */</span>
	<span class="n">bool</span> <span class="n">only_vendor_specific_insn</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">have_exception</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">x86_exception</span> <span class="n">exception</span><span class="p">;</span>

	<span class="cm">/* decode cache */</span>
	<span class="n">u8</span> <span class="n">twobyte</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">intercept</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">lock_prefix</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rep_prefix</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">op_bytes</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ad_bytes</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rex_prefix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">operand</span> <span class="n">src</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">operand</span> <span class="n">src2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">operand</span> <span class="n">dst</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_seg_override</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">seg_override</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">execute</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_perm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="cm">/* modrm */</span>
	<span class="n">u8</span> <span class="n">modrm</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">modrm_mod</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">modrm_reg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">modrm_rm</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">modrm_seg</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rip_relative</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_eip</span><span class="p">;</span>
	<span class="cm">/* Fields above regs are cleared together. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regs</span><span class="p">[</span><span class="n">NR_VCPU_REGS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">operand</span> <span class="n">memop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">operand</span> <span class="o">*</span><span class="n">memopp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fetch_cache</span> <span class="n">fetch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">read_cache</span> <span class="n">io_read</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">read_cache</span> <span class="n">mem_read</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Repeat String Operation Prefix */</span>
<span class="cp">#define REPE_PREFIX	0xf3</span>
<span class="cp">#define REPNE_PREFIX	0xf2</span>

<span class="cm">/* Execution mode, passed to the emulator. */</span>
<span class="cp">#define X86EMUL_MODE_REAL     0	</span><span class="cm">/* Real mode.             */</span><span class="cp"></span>
<span class="cp">#define X86EMUL_MODE_VM86     1	</span><span class="cm">/* Virtual 8086 mode.     */</span><span class="cp"></span>
<span class="cp">#define X86EMUL_MODE_PROT16   2	</span><span class="cm">/* 16-bit protected mode. */</span><span class="cp"></span>
<span class="cp">#define X86EMUL_MODE_PROT32   4	</span><span class="cm">/* 32-bit protected mode. */</span><span class="cp"></span>
<span class="cp">#define X86EMUL_MODE_PROT64   8	</span><span class="cm">/* 64-bit (long) mode.    */</span><span class="cp"></span>

<span class="cm">/* any protected mode   */</span>
<span class="cp">#define X86EMUL_MODE_PROT     (X86EMUL_MODE_PROT16|X86EMUL_MODE_PROT32| \</span>
<span class="cp">			       X86EMUL_MODE_PROT64)</span>

<span class="cm">/* CPUID vendors */</span>
<span class="cp">#define X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx 0x68747541</span>
<span class="cp">#define X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx 0x444d4163</span>
<span class="cp">#define X86EMUL_CPUID_VENDOR_AuthenticAMD_edx 0x69746e65</span>

<span class="cp">#define X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx 0x69444d41</span>
<span class="cp">#define X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx 0x21726574</span>
<span class="cp">#define X86EMUL_CPUID_VENDOR_AMDisbetterI_edx 0x74656273</span>

<span class="cp">#define X86EMUL_CPUID_VENDOR_GenuineIntel_ebx 0x756e6547</span>
<span class="cp">#define X86EMUL_CPUID_VENDOR_GenuineIntel_ecx 0x6c65746e</span>
<span class="cp">#define X86EMUL_CPUID_VENDOR_GenuineIntel_edx 0x49656e69</span>

<span class="k">enum</span> <span class="n">x86_intercept_stage</span> <span class="p">{</span>
	<span class="n">X86_ICTP_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="cm">/* Allow zero-init to not match anything */</span>
	<span class="n">X86_ICPT_PRE_EXCEPT</span><span class="p">,</span>
	<span class="n">X86_ICPT_POST_EXCEPT</span><span class="p">,</span>
	<span class="n">X86_ICPT_POST_MEMACCESS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">x86_intercept</span> <span class="p">{</span>
	<span class="n">x86_intercept_none</span><span class="p">,</span>
	<span class="n">x86_intercept_cr_read</span><span class="p">,</span>
	<span class="n">x86_intercept_cr_write</span><span class="p">,</span>
	<span class="n">x86_intercept_clts</span><span class="p">,</span>
	<span class="n">x86_intercept_lmsw</span><span class="p">,</span>
	<span class="n">x86_intercept_smsw</span><span class="p">,</span>
	<span class="n">x86_intercept_dr_read</span><span class="p">,</span>
	<span class="n">x86_intercept_dr_write</span><span class="p">,</span>
	<span class="n">x86_intercept_lidt</span><span class="p">,</span>
	<span class="n">x86_intercept_sidt</span><span class="p">,</span>
	<span class="n">x86_intercept_lgdt</span><span class="p">,</span>
	<span class="n">x86_intercept_sgdt</span><span class="p">,</span>
	<span class="n">x86_intercept_lldt</span><span class="p">,</span>
	<span class="n">x86_intercept_sldt</span><span class="p">,</span>
	<span class="n">x86_intercept_ltr</span><span class="p">,</span>
	<span class="n">x86_intercept_str</span><span class="p">,</span>
	<span class="n">x86_intercept_rdtsc</span><span class="p">,</span>
	<span class="n">x86_intercept_rdpmc</span><span class="p">,</span>
	<span class="n">x86_intercept_pushf</span><span class="p">,</span>
	<span class="n">x86_intercept_popf</span><span class="p">,</span>
	<span class="n">x86_intercept_cpuid</span><span class="p">,</span>
	<span class="n">x86_intercept_rsm</span><span class="p">,</span>
	<span class="n">x86_intercept_iret</span><span class="p">,</span>
	<span class="n">x86_intercept_intn</span><span class="p">,</span>
	<span class="n">x86_intercept_invd</span><span class="p">,</span>
	<span class="n">x86_intercept_pause</span><span class="p">,</span>
	<span class="n">x86_intercept_hlt</span><span class="p">,</span>
	<span class="n">x86_intercept_invlpg</span><span class="p">,</span>
	<span class="n">x86_intercept_invlpga</span><span class="p">,</span>
	<span class="n">x86_intercept_vmrun</span><span class="p">,</span>
	<span class="n">x86_intercept_vmload</span><span class="p">,</span>
	<span class="n">x86_intercept_vmsave</span><span class="p">,</span>
	<span class="n">x86_intercept_vmmcall</span><span class="p">,</span>
	<span class="n">x86_intercept_stgi</span><span class="p">,</span>
	<span class="n">x86_intercept_clgi</span><span class="p">,</span>
	<span class="n">x86_intercept_skinit</span><span class="p">,</span>
	<span class="n">x86_intercept_rdtscp</span><span class="p">,</span>
	<span class="n">x86_intercept_icebp</span><span class="p">,</span>
	<span class="n">x86_intercept_wbinvd</span><span class="p">,</span>
	<span class="n">x86_intercept_monitor</span><span class="p">,</span>
	<span class="n">x86_intercept_mwait</span><span class="p">,</span>
	<span class="n">x86_intercept_rdmsr</span><span class="p">,</span>
	<span class="n">x86_intercept_wrmsr</span><span class="p">,</span>
	<span class="n">x86_intercept_in</span><span class="p">,</span>
	<span class="n">x86_intercept_ins</span><span class="p">,</span>
	<span class="n">x86_intercept_out</span><span class="p">,</span>
	<span class="n">x86_intercept_outs</span><span class="p">,</span>

	<span class="n">nr_x86_intercepts</span>
<span class="p">};</span>

<span class="cm">/* Host execution mode. */</span>
<span class="cp">#if defined(CONFIG_X86_32)</span>
<span class="cp">#define X86EMUL_MODE_HOST X86EMUL_MODE_PROT32</span>
<span class="cp">#elif defined(CONFIG_X86_64)</span>
<span class="cp">#define X86EMUL_MODE_HOST X86EMUL_MODE_PROT64</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">x86_decode_insn</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">insn_len</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">x86_page_table_writing_insn</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>
<span class="cp">#define EMULATION_FAILED -1</span>
<span class="cp">#define EMULATION_OK 0</span>
<span class="cp">#define EMULATION_RESTART 1</span>
<span class="cp">#define EMULATION_INTERCEPTED 2</span>
<span class="kt">int</span> <span class="n">x86_emulate_insn</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">emulator_task_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span>
			 <span class="n">u16</span> <span class="n">tss_selector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idt_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">,</span>
			 <span class="n">bool</span> <span class="n">has_error_code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">emulate_int_real</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_emulate_ctxt</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* _ASM_X86_KVM_X86_EMULATE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
