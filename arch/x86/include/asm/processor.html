<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › processor.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>processor.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_X86_PROCESSOR_H</span>
<span class="cp">#define _ASM_X86_PROCESSOR_H</span>

<span class="cp">#include &lt;asm/processor-flags.h&gt;</span>

<span class="cm">/* Forward declaration, a strange C thing */</span>
<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>

<span class="cp">#include &lt;asm/vm86.h&gt;</span>
<span class="cp">#include &lt;asm/math_emu.h&gt;</span>
<span class="cp">#include &lt;asm/segment.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/sigcontext.h&gt;</span>
<span class="cp">#include &lt;asm/current.h&gt;</span>
<span class="cp">#include &lt;asm/cpufeature.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable_types.h&gt;</span>
<span class="cp">#include &lt;asm/percpu.h&gt;</span>
<span class="cp">#include &lt;asm/msr.h&gt;</span>
<span class="cp">#include &lt;asm/desc_defs.h&gt;</span>
<span class="cp">#include &lt;asm/nops.h&gt;</span>
<span class="cp">#include &lt;asm/special_insns.h&gt;</span>

<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/irqflags.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * We handle most unaligned accesses in hardware.  On the other hand</span>
<span class="cm"> * unaligned DMA can be quite expensive on some Nehalem processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Based on this we disable the IP header alignment in network drivers.</span>
<span class="cm"> */</span>
<span class="cp">#define NET_IP_ALIGN	0</span>

<span class="cp">#define HBP_NUM 4</span>
<span class="cm">/*</span>
<span class="cm"> * Default implementation of macro that returns current</span>
<span class="cm"> * instruction pointer (&quot;program counter&quot;).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">current_text_addr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;mov $1f, %0; 1:&quot;</span><span class="o">:</span><span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">pc</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">pc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_VSMP</span>
<span class="cp"># define ARCH_MIN_TASKALIGN		(1 &lt;&lt; INTERNODE_CACHE_SHIFT)</span>
<span class="cp"># define ARCH_MIN_MMSTRUCT_ALIGN	(1 &lt;&lt; INTERNODE_CACHE_SHIFT)</span>
<span class="cp">#else</span>
<span class="cp"># define ARCH_MIN_TASKALIGN		16</span>
<span class="cp"># define ARCH_MIN_MMSTRUCT_ALIGN	0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *  CPU type and hardware bug flags. Kept separately for each CPU.</span>
<span class="cm"> *  Members of this structure are referenced in head.S, so think twice</span>
<span class="cm"> *  before touching them. [mj]</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="p">{</span>
	<span class="n">__u8</span>			<span class="n">x86</span><span class="p">;</span>		<span class="cm">/* CPU family */</span>
	<span class="n">__u8</span>			<span class="n">x86_vendor</span><span class="p">;</span>	<span class="cm">/* CPU vendor */</span>
	<span class="n">__u8</span>			<span class="n">x86_model</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">x86_mask</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="kt">char</span>			<span class="n">wp_works_ok</span><span class="p">;</span>	<span class="cm">/* It doesn&#39;t on 386&#39;s */</span>

	<span class="cm">/* Problems on some 486Dx4&#39;s and old 386&#39;s: */</span>
	<span class="kt">char</span>			<span class="n">hlt_works_ok</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">hard_math</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">rfu</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">fdiv_bug</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">f00f_bug</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">coma_bug</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">pad0</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/* Number of 4K pages in DTLB/ITLB combined(in pages): */</span>
	<span class="kt">int</span>			<span class="n">x86_tlbsize</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">__u8</span>			<span class="n">x86_virt_bits</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">x86_phys_bits</span><span class="p">;</span>
	<span class="cm">/* CPUID returned core id bits: */</span>
	<span class="n">__u8</span>			<span class="n">x86_coreid_bits</span><span class="p">;</span>
	<span class="cm">/* Max extended CPUID function supported: */</span>
	<span class="n">__u32</span>			<span class="n">extended_cpuid_level</span><span class="p">;</span>
	<span class="cm">/* Maximum supported CPUID level, -1=no CPUID: */</span>
	<span class="kt">int</span>			<span class="n">cpuid_level</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">x86_capability</span><span class="p">[</span><span class="n">NCAPINTS</span><span class="p">];</span>
	<span class="kt">char</span>			<span class="n">x86_vendor_id</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">char</span>			<span class="n">x86_model_id</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="cm">/* in KB - valid for CPUS which support this call: */</span>
	<span class="kt">int</span>			<span class="n">x86_cache_size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">x86_cache_alignment</span><span class="p">;</span>	<span class="cm">/* In bytes */</span>
	<span class="kt">int</span>			<span class="n">x86_power</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">loops_per_jiffy</span><span class="p">;</span>
	<span class="cm">/* cpuid returned max cores value: */</span>
	<span class="n">u16</span>			 <span class="n">x86_max_cores</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">apicid</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">initial_apicid</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">x86_clflush_size</span><span class="p">;</span>
	<span class="cm">/* number of cores as seen by the OS: */</span>
	<span class="n">u16</span>			<span class="n">booted_cores</span><span class="p">;</span>
	<span class="cm">/* Physical processor id: */</span>
	<span class="n">u16</span>			<span class="n">phys_proc_id</span><span class="p">;</span>
	<span class="cm">/* Core id: */</span>
	<span class="n">u16</span>			<span class="n">cpu_core_id</span><span class="p">;</span>
	<span class="cm">/* Compute unit id */</span>
	<span class="n">u8</span>			<span class="n">compute_unit_id</span><span class="p">;</span>
	<span class="cm">/* Index into per_cpu list: */</span>
	<span class="n">u16</span>			<span class="n">cpu_index</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">microcode</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="n">SMP_CACHE_BYTES</span><span class="p">)));</span>

<span class="cp">#define X86_VENDOR_INTEL	0</span>
<span class="cp">#define X86_VENDOR_CYRIX	1</span>
<span class="cp">#define X86_VENDOR_AMD		2</span>
<span class="cp">#define X86_VENDOR_UMC		3</span>
<span class="cp">#define X86_VENDOR_CENTAUR	5</span>
<span class="cp">#define X86_VENDOR_TRANSMETA	7</span>
<span class="cp">#define X86_VENDOR_NSC		8</span>
<span class="cp">#define X86_VENDOR_NUM		9</span>

<span class="cp">#define X86_VENDOR_UNKNOWN	0xff</span>

<span class="cm">/*</span>
<span class="cm"> * capabilities of CPUs</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">cpuinfo_x86</span>	<span class="n">boot_cpu_data</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">cpuinfo_x86</span>	<span class="n">new_cpu_data</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tss_struct</span>	<span class="n">doublefault_tss</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">__u32</span>			<span class="n">cpu_caps_cleared</span><span class="p">[</span><span class="n">NCAPINTS</span><span class="p">];</span>
<span class="k">extern</span> <span class="n">__u32</span>			<span class="n">cpu_caps_set</span><span class="p">[</span><span class="n">NCAPINTS</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="n">DECLARE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span><span class="p">,</span> <span class="n">cpu_info</span><span class="p">);</span>
<span class="cp">#define cpu_data(cpu)		per_cpu(cpu_info, cpu)</span>
<span class="cp">#else</span>
<span class="cp">#define cpu_info		boot_cpu_data</span>
<span class="cp">#define cpu_data(cpu)		boot_cpu_data</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">cpuinfo_op</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hlt_works</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">return</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">).</span><span class="n">hlt_works_ok</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#define cache_line_size()	(boot_cpu_data.x86_cache_alignment)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">cpu_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">idle_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">early_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">identify_boot_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">identify_secondary_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">print_cpu_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">print_cpu_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_scattered_cpuid_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">init_intel_cacheinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">num_cache_leaves</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">detect_extended_topology</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">detect_ht</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_cpuid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">edx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* ecx is often an input as well as an output. */</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;cpuid&quot;</span>
	    <span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">eax</span><span class="p">),</span>
	      <span class="s">&quot;=b&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ebx</span><span class="p">),</span>
	      <span class="s">&quot;=c&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ecx</span><span class="p">),</span>
	      <span class="s">&quot;=d&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">edx</span><span class="p">)</span>
	    <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">eax</span><span class="p">),</span> <span class="s">&quot;2&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ecx</span><span class="p">)</span>
	    <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">load_cr3</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_cr3</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pgdir</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cm">/* This is the TSS defined by the hardware. */</span>
<span class="k">struct</span> <span class="n">x86_hw_tss</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">back_link</span><span class="p">,</span> <span class="n">__blh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sp0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ss0</span><span class="p">,</span> <span class="n">__ss0h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sp1</span><span class="p">;</span>
	<span class="cm">/* ss1 caches MSR_IA32_SYSENTER_CS: */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ss1</span><span class="p">,</span> <span class="n">__ss1h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sp2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ss2</span><span class="p">,</span> <span class="n">__ss2h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">__cr3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ax</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">cx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">si</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">di</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">es</span><span class="p">,</span> <span class="n">__esh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">cs</span><span class="p">,</span> <span class="n">__csh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ss</span><span class="p">,</span> <span class="n">__ssh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ds</span><span class="p">,</span> <span class="n">__dsh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">fs</span><span class="p">,</span> <span class="n">__fsh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">gs</span><span class="p">,</span> <span class="n">__gsh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ldt</span><span class="p">,</span> <span class="n">__ldth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">trace</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">io_bitmap_base</span><span class="p">;</span>

<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>
<span class="cp">#else</span>
<span class="k">struct</span> <span class="n">x86_hw_tss</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">reserved1</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">sp0</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">sp1</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">sp2</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">reserved2</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">ist</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="n">u32</span>			<span class="n">reserved3</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">reserved4</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">reserved5</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">io_bitmap_base</span><span class="p">;</span>

<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * IO-bitmap sizes:</span>
<span class="cm"> */</span>
<span class="cp">#define IO_BITMAP_BITS			65536</span>
<span class="cp">#define IO_BITMAP_BYTES			(IO_BITMAP_BITS/8)</span>
<span class="cp">#define IO_BITMAP_LONGS			(IO_BITMAP_BYTES/sizeof(long))</span>
<span class="cp">#define IO_BITMAP_OFFSET		offsetof(struct tss_struct, io_bitmap)</span>
<span class="cp">#define INVALID_IO_BITMAP_OFFSET	0x8000</span>

<span class="k">struct</span> <span class="n">tss_struct</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The hardware state:</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">x86_hw_tss</span>	<span class="n">x86_tss</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The extra 1 is there because the CPU will access an</span>
<span class="cm">	 * additional byte beyond the end of the IO permission</span>
<span class="cm">	 * bitmap. The extra byte must be all 1 bits, and must</span>
<span class="cm">	 * be within the limit.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">io_bitmap</span><span class="p">[</span><span class="n">IO_BITMAP_LONGS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * .. and then another 0x100 bytes for the emergency kernel stack:</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">stack</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="n">DECLARE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">tss_struct</span><span class="p">,</span> <span class="n">init_tss</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Save the original ist values for checking stack pointers during debugging</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">orig_ist</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ist</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define	MXCSR_DEFAULT		0x1f80</span>

<span class="k">struct</span> <span class="n">i387_fsave_struct</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">cwd</span><span class="p">;</span>	<span class="cm">/* FPU Control Word		*/</span>
	<span class="n">u32</span>			<span class="n">swd</span><span class="p">;</span>	<span class="cm">/* FPU Status Word		*/</span>
	<span class="n">u32</span>			<span class="n">twd</span><span class="p">;</span>	<span class="cm">/* FPU Tag Word			*/</span>
	<span class="n">u32</span>			<span class="n">fip</span><span class="p">;</span>	<span class="cm">/* FPU IP Offset		*/</span>
	<span class="n">u32</span>			<span class="n">fcs</span><span class="p">;</span>	<span class="cm">/* FPU IP Selector		*/</span>
	<span class="n">u32</span>			<span class="n">foo</span><span class="p">;</span>	<span class="cm">/* FPU Operand Pointer Offset	*/</span>
	<span class="n">u32</span>			<span class="n">fos</span><span class="p">;</span>	<span class="cm">/* FPU Operand Pointer Selector	*/</span>

	<span class="cm">/* 8*10 bytes for each FP-reg = 80 bytes:			*/</span>
	<span class="n">u32</span>			<span class="n">st_space</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

	<span class="cm">/* Software status information [not touched by FSAVE ]:		*/</span>
	<span class="n">u32</span>			<span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">i387_fxsave_struct</span> <span class="p">{</span>
	<span class="n">u16</span>			<span class="n">cwd</span><span class="p">;</span> <span class="cm">/* Control Word			*/</span>
	<span class="n">u16</span>			<span class="n">swd</span><span class="p">;</span> <span class="cm">/* Status Word			*/</span>
	<span class="n">u16</span>			<span class="n">twd</span><span class="p">;</span> <span class="cm">/* Tag Word			*/</span>
	<span class="n">u16</span>			<span class="n">fop</span><span class="p">;</span> <span class="cm">/* Last Instruction Opcode		*/</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u64</span>	<span class="n">rip</span><span class="p">;</span> <span class="cm">/* Instruction Pointer		*/</span>
			<span class="n">u64</span>	<span class="n">rdp</span><span class="p">;</span> <span class="cm">/* Data Pointer			*/</span>
		<span class="p">};</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span>	<span class="n">fip</span><span class="p">;</span> <span class="cm">/* FPU IP Offset			*/</span>
			<span class="n">u32</span>	<span class="n">fcs</span><span class="p">;</span> <span class="cm">/* FPU IP Selector			*/</span>
			<span class="n">u32</span>	<span class="n">foo</span><span class="p">;</span> <span class="cm">/* FPU Operand Offset		*/</span>
			<span class="n">u32</span>	<span class="n">fos</span><span class="p">;</span> <span class="cm">/* FPU Operand Selector		*/</span>
		<span class="p">};</span>
	<span class="p">};</span>
	<span class="n">u32</span>			<span class="n">mxcsr</span><span class="p">;</span>		<span class="cm">/* MXCSR Register State */</span>
	<span class="n">u32</span>			<span class="n">mxcsr_mask</span><span class="p">;</span>	<span class="cm">/* MXCSR Mask		*/</span>

	<span class="cm">/* 8*16 bytes for each FP-reg = 128 bytes:			*/</span>
	<span class="n">u32</span>			<span class="n">st_space</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="cm">/* 16*16 bytes for each XMM-reg = 256 bytes:			*/</span>
	<span class="n">u32</span>			<span class="n">xmm_space</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

	<span class="n">u32</span>			<span class="n">padding</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span>		<span class="n">padding1</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
		<span class="n">u32</span>		<span class="n">sw_reserved</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="p">};</span>

<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>

<span class="k">struct</span> <span class="n">i387_soft_struct</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">cwd</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">swd</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">twd</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">fip</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">fcs</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">foo</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">fos</span><span class="p">;</span>
	<span class="cm">/* 8*10 bytes for each FP-reg = 80 bytes: */</span>
	<span class="n">u32</span>			<span class="n">st_space</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">ftop</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">changed</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">lookahead</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">no_update</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">rm</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">alimit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">math_emu_info</span>	<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">entry_eip</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ymmh_struct</span> <span class="p">{</span>
	<span class="cm">/* 16 * 16 bytes for each YMMH-reg = 256 bytes */</span>
	<span class="n">u32</span> <span class="n">ymmh_space</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xsave_hdr_struct</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">xstate_bv</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">reserved1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">xsave_struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">i387_fxsave_struct</span> <span class="n">i387</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xsave_hdr_struct</span> <span class="n">xsave_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ymmh_struct</span> <span class="n">ymmh</span><span class="p">;</span>
	<span class="cm">/* new processor state extensions will go here */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span> <span class="p">(</span><span class="mi">64</span><span class="p">)));</span>

<span class="k">union</span> <span class="n">thread_xstate</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">i387_fsave_struct</span>	<span class="n">fsave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i387_fxsave_struct</span>	<span class="n">fxsave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i387_soft_struct</span>		<span class="n">soft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xsave_struct</span>		<span class="n">xsave</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fpu</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">has_fpu</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">thread_xstate</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">orig_ist</span><span class="p">,</span> <span class="n">orig_ist</span><span class="p">);</span>

<span class="k">union</span> <span class="n">irq_stack_union</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">irq_stack</span><span class="p">[</span><span class="n">IRQ_STACK_SIZE</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * GCC hardcodes the stack canary as %gs:40.  Since the</span>
<span class="cm">	 * irq_stack is the object at %gs:0, we reserve the bottom</span>
<span class="cm">	 * 48 bytes of the irq stack for the canary.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">gs_base</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_canary</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="n">DECLARE_PER_CPU_FIRST</span><span class="p">(</span><span class="k">union</span> <span class="n">irq_stack_union</span><span class="p">,</span> <span class="n">irq_stack_union</span><span class="p">);</span>
<span class="n">DECLARE_INIT_PER_CPU</span><span class="p">(</span><span class="n">irq_stack_union</span><span class="p">);</span>

<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">irq_stack_ptr</span><span class="p">);</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">irq_count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_eflags</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">ignore_sysret</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else	</span><span class="cm">/* X86_64 */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_CC_STACKPROTECTOR</span>
<span class="cm">/*</span>
<span class="cm"> * Make sure stack canary segment base is cached-aligned:</span>
<span class="cm"> *   &quot;For Intel Atom processors, avoid non zero segment base address</span>
<span class="cm"> *    that is not aligned to cache line boundary at all cost.&quot;</span>
<span class="cm"> * (Optim Ref Manual Assembly/Compiler Coding Rule 15.)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">stack_canary</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">__pad</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>		<span class="cm">/* canary at %gs:20 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">canary</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DECLARE_PER_CPU_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">stack_canary</span><span class="p">,</span> <span class="n">stack_canary</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif	</span><span class="cm">/* X86_64 */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xstate_size</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_thread_xstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">task_xstate_cachep</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">perf_event</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">thread_struct</span> <span class="p">{</span>
	<span class="cm">/* Cached TLS descriptors: */</span>
	<span class="k">struct</span> <span class="n">desc_struct</span>	<span class="n">tls_array</span><span class="p">[</span><span class="n">GDT_ENTRY_TLS_ENTRIES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sp0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sp</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sysenter_cs</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">usersp</span><span class="p">;</span>	<span class="cm">/* Copy from PDA */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">es</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">fsindex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">gsindex</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ip</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">fs</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">gs</span><span class="p">;</span>
	<span class="cm">/* Save middle states of ptrace breakpoints */</span>
	<span class="k">struct</span> <span class="n">perf_event</span>	<span class="o">*</span><span class="n">ptrace_bps</span><span class="p">[</span><span class="n">HBP_NUM</span><span class="p">];</span>
	<span class="cm">/* Debug status used for traps, single steps, etc... */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">debugreg6</span><span class="p">;</span>
	<span class="cm">/* Keep track of the exact dr7 value set by the user */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">ptrace_dr7</span><span class="p">;</span>
	<span class="cm">/* Fault info: */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">cr2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">trap_nr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">error_code</span><span class="p">;</span>
	<span class="cm">/* floating point and extended processor state */</span>
	<span class="k">struct</span> <span class="n">fpu</span>		<span class="n">fpu</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/* Virtual 86 mode info */</span>
	<span class="k">struct</span> <span class="n">vm86_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">vm86_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">screen_bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">v86flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">v86mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">saved_sp0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">saved_fs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">saved_gs</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* IO permissions: */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="o">*</span><span class="n">io_bitmap_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">iopl</span><span class="p">;</span>
	<span class="cm">/* Max allowed port in the bitmap, in bytes: */</span>
	<span class="kt">unsigned</span>		<span class="n">io_bitmap_max</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Set IOPL bits in EFLAGS from given mask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_set_iopl_mask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;pushfl;&quot;</span>
		      <span class="s">&quot;popl %0;&quot;</span>
		      <span class="s">&quot;andl %1, %0;&quot;</span>
		      <span class="s">&quot;orl %2, %0;&quot;</span>
		      <span class="s">&quot;pushl %0;&quot;</span>
		      <span class="s">&quot;popfl&quot;</span>
		      <span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span>
		      <span class="o">:</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="o">~</span><span class="n">X86_EFLAGS_IOPL</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">mask</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">native_load_sp0</span><span class="p">(</span><span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">tss</span><span class="p">,</span> <span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tss</span><span class="o">-&gt;</span><span class="n">x86_tss</span><span class="p">.</span><span class="n">sp0</span> <span class="o">=</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">sp0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/* Only happens when SEP is enabled, no need to test &quot;SEP&quot;arately: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tss</span><span class="o">-&gt;</span><span class="n">x86_tss</span><span class="p">.</span><span class="n">ss1</span> <span class="o">!=</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">sysenter_cs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tss</span><span class="o">-&gt;</span><span class="n">x86_tss</span><span class="p">.</span><span class="n">ss1</span> <span class="o">=</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">sysenter_cs</span><span class="p">;</span>
		<span class="n">wrmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_CS</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">sysenter_cs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_swapgs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;swapgs&quot;</span> <span class="o">:::</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PARAVIRT</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#define __cpuid			native_cpuid</span>
<span class="cp">#define paravirt_enabled()	0</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">load_sp0</span><span class="p">(</span><span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">tss</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">native_load_sp0</span><span class="p">(</span><span class="n">tss</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define set_iopl_mask native_set_iopl_mask</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PARAVIRT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Save the cr4 feature set we&#39;re using (ie</span>
<span class="cm"> * Pentium 4MB enable and PPro Global page</span>
<span class="cm"> * enable), so that any CPU&#39;s that boot up</span>
<span class="cm"> * after us can get the correct flags.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmu_cr4_features</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="o">*</span><span class="n">trampoline_cr4_features</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_in_cr4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr4</span><span class="p">;</span>

	<span class="n">mmu_cr4_features</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trampoline_cr4_features</span><span class="p">)</span>
		<span class="o">*</span><span class="n">trampoline_cr4_features</span> <span class="o">=</span> <span class="n">mmu_cr4_features</span><span class="p">;</span>
	<span class="n">cr4</span> <span class="o">=</span> <span class="n">read_cr4</span><span class="p">();</span>
	<span class="n">cr4</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">write_cr4</span><span class="p">(</span><span class="n">cr4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_in_cr4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr4</span><span class="p">;</span>

	<span class="n">mmu_cr4_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trampoline_cr4_features</span><span class="p">)</span>
		<span class="o">*</span><span class="n">trampoline_cr4_features</span> <span class="o">=</span> <span class="n">mmu_cr4_features</span><span class="p">;</span>
	<span class="n">cr4</span> <span class="o">=</span> <span class="n">read_cr4</span><span class="p">();</span>
	<span class="n">cr4</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">write_cr4</span><span class="p">(</span><span class="n">cr4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">seg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mm_segment_t</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * create a kernel thread without removing it from tasklists</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* Free all resources held by a thread. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">release_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_wchan</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Generic CPUID function</span>
<span class="cm"> * clear %ecx since some cpus (Cyrix MII) do not set or clear %ecx</span>
<span class="cm"> * resulting in stale register contents being returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpuid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">edx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__cpuid</span><span class="p">(</span><span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Some CPUID calls want &#39;count&#39; to be placed in ecx */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpuid_count</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">edx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">__cpuid</span><span class="p">(</span><span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CPUID functions returning a single datum</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpuid_eax</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>

	<span class="n">cpuid</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">eax</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpuid_ebx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>

	<span class="n">cpuid</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ebx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpuid_ecx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>

	<span class="n">cpuid</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ecx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpuid_edx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>

	<span class="n">cpuid</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">edx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rep_nop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;rep; nop&quot;</span> <span class="o">:::</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpu_relax</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rep_nop</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Stop speculative execution and prefetching of modified code. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sync_core</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_M386) || defined(CONFIG_M486)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
		<span class="cm">/* There is no speculative execution.</span>
<span class="cm">		 * jmp is a barrier to prefetching. */</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;jmp 1f</span><span class="se">\n</span><span class="s">1:</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:::</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="cm">/* cpuid is a barrier to speculative execution.</span>
<span class="cm">		 * Prefetched instructions are automatically</span>
<span class="cm">		 * invalidated when modified. */</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;cpuid&quot;</span> <span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			     <span class="o">:</span> <span class="s">&quot;ebx&quot;</span><span class="p">,</span> <span class="s">&quot;ecx&quot;</span><span class="p">,</span> <span class="s">&quot;edx&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__monitor</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ecx</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">edx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* &quot;monitor %eax, %ecx, %edx;&quot; */</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;.byte 0x0f, 0x01, 0xc8;&quot;</span>
		     <span class="o">::</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="n">eax</span><span class="p">),</span> <span class="s">&quot;c&quot;</span> <span class="p">(</span><span class="n">ecx</span><span class="p">),</span> <span class="s">&quot;d&quot;</span><span class="p">(</span><span class="n">edx</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__mwait</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eax</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ecx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* &quot;mwait %eax, %ecx;&quot; */</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;.byte 0x0f, 0x01, 0xc9;&quot;</span>
		     <span class="o">::</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="n">eax</span><span class="p">),</span> <span class="s">&quot;c&quot;</span> <span class="p">(</span><span class="n">ecx</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__sti_mwait</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eax</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ecx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_hardirqs_on</span><span class="p">();</span>
	<span class="cm">/* &quot;mwait %eax, %ecx;&quot; */</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sti; .byte 0x0f, 0x01, 0xc9;&quot;</span>
		     <span class="o">::</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="n">eax</span><span class="p">),</span> <span class="s">&quot;c&quot;</span> <span class="p">(</span><span class="n">ecx</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">select_idle_routine</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_amd_e400_c1e_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">boot_option_idle_override</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">bool</span>			<span class="n">amd_e400_c1e_detected</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">idle_boot_override</span> <span class="p">{</span><span class="n">IDLE_NO_OVERRIDE</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IDLE_HALT</span><span class="p">,</span> <span class="n">IDLE_NOMWAIT</span><span class="p">,</span>
			 <span class="n">IDLE_POLL</span><span class="p">,</span> <span class="n">IDLE_FORCE_MWAIT</span><span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">enable_sep_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysenter_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">early_trap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Defined in head.S */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">desc_ptr</span>		<span class="n">early_gdt_descr</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">cpu_set_gdt</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">switch_to_new_gdt</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">load_percpu_segment</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_debugctlmsr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">debugctlmsr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_X86_DEBUGCTLMSR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_DEBUGCTLMSR</span><span class="p">,</span> <span class="n">debugctlmsr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">debugctlmsr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_debugctlmsr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">debugctlmsr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_X86_DEBUGCTLMSR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_DEBUGCTLMSR</span><span class="p">,</span> <span class="n">debugctlmsr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * from system description table in BIOS. Mostly for MCA use, but</span>
<span class="cm"> * others may find it useful:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">machine_id</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">machine_submodel_id</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">BIOS_revision</span><span class="p">;</span>

<span class="cm">/* Boot loader type from the setup header: */</span>
<span class="k">extern</span> <span class="kt">int</span>			<span class="n">bootloader_type</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span>			<span class="n">bootloader_version</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">char</span>			<span class="n">ignore_fpu_irq</span><span class="p">;</span>

<span class="cp">#define HAVE_ARCH_PICK_MMAP_LAYOUT 1</span>
<span class="cp">#define ARCH_HAS_PREFETCHW</span>
<span class="cp">#define ARCH_HAS_SPINLOCK_PREFETCH</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cp"># define BASE_PREFETCH		ASM_NOP4</span>
<span class="cp"># define ARCH_HAS_PREFETCH</span>
<span class="cp">#else</span>
<span class="cp"># define BASE_PREFETCH		&quot;prefetcht0 (%1)&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Prefetch instructions for Pentium III (+) and AMD Athlon (+)</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s not worth to care about 3dnow prefetches for the K6</span>
<span class="cm"> * because they are microcoded there and very slow.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prefetch</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">alternative_input</span><span class="p">(</span><span class="n">BASE_PREFETCH</span><span class="p">,</span>
			  <span class="s">&quot;prefetchnta (%1)&quot;</span><span class="p">,</span>
			  <span class="n">X86_FEATURE_XMM</span><span class="p">,</span>
			  <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3dnow prefetch to get an exclusive cache line.</span>
<span class="cm"> * Useful for spinlocks to avoid one state transition in the</span>
<span class="cm"> * cache coherency protocol:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prefetchw</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">alternative_input</span><span class="p">(</span><span class="n">BASE_PREFETCH</span><span class="p">,</span>
			  <span class="s">&quot;prefetchw (%1)&quot;</span><span class="p">,</span>
			  <span class="n">X86_FEATURE_3DNOW</span><span class="p">,</span>
			  <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spin_lock_prefetch</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prefetchw</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cm">/*</span>
<span class="cm"> * User space process size: 3GB (default).</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_SIZE		PAGE_OFFSET</span>
<span class="cp">#define TASK_SIZE_MAX		TASK_SIZE</span>
<span class="cp">#define STACK_TOP		TASK_SIZE</span>
<span class="cp">#define STACK_TOP_MAX		STACK_TOP</span>

<span class="cp">#define INIT_THREAD  {							  \</span>
<span class="cp">	.sp0			= sizeof(init_stack) + (long)&amp;init_stack, \</span>
<span class="cp">	.vm86_info		= NULL,					  \</span>
<span class="cp">	.sysenter_cs		= __KERNEL_CS,				  \</span>
<span class="cp">	.io_bitmap_ptr		= NULL,					  \</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note that the .io_bitmap member must be extra-big. This is because</span>
<span class="cm"> * the CPU will access an additional byte beyond the end of the IO</span>
<span class="cm"> * permission bitmap. The extra byte must be all 1 bits, and must</span>
<span class="cm"> * be within the limit.</span>
<span class="cm"> */</span>
<span class="cp">#define INIT_TSS  {							  \</span>
<span class="cp">	.x86_tss = {							  \</span>
<span class="cp">		.sp0		= sizeof(init_stack) + (long)&amp;init_stack, \</span>
<span class="cp">		.ss0		= __KERNEL_DS,				  \</span>
<span class="cp">		.ss1		= __KERNEL_CS,				  \</span>
<span class="cp">		.io_bitmap_base	= INVALID_IO_BITMAP_OFFSET,		  \</span>
<span class="cp">	 },								  \</span>
<span class="cp">	.io_bitmap		= { [0 ... IO_BITMAP_LONGS] = ~0 },	  \</span>
<span class="cp">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thread_saved_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="cp">#define THREAD_SIZE_LONGS      (THREAD_SIZE/sizeof(unsigned long))</span>
<span class="cp">#define KSTK_TOP(info)                                                 \</span>
<span class="cp">({                                                                     \</span>
<span class="cp">       unsigned long *__ptr = (unsigned long *)(info);                 \</span>
<span class="cp">       (unsigned long)(&amp;__ptr[THREAD_SIZE_LONGS]);                     \</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * The below -8 is to reserve 8 bytes on top of the ring0 stack.</span>
<span class="cm"> * This is necessary to guarantee that the entire &quot;struct pt_regs&quot;</span>
<span class="cm"> * is accessible even if the CPU haven&#39;t stored the SS/ESP registers</span>
<span class="cm"> * on the stack (interrupt gate does not save these registers</span>
<span class="cm"> * when switching to the same priv ring).</span>
<span class="cm"> * Therefore beware: accessing the ss/esp fields of the</span>
<span class="cm"> * &quot;struct pt_regs&quot; is possible, but they may contain the</span>
<span class="cm"> * completely wrong values.</span>
<span class="cm"> */</span>
<span class="cp">#define task_pt_regs(task)                                             \</span>
<span class="cp">({                                                                     \</span>
<span class="cp">       struct pt_regs *__regs__;                                       \</span>
<span class="cp">       __regs__ = (struct pt_regs *)(KSTK_TOP(task_stack_page(task))-8); \</span>
<span class="cp">       __regs__ - 1;                                                   \</span>
<span class="cp">})</span>

<span class="cp">#define KSTK_ESP(task)		(task_pt_regs(task)-&gt;sp)</span>

<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * User space process size. 47bits minus one guard page.</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_SIZE_MAX	((1UL &lt;&lt; 47) - PAGE_SIZE)</span>

<span class="cm">/* This decides where the kernel will search for a free chunk of vm</span>
<span class="cm"> * space during mmap&#39;s.</span>
<span class="cm"> */</span>
<span class="cp">#define IA32_PAGE_OFFSET	((current-&gt;personality &amp; ADDR_LIMIT_3GB) ? \</span>
<span class="cp">					0xc0000000 : 0xFFFFe000)</span>

<span class="cp">#define TASK_SIZE		(test_thread_flag(TIF_ADDR32) ? \</span>
<span class="cp">					IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span>
<span class="cp">#define TASK_SIZE_OF(child)	((test_tsk_thread_flag(child, TIF_ADDR32)) ? \</span>
<span class="cp">					IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span>

<span class="cp">#define STACK_TOP		TASK_SIZE</span>
<span class="cp">#define STACK_TOP_MAX		TASK_SIZE_MAX</span>

<span class="cp">#define INIT_THREAD  { \</span>
<span class="cp">	.sp0 = (unsigned long)&amp;init_stack + sizeof(init_stack) \</span>
<span class="cp">}</span>

<span class="cp">#define INIT_TSS  { \</span>
<span class="cp">	.x86_tss.sp0 = (unsigned long)&amp;init_stack + sizeof(init_stack) \</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return saved PC of a blocked thread.</span>
<span class="cm"> * What is this good for? it will be always the scheduler or ret_from_fork.</span>
<span class="cm"> */</span>
<span class="cp">#define thread_saved_pc(t)	(*(unsigned long *)((t)-&gt;thread.sp - 8))</span>

<span class="cp">#define task_pt_regs(tsk)	((struct pt_regs *)(tsk)-&gt;thread.sp0 - 1)</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">KSTK_ESP</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * User space RSP while inside the SYSCALL fast path</span>
<span class="cm"> */</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">old_rsp</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">start_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_ip</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_sp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This decides where the kernel will search for a free chunk of vm</span>
<span class="cm"> * space during mmap&#39;s.</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))</span>

<span class="cp">#define KSTK_EIP(task)		(task_pt_regs(task)-&gt;ip)</span>

<span class="cm">/* Get/set a process&#39; ability to use the timestamp counter instruction */</span>
<span class="cp">#define GET_TSC_CTL(adr)	get_tsc_mode((adr))</span>
<span class="cp">#define SET_TSC_CTL(val)	set_tsc_mode((val))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_tsc_mode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_tsc_mode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">amd_get_nb_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">aperfmperf</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">aperf</span><span class="p">,</span> <span class="n">mperf</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_aperfmperf</span><span class="p">(</span><span class="k">struct</span> <span class="n">aperfmperf</span> <span class="o">*</span><span class="n">am</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_APERFMPERF</span><span class="p">));</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_APERF</span><span class="p">,</span> <span class="n">am</span><span class="o">-&gt;</span><span class="n">aperf</span><span class="p">);</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MPERF</span><span class="p">,</span> <span class="n">am</span><span class="o">-&gt;</span><span class="n">mperf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define APERFMPERF_SHIFT 10</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">calc_aperfmperf_ratio</span><span class="p">(</span><span class="k">struct</span> <span class="n">aperfmperf</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">aperfmperf</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">aperf</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">aperf</span> <span class="o">-</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">aperf</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mperf</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">mperf</span> <span class="o">-</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mperf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ratio</span> <span class="o">=</span> <span class="n">aperf</span><span class="p">;</span>

	<span class="n">mperf</span> <span class="o">&gt;&gt;=</span> <span class="n">APERFMPERF_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mperf</span><span class="p">)</span>
		<span class="n">ratio</span> <span class="o">=</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">aperf</span><span class="p">,</span> <span class="n">mperf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ratio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * AMD errata checking</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_CPU_SUP_AMD</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">amd_erratum_383</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">amd_erratum_400</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">cpu_has_amd_erratum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#define AMD_LEGACY_ERRATUM(...)		{ -1, __VA_ARGS__, 0 }</span>
<span class="cp">#define AMD_OSVW_ERRATUM(osvw_id, ...)	{ osvw_id, __VA_ARGS__, 0 }</span>
<span class="cp">#define AMD_MODEL_RANGE(f, m_start, s_start, m_end, s_end) \</span>
<span class="cp">	((f &lt;&lt; 24) | (m_start &lt;&lt; 16) | (s_start &lt;&lt; 12) | (m_end &lt;&lt; 4) | (s_end))</span>
<span class="cp">#define AMD_MODEL_RANGE_FAMILY(range)	(((range) &gt;&gt; 24) &amp; 0xff)</span>
<span class="cp">#define AMD_MODEL_RANGE_START(range)	(((range) &gt;&gt; 12) &amp; 0xfff)</span>
<span class="cp">#define AMD_MODEL_RANGE_END(range)	((range) &amp; 0xfff)</span>

<span class="cp">#else</span>
<span class="cp">#define cpu_has_amd_erratum(x)	(false)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CPU_SUP_AMD */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arch_align_stack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_init_pages</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">what</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">default_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">set_pm_idle_to_default</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">stop_this_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_PROCESSOR_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
