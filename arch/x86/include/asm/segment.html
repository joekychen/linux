<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › include › asm › segment.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>segment.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_X86_SEGMENT_H</span>
<span class="cp">#define _ASM_X86_SEGMENT_H</span>

<span class="cp">#include &lt;linux/const.h&gt;</span>

<span class="cm">/* Constructor for a conventional segment GDT (or LDT) entry */</span>
<span class="cm">/* This is a macro so it can be used in initializers */</span>
<span class="cp">#define GDT_ENTRY(flags, base, limit)			\</span>
<span class="cp">	((((base)  &amp; _AC(0xff000000,ULL)) &lt;&lt; (56-24)) |	\</span>
<span class="cp">	 (((flags) &amp; _AC(0x0000f0ff,ULL)) &lt;&lt; 40) |	\</span>
<span class="cp">	 (((limit) &amp; _AC(0x000f0000,ULL)) &lt;&lt; (48-16)) |	\</span>
<span class="cp">	 (((base)  &amp; _AC(0x00ffffff,ULL)) &lt;&lt; 16) |	\</span>
<span class="cp">	 (((limit) &amp; _AC(0x0000ffff,ULL))))</span>

<span class="cm">/* Simple and small GDT entries for booting only */</span>

<span class="cp">#define GDT_ENTRY_BOOT_CS	2</span>
<span class="cp">#define __BOOT_CS		(GDT_ENTRY_BOOT_CS * 8)</span>

<span class="cp">#define GDT_ENTRY_BOOT_DS	(GDT_ENTRY_BOOT_CS + 1)</span>
<span class="cp">#define __BOOT_DS		(GDT_ENTRY_BOOT_DS * 8)</span>

<span class="cp">#define GDT_ENTRY_BOOT_TSS	(GDT_ENTRY_BOOT_CS + 2)</span>
<span class="cp">#define __BOOT_TSS		(GDT_ENTRY_BOOT_TSS * 8)</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cm">/*</span>
<span class="cm"> * The layout of the per-CPU GDT under Linux:</span>
<span class="cm"> *</span>
<span class="cm"> *   0 - null</span>
<span class="cm"> *   1 - reserved</span>
<span class="cm"> *   2 - reserved</span>
<span class="cm"> *   3 - reserved</span>
<span class="cm"> *</span>
<span class="cm"> *   4 - unused			&lt;==== new cacheline</span>
<span class="cm"> *   5 - unused</span>
<span class="cm"> *</span>
<span class="cm"> *  ------- start of TLS (Thread-Local Storage) segments:</span>
<span class="cm"> *</span>
<span class="cm"> *   6 - TLS segment #1			[ glibc&#39;s TLS segment ]</span>
<span class="cm"> *   7 - TLS segment #2			[ Wine&#39;s %fs Win32 segment ]</span>
<span class="cm"> *   8 - TLS segment #3</span>
<span class="cm"> *   9 - reserved</span>
<span class="cm"> *  10 - reserved</span>
<span class="cm"> *  11 - reserved</span>
<span class="cm"> *</span>
<span class="cm"> *  ------- start of kernel segments:</span>
<span class="cm"> *</span>
<span class="cm"> *  12 - kernel code segment		&lt;==== new cacheline</span>
<span class="cm"> *  13 - kernel data segment</span>
<span class="cm"> *  14 - default user CS</span>
<span class="cm"> *  15 - default user DS</span>
<span class="cm"> *  16 - TSS</span>
<span class="cm"> *  17 - LDT</span>
<span class="cm"> *  18 - PNPBIOS support (16-&gt;32 gate)</span>
<span class="cm"> *  19 - PNPBIOS support</span>
<span class="cm"> *  20 - PNPBIOS support</span>
<span class="cm"> *  21 - PNPBIOS support</span>
<span class="cm"> *  22 - PNPBIOS support</span>
<span class="cm"> *  23 - APM BIOS support</span>
<span class="cm"> *  24 - APM BIOS support</span>
<span class="cm"> *  25 - APM BIOS support</span>
<span class="cm"> *</span>
<span class="cm"> *  26 - ESPFIX small SS</span>
<span class="cm"> *  27 - per-cpu			[ offset to per-cpu data area ]</span>
<span class="cm"> *  28 - stack_canary-20		[ for stack protector ]</span>
<span class="cm"> *  29 - unused</span>
<span class="cm"> *  30 - unused</span>
<span class="cm"> *  31 - TSS for double fault handler</span>
<span class="cm"> */</span>
<span class="cp">#define GDT_ENTRY_TLS_MIN	6</span>
<span class="cp">#define GDT_ENTRY_TLS_MAX 	(GDT_ENTRY_TLS_MIN + GDT_ENTRY_TLS_ENTRIES - 1)</span>

<span class="cp">#define GDT_ENTRY_DEFAULT_USER_CS	14</span>

<span class="cp">#define GDT_ENTRY_DEFAULT_USER_DS	15</span>

<span class="cp">#define GDT_ENTRY_KERNEL_BASE		(12)</span>

<span class="cp">#define GDT_ENTRY_KERNEL_CS		(GDT_ENTRY_KERNEL_BASE+0)</span>

<span class="cp">#define GDT_ENTRY_KERNEL_DS		(GDT_ENTRY_KERNEL_BASE+1)</span>

<span class="cp">#define GDT_ENTRY_TSS			(GDT_ENTRY_KERNEL_BASE+4)</span>
<span class="cp">#define GDT_ENTRY_LDT			(GDT_ENTRY_KERNEL_BASE+5)</span>

<span class="cp">#define GDT_ENTRY_PNPBIOS_BASE		(GDT_ENTRY_KERNEL_BASE+6)</span>
<span class="cp">#define GDT_ENTRY_APMBIOS_BASE		(GDT_ENTRY_KERNEL_BASE+11)</span>

<span class="cp">#define GDT_ENTRY_ESPFIX_SS		(GDT_ENTRY_KERNEL_BASE+14)</span>
<span class="cp">#define __ESPFIX_SS			(GDT_ENTRY_ESPFIX_SS*8)</span>

<span class="cp">#define GDT_ENTRY_PERCPU		(GDT_ENTRY_KERNEL_BASE+15)</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#define __KERNEL_PERCPU (GDT_ENTRY_PERCPU * 8)</span>
<span class="cp">#else</span>
<span class="cp">#define __KERNEL_PERCPU 0</span>
<span class="cp">#endif</span>

<span class="cp">#define GDT_ENTRY_STACK_CANARY		(GDT_ENTRY_KERNEL_BASE+16)</span>
<span class="cp">#ifdef CONFIG_CC_STACKPROTECTOR</span>
<span class="cp">#define __KERNEL_STACK_CANARY		(GDT_ENTRY_STACK_CANARY*8)</span>
<span class="cp">#else</span>
<span class="cp">#define __KERNEL_STACK_CANARY		0</span>
<span class="cp">#endif</span>

<span class="cp">#define GDT_ENTRY_DOUBLEFAULT_TSS	31</span>

<span class="cm">/*</span>
<span class="cm"> * The GDT has 32 entries</span>
<span class="cm"> */</span>
<span class="cp">#define GDT_ENTRIES 32</span>

<span class="cm">/* The PnP BIOS entries in the GDT */</span>
<span class="cp">#define GDT_ENTRY_PNPBIOS_CS32		(GDT_ENTRY_PNPBIOS_BASE + 0)</span>
<span class="cp">#define GDT_ENTRY_PNPBIOS_CS16		(GDT_ENTRY_PNPBIOS_BASE + 1)</span>
<span class="cp">#define GDT_ENTRY_PNPBIOS_DS		(GDT_ENTRY_PNPBIOS_BASE + 2)</span>
<span class="cp">#define GDT_ENTRY_PNPBIOS_TS1		(GDT_ENTRY_PNPBIOS_BASE + 3)</span>
<span class="cp">#define GDT_ENTRY_PNPBIOS_TS2		(GDT_ENTRY_PNPBIOS_BASE + 4)</span>

<span class="cm">/* The PnP BIOS selectors */</span>
<span class="cp">#define PNP_CS32   (GDT_ENTRY_PNPBIOS_CS32 * 8)	</span><span class="cm">/* segment for calling fn */</span><span class="cp"></span>
<span class="cp">#define PNP_CS16   (GDT_ENTRY_PNPBIOS_CS16 * 8)	</span><span class="cm">/* code segment for BIOS */</span><span class="cp"></span>
<span class="cp">#define PNP_DS     (GDT_ENTRY_PNPBIOS_DS * 8)	</span><span class="cm">/* data segment for BIOS */</span><span class="cp"></span>
<span class="cp">#define PNP_TS1    (GDT_ENTRY_PNPBIOS_TS1 * 8)	</span><span class="cm">/* transfer data segment */</span><span class="cp"></span>
<span class="cp">#define PNP_TS2    (GDT_ENTRY_PNPBIOS_TS2 * 8)	</span><span class="cm">/* another data segment */</span><span class="cp"></span>

<span class="cm">/* Bottom two bits of selector give the ring privilege level */</span>
<span class="cp">#define SEGMENT_RPL_MASK	0x3</span>
<span class="cm">/* Bit 2 is table indicator (LDT/GDT) */</span>
<span class="cp">#define SEGMENT_TI_MASK		0x4</span>

<span class="cm">/* User mode is privilege level 3 */</span>
<span class="cp">#define USER_RPL		0x3</span>
<span class="cm">/* LDT segment has TI set, GDT has it cleared */</span>
<span class="cp">#define SEGMENT_LDT		0x4</span>
<span class="cp">#define SEGMENT_GDT		0x0</span>

<span class="cm">/*</span>
<span class="cm"> * Matching rules for certain types of segments.</span>
<span class="cm"> */</span>

<span class="cm">/* Matches PNP_CS32 and PNP_CS16 (they must be consecutive) */</span>
<span class="cp">#define SEGMENT_IS_PNP_CODE(x)   (((x) &amp; 0xf4) == GDT_ENTRY_PNPBIOS_BASE * 8)</span>


<span class="cp">#else</span>
<span class="cp">#include &lt;asm/cache.h&gt;</span>

<span class="cp">#define GDT_ENTRY_KERNEL32_CS 1</span>
<span class="cp">#define GDT_ENTRY_KERNEL_CS 2</span>
<span class="cp">#define GDT_ENTRY_KERNEL_DS 3</span>

<span class="cp">#define __KERNEL32_CS   (GDT_ENTRY_KERNEL32_CS * 8)</span>

<span class="cm">/*</span>
<span class="cm"> * we cannot use the same code segment descriptor for user and kernel</span>
<span class="cm"> * -- not even in the long flat mode, because of different DPL /kkeil</span>
<span class="cm"> * The segment offset needs to contain a RPL. Grr. -AK</span>
<span class="cm"> * GDT layout to get 64bit syscall right (sysret hardcodes gdt offsets)</span>
<span class="cm"> */</span>
<span class="cp">#define GDT_ENTRY_DEFAULT_USER32_CS 4</span>
<span class="cp">#define GDT_ENTRY_DEFAULT_USER_DS 5</span>
<span class="cp">#define GDT_ENTRY_DEFAULT_USER_CS 6</span>
<span class="cp">#define __USER32_CS   (GDT_ENTRY_DEFAULT_USER32_CS*8+3)</span>
<span class="cp">#define __USER32_DS	__USER_DS</span>

<span class="cp">#define GDT_ENTRY_TSS 8	</span><span class="cm">/* needs two entries */</span><span class="cp"></span>
<span class="cp">#define GDT_ENTRY_LDT 10 </span><span class="cm">/* needs two entries */</span><span class="cp"></span>
<span class="cp">#define GDT_ENTRY_TLS_MIN 12</span>
<span class="cp">#define GDT_ENTRY_TLS_MAX 14</span>

<span class="cp">#define GDT_ENTRY_PER_CPU 15	</span><span class="cm">/* Abused to load per CPU data from limit */</span><span class="cp"></span>
<span class="cp">#define __PER_CPU_SEG	(GDT_ENTRY_PER_CPU * 8 + 3)</span>

<span class="cm">/* TLS indexes for 64bit - hardcoded in arch_prctl */</span>
<span class="cp">#define FS_TLS 0</span>
<span class="cp">#define GS_TLS 1</span>

<span class="cp">#define GS_TLS_SEL ((GDT_ENTRY_TLS_MIN+GS_TLS)*8 + 3)</span>
<span class="cp">#define FS_TLS_SEL ((GDT_ENTRY_TLS_MIN+FS_TLS)*8 + 3)</span>

<span class="cp">#define GDT_ENTRIES 16</span>

<span class="cp">#endif</span>

<span class="cp">#define __KERNEL_CS	(GDT_ENTRY_KERNEL_CS*8)</span>
<span class="cp">#define __KERNEL_DS	(GDT_ENTRY_KERNEL_DS*8)</span>
<span class="cp">#define __USER_DS	(GDT_ENTRY_DEFAULT_USER_DS*8+3)</span>
<span class="cp">#define __USER_CS	(GDT_ENTRY_DEFAULT_USER_CS*8+3)</span>
<span class="cp">#ifndef CONFIG_PARAVIRT</span>
<span class="cp">#define get_kernel_rpl()  0</span>
<span class="cp">#endif</span>

<span class="cm">/* User mode is privilege level 3 */</span>
<span class="cp">#define USER_RPL		0x3</span>
<span class="cm">/* LDT segment has TI set, GDT has it cleared */</span>
<span class="cp">#define SEGMENT_LDT		0x4</span>
<span class="cp">#define SEGMENT_GDT		0x0</span>

<span class="cm">/* Bottom two bits of selector give the ring privilege level */</span>
<span class="cp">#define SEGMENT_RPL_MASK	0x3</span>
<span class="cm">/* Bit 2 is table indicator (LDT/GDT) */</span>
<span class="cp">#define SEGMENT_TI_MASK		0x4</span>

<span class="cp">#define IDT_ENTRIES 256</span>
<span class="cp">#define NUM_EXCEPTION_VECTORS 32</span>
<span class="cm">/* Bitmask of exception vectors which push an error code on the stack */</span>
<span class="cp">#define EXCEPTION_ERRCODE_MASK  0x00027d00</span>
<span class="cp">#define GDT_SIZE (GDT_ENTRIES * 8)</span>
<span class="cp">#define GDT_ENTRY_TLS_ENTRIES 3</span>
<span class="cp">#define TLS_SIZE (GDT_ENTRY_TLS_ENTRIES * 8)</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">early_idt_handlers</span><span class="p">[</span><span class="n">NUM_EXCEPTION_VECTORS</span><span class="p">][</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">5</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Load a segment. Fall back on loading the zero</span>
<span class="cm"> * segment if something goes wrong..</span>
<span class="cm"> */</span>
<span class="cp">#define loadsegment(seg, value)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	unsigned short __val = (value);					\</span>
<span class="cp">									\</span>
<span class="cp">	asm volatile(&quot;						\n&quot;	\</span>
<span class="cp">		     &quot;1:	movl %k0,%%&quot; #seg &quot;		\n&quot;	\</span>
<span class="cp">									\</span>
<span class="cp">		     &quot;.section .fixup,\&quot;ax\&quot;			\n&quot;	\</span>
<span class="cp">		     &quot;2:	xorl %k0,%k0			\n&quot;	\</span>
<span class="cp">		     &quot;		jmp 1b				\n&quot;	\</span>
<span class="cp">		     &quot;.previous					\n&quot;	\</span>
<span class="cp">									\</span>
<span class="cp">		     _ASM_EXTABLE(1b, 2b)				\</span>
<span class="cp">									\</span>
<span class="cp">		     : &quot;+r&quot; (__val) : : &quot;memory&quot;);			\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Save a segment register away</span>
<span class="cm"> */</span>
<span class="cp">#define savesegment(seg, value)				\</span>
<span class="cp">	asm(&quot;mov %%&quot; #seg &quot;,%0&quot;:&quot;=r&quot; (value) : : &quot;memory&quot;)</span>

<span class="cm">/*</span>
<span class="cm"> * x86_32 user gs accessors.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cp">#ifdef CONFIG_X86_32_LAZY_GS</span>
<span class="cp">#define get_user_gs(regs)	(u16)({unsigned long v; savesegment(gs, v); v;})</span>
<span class="cp">#define set_user_gs(regs, v)	loadsegment(gs, (unsigned long)(v))</span>
<span class="cp">#define task_user_gs(tsk)	((tsk)-&gt;thread.gs)</span>
<span class="cp">#define lazy_save_gs(v)		savesegment(gs, (v))</span>
<span class="cp">#define lazy_load_gs(v)		loadsegment(gs, (v))</span>
<span class="cp">#else	</span><span class="cm">/* X86_32_LAZY_GS */</span><span class="cp"></span>
<span class="cp">#define get_user_gs(regs)	(u16)((regs)-&gt;gs)</span>
<span class="cp">#define set_user_gs(regs, v)	do { (regs)-&gt;gs = (v); } while (0)</span>
<span class="cp">#define task_user_gs(tsk)	(task_pt_regs(tsk)-&gt;gs)</span>
<span class="cp">#define lazy_save_gs(v)		do { } while (0)</span>
<span class="cp">#define lazy_load_gs(v)		do { } while (0)</span>
<span class="cp">#endif	</span><span class="cm">/* X86_32_LAZY_GS */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* X86_32 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_limit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">segment</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__limit</span><span class="p">;</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;lsll %1,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">__limit</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">segment</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">__limit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_X86_SEGMENT_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
