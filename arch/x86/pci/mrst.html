<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › pci › mrst.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mrst.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Moorestown PCI support</span>
<span class="cm"> *   Copyright (c) 2008 Intel Corporation</span>
<span class="cm"> *     Jesse Barnes &lt;jesse.barnes@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Moorestown has an interesting PCI implementation:</span>
<span class="cm"> *   - configuration space is memory mapped (as defined by MCFG)</span>
<span class="cm"> *   - Lincroft devices also have a real, type 1 configuration space</span>
<span class="cm"> *   - Early Lincroft silicon has a type 1 access bug that will cause</span>
<span class="cm"> *     a hang if non-existent devices are accessed</span>
<span class="cm"> *   - some devices have the &quot;fixed BAR&quot; capability, which means</span>
<span class="cm"> *     they can&#39;t be relocated or modified; check for that during</span>
<span class="cm"> *     BAR sizing</span>
<span class="cm"> *</span>
<span class="cm"> * So, we use the MCFG space for all reads and writes, but also send</span>
<span class="cm"> * Lincroft writes to type 1 space.  But only read/write if the device</span>
<span class="cm"> * actually exists, otherwise return all 1s for reads and bit bucket</span>
<span class="cm"> * the writes.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>

<span class="cp">#include &lt;asm/acpi.h&gt;</span>
<span class="cp">#include &lt;asm/segment.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/pci_x86.h&gt;</span>
<span class="cp">#include &lt;asm/hw_irq.h&gt;</span>
<span class="cp">#include &lt;asm/io_apic.h&gt;</span>

<span class="cp">#define PCIE_CAP_OFFSET	0x100</span>

<span class="cm">/* Fixed BAR fields */</span>
<span class="cp">#define PCIE_VNDR_CAP_ID_FIXED_BAR 0x00	</span><span class="cm">/* Fixed BAR (TBD) */</span><span class="cp"></span>
<span class="cp">#define PCI_FIXED_BAR_0_SIZE	0x04</span>
<span class="cp">#define PCI_FIXED_BAR_1_SIZE	0x08</span>
<span class="cp">#define PCI_FIXED_BAR_2_SIZE	0x0c</span>
<span class="cp">#define PCI_FIXED_BAR_3_SIZE	0x10</span>
<span class="cp">#define PCI_FIXED_BAR_4_SIZE	0x14</span>
<span class="cp">#define PCI_FIXED_BAR_5_SIZE	0x1c</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pci_soc_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * fixed_bar_cap - return the offset of the fixed BAR cap if found</span>
<span class="cm"> * @bus: PCI bus</span>
<span class="cm"> * @devfn: device in question</span>
<span class="cm"> *</span>
<span class="cm"> * Look for the fixed BAR cap on @bus and @devfn, returning its offset</span>
<span class="cm"> * if found or 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fixed_bar_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pcie_cap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cap_data</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">PCIE_CAP_OFFSET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw_pci_ext_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">raw_pci_ext_ops</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					  <span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcie_cap</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_EXT_CAP_ID</span><span class="p">(</span><span class="n">pcie_cap</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0000</span> <span class="o">||</span>
			<span class="n">PCI_EXT_CAP_ID</span><span class="p">(</span><span class="n">pcie_cap</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_EXT_CAP_ID</span><span class="p">(</span><span class="n">pcie_cap</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_EXT_CAP_ID_VNDR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raw_pci_ext_ops</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					      <span class="n">devfn</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cap_data</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCIE_VNDR_CAP_ID_FIXED_BAR</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">PCI_EXT_CAP_NEXT</span><span class="p">(</span><span class="n">pcie_cap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_device_update_fixed</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="n">busnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">-</span> <span class="n">PCI_BASE_ADDRESS_0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">domain</span> <span class="o">=</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">busnum</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">decode</span><span class="p">;</span>

		<span class="n">raw_pci_ext_ops</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">busnum</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
			       <span class="n">offset</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="p">(</span><span class="n">bar</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

		<span class="cm">/* Turn the size into a decode pattern for the sizing code */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">decode</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">decode</span> <span class="o">|=</span> <span class="n">decode</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">decode</span> <span class="o">|=</span> <span class="n">decode</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">decode</span> <span class="o">|=</span> <span class="n">decode</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">decode</span> <span class="o">|=</span> <span class="n">decode</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">decode</span> <span class="o">|=</span> <span class="n">decode</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">decode</span><span class="o">++</span><span class="p">;</span>
			<span class="n">decode</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">decode</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">decode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If val is all ones, the core code is trying to size the reg,</span>
<span class="cm">		 * so update the mmconfig space with the real size.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note: this assumes the fixed size we got is a power of two.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">raw_pci_ext_ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">busnum</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
				       <span class="n">decode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* This is some other kind of BAR write, so just do it. */</span>
	<span class="k">return</span> <span class="n">raw_pci_ext_ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">busnum</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * type1_access_ok - check whether to use type 1</span>
<span class="cm"> * @bus: bus number</span>
<span class="cm"> * @devfn: device &amp; function in question</span>
<span class="cm"> *</span>
<span class="cm"> * If the bus is on a Lincroft chip and it exists, or is not on a Lincroft at</span>
<span class="cm"> * all, the we can go ahead with any reads &amp; writes.  If it&#39;s on a Lincroft,</span>
<span class="cm"> * but doesn&#39;t exist, avoid the access altogether to keep the chip from</span>
<span class="cm"> * hanging.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">type1_access_ok</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is a workaround for A0 LNC bug where PCI status register does</span>
<span class="cm">	 * not have new CAP bit set. can not be written by SW either.</span>
<span class="cm">	 *</span>
<span class="cm">	 * PCI header type in real LNC indicates a single function device, this</span>
<span class="cm">	 * will prevent probing other devices under the same function in PCI</span>
<span class="cm">	 * shim. Therefore, use the header type in shim instead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;=</span> <span class="mh">0x100</span> <span class="o">||</span> <span class="n">reg</span> <span class="o">==</span> <span class="n">PCI_STATUS</span> <span class="o">||</span> <span class="n">reg</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">==</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="o">||</span> <span class="n">devfn</span> <span class="o">==</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="o">||</span> <span class="n">devfn</span> <span class="o">==</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* langwell on others */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type1_access_ok</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_direct_conf1</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					<span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">raw_pci_ext_ops</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
			      <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* On MRST, there is no PCI ROM BAR, this will cause a subsequent read</span>
<span class="cm">	 * to ROM BAR return 0 then being ignored.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">where</span> <span class="o">==</span> <span class="n">PCI_ROM_ADDRESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Devices with fixed BARs need special handling:</span>
<span class="cm">	 *   - BAR sizing code will save, write ~0, read size, restore</span>
<span class="cm">	 *   - so writes to fixed BARs need special handling</span>
<span class="cm">	 *   - other writes to fixed BAR devices should go through mmconfig</span>
<span class="cm">	 */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">fixed_bar_cap</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">where</span> <span class="o">&gt;=</span> <span class="n">PCI_BASE_ADDRESS_0</span> <span class="o">&amp;&amp;</span> <span class="n">where</span> <span class="o">&lt;=</span> <span class="n">PCI_BASE_ADDRESS_5</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">pci_device_update_fixed</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
					       <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * On Moorestown update both real &amp; mmconfig space</span>
<span class="cm">	 * Note: early Lincroft silicon can&#39;t handle type 1 accesses to</span>
<span class="cm">	 *       non-existent devices, so just eat the write in that case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type1_access_ok</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_direct_conf1</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
					      <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">raw_pci_ext_ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
			       <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mrst_pci_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">pin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="n">irq_attr</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_INTERRUPT_PIN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pin</span><span class="p">);</span>

	<span class="cm">/* MRST only have IOAPIC, the PCI irq lines are 1:1 mapped to</span>
<span class="cm">	 * IOAPIC RTE entries, so we just enable RTE for the device.</span>
<span class="cm">	 */</span>
	<span class="n">irq_attr</span><span class="p">.</span><span class="n">ioapic</span> <span class="o">=</span> <span class="n">mp_find_ioapic</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">irq_attr</span><span class="p">.</span><span class="n">ioapic_pin</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">irq_attr</span><span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* level */</span>
	<span class="n">irq_attr</span><span class="p">.</span><span class="n">polarity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* active low */</span>
	<span class="n">io_apic_set_pci_routing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_attr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">pci_mrst_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">pci_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">pci_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pci_mrst_init - installs pci_mrst_ops</span>
<span class="cm"> *</span>
<span class="cm"> * Moorestown has an interesting PCI implementation (see above).</span>
<span class="cm"> * Called when the early platform detection installs it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">pci_mrst_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Intel MID platform detected, using MID PCI ops</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pci_mmcfg_late_init</span><span class="p">();</span>
	<span class="n">pcibios_enable_irq</span> <span class="o">=</span> <span class="n">mrst_pci_irq_enable</span><span class="p">;</span>
	<span class="n">pci_root_ops</span> <span class="o">=</span> <span class="n">pci_mrst_ops</span><span class="p">;</span>
	<span class="n">pci_soc_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Continue with standard init */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Langwell devices are not true pci devices, they are not subject to 10 ms</span>
<span class="cm"> * d3 to d0 delay required by pci spec.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_d3delay_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* PCI fixups are effectively decided compile time. If we have a dual</span>
<span class="cm">	   SoC/non-SoC kernel we don&#39;t want to mangle d3 on non SoC devices */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_soc_mode</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
	<span class="cm">/* true pci devices in lincroft should allow type 1 access, the rest</span>
<span class="cm">	 * are langwell fake pci devices.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type1_access_ok</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">d3_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">pci_d3delay_fixup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">mrst_power_off_unused_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D3cold</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x0801</span><span class="p">,</span> <span class="n">mrst_power_off_unused_dev</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x0809</span><span class="p">,</span> <span class="n">mrst_power_off_unused_dev</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x080C</span><span class="p">,</span> <span class="n">mrst_power_off_unused_dev</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x0812</span><span class="p">,</span> <span class="n">mrst_power_off_unused_dev</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x0815</span><span class="p">,</span> <span class="n">mrst_power_off_unused_dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Langwell devices reside at fixed offsets, don&#39;t try to move them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_fixed_bar_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_soc_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Must have extended configuration space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_size</span> <span class="o">&lt;</span> <span class="n">PCIE_CAP_OFFSET</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Fixup the BAR sizes for fixed BAR devices and make them unmoveable */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">fixed_bar_cap</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset</span> <span class="o">||</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">||</span>
	    <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCI_ROM_RESOURCE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IORESOURCE_PCI_FIXED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">pci_fixed_bar_fixup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
