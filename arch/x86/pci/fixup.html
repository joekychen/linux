<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › pci › fixup.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fixup.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Exceptions for specific devices. Usually work-arounds for fatal design flaws.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/vgaarb.h&gt;</span>
<span class="cp">#include &lt;asm/pci_x86.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_fixup_i450nx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * i450NX -- Find and scan all secondary buses on all PXB&#39;s.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">pxb</span><span class="p">,</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">busno</span><span class="p">,</span> <span class="n">suba</span><span class="p">,</span> <span class="n">subb</span><span class="p">;</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Searching for i450NX host bridges</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="mh">0xd0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">pxb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pxb</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">pxb</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">reg</span><span class="o">++</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">busno</span><span class="p">);</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">reg</span><span class="o">++</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">suba</span><span class="p">);</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">reg</span><span class="o">++</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subb</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;i450NX PXB %d: %02x/%02x/%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pxb</span><span class="p">,</span> <span class="n">busno</span><span class="p">,</span>
			<span class="n">suba</span><span class="p">,</span> <span class="n">subb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">busno</span><span class="p">)</span>
			<span class="n">pci_scan_bus_with_sysdata</span><span class="p">(</span><span class="n">busno</span><span class="p">);</span>	<span class="cm">/* Bus A */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">suba</span> <span class="o">&lt;</span> <span class="n">subb</span><span class="p">)</span>
			<span class="n">pci_scan_bus_with_sysdata</span><span class="p">(</span><span class="n">suba</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* Bus B */</span>
	<span class="p">}</span>
	<span class="n">pcibios_last_bus</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82451NX</span><span class="p">,</span> <span class="n">pci_fixup_i450nx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_fixup_i450gx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * i450GX and i450KX -- Find and scan all secondary buses.</span>
<span class="cm">	 * (called separately for each PCI bridge found)</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">busno</span><span class="p">;</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mh">0x4a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">busno</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;i440KX/GX host bridge; secondary bus %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">busno</span><span class="p">);</span>
	<span class="n">pci_scan_bus_with_sysdata</span><span class="p">(</span><span class="n">busno</span><span class="p">);</span>
	<span class="n">pcibios_last_bus</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82454GX</span><span class="p">,</span> <span class="n">pci_fixup_i450gx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span>  <span class="nf">pci_fixup_umc_ide</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * UM8886BF IDE controller sets region type bits incorrectly,</span>
<span class="cm">	 * therefore they look like memory despite of them being I/O.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Fixing base address flags</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PCI_BASE_ADDRESS_SPACE_IO</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_UMC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_UMC_UM8886BF</span><span class="p">,</span> <span class="n">pci_fixup_umc_ide</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span>  <span class="nf">pci_fixup_ncr53c810</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * NCR 53C810 returns class code 0 (at least on some systems).</span>
<span class="cm">	 * Fix class to be PCI_CLASS_STORAGE_SCSI</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Fixing NCR 53C810 class code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_STORAGE_SCSI</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NCR</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C810</span><span class="p">,</span> <span class="n">pci_fixup_ncr53c810</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span>  <span class="nf">pci_fixup_latency</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  SiS 5597 and 5598 chipsets require latency timer set to</span>
<span class="cm">	 *  at most 32 to avoid lockups.</span>
<span class="cm">	 */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Setting max latency to 32</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pcibios_max_latency</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SI_5597</span><span class="p">,</span> <span class="n">pci_fixup_latency</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SI_5598</span><span class="p">,</span> <span class="n">pci_fixup_latency</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_fixup_piix4_acpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * PIIX4 ACPI device: hardwired IRQ9</span>
<span class="cm">	 */</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82371AB_3</span><span class="p">,</span> <span class="n">pci_fixup_piix4_acpi</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Addresses issues with problems in the memory write queue timer in</span>
<span class="cm"> * certain VIA Northbridges.  This bugfix is per VIA&#39;s specifications,</span>
<span class="cm"> * except for the KL133/KM133: clearing bit 5 on those Northbridges seems</span>
<span class="cm"> * to trigger a bug in its integrated ProSavage video card, which</span>
<span class="cm"> * causes screen corruption.  We only clear bits 6 and 7 for that chipset,</span>
<span class="cm"> * until VIA can provide us with definitive information on why screen</span>
<span class="cm"> * corruption occurs, and what exactly those bits do.</span>
<span class="cm"> *</span>
<span class="cm"> * VIA 8363,8622,8361 Northbridges:</span>
<span class="cm"> *  - bits  5, 6, 7 at offset 0x55 need to be turned off</span>
<span class="cm"> * VIA 8367 (KT266x) Northbridges:</span>
<span class="cm"> *  - bits  5, 6, 7 at offset 0x95 need to be turned off</span>
<span class="cm"> * VIA 8363 rev 0x81/0x84 (KL133/KM133) Northbridges:</span>
<span class="cm"> *  - bits     6, 7 at offset 0x55 need to be turned off</span>
<span class="cm"> */</span>

<span class="cp">#define VIA_8363_KL133_REVISION_ID 0x81</span>
<span class="cp">#define VIA_8363_KM133_REVISION_ID 0x84</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_fixup_via_northbridge_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">where</span> <span class="o">=</span> <span class="mh">0x55</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span> <span class="cm">/* clear bits 5, 6, 7 by default */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_VIA_8367_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* fix pci bus latency issues resulted by NB bios error</span>
<span class="cm">		   it appears on bug free^Wreduced kt266x&#39;s bios forces</span>
<span class="cm">		   NB latency to zero */</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">where</span> <span class="o">=</span> <span class="mh">0x95</span><span class="p">;</span> <span class="cm">/* the memory write queue timer register is</span>
<span class="cm">				different for the KT266x&#39;s: 0x95 not 0x55 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_VIA_8363_0</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="n">VIA_8363_KL133_REVISION_ID</span> <span class="o">||</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="n">VIA_8363_KM133_REVISION_ID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x3f</span><span class="p">;</span> <span class="cm">/* clear only bits 6 and 7; clearing bit 5</span>
<span class="cm">					causes screen corruption on the KL133/KM133 */</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Disabling VIA memory write queue (PCI ID %04x, rev %02x): [%02x] %02x &amp; %02x -&gt; %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> \
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">v</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">v</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8363_0</span><span class="p">,</span> <span class="n">pci_fixup_via_northbridge_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8622</span><span class="p">,</span> <span class="n">pci_fixup_via_northbridge_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8361</span><span class="p">,</span> <span class="n">pci_fixup_via_northbridge_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8367_0</span><span class="p">,</span> <span class="n">pci_fixup_via_northbridge_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8363_0</span><span class="p">,</span> <span class="n">pci_fixup_via_northbridge_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8622</span><span class="p">,</span> <span class="n">pci_fixup_via_northbridge_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8361</span><span class="p">,</span> <span class="n">pci_fixup_via_northbridge_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8367_0</span><span class="p">,</span> <span class="n">pci_fixup_via_northbridge_bug</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * For some reasons Intel decided that certain parts of their</span>
<span class="cm"> * 815, 845 and some other chipsets must look like PCI-to-PCI bridges</span>
<span class="cm"> * while they are obviously not. The 82801 family (AA, AB, BAM/CAM,</span>
<span class="cm"> * BA/CA/DB and E) PCI bridges are actually HUB-to-PCI ones, according</span>
<span class="cm"> * to Intel terminology. These devices do forward all addresses from</span>
<span class="cm"> * system to PCI bus no matter what are their window settings, so they are</span>
<span class="cm"> * &quot;transparent&quot; (or subtractive decoding) from programmers point of view.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_fixup_transparent_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x2400</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transparent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
			 <span class="n">PCI_CLASS_BRIDGE_PCI</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">pci_fixup_transparent_bridge</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Fixup for C1 Halt Disconnect problem on nForce2 systems.</span>
<span class="cm"> *</span>
<span class="cm"> * From information provided by &quot;Allen Martin&quot; &lt;AMartin@nvidia.com&gt;:</span>
<span class="cm"> *</span>
<span class="cm"> * A hang is caused when the CPU generates a very fast CONNECT/HALT cycle</span>
<span class="cm"> * sequence.  Workaround is to set the SYSTEM_IDLE_TIMEOUT to 80 ns.</span>
<span class="cm"> * This allows the state-machine and timer to return to a proper state within</span>
<span class="cm"> * 80 ns of the CONNECT and probe appearing together.  Since the CPU will not</span>
<span class="cm"> * issue another HALT within 80 ns of the initial HALT, the failure condition</span>
<span class="cm"> * is avoided.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_fixup_nforce2</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Chip  Old value   New value</span>
<span class="cm">	 * C17   0x1F0FFF01  0x1F01FF01</span>
<span class="cm">	 * C18D  0x9F0FFF01  0x9F01FF01</span>
<span class="cm">	 *</span>
<span class="cm">	 * Northbridge chip version may be determined by</span>
<span class="cm">	 * reading the PCI revision ID (0xC1 or greater is C18D).</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Apply fixup if needed, but don&#39;t touch disconnect state</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x00FF0000</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x00010000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;nForce2 C1 Halt Disconnect fixup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xFF00FFFF</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x00010000</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NVIDIA_NFORCE2</span><span class="p">,</span> <span class="n">pci_fixup_nforce2</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NVIDIA_NFORCE2</span><span class="p">,</span> <span class="n">pci_fixup_nforce2</span><span class="p">);</span>

<span class="cm">/* Max PCI Express root ports */</span>
<span class="cp">#define MAX_PCIEROOT	6</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">quirk_aspm_offset</span><span class="p">[</span><span class="n">MAX_PCIEROOT</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">];</span>

<span class="cp">#define GET_INDEX(a, b) ((((a) - PCI_DEVICE_ID_INTEL_MCH_PA) &lt;&lt; 3) + ((b) &amp; 7))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">quirk_pcie_aspm_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_pci_read</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
						<span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Replace the original pci bus ops for write with a new one that will filter</span>
<span class="cm"> * the request to insure ASPM cannot be enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">quirk_pcie_aspm_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">quirk_aspm_offset</span><span class="p">[</span><span class="n">GET_INDEX</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">devfn</span><span class="p">)];</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">where</span> <span class="o">==</span> <span class="n">offset</span><span class="p">))</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xfffffffc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">raw_pci_write</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
						<span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">quirk_pcie_aspm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">quirk_pcie_aspm_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">quirk_pcie_aspm_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Prevents PCI Express ASPM (Active State Power Management) being enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Save the register offset, where the ASPM control bits are located,</span>
<span class="cm"> * for each PCI Express device that is in the device list of</span>
<span class="cm"> * the root port in an array for fast indexing. Replace the bus ops</span>
<span class="cm"> * with the modified one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcie_rootport_aspm_quirk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cap_base</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span>  <span class="o">*</span><span class="n">pbus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pbus</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the DID of pdev matches one of the six root ports. This</span>
<span class="cm">	 * check is needed in the case this function is called directly by the</span>
<span class="cm">	 * hot-plug driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&lt;</span> <span class="n">PCI_DEVICE_ID_INTEL_MCH_PA</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&gt;</span> <span class="n">PCI_DEVICE_ID_INTEL_MCH_PC1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbus</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If no device is attached to the root port at power-up or</span>
<span class="cm">		 * after hot-remove, the pbus-&gt;devices is empty and this code</span>
<span class="cm">		 * will set the offsets to zero and the bus ops to parent&#39;s bus</span>
<span class="cm">		 * ops, which is unmodified.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">GET_INDEX</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">GET_INDEX</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">quirk_aspm_offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">pbus</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">pbus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If devices are attached to the root port at power-up or</span>
<span class="cm">		 * after hot-add, the code loops through the device list of</span>
<span class="cm">		 * each root port to save the register offsets and replace the</span>
<span class="cm">		 * bus ops.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbus</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">bus_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* There are 0 to 8 devices attached to this bus */</span>
			<span class="n">cap_base</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">);</span>
			<span class="n">quirk_aspm_offset</span><span class="p">[</span><span class="n">GET_INDEX</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cap_base</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pbus</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">quirk_pcie_aspm_ops</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_MCH_PA</span><span class="p">,</span>	<span class="n">pcie_rootport_aspm_quirk</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_MCH_PA1</span><span class="p">,</span>	<span class="n">pcie_rootport_aspm_quirk</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_MCH_PB</span><span class="p">,</span>	<span class="n">pcie_rootport_aspm_quirk</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_MCH_PB1</span><span class="p">,</span>	<span class="n">pcie_rootport_aspm_quirk</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_MCH_PC</span><span class="p">,</span>	<span class="n">pcie_rootport_aspm_quirk</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_MCH_PC1</span><span class="p">,</span>	<span class="n">pcie_rootport_aspm_quirk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Fixup to mark boot BIOS video selected by BIOS before it changes</span>
<span class="cm"> *</span>
<span class="cm"> * From information provided by &quot;Jon Smirl&quot; &lt;jonsmirl@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * The standard boot ROM sequence for an x86 machine uses the BIOS</span>
<span class="cm"> * to select an initial video card for boot display. This boot video</span>
<span class="cm"> * card will have it&#39;s BIOS copied to C0000 in system RAM.</span>
<span class="cm"> * IORESOURCE_ROM_SHADOW is used to associate the boot video</span>
<span class="cm"> * card with this copy. On laptops this copy has to be used since</span>
<span class="cm"> * the main ROM may be compressed or combined with another image.</span>
<span class="cm"> * See pci_map_rom() for use of this flag. IORESOURCE_ROM_SHADOW</span>
<span class="cm"> * is marked here since the boot video device will be the only enabled</span>
<span class="cm"> * video device at this point.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_fixup_video</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">config</span><span class="p">;</span>

	<span class="cm">/* Is VGA routed to us? */</span>
	<span class="n">bus</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bridge</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * From information provided by</span>
<span class="cm">		 * &quot;David Miller&quot; &lt;davem@davemloft.net&gt;</span>
<span class="cm">		 * The bridge control register is valid for PCI header</span>
<span class="cm">		 * type BRIDGE, or CARDBUS. Host to PCI controllers use</span>
<span class="cm">		 * PCI header type NORMAL.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bridge</span>
		    <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">bridge</span><span class="o">-&gt;</span><span class="n">hdr_type</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_BRIDGE</span><span class="p">)</span>
		       <span class="o">||</span> <span class="p">(</span><span class="n">bridge</span><span class="o">-&gt;</span><span class="n">hdr_type</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_CARDBUS</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">PCI_BRIDGE_CTL_VGA</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI_COMMAND_IO</span> <span class="o">|</span> <span class="n">PCI_COMMAND_MEMORY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">PCI_ROM_RESOURCE</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IORESOURCE_ROM_SHADOW</span><span class="p">;</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Boot video device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vga_default_device</span><span class="p">())</span>
			<span class="n">vga_set_default_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_FINAL</span><span class="p">(</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
				<span class="n">PCI_CLASS_DISPLAY_VGA</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">pci_fixup_video</span><span class="p">);</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="n">__devinitconst</span> <span class="n">msi_k8t_dmi_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="s">&quot;MSI-K8T-Neo2Fir&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;MSI&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;MS-6702E&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The AMD-Athlon64 board MSI &quot;K8T Neo2-FIR&quot; disables the onboard sound</span>
<span class="cm"> * card if a PCI-soundcard is added.</span>
<span class="cm"> *</span>
<span class="cm"> * The BIOS only gives options &quot;DISABLED&quot; and &quot;AUTO&quot;. This code sets</span>
<span class="cm"> * the corresponding register-value to enable the soundcard.</span>
<span class="cm"> *</span>
<span class="cm"> * The soundcard is only enabled, if the mainborad is identified</span>
<span class="cm"> * via DMI-tables and the soundcard is detected to be off.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_fixup_msi_k8t_onboard_sound</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmi_check_system</span><span class="p">(</span><span class="n">msi_k8t_dmi_table</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* only applies to MSI K8T Neo2-FIR */</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x40</span><span class="p">));</span>

		<span class="cm">/* verify the change for status output */</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Detected MSI K8T Neo2-FIR; &quot;</span>
					<span class="s">&quot;can&#39;t enable onboard soundcard!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Detected MSI K8T Neo2-FIR; &quot;</span>
					<span class="s">&quot;enabled onboard soundcard</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8237</span><span class="p">,</span>
		<span class="n">pci_fixup_msi_k8t_onboard_sound</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8237</span><span class="p">,</span>
		<span class="n">pci_fixup_msi_k8t_onboard_sound</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Some Toshiba laptops need extra code to enable their TI TSB43AB22/A.</span>
<span class="cm"> *</span>
<span class="cm"> * We pretend to bring them out of full D3 state, and restore the proper</span>
<span class="cm"> * IRQ, PCI cache line size, and BARs, otherwise the device won&#39;t function</span>
<span class="cm"> * properly.  In some cases, the device will generate an interrupt on</span>
<span class="cm"> * the wrong IRQ line, causing any devices sharing the line it&#39;s</span>
<span class="cm"> * *supposed* to use to be disabled by the kernel&#39;s IRQ debug code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">toshiba_line_size</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="n">__devinitconst</span> <span class="n">toshiba_ohci1394_dmi_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="s">&quot;Toshiba PS5 based laptop&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;TOSHIBA&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_VERSION</span><span class="p">,</span> <span class="s">&quot;PS5&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="s">&quot;Toshiba PSM4 based laptop&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;TOSHIBA&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_VERSION</span><span class="p">,</span> <span class="s">&quot;PSM4&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="s">&quot;Toshiba A40 based laptop&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;TOSHIBA&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_VERSION</span><span class="p">,</span> <span class="s">&quot;PSA40U&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_pre_fixup_toshiba_ohci1394</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmi_check_system</span><span class="p">(</span><span class="n">toshiba_ohci1394_dmi_table</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* only applies to certain Toshibas (so far) */</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">=</span> <span class="n">PCI_D3cold</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">toshiba_line_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_TI</span><span class="p">,</span> <span class="mh">0x8032</span><span class="p">,</span>
			 <span class="n">pci_pre_fixup_toshiba_ohci1394</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_post_fixup_toshiba_ohci1394</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmi_check_system</span><span class="p">(</span><span class="n">toshiba_ohci1394_dmi_table</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* only applies to certain Toshibas (so far) */</span>

	<span class="cm">/* Restore config space on Toshiba laptops */</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="n">toshiba_line_size</span><span class="p">);</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_INTERRUPT_LINE</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_BASE_ADDRESS_0</span><span class="p">,</span>
			       <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_BASE_ADDRESS_1</span><span class="p">,</span>
			       <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_ENABLE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_TI</span><span class="p">,</span> <span class="mh">0x8032</span><span class="p">,</span>
			 <span class="n">pci_post_fixup_toshiba_ohci1394</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Prevent the BIOS trapping accesses to the Cyrix CS5530A video device</span>
<span class="cm"> * configuration space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_early_fixup_cyrix_5530</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">r</span><span class="p">;</span>
	<span class="cm">/* clear &#39;F4 Video Configuration Trap&#39; bit */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">&amp;=</span> <span class="mh">0xfd</span><span class="p">;</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CYRIX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CYRIX_5530_LEGACY</span><span class="p">,</span>
			<span class="n">pci_early_fixup_cyrix_5530</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CYRIX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_CYRIX_5530_LEGACY</span><span class="p">,</span>
			<span class="n">pci_early_fixup_cyrix_5530</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Siemens Nixdorf AG FSC Multiprocessor Interrupt Controller:</span>
<span class="cm"> * prevent update of the BAR0, which doesn&#39;t look like a normal BAR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pci_siemens_interrupt_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IORESOURCE_PCI_FIXED</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SIEMENS</span><span class="p">,</span> <span class="mh">0x0015</span><span class="p">,</span>
			  <span class="n">pci_siemens_interrupt_controller</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SB600: Disable BAR1 on device 14.0 to avoid HPET resources from</span>
<span class="cm"> * confusing the PCI engine:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sb600_disable_hpet_bar</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The SB600 and SB700 both share the same device</span>
<span class="cm">	 * ID, but the PM register 0x55 does something different</span>
<span class="cm">	 * for the SB700, so make sure we are dealing with the</span>
<span class="cm">	 * SB600 before touching the bit:</span>
<span class="cm">	 */</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mh">0x2F</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="mh">0xCD6</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0xCD7</span><span class="p">);</span>

		<span class="cm">/* Set bit 7 in PM register 0x55 */</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="mh">0xCD6</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">val</span> <span class="o">|</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0xCD7</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4385</span><span class="p">,</span> <span class="n">sb600_disable_hpet_bar</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Twinhead H12Y needs us to block out a region otherwise we map devices</span>
<span class="cm"> * there and any access kills the box.</span>
<span class="cm"> *</span>
<span class="cm"> *   See: https://bugzilla.kernel.org/show_bug.cgi?id=10231</span>
<span class="cm"> *</span>
<span class="cm"> * Match off the LPC and svid/sdid (older kernels lose the bridge subvendor)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">twinhead_reserve_killing_zone</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="mh">0x14FF</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">==</span> <span class="mh">0xA003</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Reserving memory on Twinhead H12Y</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="n">request_mem_region</span><span class="p">(</span><span class="mh">0xFFB00000</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="s">&quot;twinhead&quot;</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x27B9</span><span class="p">,</span> <span class="n">twinhead_reserve_killing_zone</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
