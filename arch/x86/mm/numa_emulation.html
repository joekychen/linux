<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › mm › numa_emulation.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>numa_emulation.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NUMA emulation</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/topology.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>

<span class="cp">#include &quot;numa_internal.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">]</span> <span class="n">__cpuinitdata</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">emu_cmdline</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">numa_emu_cmdline</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">emu_cmdline</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">emu_find_memblk_by_nid</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">__init</span> <span class="nf">mem_hole_size</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">absent_pages_in_range</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sets up nid to range from @start to @end.  The return value is -errno if</span>
<span class="cm"> * something went wrong, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">emu_setup_memblk</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">ei</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phys_blk</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">numa_memblk</span> <span class="o">*</span><span class="n">eb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">numa_memblk</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">phys_blk</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">nr_blks</span> <span class="o">&gt;=</span> <span class="n">NR_NODE_MEMBLKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;NUMA: Too many emulated memblks, failing emulation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="o">++</span><span class="p">;</span>
	<span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">eb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">eb</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">pb</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pb</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">pb</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
		<span class="n">numa_remove_memblk_from</span><span class="p">(</span><span class="n">phys_blk</span><span class="p">,</span> <span class="n">pi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Faking node %d at [mem %#018Lx-%#018Lx] (%LuMB)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">nid</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">eb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sets up nr_nodes fake nodes interleaved over physical nodes ranging from addr</span>
<span class="cm"> * to max_addr.  The return value is the number of nodes allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">split_nodes_interleave</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">ei</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span>
					 <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">max_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_nodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">physnode_mask</span> <span class="o">=</span> <span class="n">NODE_MASK_NONE</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">big</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_nodes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_nodes</span> <span class="o">&gt;</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;numa=fake=%d too large, reducing to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">nr_nodes</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
		<span class="n">nr_nodes</span> <span class="o">=</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate target node size.  x86_32 freaks on __udivdi3() so do</span>
<span class="cm">	 * the division in ulong number of pages and convert back.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">max_addr</span> <span class="o">-</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">mem_hole_size</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">/</span> <span class="n">nr_nodes</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the number of big nodes that can be allocated as a result</span>
<span class="cm">	 * of consolidating the remainder.</span>
<span class="cm">	 */</span>
	<span class="n">big</span> <span class="o">=</span> <span class="p">((</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FAKE_NODE_MIN_HASH_MASK</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_nodes</span><span class="p">)</span> <span class="o">/</span>
		<span class="n">FAKE_NODE_MIN_SIZE</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">&amp;=</span> <span class="n">FAKE_NODE_MIN_HASH_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Not enough memory for each node.  &quot;</span>
			<span class="s">&quot;NUMA emulation disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">node_set</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">,</span> <span class="n">physnode_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Continue to fill physical nodes with fake nodes until there is no</span>
<span class="cm">	 * memory left on any of them.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nodes_weight</span><span class="p">(</span><span class="n">physnode_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">physnode_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">dma32_end</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">MAX_DMA32_PFN</span><span class="p">);</span>
			<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">phys_blk</span><span class="p">;</span>

			<span class="n">phys_blk</span> <span class="o">=</span> <span class="n">emu_find_memblk_by_nid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phys_blk</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">node_clear</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">physnode_mask</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">phys_blk</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">phys_blk</span><span class="p">].</span><span class="n">end</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="n">big</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">+=</span> <span class="n">FAKE_NODE_MIN_SIZE</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Continue to add memory to this fake node if its</span>
<span class="cm">			 * non-reserved memory is less than the per-node size.</span>
<span class="cm">			 */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">-</span> <span class="n">mem_hole_size</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">end</span> <span class="o">+=</span> <span class="n">FAKE_NODE_MIN_SIZE</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">end</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * If there won&#39;t be at least FAKE_NODE_MIN_SIZE of</span>
<span class="cm">			 * non-reserved memory in ZONE_DMA32 for the next node,</span>
<span class="cm">			 * this one must extend to the boundary.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">dma32_end</span> <span class="o">&amp;&amp;</span> <span class="n">dma32_end</span> <span class="o">-</span> <span class="n">end</span> <span class="o">-</span>
			    <span class="n">mem_hole_size</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">dma32_end</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">FAKE_NODE_MIN_SIZE</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">dma32_end</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If there won&#39;t be enough non-reserved memory for the</span>
<span class="cm">			 * next node, this one must extend to the end of the</span>
<span class="cm">			 * physical node.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">end</span> <span class="o">-</span> <span class="n">mem_hole_size</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">emu_setup_memblk</span><span class="p">(</span><span class="n">ei</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">nid</span><span class="o">++</span> <span class="o">%</span> <span class="n">nr_nodes</span><span class="p">,</span>
					       <span class="n">phys_blk</span><span class="p">,</span>
					       <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns the end address of a node so that there is at least `size&#39; amount of</span>
<span class="cm"> * non-reserved memory or `max_addr&#39; is reached.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">__init</span> <span class="nf">find_end_of_node</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">max_addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">-</span> <span class="n">mem_hole_size</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end</span> <span class="o">+=</span> <span class="n">FAKE_NODE_MIN_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">max_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">max_addr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sets up fake nodes of `size&#39; interleaved over physical nodes ranging from</span>
<span class="cm"> * `addr&#39; to `max_addr&#39;.  The return value is the number of nodes allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">split_nodes_size_interleave</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">ei</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span>
					      <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">max_addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">physnode_mask</span> <span class="o">=</span> <span class="n">NODE_MASK_NONE</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">min_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The limit on emulated nodes is MAX_NUMNODES, so the size per node is</span>
<span class="cm">	 * increased accordingly if the requested size is too small.  This</span>
<span class="cm">	 * creates a uniform distribution of node sizes across the entire</span>
<span class="cm">	 * machine (but not necessarily over physical nodes).</span>
<span class="cm">	 */</span>
	<span class="n">min_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_addr</span> <span class="o">-</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">mem_hole_size</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">))</span> <span class="o">/</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span>
	<span class="n">min_size</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_size</span><span class="p">,</span> <span class="n">FAKE_NODE_MIN_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">min_size</span> <span class="o">&amp;</span> <span class="n">FAKE_NODE_MIN_HASH_MASK</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_size</span><span class="p">)</span>
		<span class="n">min_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_size</span> <span class="o">+</span> <span class="n">FAKE_NODE_MIN_SIZE</span><span class="p">)</span> <span class="o">&amp;</span>
						<span class="n">FAKE_NODE_MIN_HASH_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">min_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Fake node size %LuMB too small, increasing to %LuMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="n">min_size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">min_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">size</span> <span class="o">&amp;=</span> <span class="n">FAKE_NODE_MIN_HASH_MASK</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">node_set</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">,</span> <span class="n">physnode_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill physical nodes with fake nodes of size until there is no memory</span>
<span class="cm">	 * left on any of them.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nodes_weight</span><span class="p">(</span><span class="n">physnode_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">physnode_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">dma32_end</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">MAX_DMA32_PFN</span><span class="p">);</span>
			<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">phys_blk</span><span class="p">;</span>

			<span class="n">phys_blk</span> <span class="o">=</span> <span class="n">emu_find_memblk_by_nid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phys_blk</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">node_clear</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">physnode_mask</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">phys_blk</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">phys_blk</span><span class="p">].</span><span class="n">end</span><span class="p">;</span>

			<span class="n">end</span> <span class="o">=</span> <span class="n">find_end_of_node</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If there won&#39;t be at least FAKE_NODE_MIN_SIZE of</span>
<span class="cm">			 * non-reserved memory in ZONE_DMA32 for the next node,</span>
<span class="cm">			 * this one must extend to the boundary.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">dma32_end</span> <span class="o">&amp;&amp;</span> <span class="n">dma32_end</span> <span class="o">-</span> <span class="n">end</span> <span class="o">-</span>
			    <span class="n">mem_hole_size</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">dma32_end</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">FAKE_NODE_MIN_SIZE</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">dma32_end</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If there won&#39;t be enough non-reserved memory for the</span>
<span class="cm">			 * next node, this one must extend to the end of the</span>
<span class="cm">			 * physical node.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">end</span> <span class="o">-</span> <span class="n">mem_hole_size</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">emu_setup_memblk</span><span class="p">(</span><span class="n">ei</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">nid</span><span class="o">++</span> <span class="o">%</span> <span class="n">MAX_NUMNODES</span><span class="p">,</span>
					       <span class="n">phys_blk</span><span class="p">,</span>
					       <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * numa_emulation - Emulate NUMA nodes</span>
<span class="cm"> * @numa_meminfo: NUMA configuration to massage</span>
<span class="cm"> * @numa_dist_cnt: The size of the physical NUMA distance table</span>
<span class="cm"> *</span>
<span class="cm"> * Emulate NUMA nodes according to the numa=fake kernel parameter.</span>
<span class="cm"> * @numa_meminfo contains the physical memory configuration and is modified</span>
<span class="cm"> * to reflect the emulated configuration on success.  @numa_dist_cnt is</span>
<span class="cm"> * used to determine the size of the physical distance table.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, the following modifications are made.</span>
<span class="cm"> *</span>
<span class="cm"> * - @numa_meminfo is updated to reflect the emulated nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * - __apicid_to_node[] is updated such that APIC IDs are mapped to the</span>
<span class="cm"> *   emulated nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * - NUMA distance table is rebuilt to represent distances between emulated</span>
<span class="cm"> *   nodes.  The distances are determined considering how emulated nodes</span>
<span class="cm"> *   are mapped to physical nodes and match the actual distances.</span>
<span class="cm"> *</span>
<span class="cm"> * - emu_nid_to_phys[] reflects how emulated nodes are mapped to physical</span>
<span class="cm"> *   nodes.  This is used by numa_add_cpu() and numa_remove_cpu().</span>
<span class="cm"> *</span>
<span class="cm"> * If emulation is not enabled or fails, emu_nid_to_phys[] is filled with</span>
<span class="cm"> * identity mapping and no other modification is made.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">numa_emulation</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">numa_meminfo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numa_dist_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="n">ei</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="n">pi</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u64</span> <span class="n">max_addr</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">max_pfn</span><span class="p">);</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">phys_dist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">phys_size</span> <span class="o">=</span> <span class="n">numa_dist_cnt</span> <span class="o">*</span> <span class="n">numa_dist_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phys_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="n">max_emu_nid</span><span class="p">,</span> <span class="n">dfl_phys_nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emu_cmdline</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_emu</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ei</span><span class="p">));</span>
	<span class="n">pi</span> <span class="o">=</span> <span class="o">*</span><span class="n">numa_meminfo</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the numa=fake command-line contains a &#39;M&#39; or &#39;G&#39;, it represents</span>
<span class="cm">	 * the fixed node size.  Otherwise, if it is just a single number N,</span>
<span class="cm">	 * split the system RAM into N fake nodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">emu_cmdline</span><span class="p">,</span> <span class="sc">&#39;M&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">strchr</span><span class="p">(</span><span class="n">emu_cmdline</span><span class="p">,</span> <span class="sc">&#39;G&#39;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">emu_cmdline</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emu_cmdline</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">split_nodes_size_interleave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">emu_cmdline</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emu_cmdline</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">split_nodes_interleave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">emu_cmdline</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
		<span class="n">emu_cmdline</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_emu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numa_cleanup_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;NUMA: Warning: constructed meminfo invalid, disabling emulation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_emu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* copy the physical distance table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numa_dist_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">phys</span><span class="p">;</span>

		<span class="n">phys</span> <span class="o">=</span> <span class="n">memblock_find_in_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">max_pfn_mapped</span><span class="p">),</span>
					      <span class="n">phys_size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;NUMA: Warning: can&#39;t allocate copy of distance table, disabling emulation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_emu</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_size</span><span class="p">);</span>
		<span class="n">phys_dist</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">phys</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numa_dist_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numa_dist_cnt</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">phys_dist</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">numa_dist_cnt</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">node_distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine the max emulated nid and the default phys nid to use</span>
<span class="cm">	 * for unmapped nodes.</span>
<span class="cm">	 */</span>
	<span class="n">max_emu_nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dfl_phys_nid</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">max_emu_nid</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dfl_phys_nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
				<span class="n">dfl_phys_nid</span> <span class="o">=</span> <span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfl_phys_nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;NUMA: Warning: can&#39;t determine default physical node, disabling emulation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_emu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* commit */</span>
	<span class="o">*</span><span class="n">numa_meminfo</span> <span class="o">=</span> <span class="n">ei</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transform __apicid_to_node table to use emulated nids by</span>
<span class="cm">	 * reverse-mapping phys_nid.  The maps should always exist but fall</span>
<span class="cm">	 * back to zero just in case.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">__apicid_to_node</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__apicid_to_node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__apicid_to_node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="n">__apicid_to_node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">)</span> <span class="o">?</span> <span class="n">j</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* make sure all emulated nodes are mapped to a physical node */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
			<span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfl_phys_nid</span><span class="p">;</span>

	<span class="cm">/* transform distance table */</span>
	<span class="n">numa_reset_distance</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_emu_nid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">max_emu_nid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">physi</span> <span class="o">=</span> <span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="kt">int</span> <span class="n">physj</span> <span class="o">=</span> <span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="kt">int</span> <span class="n">dist</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">emu_cmdline</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
				<span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">physi</span> <span class="o">&gt;=</span> <span class="n">numa_dist_cnt</span> <span class="o">||</span> <span class="n">physj</span> <span class="o">&gt;=</span> <span class="n">numa_dist_cnt</span><span class="p">)</span>
				<span class="n">dist</span> <span class="o">=</span> <span class="n">physi</span> <span class="o">==</span> <span class="n">physj</span> <span class="o">?</span>
					<span class="n">LOCAL_DISTANCE</span> <span class="o">:</span> <span class="n">REMOTE_DISTANCE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dist</span> <span class="o">=</span> <span class="n">phys_dist</span><span class="p">[</span><span class="n">physi</span> <span class="o">*</span> <span class="n">numa_dist_cnt</span> <span class="o">+</span> <span class="n">physj</span><span class="p">];</span>

			<span class="n">numa_set_distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* free the copied physical distance table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phys_dist</span><span class="p">)</span>
		<span class="n">memblock_free</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">phys_dist</span><span class="p">),</span> <span class="n">phys_size</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">no_emu:</span>
	<span class="cm">/* No emulation.  Build identity emu_nid_to_phys[] for numa_add_cpu() */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_DEBUG_PER_CPU_MAPS</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_add_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">physnid</span><span class="p">,</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">nid</span> <span class="o">=</span> <span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">nid</span><span class="p">));</span>

	<span class="n">physnid</span> <span class="o">=</span> <span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map the cpu to each emulated node that is allocated on the physical</span>
<span class="cm">	 * node of the cpu&#39;s apic id.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">==</span> <span class="n">physnid</span><span class="p">)</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">nid</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_remove_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* !CONFIG_DEBUG_PER_CPU_MAPS */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_set_cpumask</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">physnid</span><span class="p">;</span>

	<span class="n">nid</span> <span class="o">=</span> <span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* early_cpu_to_node() already emits a warning and trace */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">physnid</span> <span class="o">=</span> <span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emu_nid_to_phys</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">!=</span> <span class="n">physnid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">debug_cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_add_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">numa_set_cpumask</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_remove_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">numa_set_cpumask</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* !CONFIG_DEBUG_PER_CPU_MAPS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
