<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › mm › numa.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>numa.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Common code for 32 and 64-bit NUMA */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/topology.h&gt;</span>

<span class="cp">#include &lt;asm/e820.h&gt;</span>
<span class="cp">#include &lt;asm/proto.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/acpi.h&gt;</span>
<span class="cp">#include &lt;asm/amd_nb.h&gt;</span>

<span class="cp">#include &quot;numa_internal.h&quot;</span>

<span class="kt">int</span> <span class="n">__initdata</span> <span class="n">numa_off</span><span class="p">;</span>
<span class="n">nodemask_t</span> <span class="n">numa_nodes_parsed</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">node_data</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">node_data</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="n">numa_meminfo</span>
<span class="cp">#ifndef CONFIG_MEMORY_HOTPLUG</span>
<span class="n">__initdata</span>
<span class="cp">#endif</span>
<span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">numa_distance_cnt</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="n">numa_distance</span><span class="p">;</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">numa_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
		<span class="n">numa_off</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NUMA_EMU</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="s">&quot;fake=&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
		<span class="n">numa_emu_cmdline</span><span class="p">(</span><span class="n">opt</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_ACPI_NUMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="s">&quot;noacpi&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
		<span class="n">acpi_numa</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;numa&quot;</span><span class="p">,</span> <span class="n">numa_setup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * apicid, cpu, node mappings</span>
<span class="cm"> */</span>
<span class="n">s16</span> <span class="n">__apicid_to_node</span><span class="p">[</span><span class="n">MAX_LOCAL_APIC</span><span class="p">]</span> <span class="n">__cpuinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">MAX_LOCAL_APIC</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">numa_cpu_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">apicid</span> <span class="o">=</span> <span class="n">early_per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apicid</span> <span class="o">!=</span> <span class="n">BAD_APICID</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__apicid_to_node</span><span class="p">[</span><span class="n">apicid</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cpumask_var_t</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">node_to_cpumask_map</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Map cpu index to node index</span>
<span class="cm"> */</span>
<span class="n">DEFINE_EARLY_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">x86_cpu_to_node_map</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>
<span class="n">EXPORT_EARLY_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">x86_cpu_to_node_map</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_set_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">cpu_to_node_map</span> <span class="o">=</span> <span class="n">early_per_cpu_ptr</span><span class="p">(</span><span class="n">x86_cpu_to_node_map</span><span class="p">);</span>

	<span class="cm">/* early setting, no percpu area yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_to_node_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_to_node_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_PER_CPU_MAPS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;numa_set_node: invalid cpu# (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_node_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">set_cpu_numa_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_clear_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">numa_set_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate node_to_cpumask_map based on number of available nodes</span>
<span class="cm"> * Requires node_possible_map to be valid.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: cpumask_of_node() is not valid until after this is done.</span>
<span class="cm"> * (Use CONFIG_DEBUG_PER_CPU_MAPS to check this.)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_node_to_cpumask_map</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* setup nr_node_ids if not done yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_node_ids</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node_possible_map</span><span class="p">)</span>
			<span class="n">num</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="n">nr_node_ids</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate the map */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">node</span><span class="o">++</span><span class="p">)</span>
		<span class="n">alloc_bootmem_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>

	<span class="cm">/* cpumask_of_node() will now work */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Node to cpumask map for %d nodes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_node_ids</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_add_memblk_to</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* ignore zero length blks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* whine about and ignore invalid blks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span> <span class="o">||</span> <span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nid</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;NUMA: Warning: invalid memblk node %d [mem %#010Lx-%#010Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">nid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span> <span class="o">&gt;=</span> <span class="n">NR_NODE_MEMBLKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;NUMA: too many memblk ranges</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">].</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">].</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
	<span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * numa_remove_memblk_from - Remove one numa_memblk from a numa_meminfo</span>
<span class="cm"> * @idx: Index of memblk to remove</span>
<span class="cm"> * @mi: numa_meminfo to remove memblk from</span>
<span class="cm"> *</span>
<span class="cm"> * Remove @idx&#39;th numa_memblk from @mi by shifting @mi-&gt;blk[] and</span>
<span class="cm"> * decrementing @mi-&gt;nr_blks.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">numa_remove_memblk_from</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="o">--</span><span class="p">;</span>
	<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
		<span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span> <span class="o">-</span> <span class="n">idx</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * numa_add_memblk - Add one numa_memblk to numa_meminfo</span>
<span class="cm"> * @nid: NUMA node ID of the new memblk</span>
<span class="cm"> * @start: Start address of the new memblk</span>
<span class="cm"> * @end: End address of the new memblk</span>
<span class="cm"> *</span>
<span class="cm"> * Add a new memblk to the default numa_meminfo.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_add_memblk</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">numa_add_memblk_to</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numa_meminfo</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize NODE_DATA for a node on the local memory */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_node_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">nd_size</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pg_data_t</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">remapped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">nd_pa</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">nd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tnid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t confuse VM with a node that doesn&#39;t have the</span>
<span class="cm">	 * minimum amount of memory:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NODE_MIN_SIZE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* initialize remap allocator before aligning to ZONE_ALIGN */</span>
	<span class="n">init_alloc_remap</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ZONE_ALIGN</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Initmem setup node %d [mem %#010Lx-%#010Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">nid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate node data.  Try remap allocator first, node-local</span>
<span class="cm">	 * memory and then any node.  Never allocate in DMA zone.</span>
<span class="cm">	 */</span>
	<span class="n">nd</span> <span class="o">=</span> <span class="n">alloc_remap</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">nd_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nd_pa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
		<span class="n">remapped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">nd_pa</span> <span class="o">=</span> <span class="n">memblock_alloc_nid</span><span class="p">(</span><span class="n">nd_size</span><span class="p">,</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nd_pa</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Cannot find %zu bytes in node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">nd_size</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nd</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">nd_pa</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* report and initialize */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  NODE_DATA [mem %#010Lx-%#010Lx]%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">nd_pa</span><span class="p">,</span> <span class="n">nd_pa</span> <span class="o">+</span> <span class="n">nd_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">remapped</span> <span class="o">?</span> <span class="s">&quot; (remapped)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">tnid</span> <span class="o">=</span> <span class="n">early_pfn_to_nid</span><span class="p">(</span><span class="n">nd_pa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remapped</span> <span class="o">&amp;&amp;</span> <span class="n">tnid</span> <span class="o">!=</span> <span class="n">nid</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;    NODE_DATA(%d) on node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">tnid</span><span class="p">);</span>

	<span class="n">node_data</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">nd</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pg_data_t</span><span class="p">));</span>
	<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
	<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">node_set_online</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * numa_cleanup_meminfo - Cleanup a numa_meminfo</span>
<span class="cm"> * @mi: numa_meminfo to clean up</span>
<span class="cm"> *</span>
<span class="cm"> * Sanitize @mi by merging and removing unncessary memblks.  Also check for</span>
<span class="cm"> * conflicts and clear unused memblks.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_cleanup_meminfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u64</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u64</span> <span class="n">high</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">max_pfn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>

	<span class="cm">/* first, trim all entries */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">numa_memblk</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* make sure all blocks are inside the limits */</span>
		<span class="n">bi</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">low</span><span class="p">);</span>
		<span class="n">bi</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>

		<span class="cm">/* and there&#39;s no empty block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="n">numa_remove_memblk_from</span><span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">mi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* merge neighboring / overlapping entries */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">numa_memblk</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">numa_memblk</span> <span class="o">*</span><span class="n">bj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * See whether there are overlapping blocks.  Whine</span>
<span class="cm">			 * about but allow overlaps of the same nid.  They</span>
<span class="cm">			 * will be merged below.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">!=</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;NUMA: node %d [mem %#010Lx-%#010Lx] overlaps with node %d [mem %#010Lx-%#010Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">bi</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					       <span class="n">bj</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;NUMA: Warning: node %d [mem %#010Lx-%#010Lx] overlaps with itself [mem %#010Lx-%#010Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">bi</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					   <span class="n">bj</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Join together blocks on the same node, holes</span>
<span class="cm">			 * between which don&#39;t overlap with memory on other</span>
<span class="cm">			 * nodes.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">!=</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">numa_memblk</span> <span class="o">*</span><span class="n">bk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">==</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NUMA: Node %d [mem %#010Lx-%#010Lx] + [mem %#010Lx-%#010Lx] -&gt; [mem %#010Lx-%#010Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bi</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bj</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
			       <span class="n">bj</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">bi</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">bi</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="n">numa_remove_memblk_from</span><span class="p">(</span><span class="n">j</span><span class="o">--</span><span class="p">,</span> <span class="n">mi</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* clear unused ones */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set nodes, which have memory in @mi, in *@nodemask.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">numa_nodemask_from_meminfo</span><span class="p">(</span><span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span>
					      <span class="k">const</span> <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">!=</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span> <span class="o">&amp;&amp;</span>
		    <span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span> <span class="o">!=</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
			<span class="n">node_set</span><span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">,</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * numa_reset_distance - Reset NUMA distance table</span>
<span class="cm"> *</span>
<span class="cm"> * The current table is freed.  The next numa_set_distance() call will</span>
<span class="cm"> * create a new one.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">numa_reset_distance</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">numa_distance_cnt</span> <span class="o">*</span> <span class="n">numa_distance_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">numa_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* numa_distance could be 1LU marking allocation failure, test cnt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numa_distance_cnt</span><span class="p">)</span>
		<span class="n">memblock_free</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">numa_distance</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">numa_distance_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">numa_distance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* enable table creation */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_alloc_distance</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodemask_t</span> <span class="n">nodes_parsed</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">phys</span><span class="p">;</span>

	<span class="cm">/* size the new table and allocate it */</span>
	<span class="n">nodes_parsed</span> <span class="o">=</span> <span class="n">numa_nodes_parsed</span><span class="p">;</span>
	<span class="n">numa_nodemask_from_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes_parsed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numa_meminfo</span><span class="p">);</span>

	<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nodes_parsed</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">*</span> <span class="n">cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">numa_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">phys</span> <span class="o">=</span> <span class="n">memblock_find_in_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">max_pfn_mapped</span><span class="p">),</span>
				      <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;NUMA: Warning: can&#39;t allocate distance table!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* don&#39;t retry until explicitly reset */</span>
		<span class="n">numa_distance</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1LU</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">numa_distance</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">numa_distance_cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="cm">/* fill with the default distances */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">numa_distance</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">cnt</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="o">?</span>
				<span class="n">LOCAL_DISTANCE</span> <span class="o">:</span> <span class="n">REMOTE_DISTANCE</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;NUMA: Initialized distance table, cnt=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * numa_set_distance - Set NUMA distance from one NUMA to another</span>
<span class="cm"> * @from: the &#39;from&#39; node to set distance</span>
<span class="cm"> * @to: the &#39;to&#39;  node to set distance</span>
<span class="cm"> * @distance: NUMA distance</span>
<span class="cm"> *</span>
<span class="cm"> * Set the distance from node @from to @to to @distance.  If distance table</span>
<span class="cm"> * doesn&#39;t exist, one which is large enough to accommodate all the currently</span>
<span class="cm"> * known nodes will be created.</span>
<span class="cm"> *</span>
<span class="cm"> * If such table cannot be allocated, a warning is printed and further</span>
<span class="cm"> * calls are ignored until the distance table is reset with</span>
<span class="cm"> * numa_reset_distance().</span>
<span class="cm"> *</span>
<span class="cm"> * If @from or @to is higher than the highest known node or lower than zero</span>
<span class="cm"> * at the time of table creation or @distance doesn&#39;t make sense, the call</span>
<span class="cm"> * is ignored.</span>
<span class="cm"> * This is to allow simplification of specific NUMA config implementations.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">numa_set_distance</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">distance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numa_distance</span> <span class="o">&amp;&amp;</span> <span class="n">numa_alloc_distance</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;=</span> <span class="n">numa_distance_cnt</span> <span class="o">||</span> <span class="n">to</span> <span class="o">&gt;=</span> <span class="n">numa_distance_cnt</span> <span class="o">||</span>
			<span class="n">from</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">to</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn_once</span><span class="p">(</span><span class="s">&quot;NUMA: Warning: node ids are out of bound, from=%d to=%d distance=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">distance</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">u8</span><span class="p">)</span><span class="n">distance</span> <span class="o">!=</span> <span class="n">distance</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">from</span> <span class="o">==</span> <span class="n">to</span> <span class="o">&amp;&amp;</span> <span class="n">distance</span> <span class="o">!=</span> <span class="n">LOCAL_DISTANCE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn_once</span><span class="p">(</span><span class="s">&quot;NUMA: Warning: invalid distance parameter, from=%d to=%d distance=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">distance</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">numa_distance</span><span class="p">[</span><span class="n">from</span> <span class="o">*</span> <span class="n">numa_distance_cnt</span> <span class="o">+</span> <span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__node_distance</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;=</span> <span class="n">numa_distance_cnt</span> <span class="o">||</span> <span class="n">to</span> <span class="o">&gt;=</span> <span class="n">numa_distance_cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">from</span> <span class="o">==</span> <span class="n">to</span> <span class="o">?</span> <span class="n">LOCAL_DISTANCE</span> <span class="o">:</span> <span class="n">REMOTE_DISTANCE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">numa_distance</span><span class="p">[</span><span class="n">from</span> <span class="o">*</span> <span class="n">numa_distance_cnt</span> <span class="o">+</span> <span class="n">to</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__node_distance</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Sanity check to catch more bad NUMA configurations (they are amazingly</span>
<span class="cm"> * common).  Make sure the nodes cover all memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">__init</span> <span class="nf">numa_meminfo_cover_memory</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">numaram</span><span class="p">,</span> <span class="n">e820ram</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">numaram</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">s</span> <span class="o">=</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">e</span> <span class="o">=</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">numaram</span> <span class="o">+=</span> <span class="n">e</span> <span class="o">-</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">numaram</span> <span class="o">-=</span> <span class="n">__absent_pages_in_range</span><span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">numaram</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">numaram</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">e820ram</span> <span class="o">=</span> <span class="n">max_pfn</span> <span class="o">-</span> <span class="n">absent_pages_in_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_pfn</span><span class="p">);</span>

	<span class="cm">/* We seem to lose 3 pages somewhere. Allow 1M of slack. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)(</span><span class="n">e820ram</span> <span class="o">-</span> <span class="n">numaram</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NUMA: nodes only cover %LuMB of your %LuMB e820 RAM. Not used.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">numaram</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">e820ram</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_register_memblks</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">pfn_align</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nid</span><span class="p">;</span>

	<span class="cm">/* Account for nodes with cpus and no memory */</span>
	<span class="n">node_possible_map</span> <span class="o">=</span> <span class="n">numa_nodes_parsed</span><span class="p">;</span>
	<span class="n">numa_nodemask_from_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_possible_map</span><span class="p">,</span> <span class="n">mi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">nodes_empty</span><span class="p">(</span><span class="n">node_possible_map</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">numa_memblk</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">memblock_set_node</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If sections array is gonna be used for pfn -&gt; nid mapping, check</span>
<span class="cm">	 * whether its granularity is fine enough.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef NODE_NOT_IN_PAGE_FLAGS</span>
	<span class="n">pfn_align</span> <span class="o">=</span> <span class="n">node_map_pfn_alignment</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfn_align</span> <span class="o">&amp;&amp;</span> <span class="n">pfn_align</span> <span class="o">&lt;</span> <span class="n">PAGES_PER_SECTION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Node alignment %LuMB &lt; min %LuMB, rejecting NUMA config</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pfn_align</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span>
		       <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">PAGES_PER_SECTION</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numa_meminfo_cover_memory</span><span class="p">(</span><span class="n">mi</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Finally register nodes. */</span>
	<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">node_possible_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">start</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">max_pfn</span><span class="p">);</span>
		<span class="n">u64</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">!=</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="n">setup_node_data</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Dump memblock with node info and return. */</span>
	<span class="n">memblock_dump_all</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are unfortunately some poorly designed mainboards around that</span>
<span class="cm"> * only connect memory to a single CPU. This breaks the 1:1 cpu-&gt;node</span>
<span class="cm"> * mapping. To avoid this fill in the mapping for all possible CPUs,</span>
<span class="cm"> * as the number of CPUs is not known yet. We round robin the existing</span>
<span class="cm"> * nodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">numa_init_array</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rr</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rr</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">node_online_map</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">numa_set_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rr</span><span class="p">);</span>
		<span class="n">rr</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">rr</span><span class="p">,</span> <span class="n">node_online_map</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rr</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
			<span class="n">rr</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">node_online_map</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_init</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init_func</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_LOCAL_APIC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_apicid_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>

	<span class="n">nodes_clear</span><span class="p">(</span><span class="n">numa_nodes_parsed</span><span class="p">);</span>
	<span class="n">nodes_clear</span><span class="p">(</span><span class="n">node_possible_map</span><span class="p">);</span>
	<span class="n">nodes_clear</span><span class="p">(</span><span class="n">node_online_map</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numa_meminfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">numa_meminfo</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">memblock_set_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ULLONG_MAX</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">));</span>
	<span class="n">numa_reset_distance</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">init_func</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">numa_cleanup_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numa_meminfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">numa_emulation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numa_meminfo</span><span class="p">,</span> <span class="n">numa_distance_cnt</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">numa_register_memblks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numa_meminfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">nid</span><span class="p">))</span>
			<span class="n">numa_clear_node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">numa_init_array</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dummy_numa_init - Fallback dummy NUMA init</span>
<span class="cm"> *</span>
<span class="cm"> * Used if there&#39;s no underlying NUMA architecture, NUMA initialization</span>
<span class="cm"> * fails, or NUMA is disabled on the command line.</span>
<span class="cm"> *</span>
<span class="cm"> * Must online at least one node and add memory blocks that cover all</span>
<span class="cm"> * allowed memory.  This function must not fail.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dummy_numa_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">numa_off</span> <span class="o">?</span> <span class="s">&quot;NUMA turned off&quot;</span> <span class="o">:</span> <span class="s">&quot;No NUMA configuration found&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Faking a node at [mem %#018Lx-%#018Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="mi">0LLU</span><span class="p">,</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">max_pfn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">node_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numa_nodes_parsed</span><span class="p">);</span>
	<span class="n">numa_add_memblk</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">max_pfn</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * x86_numa_init - Initialize NUMA</span>
<span class="cm"> *</span>
<span class="cm"> * Try each configured NUMA initialization method until one succeeds.  The</span>
<span class="cm"> * last fallback is dummy single node config encomapssing whole memory and</span>
<span class="cm"> * never fails.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">x86_numa_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numa_off</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_NUMAQ</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numa_init</span><span class="p">(</span><span class="n">numaq_numa_init</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_ACPI_NUMA</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numa_init</span><span class="p">(</span><span class="n">x86_acpi_numa_init</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_AMD_NUMA</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numa_init</span><span class="p">(</span><span class="n">amd_numa_init</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">numa_init</span><span class="p">(</span><span class="n">dummy_numa_init</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">find_near_online_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_val</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">best_node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">min_val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="n">best_node</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">best_node</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup early cpu_to_node.</span>
<span class="cm"> *</span>
<span class="cm"> * Populate cpu_to_node[] only if x86_cpu_to_apicid[],</span>
<span class="cm"> * and apicid_to_node[] tables have valid entries for a CPU.</span>
<span class="cm"> * This means we skip cpu_to_node[] initialisation for NUMA</span>
<span class="cm"> * emulation and faking node case (when running a kernel compiled</span>
<span class="cm"> * for NUMA on a non NUMA box), which is OK as cpu_to_node[]</span>
<span class="cm"> * is already initialized in a round robin manner at numa_init_array,</span>
<span class="cm"> * prior to this call, and this initialization is good enough</span>
<span class="cm"> * for the fake NUMA cases.</span>
<span class="cm"> *</span>
<span class="cm"> * Called before the per_cpu areas are setup.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_cpu_to_node</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">cpu_to_apicid</span> <span class="o">=</span> <span class="n">early_per_cpu_ptr</span><span class="p">(</span><span class="n">x86_cpu_to_apicid</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_to_apicid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">numa_cpu_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">find_near_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="n">numa_set_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_DEBUG_PER_CPU_MAPS</span>

<span class="cp"># ifndef CONFIG_NUMA_EMU</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_add_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">)]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_remove_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">)]);</span>
<span class="p">}</span>
<span class="cp"># endif	</span><span class="cm">/* !CONFIG_NUMA_EMU */</span><span class="cp"></span>

<span class="cp">#else	</span><span class="cm">/* !CONFIG_DEBUG_PER_CPU_MAPS */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">__cpu_to_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">early_per_cpu_ptr</span><span class="p">(</span><span class="n">x86_cpu_to_node_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;cpu_to_node(%d): usage too early!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">early_per_cpu_ptr</span><span class="p">(</span><span class="n">x86_cpu_to_node_map</span><span class="p">)[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_node_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__cpu_to_node</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Same function as cpu_to_node() but used if called before the</span>
<span class="cm"> * per_cpu areas are setup.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">early_cpu_to_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">early_per_cpu_ptr</span><span class="p">(</span><span class="n">x86_cpu_to_node_map</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">early_per_cpu_ptr</span><span class="p">(</span><span class="n">x86_cpu_to_node_map</span><span class="p">)[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;early_cpu_to_node(%d): no per_cpu area!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_node_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debug_cpumask_set_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* early_cpu_to_node() already emits a warning and trace */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;node_to_cpumask_map[%i] NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s cpu %d node %d: mask now %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">enable</span> <span class="o">?</span> <span class="s">&quot;numa_add_cpu&quot;</span> <span class="o">:</span> <span class="s">&quot;numa_remove_cpu&quot;</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp"># ifndef CONFIG_NUMA_EMU</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_set_cpumask</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">enable</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_add_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">numa_set_cpumask</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">numa_remove_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">numa_set_cpumask</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp"># endif	</span><span class="cm">/* !CONFIG_NUMA_EMU */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Returns a pointer to the bitmask of CPUs on Node &#39;node&#39;.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">cpumask_of_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="n">nr_node_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;cpumask_of_node(%d): node &gt; nr_node_ids(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">node</span><span class="p">,</span> <span class="n">nr_node_ids</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">cpu_none_mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;cpumask_of_node(%d): no node_to_cpumask_map!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">node</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">cpu_online_mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpumask_of_node</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* !CONFIG_DEBUG_PER_CPU_MAPS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTPLUG</span>
<span class="kt">int</span> <span class="nf">memory_add_physaddr_to_nid</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">numa_meminfo</span> <span class="o">*</span><span class="n">mi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">numa_meminfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">memory_add_physaddr_to_nid</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
