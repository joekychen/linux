<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › mm › init_64.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>init_64.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/x86_64/mm/init.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1995  Linus Torvalds</span>
<span class="cm"> *  Copyright (C) 2000  Pavel Machek &lt;pavel@ucw.cz&gt;</span>
<span class="cm"> *  Copyright (C) 2002,2003 Andi Kleen &lt;ak@suse.de&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>
<span class="cp">#include &lt;linux/poison.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/memory.h&gt;</span>
<span class="cp">#include &lt;linux/memory_hotplug.h&gt;</span>
<span class="cp">#include &lt;linux/nmi.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/bios_ebda.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/fixmap.h&gt;</span>
<span class="cp">#include &lt;asm/e820.h&gt;</span>
<span class="cp">#include &lt;asm/apic.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/proto.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/kdebug.h&gt;</span>
<span class="cp">#include &lt;asm/numa.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/init.h&gt;</span>
<span class="cp">#include &lt;asm/uv/uv.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_direct_gbpages_off</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">direct_gbpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;nogbpages&quot;</span><span class="p">,</span> <span class="n">parse_direct_gbpages_off</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_direct_gbpages_on</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">direct_gbpages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;gbpages&quot;</span><span class="p">,</span> <span class="n">parse_direct_gbpages_on</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: pagetable_init alloc all the fixmap pagetables contiguous on the</span>
<span class="cm"> * physical space so we can cache the place of the first one and move</span>
<span class="cm"> * around without checking the pgd every time.</span>
<span class="cm"> */</span>

<span class="n">pteval_t</span> <span class="n">__supported_pte_mask</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="o">~</span><span class="n">_PAGE_IOMAP</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__supported_pte_mask</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">force_personality32</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * noexec32=on|off</span>
<span class="cm"> * Control non executable heap for 32bit processes.</span>
<span class="cm"> * To control the stack too use noexec=off</span>
<span class="cm"> *</span>
<span class="cm"> * on	PROT_READ does not imply PROT_EXEC for 32-bit processes (default)</span>
<span class="cm"> * off	PROT_READ implies PROT_EXEC</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nonx32_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">))</span>
		<span class="n">force_personality32</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">READ_IMPLIES_EXEC</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">))</span>
		<span class="n">force_personality32</span> <span class="o">|=</span> <span class="n">READ_IMPLIES_EXEC</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noexec32=&quot;</span><span class="p">,</span> <span class="n">nonx32_setup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * When memory was added/removed make sure all the processes MM have</span>
<span class="cm"> * suitable PGD entries in the local PGD level page.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sync_global_pgds</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">address</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">address</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">PGDIR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd_ref</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd_ref</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgd_list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
			<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">pgt_lock</span><span class="p">;</span>

			<span class="n">pgd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
			<span class="cm">/* the pgt_lock only for Xen */</span>
			<span class="n">pgt_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pgd_page_get_mm</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">pgt_lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
				<span class="n">set_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="o">*</span><span class="n">pgd_ref</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pgd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span>
				       <span class="o">!=</span> <span class="n">pgd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">pgd_ref</span><span class="p">));</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">pgt_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: This function is marked __ref because it calls __init function</span>
<span class="cm"> * (alloc_bootmem_pages). It&#39;s safe to do it ONLY when after_bootmem == 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__ref</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">spp_getpage</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">after_bootmem</span><span class="p">)</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_NOTRACK</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">alloc_bootmem_pages</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span> <span class="o">||</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;set_pte_phys: cannot allocate page data %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">after_bootmem</span> <span class="o">?</span> <span class="s">&quot;after bootmem&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;spp_getpage %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pud_t</span> <span class="o">*</span><span class="nf">fill_pud</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span> <span class="o">=</span> <span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="p">)</span><span class="n">spp_getpage</span><span class="p">();</span>
		<span class="n">pgd_populate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">pud</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pud</span> <span class="o">!=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PAGETABLE BUG #00! %p &lt;-&gt; %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">pud</span><span class="p">,</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="nf">fill_pmd</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">spp_getpage</span><span class="p">();</span>
		<span class="n">pud_populate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd</span> <span class="o">!=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PAGETABLE BUG #01! %p &lt;-&gt; %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">pmd</span><span class="p">,</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pte_t</span> <span class="o">*</span><span class="nf">fill_pte</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">spp_getpage</span><span class="p">();</span>
		<span class="n">pmd_populate_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">!=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PAGETABLE BUG #02!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_pte_vaddr_pud</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">new_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_page</span> <span class="o">+</span> <span class="n">pud_index</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">fill_pmd</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">fill_pte</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>

	<span class="n">set_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">new_pte</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s enough to flush this one mapping.</span>
<span class="cm">	 * (PGE mappings get flushed as well)</span>
<span class="cm">	 */</span>
	<span class="n">__flush_tlb_one</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_pte_vaddr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud_page</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;set_pte_vaddr %lx to %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">native_pte_val</span><span class="p">(</span><span class="n">pteval</span><span class="p">));</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;PGD FIXMAP MISSING, it should be setup in head.S!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pud_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">pud_t</span><span class="o">*</span><span class="p">)</span><span class="n">pgd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">set_pte_vaddr_pud</span><span class="p">(</span><span class="n">pud_page</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">pmd_t</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">populate_extra_pmd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">fill_pud</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fill_pmd</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">pte_t</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">populate_extra_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">populate_extra_pmd</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fill_pte</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create large page table mappings for a range of physical addresses.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">__init_extra_mapping</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
						<span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">phys</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PMD_MASK</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PMD_MASK</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">size</span><span class="p">;</span> <span class="n">phys</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">,</span> <span class="n">size</span> <span class="o">-=</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">phys</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pud</span> <span class="o">=</span> <span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">spp_getpage</span><span class="p">();</span>
			<span class="n">set_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">__pgd</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pud</span><span class="p">)</span> <span class="o">|</span> <span class="n">_KERNPG_TABLE</span> <span class="o">|</span>
						<span class="n">_PAGE_USER</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">phys</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">spp_getpage</span><span class="p">();</span>
			<span class="n">set_pud</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">__pud</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">|</span> <span class="n">_KERNPG_TABLE</span> <span class="o">|</span>
						<span class="n">_PAGE_USER</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">phys</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
		<span class="n">set_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="n">phys</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">)));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_extra_mapping_wb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__init_extra_mapping</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_KERNEL_LARGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_extra_mapping_uc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__init_extra_mapping</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_KERNEL_LARGE_NOCACHE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The head.S code sets up the kernel high mapping:</span>
<span class="cm"> *</span>
<span class="cm"> *   from __START_KERNEL_map to __START_KERNEL_map + size (== _end-_text)</span>
<span class="cm"> *</span>
<span class="cm"> * phys_addr holds the negative offset to the kernel, which is added</span>
<span class="cm"> * to the compile time generated pmds. This results in invalid pmds up</span>
<span class="cm"> * to the point where we hit the physaddr 0 mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * We limit the mappings to the region from _text to _brk_end.  _brk_end</span>
<span class="cm"> * is rounded up to the 2MB boundary. This catches the invalid pmds as</span>
<span class="cm"> * well, as they are located before _text:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">cleanup_highmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="n">__START_KERNEL_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr_end</span> <span class="o">=</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_pfn_mapped</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_brk_end</span><span class="p">,</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">level2_kernel_pgt</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">PMD_SIZE</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">vaddr_end</span><span class="p">;</span> <span class="n">pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_text</span> <span class="o">||</span> <span class="n">vaddr</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="n">set_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__ref</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_low_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">pgt_buf_end</span><span class="o">++</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">adr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">after_bootmem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_NOTRACK</span><span class="p">);</span>
		<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">adr</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">adr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">pgt_buf_top</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;alloc_low_page: ran out of memory&quot;</span><span class="p">);</span>

	<span class="n">adr</span> <span class="o">=</span> <span class="n">early_memremap</span><span class="p">(</span><span class="n">pfn</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">clear_page</span><span class="p">(</span><span class="n">adr</span><span class="p">);</span>
	<span class="o">*</span><span class="n">phys</span>  <span class="o">=</span> <span class="n">pfn</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">adr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__ref</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">map_low_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">adr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys</span><span class="p">,</span> <span class="n">left</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">after_bootmem</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">virt</span><span class="p">;</span>

	<span class="n">phys</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">virt</span><span class="p">);</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">phys</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">adr</span> <span class="o">=</span> <span class="n">early_memremap</span><span class="p">(</span><span class="n">phys</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">adr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">adr</span><span class="p">)</span> <span class="o">|</span> <span class="n">left</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">adr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__ref</span> <span class="kt">void</span> <span class="nf">unmap_low_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">after_bootmem</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">early_iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">adr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__meminit</span>
<span class="nf">phys_pte_init</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">pte_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
	      <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pte_page</span> <span class="o">+</span> <span class="n">pte_index</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">pte_index</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">pte</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after_bootmem</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">pte</span><span class="o">++</span><span class="p">)</span>
					<span class="n">set_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We will re-use the existing mapping.</span>
<span class="cm">		 * Xen for example has some special requirements, like mapping</span>
<span class="cm">		 * pagetable pages as RO. So assume someone who pre-setup</span>
<span class="cm">		 * these mappings are more intelligent.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pages</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;   pte=%p addr=%lx pte=%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">pte</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">).</span><span class="n">pte</span><span class="p">);</span>
		<span class="n">pages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">set_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">prot</span><span class="p">));</span>
		<span class="n">last_map_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">update_page_count</span><span class="p">(</span><span class="n">PG_LEVEL_4K</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">last_map_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__meminit</span>
<span class="nf">phys_pmd_init</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_size_mask</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pmd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PMD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte_phys</span><span class="p">;</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_page</span> <span class="o">+</span> <span class="n">pmd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
		<span class="n">pgprot_t</span> <span class="n">new_prot</span> <span class="o">=</span> <span class="n">prot</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after_bootmem</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PMD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">pmd</span><span class="o">++</span><span class="p">)</span>
					<span class="n">set_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">PMD_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_large</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
				<span class="n">pte</span> <span class="o">=</span> <span class="n">map_low_page</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
				<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">phys_pte_init</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
								<span class="n">end</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
				<span class="n">unmap_low_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we are ok with PG_LEVEL_2M mapping, then we will</span>
<span class="cm">			 * use the existing mapping,</span>
<span class="cm">			 *</span>
<span class="cm">			 * Otherwise, we will split the large page mapping but</span>
<span class="cm">			 * use the same existing protection bits except for</span>
<span class="cm">			 * large page, so that we don&#39;t violate Intel&#39;s TLB</span>
<span class="cm">			 * Application note (317080) which says, while changing</span>
<span class="cm">			 * the page sizes, new and old translations should</span>
<span class="cm">			 * not differ with respect to page frame and</span>
<span class="cm">			 * attributes.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_size_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_LEVEL_2M</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">new_prot</span> <span class="o">=</span> <span class="n">pte_pgprot</span><span class="p">(</span><span class="n">pte_clrhuge</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page_size_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">PG_LEVEL_2M</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="n">set_pte</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">,</span>
				<span class="n">pfn_pte</span><span class="p">(</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
					<span class="n">__pgprot</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_PSE</span><span class="p">)));</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">alloc_low_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte_phys</span><span class="p">);</span>
		<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">phys_pte_init</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">new_prot</span><span class="p">);</span>
		<span class="n">unmap_low_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">pmd_populate_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">__va</span><span class="p">(</span><span class="n">pte_phys</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">update_page_count</span><span class="p">(</span><span class="n">PG_LEVEL_2M</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">last_map_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__meminit</span>
<span class="nf">phys_pud_init</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_size_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pud_index</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PUD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmd_phys</span><span class="p">;</span>
		<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span> <span class="o">=</span> <span class="n">pud_page</span> <span class="o">+</span> <span class="n">pud_index</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
		<span class="n">pgprot_t</span> <span class="n">prot</span> <span class="o">=</span> <span class="n">PAGE_KERNEL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">PUD_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">PUD_SIZE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after_bootmem</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">e820_any_mapped</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_pud</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">__pud</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pud_val</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_large</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pmd</span> <span class="o">=</span> <span class="n">map_low_page</span><span class="p">(</span><span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
				<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">phys_pmd_init</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
							 <span class="n">page_size_mask</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
				<span class="n">unmap_low_page</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
				<span class="n">__flush_tlb_all</span><span class="p">();</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we are ok with PG_LEVEL_1G mapping, then we will</span>
<span class="cm">			 * use the existing mapping.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Otherwise, we will split the gbpage mapping but use</span>
<span class="cm">			 * the same existing protection  bits except for large</span>
<span class="cm">			 * page, so that we don&#39;t violate Intel&#39;s TLB</span>
<span class="cm">			 * Application note (317080) which says, while changing</span>
<span class="cm">			 * the page sizes, new and old translations should</span>
<span class="cm">			 * not differ with respect to page frame and</span>
<span class="cm">			 * attributes.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_size_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_LEVEL_1G</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">prot</span> <span class="o">=</span> <span class="n">pte_pgprot</span><span class="p">(</span><span class="n">pte_clrhuge</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pud</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page_size_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">PG_LEVEL_1G</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="n">set_pte</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pud</span><span class="p">,</span>
				<span class="n">pfn_pte</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">PAGE_KERNEL_LARGE</span><span class="p">));</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pmd</span> <span class="o">=</span> <span class="n">alloc_low_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmd_phys</span><span class="p">);</span>
		<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">phys_pmd_init</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">page_size_mask</span><span class="p">,</span>
					      <span class="n">prot</span><span class="p">);</span>
		<span class="n">unmap_low_page</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">pud_populate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">__va</span><span class="p">(</span><span class="n">pmd_phys</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__flush_tlb_all</span><span class="p">();</span>

	<span class="n">update_page_count</span><span class="p">(</span><span class="n">PG_LEVEL_1G</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">last_map_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__meminit</span>
<span class="nf">kernel_physical_mapping_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_size_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">pgd_changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">,</span> <span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">start</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pud_phys</span><span class="p">;</span>
		<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>

		<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">PGDIR_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PGDIR_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pud</span> <span class="o">=</span> <span class="n">map_low_page</span><span class="p">((</span><span class="n">pud_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pgd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">));</span>
			<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">phys_pud_init</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
						 <span class="n">__pa</span><span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="n">page_size_mask</span><span class="p">);</span>
			<span class="n">unmap_low_page</span><span class="p">(</span><span class="n">pud</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pud</span> <span class="o">=</span> <span class="n">alloc_low_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pud_phys</span><span class="p">);</span>
		<span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">phys_pud_init</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">next</span><span class="p">),</span>
						 <span class="n">page_size_mask</span><span class="p">);</span>
		<span class="n">unmap_low_page</span><span class="p">(</span><span class="n">pud</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">pgd_populate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">__va</span><span class="p">(</span><span class="n">pud_phys</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">pgd_changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_changed</span><span class="p">)</span>
		<span class="n">sync_global_pgds</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">__flush_tlb_all</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">last_map_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_NUMA</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">initmem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memblock_set_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">ULLONG_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sparse_memory_present_with_active_regions</span><span class="p">(</span><span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="n">sparse_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * clear the default setting with node 0</span>
<span class="cm">	 * note: don&#39;t use nodes_clear here, that is really clearing when</span>
<span class="cm">	 *	 numa support is not compiled in, and later node_set_state</span>
<span class="cm">	 *	 will not set it back.</span>
<span class="cm">	 */</span>
	<span class="n">node_clear_state</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">);</span>

	<span class="n">zone_sizes_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Memory hotplug specific functions</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_MEMORY_HOTPLUG</span>
<span class="cm">/*</span>
<span class="cm"> * After memory hotplug the variables max_pfn, max_low_pfn and high_memory need</span>
<span class="cm"> * updating.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>  <span class="nf">update_end_of_memory_vars</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">max_pfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="n">high_memory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">max_pfn</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Memory is added always to NORMAL zone. This means you will never get</span>
<span class="cm"> * additional DMA/DMA32 memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">arch_add_memory</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span> <span class="o">+</span> <span class="n">ZONE_NORMAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_mapped_pfn</span><span class="p">,</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">last_mapped_pfn</span> <span class="o">=</span> <span class="n">init_memory_mapping</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_mapped_pfn</span> <span class="o">&gt;</span> <span class="n">max_pfn_mapped</span><span class="p">)</span>
		<span class="n">max_pfn_mapped</span> <span class="o">=</span> <span class="n">last_mapped_pfn</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_pages</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* update max_pfn, max_low_pfn and high_memory */</span>
	<span class="n">update_end_of_memory_vars</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">arch_add_memory</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MEMORY_HOTPLUG */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kcore_list</span> <span class="n">kcore_vsyscall</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">mem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">codesize</span><span class="p">,</span> <span class="n">reservedpages</span><span class="p">,</span> <span class="n">datasize</span><span class="p">,</span> <span class="n">initsize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">absent_pages</span><span class="p">;</span>

	<span class="n">pci_iommu_alloc</span><span class="p">();</span>

	<span class="cm">/* clear_bss() already clear the empty_zero_page */</span>

	<span class="n">reservedpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* this will put all low memory onto the freelists */</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">totalram_pages</span> <span class="o">=</span> <span class="n">numa_free_all_bootmem</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="n">totalram_pages</span> <span class="o">=</span> <span class="n">free_all_bootmem</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">absent_pages</span> <span class="o">=</span> <span class="n">absent_pages_in_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_pfn</span><span class="p">);</span>
	<span class="n">reservedpages</span> <span class="o">=</span> <span class="n">max_pfn</span> <span class="o">-</span> <span class="n">totalram_pages</span> <span class="o">-</span> <span class="n">absent_pages</span><span class="p">;</span>
	<span class="n">after_bootmem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">codesize</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">_etext</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">_text</span><span class="p">;</span>
	<span class="n">datasize</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">_edata</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">_etext</span><span class="p">;</span>
	<span class="n">initsize</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">__init_end</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">__init_begin</span><span class="p">;</span>

	<span class="cm">/* Register memory areas for /proc/kcore */</span>
	<span class="n">kclist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kcore_vsyscall</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">VSYSCALL_START</span><span class="p">,</span>
			 <span class="n">VSYSCALL_END</span> <span class="o">-</span> <span class="n">VSYSCALL_START</span><span class="p">,</span> <span class="n">KCORE_OTHER</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Memory: %luk/%luk available (%ldk kernel code, &quot;</span>
			 <span class="s">&quot;%ldk absent, %ldk reserved, %ldk data, %ldk init)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nr_free_pages</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">max_pfn</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">codesize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">absent_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">reservedpages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">datasize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">initsize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_RODATA</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">rodata_test_data</span> <span class="o">=</span> <span class="mh">0xC3</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rodata_test_data</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">kernel_set_to_readonly</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">set_kernel_text_rw</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">_text</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">__stop___ex_table</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kernel_set_to_readonly</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Set kernel text: %lx - %lx for read write</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make the kernel identity mapping for text RW. Kernel text</span>
<span class="cm">	 * mapping will always be RO. Refer to the comment in</span>
<span class="cm">	 * static_protections() in pageattr.c</span>
<span class="cm">	 */</span>
	<span class="n">set_memory_rw</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_kernel_text_ro</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">_text</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">__stop___ex_table</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kernel_set_to_readonly</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Set kernel text: %lx - %lx for read only</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the kernel identity mapping for text RO.</span>
<span class="cm">	 */</span>
	<span class="n">set_memory_ro</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mark_rodata_ro</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">_text</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rodata_start</span> <span class="o">=</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__start_rodata</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">__end_rodata_hpage_align</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_end</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">__stop___ex_table</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rodata_end</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">__end_rodata</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">_sdata</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Write protecting the kernel read-only data: %luk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">set_memory_ro</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">kernel_set_to_readonly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The rodata section (but not the kernel text!) should also be</span>
<span class="cm">	 * not-executable.</span>
<span class="cm">	 */</span>
	<span class="n">set_memory_nx</span><span class="p">(</span><span class="n">rodata_start</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">rodata_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">rodata_test</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_CPA_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Testing CPA: undo %lx-%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">set_memory_rw</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Testing CPA: again</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">set_memory_ro</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">free_init_pages</span><span class="p">(</span><span class="s">&quot;unused kernel memory&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page_address</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">text_end</span><span class="p">)),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
				 <span class="n">page_address</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">rodata_start</span><span class="p">)));</span>
	<span class="n">free_init_pages</span><span class="p">(</span><span class="s">&quot;unused kernel memory&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page_address</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">rodata_end</span><span class="p">)),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page_address</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">data_start</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">kern_addr_valid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">above</span> <span class="o">=</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">__VIRTUAL_MASK_SHIFT</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">above</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">above</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1UL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_large</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pfn_valid</span><span class="p">(</span><span class="n">pmd_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pfn_valid</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A pseudo VMA to allow ptrace access for the vsyscall page.  This only</span>
<span class="cm"> * covers the 64bit vsyscall page now. 32bit has a real VMA now and does</span>
<span class="cm"> * not need special handling anymore:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="n">gate_vma</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">vm_start</span>	<span class="o">=</span> <span class="n">VSYSCALL_START</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vm_end</span>		<span class="o">=</span> <span class="n">VSYSCALL_START</span> <span class="o">+</span> <span class="p">(</span><span class="n">VSYSCALL_MAPPED_PAGES</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">),</span>
	<span class="p">.</span><span class="n">vm_page_prot</span>	<span class="o">=</span> <span class="n">PAGE_READONLY_EXEC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vm_flags</span>	<span class="o">=</span> <span class="n">VM_READ</span> <span class="o">|</span> <span class="n">VM_EXEC</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">get_gate_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IA32_EMULATION</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span> <span class="o">||</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ia32_compat</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">gate_vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">in_gate_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">get_gate_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use this when you have no reliable mm, typically from interrupt</span>
<span class="cm"> * context. It is less reliable than using a task&#39;s mm and may give</span>
<span class="cm"> * false positives.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">in_gate_area_no_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">VSYSCALL_START</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">VSYSCALL_END</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">arch_vma_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">==</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">vdso</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;[vdso]&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">gate_vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;[vsyscall]&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_UV</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">memory_block_size_bytes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_uv_system</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;UV: memory block size 2GB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">2UL</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">MIN_MEMORY_BLOCK_SIZE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SPARSEMEM_VMEMMAP</span>
<span class="cm">/*</span>
<span class="cm"> * Initialise the sparsemem vmemmap using huge-pages at the PMD level.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">__meminitdata</span> <span class="n">addr_start</span><span class="p">,</span> <span class="n">addr_end</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__meminitdata</span> <span class="o">*</span><span class="n">p_start</span><span class="p">,</span> <span class="o">*</span><span class="n">p_end</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__meminitdata</span> <span class="n">node_start</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">__meminit</span>
<span class="nf">vmemmap_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">start_page</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">pgd</span> <span class="o">=</span> <span class="n">vmemmap_pgd_populate</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">pud</span> <span class="o">=</span> <span class="n">vmemmap_pud_populate</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_pse</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
			<span class="n">pmd</span> <span class="o">=</span> <span class="n">vmemmap_pmd_populate</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="n">p</span> <span class="o">=</span> <span class="n">vmemmap_pte_populate</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="n">addr_end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">p_end</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

			<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>

				<span class="n">p</span> <span class="o">=</span> <span class="n">vmemmap_alloc_block_buf</span><span class="p">(</span><span class="n">PMD_SIZE</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

				<span class="n">entry</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
						<span class="n">PAGE_KERNEL_LARGE</span><span class="p">);</span>
				<span class="n">set_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">entry</span><span class="p">)));</span>

				<span class="cm">/* check to see if we have contiguous blocks */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">p_end</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">||</span> <span class="n">node_start</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">p_start</span><span class="p">)</span>
						<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; [%lx-%lx] PMD -&gt; [%p-%p] on node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						       <span class="n">addr_start</span><span class="p">,</span> <span class="n">addr_end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_start</span><span class="p">,</span> <span class="n">p_end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">node_start</span><span class="p">);</span>
					<span class="n">addr_start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
					<span class="n">node_start</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
					<span class="n">p_start</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">addr_end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
				<span class="n">p_end</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">vmemmap_verify</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="n">sync_global_pgds</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start_page</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__meminit</span> <span class="nf">vmemmap_populate_print_last</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; [%lx-%lx] PMD -&gt; [%p-%p] on node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">addr_start</span><span class="p">,</span> <span class="n">addr_end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_start</span><span class="p">,</span> <span class="n">p_end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">node_start</span><span class="p">);</span>
		<span class="n">p_start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">p_end</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">node_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
