<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › mm › pat.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pat.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Handle caching attributes in page tables (PAT)</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Venkatesh Pallipadi &lt;venkatesh.pallipadi@intel.com&gt;</span>
<span class="cm"> *          Suresh B Siddha &lt;suresh.b.siddha@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Loosely based on earlier PAT patchset from Eric Biederman and Andi Kleen.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>

<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/x86_init.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/fcntl.h&gt;</span>
<span class="cp">#include &lt;asm/e820.h&gt;</span>
<span class="cp">#include &lt;asm/mtrr.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/msr.h&gt;</span>
<span class="cp">#include &lt;asm/pat.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#include &quot;pat_internal.h&quot;</span>

<span class="cp">#ifdef CONFIG_X86_PAT</span>
<span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">pat_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pat_disable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pat_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nopat</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pat_disable</span><span class="p">(</span><span class="s">&quot;PAT support disabled.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;nopat&quot;</span><span class="p">,</span> <span class="n">nopat</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pat_disable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">reason</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="kt">int</span> <span class="n">pat_debug_enable</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pat_debug_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pat_debug_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;debugpat&quot;</span><span class="p">,</span> <span class="n">pat_debug_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">boot_pat_state</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">PAT_UC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* uncached */</span>
	<span class="n">PAT_WC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* Write combining */</span>
	<span class="n">PAT_WT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>		<span class="cm">/* Write Through */</span>
	<span class="n">PAT_WP</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>		<span class="cm">/* Write Protected */</span>
	<span class="n">PAT_WB</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>		<span class="cm">/* Write Back (default) */</span>
	<span class="n">PAT_UC_MINUS</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* UC, but can be overriden by MTRR */</span>
<span class="p">};</span>

<span class="cp">#define PAT(x, y)	((u64)PAT_ ## y &lt;&lt; ((x)*8))</span>

<span class="kt">void</span> <span class="nf">pat_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">pat</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">boot_cpu</span> <span class="o">=</span> <span class="o">!</span><span class="n">boot_pat_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pat_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_pat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_pat_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pat_disable</span><span class="p">(</span><span class="s">&quot;PAT not supported by CPU.&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this happens we are on a secondary CPU, but</span>
<span class="cm">			 * switched to PAT on the boot CPU. We have no way to</span>
<span class="cm">			 * undo PAT.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PAT enabled, &quot;</span>
			       <span class="s">&quot;but not supported by secondary CPU</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Set PWT to Write-Combining. All other bits stay the same */</span>
	<span class="cm">/*</span>
<span class="cm">	 * PTE encoding used in Linux:</span>
<span class="cm">	 *      PAT</span>
<span class="cm">	 *      |PCD</span>
<span class="cm">	 *      ||PWT</span>
<span class="cm">	 *      |||</span>
<span class="cm">	 *      000 WB		_PAGE_CACHE_WB</span>
<span class="cm">	 *      001 WC		_PAGE_CACHE_WC</span>
<span class="cm">	 *      010 UC-		_PAGE_CACHE_UC_MINUS</span>
<span class="cm">	 *      011 UC		_PAGE_CACHE_UC</span>
<span class="cm">	 * PAT bit unused</span>
<span class="cm">	 */</span>
	<span class="n">pat</span> <span class="o">=</span> <span class="n">PAT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">WB</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">WC</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAT</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">UC_MINUS</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">UC</span><span class="p">)</span> <span class="o">|</span>
	      <span class="n">PAT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">WB</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAT</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">WC</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAT</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">UC_MINUS</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAT</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">UC</span><span class="p">);</span>

	<span class="cm">/* Boot CPU check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_pat_state</span><span class="p">)</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_CR_PAT</span><span class="p">,</span> <span class="n">boot_pat_state</span><span class="p">);</span>

	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_CR_PAT</span><span class="p">,</span> <span class="n">pat</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;x86 PAT enabled: cpu %d, old 0x%Lx, new 0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">boot_pat_state</span><span class="p">,</span> <span class="n">pat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#undef PAT</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">memtype_lock</span><span class="p">);</span>	<span class="cm">/* protects memtype accesses */</span>

<span class="cm">/*</span>
<span class="cm"> * Does intersection of PAT memory type and MTRR memory type and returns</span>
<span class="cm"> * the resulting memory type as PAT understands it.</span>
<span class="cm"> * (Type in pat and mtrr will not have same value)</span>
<span class="cm"> * The intersection is based on &quot;Effective Memory Type&quot; tables in IA-32</span>
<span class="cm"> * SDM vol 3a</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pat_x_mtrr_type</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">req_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look for MTRR hint to get the effective type in case where PAT</span>
<span class="cm">	 * request is for WB.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req_type</span> <span class="o">==</span> <span class="n">_PAGE_CACHE_WB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">mtrr_type</span><span class="p">;</span>

		<span class="n">mtrr_type</span> <span class="o">=</span> <span class="n">mtrr_type_lookup</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtrr_type</span> <span class="o">!=</span> <span class="n">MTRR_TYPE_WRBACK</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">_PAGE_CACHE_WB</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">req_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pagerange_state</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">cur_pfn</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ram</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">not_ram</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pagerange_is_ram_callback</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">initial_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_nr_pages</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pagerange_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="n">state</span><span class="o">-&gt;</span><span class="n">not_ram</span>	<span class="o">|=</span> <span class="n">initial_pfn</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">cur_pfn</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">ram</span>	<span class="o">|=</span> <span class="n">total_nr_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">cur_pfn</span>	 <span class="o">=</span> <span class="n">initial_pfn</span> <span class="o">+</span> <span class="n">total_nr_pages</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">ram</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">not_ram</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pat_pagerange_is_ram</span><span class="p">(</span><span class="n">resource_size_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagerange_state</span> <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="n">start_pfn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * For legacy reasons, physical address range in the legacy ISA</span>
<span class="cm">	 * region is tracked as non-RAM. This will allow users of</span>
<span class="cm">	 * /dev/mem to map portions of legacy ISA region, even when</span>
<span class="cm">	 * some of those portions are listed(or not even listed) with</span>
<span class="cm">	 * different e820 types(RAM/reserved/..)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">&lt;</span> <span class="n">ISA_END_ADDRESS</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
		<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">ISA_END_ADDRESS</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_system_ram_range</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">pagerange_is_ram_callback</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">ram</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For RAM pages, we use page flags to mark the pages with appropriate type.</span>
<span class="cm"> * Here we do two pass:</span>
<span class="cm"> * - Find the memtype of all the pages in the range, look for any conflicts</span>
<span class="cm"> * - In case of no conflicts, set the new memtype for pages in the range</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reserve_ram_pages_type</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">req_type</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">new_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req_type</span> <span class="o">==</span> <span class="n">_PAGE_CACHE_UC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We do not support strong UC */</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">req_type</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span> <span class="o">++</span><span class="n">pfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">get_page_memtype</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;reserve_ram_pages_type failed [mem %#010Lx-%#010Lx], track 0x%lx, req 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">req_type</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_type</span><span class="p">)</span>
				<span class="o">*</span><span class="n">new_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_type</span><span class="p">)</span>
		<span class="o">*</span><span class="n">new_type</span> <span class="o">=</span> <span class="n">req_type</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span> <span class="o">++</span><span class="n">pfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="n">set_page_memtype</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">req_type</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">free_ram_pages_type</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span> <span class="o">++</span><span class="n">pfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="n">set_page_memtype</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * req_type typically has one of the:</span>
<span class="cm"> * - _PAGE_CACHE_WB</span>
<span class="cm"> * - _PAGE_CACHE_WC</span>
<span class="cm"> * - _PAGE_CACHE_UC_MINUS</span>
<span class="cm"> * - _PAGE_CACHE_UC</span>
<span class="cm"> *</span>
<span class="cm"> * If new_type is NULL, function will return an error if it cannot reserve the</span>
<span class="cm"> * region with req_type. If new_type is non-NULL, function will return</span>
<span class="cm"> * available type in new_type in case of no error. In case of any error</span>
<span class="cm"> * it will return a negative return value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">reserve_memtype</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">req_type</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">new_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memtype</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">actual_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_range_ram</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">);</span> <span class="cm">/* end is exclusive */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pat_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is identical to page table setting without PAT */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">req_type</span> <span class="o">==</span> <span class="n">_PAGE_CACHE_WC</span><span class="p">)</span>
				<span class="o">*</span><span class="n">new_type</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="o">*</span><span class="n">new_type</span> <span class="o">=</span> <span class="n">req_type</span> <span class="o">&amp;</span> <span class="n">_PAGE_CACHE_MASK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Low ISA region is always mapped WB in page table. No need to track */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x86_platform</span><span class="p">.</span><span class="n">is_untracked_pat_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_type</span><span class="p">)</span>
			<span class="o">*</span><span class="n">new_type</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_WB</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call mtrr_lookup to get the type hint. This is an</span>
<span class="cm">	 * optimization for /dev/mem mmap&#39;ers into WB memory (BIOS</span>
<span class="cm">	 * tools and ACPI tools). Use WB request for WB memory and use</span>
<span class="cm">	 * UC_MINUS otherwise.</span>
<span class="cm">	 */</span>
	<span class="n">actual_type</span> <span class="o">=</span> <span class="n">pat_x_mtrr_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">req_type</span> <span class="o">&amp;</span> <span class="n">_PAGE_CACHE_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_type</span><span class="p">)</span>
		<span class="o">*</span><span class="n">new_type</span> <span class="o">=</span> <span class="n">actual_type</span><span class="p">;</span>

	<span class="n">is_range_ram</span> <span class="o">=</span> <span class="n">pat_pagerange_is_ram</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_range_ram</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">reserve_ram_pages_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">req_type</span><span class="p">,</span> <span class="n">new_type</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_range_ram</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span>  <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">memtype</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">start</span>	<span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">end</span>	<span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">type</span>	<span class="o">=</span> <span class="n">actual_type</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memtype_lock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">rbt_memtype_check_insert</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">new_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;reserve_memtype failed [mem %#010Lx-%#010Lx], track %s, req %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		       <span class="n">cattr_name</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span> <span class="n">cattr_name</span><span class="p">(</span><span class="n">req_type</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memtype_lock</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memtype_lock</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;reserve_memtype added [mem %#010Lx-%#010Lx], track %s, req %s, ret %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cattr_name</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span> <span class="n">cattr_name</span><span class="p">(</span><span class="n">req_type</span><span class="p">),</span>
		<span class="n">new_type</span> <span class="o">?</span> <span class="n">cattr_name</span><span class="p">(</span><span class="o">*</span><span class="n">new_type</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;-&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">free_memtype</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_range_ram</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memtype</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pat_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Low ISA region is always mapped WB. No need to track */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x86_platform</span><span class="p">.</span><span class="n">is_untracked_pat_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">is_range_ram</span> <span class="o">=</span> <span class="n">pat_pagerange_is_ram</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_range_ram</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">free_ram_pages_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_range_ram</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memtype_lock</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">rbt_memtype_erase</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memtype_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s:%d freeing invalid memtype [mem %#010Lx-%#010Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;free_memtype request [mem %#010Lx-%#010Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lookup_memtype - Looksup the memory type for a physical address</span>
<span class="cm"> * @paddr: physical address of which memory type needs to be looked up</span>
<span class="cm"> *</span>
<span class="cm"> * Only to be called when PAT is enabled</span>
<span class="cm"> *</span>
<span class="cm"> * Returns _PAGE_CACHE_WB, _PAGE_CACHE_WC, _PAGE_CACHE_UC_MINUS or</span>
<span class="cm"> * _PAGE_CACHE_UC</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lookup_memtype</span><span class="p">(</span><span class="n">u64</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rettype</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_WB</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memtype</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_platform</span><span class="p">.</span><span class="n">is_untracked_pat_range</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rettype</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pat_pagerange_is_ram</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">rettype</span> <span class="o">=</span> <span class="n">get_page_memtype</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * -1 from get_page_memtype() implies RAM page is in its</span>
<span class="cm">		 * default state and not reserved, and hence of type WB</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rettype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">rettype</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_WB</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">rettype</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memtype_lock</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">rbt_memtype_lookup</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">rettype</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rettype</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memtype_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rettype</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * io_reserve_memtype - Request a memory type mapping for a region of memory</span>
<span class="cm"> * @start: start (physical address) of the region</span>
<span class="cm"> * @end: end (physical address) of the region</span>
<span class="cm"> * @type: A pointer to memtype, with requested type. On success, requested</span>
<span class="cm"> * or any other compatible type that was available for the region is returned</span>
<span class="cm"> *</span>
<span class="cm"> * On success, returns 0</span>
<span class="cm"> * On failure, returns non-zero</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">io_reserve_memtype</span><span class="p">(</span><span class="n">resource_size_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">end</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">resource_size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">req_type</span> <span class="o">=</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">iomem_map_sanity_check</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_memtype</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">req_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_new_memtype_allowed</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">req_type</span><span class="p">,</span> <span class="n">new_type</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_map_sync_memtype</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">new_type</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">new_type</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">free_memtype</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * io_free_memtype - Release a memory type mapping for a region of memory</span>
<span class="cm"> * @start: start (physical address) of the region</span>
<span class="cm"> * @end: end (physical address) of the region</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">io_free_memtype</span><span class="p">(</span><span class="n">resource_size_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_memtype</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">pgprot_t</span> <span class="nf">phys_mem_access_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">vma_prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vma_prot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_STRICT_DEVMEM</span>
<span class="cm">/* This check is done in drivers/char/mem.c in case of STRICT_DEVMEM*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">range_is_allowed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/* This check is needed to avoid cache aliasing when PAT is enabled */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">range_is_allowed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">from</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">pfn</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pat_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cursor</span> <span class="o">&lt;</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devmem_is_allowed</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Program %s tried to access /dev/mem between [mem %#010Lx-%#010Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cursor</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">pfn</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_STRICT_DEVMEM */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">phys_mem_access_prot_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="o">*</span><span class="n">vma_prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_WB</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">range_is_allowed</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_DSYNC</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/*</span>
<span class="cm">	 * On the PPro and successors, the MTRRs are used to set</span>
<span class="cm">	 * memory types for physical addresses outside main memory,</span>
<span class="cm">	 * so blindly setting UC or PWT on those pages is wrong.</span>
<span class="cm">	 * For Pentiums and earlier, the surround logic should disable</span>
<span class="cm">	 * caching for the high addresses through the KEN pin, but</span>
<span class="cm">	 * we maintain the tradition of paranoia in this code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pat_enabled</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_MTRR</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_K6_MTRR</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CYRIX_ARR</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CENTAUR_MCR</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">high_memory</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_UC</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="o">*</span><span class="n">vma_prot</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">((</span><span class="n">pgprot_val</span><span class="p">(</span><span class="o">*</span><span class="n">vma_prot</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">)</span> <span class="o">|</span>
			     <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change the memory type for the physial address range in kernel identity</span>
<span class="cm"> * mapping space if that range is a part of identity map.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kernel_map_sync_memtype</span><span class="p">(</span><span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">id_sz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&gt;=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">high_memory</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">id_sz</span> <span class="o">=</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">high_memory</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">__pa</span><span class="p">(</span><span class="n">high_memory</span><span class="p">)</span> <span class="o">-</span> <span class="n">base</span> <span class="o">:</span>
				<span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioremap_change_attr</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="n">id_sz</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s:%d ioremap_change_attr failed %s &quot;</span>
			<span class="s">&quot;for [mem %#010Lx-%#010Lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
			<span class="n">cattr_name</span><span class="p">(</span><span class="n">flags</span><span class="p">),</span>
			<span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Internal interface to reserve a range of physical memory with prot.</span>
<span class="cm"> * Reserved non RAM regions only and after successful reserve_memtype,</span>
<span class="cm"> * this func also keeps identity mapping (if any) in sync with this new prot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reserve_pfn_range</span><span class="p">(</span><span class="n">u64</span> <span class="n">paddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="o">*</span><span class="n">vma_prot</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">strict_prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">is_ram</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">want_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="o">*</span><span class="n">vma_prot</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_CACHE_MASK</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">want_flags</span><span class="p">;</span>

	<span class="n">is_ram</span> <span class="o">=</span> <span class="n">pat_pagerange_is_ram</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * reserve_pfn_range() for RAM pages. We do not refcount to keep</span>
<span class="cm">	 * track of number of mappings of RAM pages. We can assert that</span>
<span class="cm">	 * the type requested matches the type of first page in the range.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ram</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pat_enabled</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">flags</span> <span class="o">=</span> <span class="n">lookup_memtype</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want_flags</span> <span class="o">!=</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:%d map pfn RAM range req %s for [mem %#010Lx-%#010Lx], got %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="n">cattr_name</span><span class="p">(</span><span class="n">want_flags</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">paddr</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">cattr_name</span><span class="p">(</span><span class="n">flags</span><span class="p">));</span>
			<span class="o">*</span><span class="n">vma_prot</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">((</span><span class="n">pgprot_val</span><span class="p">(</span><span class="o">*</span><span class="n">vma_prot</span><span class="p">)</span> <span class="o">&amp;</span>
					      <span class="p">(</span><span class="o">~</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">))</span> <span class="o">|</span>
					     <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_memtype</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">want_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">want_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strict_prot</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">is_new_memtype_allowed</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">want_flags</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">free_memtype</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s:%d map pfn expected mapping type %s&quot;</span>
				<span class="s">&quot; for [mem %#010Lx-%#010Lx], got %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				<span class="n">cattr_name</span><span class="p">(</span><span class="n">want_flags</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">paddr</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">cattr_name</span><span class="p">(</span><span class="n">flags</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We allow returning different type than the one requested in</span>
<span class="cm">		 * non strict case.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">vma_prot</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">((</span><span class="n">pgprot_val</span><span class="p">(</span><span class="o">*</span><span class="n">vma_prot</span><span class="p">)</span> <span class="o">&amp;</span>
				      <span class="p">(</span><span class="o">~</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">))</span> <span class="o">|</span>
				     <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_map_sync_memtype</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_memtype</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Internal interface to free a range of physical memory.</span>
<span class="cm"> * Frees non RAM regions only.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_pfn_range</span><span class="p">(</span><span class="n">u64</span> <span class="n">paddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">is_ram</span><span class="p">;</span>

	<span class="n">is_ram</span> <span class="o">=</span> <span class="n">pat_pagerange_is_ram</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ram</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_memtype</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * track_pfn_vma_copy is called when vma that is covering the pfnmap gets</span>
<span class="cm"> * copied through copy_page_range().</span>
<span class="cm"> *</span>
<span class="cm"> * If the vma has a linear pfn mapping for the entire range, we get the prot</span>
<span class="cm"> * from pte and reserve the entire vma range with single reserve_pfn_range call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">track_pfn_vma_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">resource_size_t</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vma_size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_linear_pfn_mapping</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * reserve the whole chunk covered by vma. We need the</span>
<span class="cm">		 * starting address and protection from pte.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">follow_phys</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">paddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pgprot</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">reserve_pfn_range</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">vma_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgprot</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * track_pfn_vma_new is called when a _new_ pfn mapping is being established</span>
<span class="cm"> * for physical range indicated by pfn and size.</span>
<span class="cm"> *</span>
<span class="cm"> * prot is passed in as a parameter for the new mapping. If the vma has a</span>
<span class="cm"> * linear pfn mapping for the entire range reserve the entire vma range with</span>
<span class="cm"> * single reserve_pfn_range call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">track_pfn_vma_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vma_size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_linear_pfn_mapping</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* reserve the whole chunk starting from vm_pgoff */</span>
		<span class="n">paddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">resource_size_t</span><span class="p">)</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">reserve_pfn_range</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">vma_size</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pat_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* for vm_insert_pfn and friends, we set prot based on lookup */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">lookup_memtype</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">((</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">))</span> <span class="o">|</span>
			 <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * untrack_pfn_vma is called while unmapping a pfnmap for a region.</span>
<span class="cm"> * untrack can be called for a specific region indicated by pfn and size or</span>
<span class="cm"> * can be for the entire vma (in which case size can be zero).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">untrack_pfn_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">resource_size_t</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vma_size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_linear_pfn_mapping</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* free the whole chunk starting from vm_pgoff */</span>
		<span class="n">paddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">resource_size_t</span><span class="p">)</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">free_pfn_range</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">vma_size</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">pgprot_t</span> <span class="nf">pgprot_writecombine</span><span class="p">(</span><span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pat_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_CACHE_WC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pgprot_writecombine</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_DEBUG_FS) &amp;&amp; defined(CONFIG_X86_PAT)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">memtype</span> <span class="o">*</span><span class="nf">memtype_get_idx</span><span class="p">(</span><span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memtype</span> <span class="o">*</span><span class="n">print_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">print_entry</span>  <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">memtype</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">print_entry</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memtype_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rbt_memtype_copy_nth_element</span><span class="p">(</span><span class="n">print_entry</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memtype_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">print_entry</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">print_entry</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">memtype_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;PAT memtype list:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">memtype_get_idx</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">memtype_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">memtype_get_idx</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">memtype_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">memtype_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memtype</span> <span class="o">*</span><span class="n">print_entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">memtype</span> <span class="o">*</span><span class="p">)</span><span class="n">v</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%s @ 0x%Lx-0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cattr_name</span><span class="p">(</span><span class="n">print_entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span>
			<span class="n">print_entry</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">print_entry</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">print_entry</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">memtype_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">memtype_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">memtype_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">memtype_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">memtype_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">memtype_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memtype_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">memtype_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">memtype_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pat_memtype_list_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pat_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;pat_memtype_list&quot;</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">,</span>
				    <span class="n">arch_debugfs_dir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memtype_fops</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">pat_memtype_list_init</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_FS &amp;&amp; CONFIG_X86_PAT */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
