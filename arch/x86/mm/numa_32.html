<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › mm › numa_32.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>numa_32.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Written by: Patricia Gaughen &lt;gone@us.ibm.com&gt;, IBM Corporation</span>
<span class="cm"> * August 2002: added remote node KVA remap - Martin J. Bligh </span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, IBM Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * All rights reserved.          </span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &quot;numa_internal.h&quot;</span>

<span class="cp">#ifdef CONFIG_DISCONTIGMEM</span>
<span class="cm">/*</span>
<span class="cm"> * 4) physnode_map     - the mapping between a pfn and owning node</span>
<span class="cm"> * physnode_map keeps track of the physical memory layout of a generic</span>
<span class="cm"> * numa node on a 64Mb break (each element of the array will</span>
<span class="cm"> * represent 64Mb of memory and will be marked by the node id.  so,</span>
<span class="cm"> * if the first gig is on node 0, and the second gig is on node 1</span>
<span class="cm"> * physnode_map will contain:</span>
<span class="cm"> *</span>
<span class="cm"> *     physnode_map[0-15] = 0;</span>
<span class="cm"> *     physnode_map[16-31] = 1;</span>
<span class="cm"> *     physnode_map[32- ] = -1;</span>
<span class="cm"> */</span>
<span class="n">s8</span> <span class="n">physnode_map</span><span class="p">[</span><span class="n">MAX_SECTIONS</span><span class="p">]</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">MAX_SECTIONS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">physnode_map</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">memory_present</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Node: %d, start_pfn: %lx, end_pfn: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">nid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  Setting physnode_map array to node %d for pfns:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">+=</span> <span class="n">PAGES_PER_SECTION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">physnode_map</span><span class="p">[</span><span class="n">pfn</span> <span class="o">/</span> <span class="n">PAGES_PER_SECTION</span><span class="p">]</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%lx &quot;</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">node_memmap_size_bytes</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">highend_pfn</span><span class="p">,</span> <span class="n">highstart_pfn</span><span class="p">;</span>

<span class="cp">#define LARGE_PAGE_BYTES (PTRS_PER_PTE * PAGE_SIZE)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node_remap_start_vaddr</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="kt">void</span> <span class="n">set_pmd_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Remap memory allocator</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_remap_start_pfn</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node_remap_end_vaddr</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node_remap_alloc_vaddr</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_remap - Allocate remapped memory</span>
<span class="cm"> * @nid: NUMA node to allocate memory from</span>
<span class="cm"> * @size: The size of allocation</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate @size bytes from the remap area of NUMA node @nid.  The</span>
<span class="cm"> * size of the remap area is predetermined by init_alloc_remap() and</span>
<span class="cm"> * only the callers considered there should call this function.  For</span>
<span class="cm"> * more info, please read the comment on top of init_alloc_remap().</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must be ready to handle allocation failure from this</span>
<span class="cm"> * function and fall back to regular memory allocator in such cases.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Single CPU early boot context.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to the allocated memory on success, %NULL on failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_remap</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">allocation</span> <span class="o">=</span> <span class="n">node_remap_alloc_vaddr</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">L1_CACHE_BYTES</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allocation</span> <span class="o">||</span> <span class="p">(</span><span class="n">allocation</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">node_remap_end_vaddr</span><span class="p">[</span><span class="n">nid</span><span class="p">])</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">node_remap_alloc_vaddr</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">allocation</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">allocation</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIBERNATION</span>
<span class="cm">/**</span>
<span class="cm"> * resume_map_numa_kva - add KVA mapping to the temporary page tables created</span>
<span class="cm"> *                       during resume from hibernation</span>
<span class="cm"> * @pgd_base - temporary resume page directory</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">resume_map_numa_kva</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_va</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">pfn</span><span class="p">;</span>

		<span class="n">start_va</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">node_remap_start_vaddr</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">node_remap_start_pfn</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_remap_end_vaddr</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">-</span>
			    <span class="n">node_remap_start_vaddr</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">+=</span> <span class="n">PTRS_PER_PTE</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="n">start_va</span> <span class="o">+</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_base</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
			<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
			<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>

			<span class="n">set_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">pfn_pmd</span><span class="p">(</span><span class="n">start_pfn</span> <span class="o">+</span> <span class="n">pfn</span><span class="p">,</span>
						<span class="n">PAGE_KERNEL_LARGE_EXEC</span><span class="p">));</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: %08lx -&gt; pfn %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">start_pfn</span> <span class="o">+</span> <span class="n">pfn</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * init_alloc_remap - Initialize remap allocator for a NUMA node</span>
<span class="cm"> * @nid: NUMA node to initizlie remap allocator for</span>
<span class="cm"> *</span>
<span class="cm"> * NUMA nodes may end up without any lowmem.  As allocating pgdat and</span>
<span class="cm"> * memmap on a different node with lowmem is inefficient, a special</span>
<span class="cm"> * remap allocator is implemented which can be used by alloc_remap().</span>
<span class="cm"> *</span>
<span class="cm"> * For each node, the amount of memory which will be necessary for</span>
<span class="cm"> * pgdat and memmap is calculated and two memory areas of the size are</span>
<span class="cm"> * allocated - one in the node and the other in lowmem; then, the area</span>
<span class="cm"> * in the node is remapped to the lowmem area.</span>
<span class="cm"> *</span>
<span class="cm"> * As pgdat and memmap must be allocated in lowmem anyway, this</span>
<span class="cm"> * doesn&#39;t waste lowmem address space; however, the actual lowmem</span>
<span class="cm"> * which gets remapped over is wasted.  The amount shouldn&#39;t be</span>
<span class="cm"> * problematic on machines this feature will be used.</span>
<span class="cm"> *</span>
<span class="cm"> * Initialization failure isn&#39;t fatal.  alloc_remap() is used</span>
<span class="cm"> * opportunistically and the callers will fall back to other memory</span>
<span class="cm"> * allocation mechanisms on failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_alloc_remap</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">node_pa</span><span class="p">,</span> <span class="n">remap_pa</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">remap_va</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The acpi/srat node info can show hot-add memroy zones where</span>
<span class="cm">	 * memory could be added but not currently present.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;node %d pfn: [%lx - %lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">nid</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>

	<span class="cm">/* calculate the necessary space aligned to large page size */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">node_memmap_size_bytes</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pg_data_t</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">LARGE_PAGE_BYTES</span><span class="p">);</span>

	<span class="cm">/* allocate node memory and the lowmem remap area */</span>
	<span class="n">node_pa</span> <span class="o">=</span> <span class="n">memblock_find_in_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">LARGE_PAGE_BYTES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_pa</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;remap_alloc: failed to allocate %lu bytes for node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">size</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">node_pa</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">remap_pa</span> <span class="o">=</span> <span class="n">memblock_find_in_range</span><span class="p">(</span><span class="n">min_low_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
					  <span class="n">max_low_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
					  <span class="n">size</span><span class="p">,</span> <span class="n">LARGE_PAGE_BYTES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remap_pa</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;remap_alloc: failed to allocate %lu bytes remap area for node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">size</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">memblock_free</span><span class="p">(</span><span class="n">node_pa</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">remap_pa</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">remap_va</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">remap_pa</span><span class="p">);</span>

	<span class="cm">/* perform actual remap */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">+=</span> <span class="n">PTRS_PER_PTE</span><span class="p">)</span>
		<span class="n">set_pmd_pfn</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">remap_va</span> <span class="o">+</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span>
			    <span class="p">(</span><span class="n">node_pa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">pfn</span><span class="p">,</span>
			    <span class="n">PAGE_KERNEL_LARGE</span><span class="p">);</span>

	<span class="cm">/* initialize remap allocator parameters */</span>
	<span class="n">node_remap_start_pfn</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_pa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">node_remap_start_vaddr</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">remap_va</span><span class="p">;</span>
	<span class="n">node_remap_end_vaddr</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">remap_va</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">node_remap_alloc_vaddr</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">remap_va</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;remap_alloc: node %d [%08llx-%08llx) -&gt; [%p-%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">nid</span><span class="p">,</span> <span class="n">node_pa</span><span class="p">,</span> <span class="n">node_pa</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">remap_va</span><span class="p">,</span> <span class="n">remap_va</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">initmem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x86_numa_init</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">highstart_pfn</span> <span class="o">=</span> <span class="n">highend_pfn</span> <span class="o">=</span> <span class="n">max_pfn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_pfn</span> <span class="o">&gt;</span> <span class="n">max_low_pfn</span><span class="p">)</span>
		<span class="n">highstart_pfn</span> <span class="o">=</span> <span class="n">max_low_pfn</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%ldMB HIGHMEM available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">pages_to_mb</span><span class="p">(</span><span class="n">highend_pfn</span> <span class="o">-</span> <span class="n">highstart_pfn</span><span class="p">));</span>
	<span class="n">num_physpages</span> <span class="o">=</span> <span class="n">highend_pfn</span><span class="p">;</span>
	<span class="n">high_memory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">highstart_pfn</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">num_physpages</span> <span class="o">=</span> <span class="n">max_low_pfn</span><span class="p">;</span>
	<span class="n">high_memory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">max_low_pfn</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%ldMB LOWMEM available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pages_to_mb</span><span class="p">(</span><span class="n">max_low_pfn</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;max_low_pfn = %lx, highstart_pfn = %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">max_low_pfn</span><span class="p">,</span> <span class="n">highstart_pfn</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Low memory ends at vaddr %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">max_low_pfn</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;High memory starts at vaddr %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">highstart_pfn</span><span class="p">));</span>

	<span class="n">setup_bootmem_allocator</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
