<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › mm › pageattr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pageattr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2002 Andi Kleen, SuSE Labs.</span>
<span class="cm"> * Thanks to Ben LaHaise for precious feedback.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>

<span class="cp">#include &lt;asm/e820.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/proto.h&gt;</span>
<span class="cp">#include &lt;asm/pat.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The current flushing context - we pass it instead of 5 arguments:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cpa_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="n">pgprot_t</span>	<span class="n">mask_set</span><span class="p">;</span>
	<span class="n">pgprot_t</span>	<span class="n">mask_clr</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">numpages</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">force_split</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">curpage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span>	<span class="o">**</span><span class="n">pages</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Serialize cpa() (for !DEBUG_PAGEALLOC which uses large identity mappings)</span>
<span class="cm"> * using cpa_lock. So that we don&#39;t allow any other cpu, with stale large tlb</span>
<span class="cm"> * entries change the page attribute in parallel to some other cpu</span>
<span class="cm"> * splitting a large page entry along with changing the attribute.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cpa_lock</span><span class="p">);</span>

<span class="cp">#define CPA_FLUSHTLB 1</span>
<span class="cp">#define CPA_ARRAY 2</span>
<span class="cp">#define CPA_PAGES_ARRAY 4</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">direct_pages_count</span><span class="p">[</span><span class="n">PG_LEVEL_NUM</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">update_page_count</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Protect against CPA */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>
	<span class="n">direct_pages_count</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">split_page_count</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">direct_pages_count</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
	<span class="n">direct_pages_count</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">PTRS_PER_PTE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_report_meminfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DirectMap4k:    %8lu kB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">direct_pages_count</span><span class="p">[</span><span class="n">PG_LEVEL_4K</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DirectMap2M:    %8lu kB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">direct_pages_count</span><span class="p">[</span><span class="n">PG_LEVEL_2M</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DirectMap4M:    %8lu kB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">direct_pages_count</span><span class="p">[</span><span class="n">PG_LEVEL_2M</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direct_gbpages</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DirectMap1G:    %8lu kB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">direct_pages_count</span><span class="p">[</span><span class="n">PG_LEVEL_1G</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">split_page_count</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_64</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">highmap_start_pfn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pa</span><span class="p">(</span><span class="n">_text</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">highmap_end_pfn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pa</span><span class="p">(</span><span class="n">roundup</span><span class="p">(</span><span class="n">_brk_end</span><span class="p">,</span> <span class="n">PMD_SIZE</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
<span class="cp"># define debug_pagealloc 1</span>
<span class="cp">#else</span>
<span class="cp"># define debug_pagealloc 0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">within</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flushing functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * clflush_cache_range - flush a cache range with clflush</span>
<span class="cm"> * @vaddr:	virtual start address</span>
<span class="cm"> * @size:	number of bytes to flush</span>
<span class="cm"> *</span>
<span class="cm"> * clflush is an unordered instruction which needs fencing with mfence</span>
<span class="cm"> * to avoid ordering issues.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clflush_cache_range</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vend</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">vend</span><span class="p">;</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_clflush_size</span><span class="p">)</span>
		<span class="n">clflush</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Flush any possible final partial cacheline:</span>
<span class="cm">	 */</span>
	<span class="n">clflush</span><span class="p">(</span><span class="n">vend</span><span class="p">);</span>

	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clflush_cache_range</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cpa_flush_all</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cache</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush all to work around Errata in early athlons regarding</span>
<span class="cm">	 * large page flushing.</span>
<span class="cm">	 */</span>
	<span class="n">__flush_tlb_all</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span> <span class="o">&amp;&amp;</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">wbinvd</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpa_flush_all</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">__cpa_flush_all</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">cache</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cpa_flush_range</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We could optimize that further and do individual per page</span>
<span class="cm">	 * tlb invalidates for a low number of pages. Caveat: we must</span>
<span class="cm">	 * flush the high aliases on 64bit as well.</span>
<span class="cm">	 */</span>
	<span class="n">__flush_tlb_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpa_flush_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">start</span><span class="p">);</span>

	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">__cpa_flush_range</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only need to flush on one CPU,</span>
<span class="cm">	 * clflush is a MESI-coherent instruction that</span>
<span class="cm">	 * will cause all other CPUs to flush the same</span>
<span class="cm">	 * cachelines:</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numpages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Only flush present addresses:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_PRESENT</span><span class="p">))</span>
			<span class="n">clflush_cache_range</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpa_flush_array</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cache</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">in_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">do_wbinvd</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">&amp;&amp;</span> <span class="n">numpages</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">;</span> <span class="cm">/* 4M threshold */</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">__cpa_flush_all</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">do_wbinvd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span> <span class="o">||</span> <span class="n">do_wbinvd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only need to flush on one CPU,</span>
<span class="cm">	 * clflush is a MESI-coherent instruction that</span>
<span class="cm">	 * will cause all other CPUs to flush the same</span>
<span class="cm">	 * cachelines:</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numpages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_flags</span> <span class="o">&amp;</span> <span class="n">CPA_PAGES_ARRAY</span><span class="p">)</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Only flush present addresses:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_PRESENT</span><span class="p">))</span>
			<span class="n">clflush_cache_range</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Certain areas of memory on x86 require very specific protection flags,</span>
<span class="cm"> * for example the BIOS area or kernel text. Callers don&#39;t always get this</span>
<span class="cm"> * right (again, ioremap() on BIOS memory is not uncommon) so this function</span>
<span class="cm"> * checks and fixes these known static required protection bits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgprot_t</span> <span class="nf">static_protections</span><span class="p">(</span><span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgprot_t</span> <span class="n">forbidden</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The BIOS area between 640k and 1Mb needs to be executable for</span>
<span class="cm">	 * PCI BIOS based config access (CONFIG_PCI_GOBIOS) support.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_PCI_BIOS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcibios_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">within</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">BIOS_BEGIN</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">BIOS_END</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="n">pgprot_val</span><span class="p">(</span><span class="n">forbidden</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_NX</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * The kernel text needs to be executable for obvious reasons</span>
<span class="cm">	 * Does not cover __inittext since that is gone later on. On</span>
<span class="cm">	 * 64bit we do not enforce !NX on the low mapping</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">within</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_text</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_etext</span><span class="p">))</span>
		<span class="n">pgprot_val</span><span class="p">(</span><span class="n">forbidden</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_NX</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The .rodata section needs to be read-only. Using the pfn</span>
<span class="cm">	 * catches all aliases.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">within</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">__pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__start_rodata</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
		   <span class="n">__pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__end_rodata</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="n">pgprot_val</span><span class="p">(</span><span class="n">forbidden</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_RW</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_X86_64) &amp;&amp; defined(CONFIG_DEBUG_RODATA)</span>
	<span class="cm">/*</span>
<span class="cm">	 * Once the kernel maps the text as RO (kernel_set_to_readonly is set),</span>
<span class="cm">	 * kernel text mappings for the large page aligned text, rodata sections</span>
<span class="cm">	 * will be always read-only. For the kernel identity mappings covering</span>
<span class="cm">	 * the holes caused by this alignment can be anything that user asks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This will preserve the large page mappings for kernel text/data</span>
<span class="cm">	 * at no extra cost.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_set_to_readonly</span> <span class="o">&amp;&amp;</span>
	    <span class="n">within</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_text</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__end_rodata_hpage_align</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t enforce the !RW mapping for the kernel text mapping,</span>
<span class="cm">		 * if the current mapping is already using small page mapping.</span>
<span class="cm">		 * No need to work hard to preserve large page mappings in this</span>
<span class="cm">		 * case.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This also fixes the Linux Xen paravirt guest boot failure</span>
<span class="cm">		 * (because of unexpected read-only mappings for kernel identity</span>
<span class="cm">		 * mappings). In this paravirt guest case, the kernel text</span>
<span class="cm">		 * mapping and the kernel identity mapping share the same</span>
<span class="cm">		 * page-table pages. Thus we can&#39;t really use different</span>
<span class="cm">		 * protections for the kernel text and identity mappings. Also,</span>
<span class="cm">		 * these shared mappings are made of small page mappings.</span>
<span class="cm">		 * Thus this don&#39;t enforce !RW mapping for small page kernel</span>
<span class="cm">		 * text mapping logic will help Linux Xen parvirt guest boot</span>
<span class="cm">		 * as well.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">PG_LEVEL_4K</span><span class="p">))</span>
			<span class="n">pgprot_val</span><span class="p">(</span><span class="n">forbidden</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_RW</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">prot</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">forbidden</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">prot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup the page table entry for a virtual address. Return a pointer</span>
<span class="cm"> * to the entry and the level of the mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: We return pud and pmd either when the entry is marked large</span>
<span class="cm"> * or when the present bit is not set. Otherwise we would return a</span>
<span class="cm"> * pointer to a nonexisting mapping.</span>
<span class="cm"> */</span>
<span class="n">pte_t</span> <span class="o">*</span><span class="nf">lookup_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

	<span class="o">*</span><span class="n">level</span> <span class="o">=</span> <span class="n">PG_LEVEL_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">level</span> <span class="o">=</span> <span class="n">PG_LEVEL_1G</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_large</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pud</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">level</span> <span class="o">=</span> <span class="n">PG_LEVEL_2M</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_large</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">;</span>

	<span class="o">*</span><span class="n">level</span> <span class="o">=</span> <span class="n">PG_LEVEL_4K</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lookup_address</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Set the new pmd in all the pgds we know about:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__set_pmd_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">kpte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* change init_mm */</span>
	<span class="n">set_pte_atomic</span><span class="p">(</span><span class="n">kpte</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SHARED_KERNEL_PMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgd_list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
			<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
			<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

			<span class="n">pgd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
			<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="n">set_pte_atomic</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">try_preserve_large_page</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">kpte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cpa_data</span> <span class="o">*</span><span class="n">cpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nextpage_addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">pmask</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">new_pte</span><span class="p">,</span> <span class="n">old_pte</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">pgprot_t</span> <span class="n">old_prot</span><span class="p">,</span> <span class="n">new_prot</span><span class="p">,</span> <span class="n">req_prot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">do_split</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">force_split</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for races, another CPU might have split this page</span>
<span class="cm">	 * up already:</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">kpte</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PG_LEVEL_2M</span>:
		<span class="n">psize</span> <span class="o">=</span> <span class="n">PMD_PAGE_SIZE</span><span class="p">;</span>
		<span class="n">pmask</span> <span class="o">=</span> <span class="n">PMD_PAGE_MASK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">case</span> <span class="n">PG_LEVEL_1G</span>:
		<span class="n">psize</span> <span class="o">=</span> <span class="n">PUD_PAGE_SIZE</span><span class="p">;</span>
		<span class="n">pmask</span> <span class="o">=</span> <span class="n">PUD_PAGE_MASK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="nl">default:</span>
		<span class="n">do_split</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the number of pages, which fit into this large</span>
<span class="cm">	 * page starting at address:</span>
<span class="cm">	 */</span>
	<span class="n">nextpage_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">psize</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pmask</span><span class="p">;</span>
	<span class="n">numpages</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextpage_addr</span> <span class="o">-</span> <span class="n">address</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numpages</span> <span class="o">&lt;</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span><span class="p">)</span>
		<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span> <span class="o">=</span> <span class="n">numpages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are safe now. Check whether the new pgprot is the same:</span>
<span class="cm">	 */</span>
	<span class="n">old_pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">kpte</span><span class="p">;</span>
	<span class="n">old_prot</span> <span class="o">=</span> <span class="n">new_prot</span> <span class="o">=</span> <span class="n">req_prot</span> <span class="o">=</span> <span class="n">pte_pgprot</span><span class="p">(</span><span class="n">old_pte</span><span class="p">);</span>

	<span class="n">pgprot_val</span><span class="p">(</span><span class="n">req_prot</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">mask_clr</span><span class="p">);</span>
	<span class="n">pgprot_val</span><span class="p">(</span><span class="n">req_prot</span><span class="p">)</span> <span class="o">|=</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">mask_set</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * old_pte points to the large page base address. So we need</span>
<span class="cm">	 * to add the offset of the virtual address:</span>
<span class="cm">	 */</span>
	<span class="n">pfn</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">old_pte</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">address</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">psize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="n">new_prot</span> <span class="o">=</span> <span class="n">static_protections</span><span class="p">(</span><span class="n">req_prot</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to check the full range, whether</span>
<span class="cm">	 * static_protection() requires a different pgprot for one of</span>
<span class="cm">	 * the pages in the range we try to preserve:</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">pmask</span><span class="p">;</span>
	<span class="n">pfn</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">old_pte</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">psize</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">pfn</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgprot_t</span> <span class="n">chk_prot</span> <span class="o">=</span> <span class="n">static_protections</span><span class="p">(</span><span class="n">req_prot</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">chk_prot</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">new_prot</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are no changes, return. maxpages has been updated</span>
<span class="cm">	 * above:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">new_prot</span><span class="p">)</span> <span class="o">==</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">old_prot</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">do_split</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to change the attributes. Check, whether we can</span>
<span class="cm">	 * change the large page in one go. We request a split, when</span>
<span class="cm">	 * the address is not aligned and the number of pages is</span>
<span class="cm">	 * smaller than the number of pages in the large page. Note</span>
<span class="cm">	 * that we limited the number of possible pages already to</span>
<span class="cm">	 * the number of pages in the large page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">pmask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span> <span class="o">==</span> <span class="p">(</span><span class="n">psize</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The address is aligned and the number of pages</span>
<span class="cm">		 * covers the full page.</span>
<span class="cm">		 */</span>
		<span class="n">new_pte</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="n">old_pte</span><span class="p">),</span> <span class="n">canon_pgprot</span><span class="p">(</span><span class="n">new_prot</span><span class="p">));</span>
		<span class="n">__set_pmd_pte</span><span class="p">(</span><span class="n">kpte</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">new_pte</span><span class="p">);</span>
		<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CPA_FLUSHTLB</span><span class="p">;</span>
		<span class="n">do_split</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">do_split</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">split_large_page</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">kpte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pfninc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pbase</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">pgprot_t</span> <span class="n">ref_prot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_pagealloc</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpa_lock</span><span class="p">);</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NOTRACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_pagealloc</span><span class="p">)</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpa_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for races, another CPU might have split this page</span>
<span class="cm">	 * up for us already:</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">kpte</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">pbase</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="n">paravirt_alloc_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">base</span><span class="p">));</span>
	<span class="n">ref_prot</span> <span class="o">=</span> <span class="n">pte_pgprot</span><span class="p">(</span><span class="n">pte_clrhuge</span><span class="p">(</span><span class="o">*</span><span class="n">kpte</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we ever want to utilize the PAT bit, we need to</span>
<span class="cm">	 * update this function to make sure it&#39;s converted from</span>
<span class="cm">	 * bit 12 to bit 7 when we cross from the 2MB level to</span>
<span class="cm">	 * the 4K level:</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">ref_prot</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_PAT_LARGE</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PG_LEVEL_1G</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfninc</span> <span class="o">=</span> <span class="n">PMD_PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">pgprot_val</span><span class="p">(</span><span class="n">ref_prot</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_PSE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the target pfn from the original entry:</span>
<span class="cm">	 */</span>
	<span class="n">pfn</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">kpte</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">pfn</span> <span class="o">+=</span> <span class="n">pfninc</span><span class="p">)</span>
		<span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbase</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">ref_prot</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">address</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">max_low_pfn_mapped</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="n">split_page_count</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">address</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">max_pfn_mapped</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="n">split_page_count</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Install the new, split up pagetable.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We use the standard kernel pagetable protections for the new</span>
<span class="cm">	 * pagetable protections, the actual ptes set above control the</span>
<span class="cm">	 * primary protection behavior:</span>
<span class="cm">	 */</span>
	<span class="n">__set_pmd_pte</span><span class="p">(</span><span class="n">kpte</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">_KERNPG_TABLE</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Intel Atom errata AAH41 workaround.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The real fix should be in hw or in a microcode update, but</span>
<span class="cm">	 * we also probabilistically try to reduce the window of having</span>
<span class="cm">	 * a large TLB mixed with 4K TLBs while instruction fetches are</span>
<span class="cm">	 * going on.</span>
<span class="cm">	 */</span>
	<span class="n">__flush_tlb_all</span><span class="p">();</span>

	<span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we dropped out via the lookup_address check under</span>
<span class="cm">	 * pgd_lock then stick the page back into the pool:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cpa_process_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpa_data</span> <span class="o">*</span><span class="n">cpa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">primary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ignore all non primary paths.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">primary</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ignore the NULL PTE for kernel identity mapping, as it is expected</span>
<span class="cm">	 * to have holes.</span>
<span class="cm">	 * Also set numpages to &#39;1&#39; indicating that we processed cpa req for</span>
<span class="cm">	 * one virtual address page and its pfn. TBD: numpages can be set based</span>
<span class="cm">	 * on the initial value and the level returned by lookup_address().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">within</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">PAGE_OFFSET</span><span class="p">,</span>
		   <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_pfn_mapped</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vaddr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_WARNING</span> <span class="s">&quot;CPA: called for zero pte. &quot;</span>
			<span class="s">&quot;vaddr = %lx cpa-&gt;vaddr = %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span>
			<span class="o">*</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__change_page_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpa_data</span> <span class="o">*</span><span class="n">cpa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">primary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_split</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">kpte</span><span class="p">,</span> <span class="n">old_pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CPA_PAGES_ARRAY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">curpage</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CPA_ARRAY</span><span class="p">)</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">[</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">curpage</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">address</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">;</span>
<span class="nl">repeat:</span>
	<span class="n">kpte</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kpte</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__cpa_process_fault</span><span class="p">(</span><span class="n">cpa</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">primary</span><span class="p">);</span>

	<span class="n">old_pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">kpte</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_val</span><span class="p">(</span><span class="n">old_pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__cpa_process_fault</span><span class="p">(</span><span class="n">cpa</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">primary</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PG_LEVEL_4K</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">new_pte</span><span class="p">;</span>
		<span class="n">pgprot_t</span> <span class="n">new_prot</span> <span class="o">=</span> <span class="n">pte_pgprot</span><span class="p">(</span><span class="n">old_pte</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">old_pte</span><span class="p">);</span>

		<span class="n">pgprot_val</span><span class="p">(</span><span class="n">new_prot</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">mask_clr</span><span class="p">);</span>
		<span class="n">pgprot_val</span><span class="p">(</span><span class="n">new_prot</span><span class="p">)</span> <span class="o">|=</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">mask_set</span><span class="p">);</span>

		<span class="n">new_prot</span> <span class="o">=</span> <span class="n">static_protections</span><span class="p">(</span><span class="n">new_prot</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to keep the pfn from the existing PTE,</span>
<span class="cm">		 * after all we&#39;re only going to change it&#39;s attributes</span>
<span class="cm">		 * not the memory it points to</span>
<span class="cm">		 */</span>
		<span class="n">new_pte</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">canon_pgprot</span><span class="p">(</span><span class="n">new_prot</span><span class="p">));</span>
		<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do we really change anything ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">old_pte</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">new_pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_pte_atomic</span><span class="p">(</span><span class="n">kpte</span><span class="p">,</span> <span class="n">new_pte</span><span class="p">);</span>
			<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CPA_FLUSHTLB</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check, whether we can keep the large page intact</span>
<span class="cm">	 * and just change the pte:</span>
<span class="cm">	 */</span>
	<span class="n">do_split</span> <span class="o">=</span> <span class="n">try_preserve_large_page</span><span class="p">(</span><span class="n">kpte</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">cpa</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * When the range fits into the existing large page,</span>
<span class="cm">	 * return. cp-&gt;numpages and cpa-&gt;tlbflush have been updated in</span>
<span class="cm">	 * try_large_page:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_split</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">do_split</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to split the large page:</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">split_large_page</span><span class="p">(</span><span class="n">kpte</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">	 	 * Do a global flush tlb after splitting the large page</span>
<span class="cm">	 	 * and before we do the actual change page attribute in the PTE.</span>
<span class="cm">	 	 *</span>
<span class="cm">	 	 * With out this, we violate the TLB application note, that says</span>
<span class="cm">	 	 * &quot;The TLBs may contain both ordinary and large-page</span>
<span class="cm">		 *  translations for a 4-KByte range of linear addresses. This</span>
<span class="cm">		 *  may occur if software modifies the paging structures so that</span>
<span class="cm">		 *  the page size used for the address range changes. If the two</span>
<span class="cm">		 *  translations differ with respect to page frame or attributes</span>
<span class="cm">		 *  (e.g., permissions), processor behavior is undefined and may</span>
<span class="cm">		 *  be implementation-specific.&quot;</span>
<span class="cm">	 	 *</span>
<span class="cm">	 	 * We do this global tlb flush inside the cpa_lock, so that we</span>
<span class="cm">		 * don&#39;t allow any other cpu, with stale tlb entries change the</span>
<span class="cm">		 * page attribute in parallel, that also falls into the</span>
<span class="cm">		 * just split large page entry.</span>
<span class="cm">	 	 */</span>
		<span class="n">flush_tlb_all</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__change_page_attr_set_clr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpa_data</span> <span class="o">*</span><span class="n">cpa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">checkalias</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpa_process_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpa_data</span> <span class="o">*</span><span class="n">cpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpa_data</span> <span class="n">alias_cpa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">laddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">max_pfn_mapped</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">max_low_pfn_mapped</span> <span class="o">&amp;&amp;</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">PAGE_SHIFT</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * No need to redo, when the primary call touched the direct</span>
<span class="cm">	 * mapping already:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CPA_PAGES_ARRAY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">curpage</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CPA_ARRAY</span><span class="p">)</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">[</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">curpage</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">within</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">PAGE_OFFSET</span><span class="p">,</span>
		    <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_pfn_mapped</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))))</span> <span class="p">{</span>

		<span class="n">alias_cpa</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpa</span><span class="p">;</span>
		<span class="n">alias_cpa</span><span class="p">.</span><span class="n">vaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">laddr</span><span class="p">;</span>
		<span class="n">alias_cpa</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CPA_PAGES_ARRAY</span> <span class="o">|</span> <span class="n">CPA_ARRAY</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">__change_page_attr_set_clr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias_cpa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the primary call didn&#39;t touch the high mapping already</span>
<span class="cm">	 * and the physical address is inside the kernel map, we need</span>
<span class="cm">	 * to touch the high mapped kernel as well:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">within</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_text</span><span class="p">,</span> <span class="n">_brk_end</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">within</span><span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pfn</span><span class="p">,</span> <span class="n">highmap_start_pfn</span><span class="p">(),</span> <span class="n">highmap_end_pfn</span><span class="p">()))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">temp_cpa_vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span>
					       <span class="n">__START_KERNEL_map</span> <span class="o">-</span> <span class="n">phys_base</span><span class="p">;</span>
		<span class="n">alias_cpa</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpa</span><span class="p">;</span>
		<span class="n">alias_cpa</span><span class="p">.</span><span class="n">vaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">temp_cpa_vaddr</span><span class="p">;</span>
		<span class="n">alias_cpa</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CPA_PAGES_ARRAY</span> <span class="o">|</span> <span class="n">CPA_ARRAY</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The high mapping range is imprecise, so ignore the</span>
<span class="cm">		 * return value.</span>
<span class="cm">		 */</span>
		<span class="n">__change_page_attr_set_clr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias_cpa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__change_page_attr_set_clr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpa_data</span> <span class="o">*</span><span class="n">cpa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">checkalias</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">numpages</span> <span class="o">=</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">numpages</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Store the remaining nr of pages for the large page</span>
<span class="cm">		 * preservation check.</span>
<span class="cm">		 */</span>
		<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span> <span class="o">=</span> <span class="n">numpages</span><span class="p">;</span>
		<span class="cm">/* for array changes, we can&#39;t use large page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CPA_ARRAY</span> <span class="o">|</span> <span class="n">CPA_PAGES_ARRAY</span><span class="p">))</span>
			<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_pagealloc</span><span class="p">)</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpa_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__change_page_attr</span><span class="p">(</span><span class="n">cpa</span><span class="p">,</span> <span class="n">checkalias</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_pagealloc</span><span class="p">)</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpa_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">checkalias</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cpa_process_alias</span><span class="p">(</span><span class="n">cpa</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Adjust the number of pages with the result of the</span>
<span class="cm">		 * CPA operation. Either a large page has been</span>
<span class="cm">		 * preserved or a single page update happened.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span> <span class="o">&gt;</span> <span class="n">numpages</span><span class="p">);</span>
		<span class="n">numpages</span> <span class="o">-=</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CPA_PAGES_ARRAY</span> <span class="o">|</span> <span class="n">CPA_ARRAY</span><span class="p">))</span>
			<span class="n">cpa</span><span class="o">-&gt;</span><span class="n">curpage</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">cpa</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+=</span> <span class="n">cpa</span><span class="o">-&gt;</span><span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cache_attr</span><span class="p">(</span><span class="n">pgprot_t</span> <span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">_PAGE_PAT</span> <span class="o">|</span> <span class="n">_PAGE_PAT_LARGE</span> <span class="o">|</span> <span class="n">_PAGE_PWT</span> <span class="o">|</span> <span class="n">_PAGE_PCD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">change_page_attr_set_clr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span>
				    <span class="n">pgprot_t</span> <span class="n">mask_set</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">mask_clr</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">force_split</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_flag</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpa_data</span> <span class="n">cpa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">checkalias</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">baddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check, if we are requested to change a not supported</span>
<span class="cm">	 * feature:</span>
<span class="cm">	 */</span>
	<span class="n">mask_set</span> <span class="o">=</span> <span class="n">canon_pgprot</span><span class="p">(</span><span class="n">mask_set</span><span class="p">);</span>
	<span class="n">mask_clr</span> <span class="o">=</span> <span class="n">canon_pgprot</span><span class="p">(</span><span class="n">mask_clr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">mask_set</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">mask_clr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">force_split</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Ensure we are PAGE_SIZE aligned */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_flag</span> <span class="o">&amp;</span> <span class="n">CPA_ARRAY</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numpages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
				<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">in_flag</span> <span class="o">&amp;</span> <span class="n">CPA_PAGES_ARRAY</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * in_flag of CPA_PAGES_ARRAY implies it is aligned.</span>
<span class="cm">		 * No need to cehck in that case</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">addr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * People should not be passing in unaligned addresses:</span>
<span class="cm">			 */</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Save address for cache flush. *addr is modified in the call</span>
<span class="cm">		 * to __change_page_attr_set_clr() below.</span>
<span class="cm">		 */</span>
		<span class="n">baddr</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Must avoid aliasing mappings in the highmem code */</span>
	<span class="n">kmap_flush_unused</span><span class="p">();</span>

	<span class="n">vm_unmap_aliases</span><span class="p">();</span>

	<span class="n">cpa</span><span class="p">.</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">cpa</span><span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="n">cpa</span><span class="p">.</span><span class="n">numpages</span> <span class="o">=</span> <span class="n">numpages</span><span class="p">;</span>
	<span class="n">cpa</span><span class="p">.</span><span class="n">mask_set</span> <span class="o">=</span> <span class="n">mask_set</span><span class="p">;</span>
	<span class="n">cpa</span><span class="p">.</span><span class="n">mask_clr</span> <span class="o">=</span> <span class="n">mask_clr</span><span class="p">;</span>
	<span class="n">cpa</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpa</span><span class="p">.</span><span class="n">curpage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpa</span><span class="p">.</span><span class="n">force_split</span> <span class="o">=</span> <span class="n">force_split</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CPA_ARRAY</span> <span class="o">|</span> <span class="n">CPA_PAGES_ARRAY</span><span class="p">))</span>
		<span class="n">cpa</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">in_flag</span><span class="p">;</span>

	<span class="cm">/* No alias checking for _NX bit modifications */</span>
	<span class="n">checkalias</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">mask_set</span><span class="p">)</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">mask_clr</span><span class="p">))</span> <span class="o">!=</span> <span class="n">_PAGE_NX</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__change_page_attr_set_clr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpa</span><span class="p">,</span> <span class="n">checkalias</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether we really changed something:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cpa</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CPA_FLUSHTLB</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to flush, when we did not set any of the caching</span>
<span class="cm">	 * attributes:</span>
<span class="cm">	 */</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_attr</span><span class="p">(</span><span class="n">mask_set</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * On success we use clflush, when the CPU supports it to</span>
<span class="cm">	 * avoid the wbindv. If the CPU does not support it and in the</span>
<span class="cm">	 * error case we fall back to cpa_flush_all (which uses</span>
<span class="cm">	 * wbindv):</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_has_clflush</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpa</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CPA_PAGES_ARRAY</span> <span class="o">|</span> <span class="n">CPA_ARRAY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpa_flush_array</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span>
					<span class="n">cpa</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">cpa_flush_range</span><span class="p">(</span><span class="n">baddr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cpa_flush_all</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">change_page_attr_set</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span>
				       <span class="n">pgprot_t</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">change_page_attr_set_clr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">(</span><span class="n">array</span> <span class="o">?</span> <span class="n">CPA_ARRAY</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">change_page_attr_clear</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span>
					 <span class="n">pgprot_t</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">change_page_attr_set_clr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">(</span><span class="n">array</span> <span class="o">?</span> <span class="n">CPA_ARRAY</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpa_set_pages_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span>
				       <span class="n">pgprot_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">change_page_attr_set_clr</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">CPA_PAGES_ARRAY</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpa_clear_pages_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span>
					 <span class="n">pgprot_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">change_page_attr_set_clr</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">CPA_PAGES_ARRAY</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">_set_memory_uc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * for now UC MINUS. see comments in ioremap_nocache()</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">change_page_attr_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span>
				    <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_memory_uc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for now UC MINUS. see comments in ioremap_nocache()</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_memtype</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			    <span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_set_memory_uc</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">free_memtype</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_memory_uc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_set_memory_array</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrinarray</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for now UC MINUS. see comments in ioremap_nocache()</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrinarray</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_memtype</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
					<span class="n">new_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">change_page_attr_set</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span>
				    <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">new_type</span> <span class="o">==</span> <span class="n">_PAGE_CACHE_WC</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">change_page_attr_set_clr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span>
					       <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_WC</span><span class="p">),</span>
					       <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">),</span>
					       <span class="mi">0</span><span class="p">,</span> <span class="n">CPA_ARRAY</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_memtype</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_memory_array_uc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrinarray</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_set_memory_array</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span> <span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_memory_array_uc</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_memory_array_wc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrinarray</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_set_memory_array</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span> <span class="n">_PAGE_CACHE_WC</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_memory_array_wc</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">_set_memory_wc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr_copy</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">change_page_attr_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span>
				    <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">change_page_attr_set_clr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr_copy</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span>
					       <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_WC</span><span class="p">),</span>
					       <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">),</span>
					       <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_memory_wc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pat_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">set_memory_uc</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_memtype</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
		<span class="n">_PAGE_CACHE_WC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_set_memory_wc</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">free_memtype</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_memory_wc</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">_set_memory_wb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">change_page_attr_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span>
				      <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_memory_wb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_set_memory_wb</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">free_memtype</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_memory_wb</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_memory_array_wb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrinarray</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">change_page_attr_clear</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span>
				      <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrinarray</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_memtype</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_memory_array_wb</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_memory_x</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">__supported_pte_mask</span> <span class="o">&amp;</span> <span class="n">_PAGE_NX</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">change_page_attr_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_NX</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_memory_x</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_memory_nx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">__supported_pte_mask</span> <span class="o">&amp;</span> <span class="n">_PAGE_NX</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">change_page_attr_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_NX</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_memory_nx</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_memory_ro</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">change_page_attr_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_RW</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">set_memory_ro</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_memory_rw</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">change_page_attr_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_RW</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">set_memory_rw</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_memory_np</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">change_page_attr_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_PRESENT</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_memory_4k</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">change_page_attr_set_clr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
					<span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_pages_uc</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">set_memory_uc</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_pages_uc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_set_pages_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrinarray</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrinarray</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reserve_memtype</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">new_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cpa_set_pages_array</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span>
			<span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">new_type</span> <span class="o">==</span> <span class="n">_PAGE_CACHE_WC</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">change_page_attr_set_clr</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span>
					       <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_WC</span><span class="p">),</span>
					       <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">),</span>
					       <span class="mi">0</span><span class="p">,</span> <span class="n">CPA_PAGES_ARRAY</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Success */</span>
<span class="nl">err_out:</span>
	<span class="n">free_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">free_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">free_memtype</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_pages_array_uc</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrinarray</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_set_pages_array</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span> <span class="n">_PAGE_CACHE_UC_MINUS</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_pages_array_uc</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_pages_array_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrinarray</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_set_pages_array</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span> <span class="n">_PAGE_CACHE_WC</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_pages_array_wc</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_pages_wb</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">set_memory_wb</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_pages_wb</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_pages_array_wb</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrinarray</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">cpa_clear_pages_array</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">addrinarray</span><span class="p">,</span>
			<span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_CACHE_MASK</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrinarray</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">free_memtype</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_pages_array_wb</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_pages_x</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">set_memory_x</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_pages_x</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_pages_nx</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">set_memory_nx</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_pages_nx</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_pages_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">set_memory_ro</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_pages_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">set_memory_rw</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__set_pages_p</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tempaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpa_data</span> <span class="n">cpa</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">vaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tempaddr</span><span class="p">,</span>
				<span class="p">.</span><span class="n">numpages</span> <span class="o">=</span> <span class="n">numpages</span><span class="p">,</span>
				<span class="p">.</span><span class="n">mask_set</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_PRESENT</span> <span class="o">|</span> <span class="n">_PAGE_RW</span><span class="p">),</span>
				<span class="p">.</span><span class="n">mask_clr</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
				<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * No alias checking needed for setting present flag. otherwise,</span>
<span class="cm">	 * we may need to break large pages for 64-bit kernel text</span>
<span class="cm">	 * mappings (this adds to complexity if we want to do this from</span>
<span class="cm">	 * atomic context especially). Let&#39;s keep it simple!</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">__change_page_attr_set_clr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__set_pages_np</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tempaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpa_data</span> <span class="n">cpa</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">vaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tempaddr</span><span class="p">,</span>
				<span class="p">.</span><span class="n">numpages</span> <span class="o">=</span> <span class="n">numpages</span><span class="p">,</span>
				<span class="p">.</span><span class="n">mask_set</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
				<span class="p">.</span><span class="n">mask_clr</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_PRESENT</span> <span class="o">|</span> <span class="n">_PAGE_RW</span><span class="p">),</span>
				<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * No alias checking needed for setting not present flag. otherwise,</span>
<span class="cm">	 * we may need to break large pages for 64-bit kernel text</span>
<span class="cm">	 * mappings (this adds to complexity if we want to do this from</span>
<span class="cm">	 * atomic context especially). Let&#39;s keep it simple!</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">__change_page_attr_set_clr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kernel_map_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debug_check_no_locks_freed</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
					   <span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The return value is ignored as the calls cannot fail.</span>
<span class="cm">	 * Large pages for identity mappings are not used at boot time</span>
<span class="cm">	 * and hence no memory allocations during large page split.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">__set_pages_p</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__set_pages_np</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">numpages</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We should perform an IPI and flush all tlbs,</span>
<span class="cm">	 * but that can deadlock-&gt;flush only current cpu:</span>
<span class="cm">	 */</span>
	<span class="n">__flush_tlb_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIBERNATION</span>

<span class="n">bool</span> <span class="nf">kernel_page_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_PRESENT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HIBERNATION */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_PAGEALLOC */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The testcases use internal knowledge of the implementation that shouldn&#39;t</span>
<span class="cm"> * be exposed to the rest of the kernel. Include these directly here.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_CPA_DEBUG</span>
<span class="cp">#include &quot;pageattr-test.c&quot;</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
