<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › xen › p2m.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>p2m.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Xen leaves the responsibility for maintaining p2m mappings to the</span>
<span class="cm"> * guests themselves, but it must also access and update the p2m array</span>
<span class="cm"> * during suspend/resume when all the pages are reallocated.</span>
<span class="cm"> *</span>
<span class="cm"> * The p2m table is logically a flat array, but we implement it as a</span>
<span class="cm"> * three-level tree to allow the address space to be sparse.</span>
<span class="cm"> *</span>
<span class="cm"> *                               Xen</span>
<span class="cm"> *                                |</span>
<span class="cm"> *     p2m_top              p2m_top_mfn</span>
<span class="cm"> *       /  \                   /   \</span>
<span class="cm"> * p2m_mid p2m_mid	p2m_mid_mfn p2m_mid_mfn</span>
<span class="cm"> *    / \      / \         /           /</span>
<span class="cm"> *  p2m p2m p2m p2m p2m p2m p2m ...</span>
<span class="cm"> *</span>
<span class="cm"> * The p2m_mid_mfn pages are mapped by p2m_top_mfn_p.</span>
<span class="cm"> *</span>
<span class="cm"> * The p2m_top and p2m_top_mfn levels are limited to 1 page, so the</span>
<span class="cm"> * maximum representable pseudo-physical address space is:</span>
<span class="cm"> *  P2M_TOP_PER_PAGE * P2M_MID_PER_PAGE * P2M_PER_PAGE pages</span>
<span class="cm"> *</span>
<span class="cm"> * P2M_PER_PAGE depends on the architecture, as a mfn is always</span>
<span class="cm"> * unsigned long (8 bytes on 64-bit, 4 bytes on 32), leading to</span>
<span class="cm"> * 512 and 1024 entries respectively. </span>
<span class="cm"> *</span>
<span class="cm"> * In short, these structures contain the Machine Frame Number (MFN) of the PFN.</span>
<span class="cm"> *</span>
<span class="cm"> * However not all entries are filled with MFNs. Specifically for all other</span>
<span class="cm"> * leaf entries, or for the top  root, or middle one, for which there is a void</span>
<span class="cm"> * entry, we assume it is  &quot;missing&quot;. So (for example)</span>
<span class="cm"> *  pfn_to_mfn(0x90909090)=INVALID_P2M_ENTRY.</span>
<span class="cm"> *</span>
<span class="cm"> * We also have the possibility of setting 1-1 mappings on certain regions, so</span>
<span class="cm"> * that:</span>
<span class="cm"> *  pfn_to_mfn(0xc0000)=0xc0000</span>
<span class="cm"> *</span>
<span class="cm"> * The benefit of this is, that we can assume for non-RAM regions (think</span>
<span class="cm"> * PCI BARs, or ACPI spaces), we can create mappings easily b/c we</span>
<span class="cm"> * get the PFN value to match the MFN.</span>
<span class="cm"> *</span>
<span class="cm"> * For this to work efficiently we have one new page p2m_identity and</span>
<span class="cm"> * allocate (via reserved_brk) any other pages we need to cover the sides</span>
<span class="cm"> * (1GB or 4MB boundary violations). All entries in p2m_identity are set to</span>
<span class="cm"> * INVALID_P2M_ENTRY type (Xen toolstack only recognizes that and MFNs,</span>
<span class="cm"> * no other fancy value).</span>
<span class="cm"> *</span>
<span class="cm"> * On lookup we spot that the entry points to p2m_identity and return the</span>
<span class="cm"> * identity value instead of dereferencing and returning INVALID_P2M_ENTRY.</span>
<span class="cm"> * If the entry points to an allocated page, we just proceed as before and</span>
<span class="cm"> * return the PFN.  If the PFN has IDENTITY_FRAME_BIT set we unmask that in</span>
<span class="cm"> * appropriate functions (pfn_to_mfn).</span>
<span class="cm"> *</span>
<span class="cm"> * The reason for having the IDENTITY_FRAME_BIT instead of just returning the</span>
<span class="cm"> * PFN is that we could find ourselves where pfn_to_mfn(pfn)==pfn for a</span>
<span class="cm"> * non-identity pfn. To protect ourselves against we elect to set (and get) the</span>
<span class="cm"> * IDENTITY_FRAME_BIT on all identity mapped PFNs.</span>
<span class="cm"> *</span>
<span class="cm"> * This simplistic diagram is used to explain the more subtle piece of code.</span>
<span class="cm"> * There is also a digram of the P2M at the end that can help.</span>
<span class="cm"> * Imagine your E820 looking as so:</span>
<span class="cm"> *</span>
<span class="cm"> *                    1GB                                           2GB</span>
<span class="cm"> * /-------------------+---------\/----\         /----------\    /---+-----\</span>
<span class="cm"> * | System RAM        | Sys RAM ||ACPI|         | reserved |    | Sys RAM |</span>
<span class="cm"> * \-------------------+---------/\----/         \----------/    \---+-----/</span>
<span class="cm"> *                               ^- 1029MB                       ^- 2001MB</span>
<span class="cm"> *</span>
<span class="cm"> * [1029MB = 263424 (0x40500), 2001MB = 512256 (0x7D100),</span>
<span class="cm"> *  2048MB = 524288 (0x80000)]</span>
<span class="cm"> *</span>
<span class="cm"> * And dom0_mem=max:3GB,1GB is passed in to the guest, meaning memory past 1GB</span>
<span class="cm"> * is actually not present (would have to kick the balloon driver to put it in).</span>
<span class="cm"> *</span>
<span class="cm"> * When we are told to set the PFNs for identity mapping (see patch: &quot;xen/setup:</span>
<span class="cm"> * Set identity mapping for non-RAM E820 and E820 gaps.&quot;) we pass in the start</span>
<span class="cm"> * of the PFN and the end PFN (263424 and 512256 respectively). The first step</span>
<span class="cm"> * is to reserve_brk a top leaf page if the p2m[1] is missing. The top leaf page</span>
<span class="cm"> * covers 512^2 of page estate (1GB) and in case the start or end PFN is not</span>
<span class="cm"> * aligned on 512^2*PAGE_SIZE (1GB) we loop on aligned 1GB PFNs from start pfn</span>
<span class="cm"> * to end pfn.  We reserve_brk top leaf pages if they are missing (means they</span>
<span class="cm"> * point to p2m_mid_missing).</span>
<span class="cm"> *</span>
<span class="cm"> * With the E820 example above, 263424 is not 1GB aligned so we allocate a</span>
<span class="cm"> * reserve_brk page which will cover the PFNs estate from 0x40000 to 0x80000.</span>
<span class="cm"> * Each entry in the allocate page is &quot;missing&quot; (points to p2m_missing).</span>
<span class="cm"> *</span>
<span class="cm"> * Next stage is to determine if we need to do a more granular boundary check</span>
<span class="cm"> * on the 4MB (or 2MB depending on architecture) off the start and end pfn&#39;s.</span>
<span class="cm"> * We check if the start pfn and end pfn violate that boundary check, and if</span>
<span class="cm"> * so reserve_brk a middle (p2m[x][y]) leaf page. This way we have a much finer</span>
<span class="cm"> * granularity of setting which PFNs are missing and which ones are identity.</span>
<span class="cm"> * In our example 263424 and 512256 both fail the check so we reserve_brk two</span>
<span class="cm"> * pages. Populate them with INVALID_P2M_ENTRY (so they both have &quot;missing&quot;</span>
<span class="cm"> * values) and assign them to p2m[1][2] and p2m[1][488] respectively.</span>
<span class="cm"> *</span>
<span class="cm"> * At this point we would at minimum reserve_brk one page, but could be up to</span>
<span class="cm"> * three. Each call to set_phys_range_identity has at maximum a three page</span>
<span class="cm"> * cost. If we were to query the P2M at this stage, all those entries from</span>
<span class="cm"> * start PFN through end PFN (so 1029MB -&gt; 2001MB) would return</span>
<span class="cm"> * INVALID_P2M_ENTRY (&quot;missing&quot;).</span>
<span class="cm"> *</span>
<span class="cm"> * The next step is to walk from the start pfn to the end pfn setting</span>
<span class="cm"> * the IDENTITY_FRAME_BIT on each PFN. This is done in set_phys_range_identity.</span>
<span class="cm"> * If we find that the middle leaf is pointing to p2m_missing we can swap it</span>
<span class="cm"> * over to p2m_identity - this way covering 4MB (or 2MB) PFN space.  At this</span>
<span class="cm"> * point we do not need to worry about boundary aligment (so no need to</span>
<span class="cm"> * reserve_brk a middle page, figure out which PFNs are &quot;missing&quot; and which</span>
<span class="cm"> * ones are identity), as that has been done earlier.  If we find that the</span>
<span class="cm"> * middle leaf is not occupied by p2m_identity or p2m_missing, we dereference</span>
<span class="cm"> * that page (which covers 512 PFNs) and set the appropriate PFN with</span>
<span class="cm"> * IDENTITY_FRAME_BIT. In our example 263424 and 512256 end up there, and we</span>
<span class="cm"> * set from p2m[1][2][256-&gt;511] and p2m[1][488][0-&gt;256] with</span>
<span class="cm"> * IDENTITY_FRAME_BIT set.</span>
<span class="cm"> *</span>
<span class="cm"> * All other regions that are void (or not filled) either point to p2m_missing</span>
<span class="cm"> * (considered missing) or have the default value of INVALID_P2M_ENTRY (also</span>
<span class="cm"> * considered missing). In our case, p2m[1][2][0-&gt;255] and p2m[1][488][257-&gt;511]</span>
<span class="cm"> * contain the INVALID_P2M_ENTRY value and are considered &quot;missing.&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * This is what the p2m ends up looking (for the E820 above) with this</span>
<span class="cm"> * fabulous drawing:</span>
<span class="cm"> *</span>
<span class="cm"> *    p2m         /--------------\</span>
<span class="cm"> *  /-----\       | &amp;mfn_list[0],|                           /-----------------\</span>
<span class="cm"> *  |  0  |------&gt;| &amp;mfn_list[1],|    /---------------\      | ~0, ~0, ..      |</span>
<span class="cm"> *  |-----|       |  ..., ~0, ~0 |    | ~0, ~0, [x]---+-----&gt;| IDENTITY [@256] |</span>
<span class="cm"> *  |  1  |---\   \--------------/    | [p2m_identity]+\     | IDENTITY [@257] |</span>
<span class="cm"> *  |-----|    \                      | [p2m_identity]+\\    | ....            |</span>
<span class="cm"> *  |  2  |--\  \--------------------&gt;|  ...          | \\   \----------------/</span>
<span class="cm"> *  |-----|   \                       \---------------/  \\</span>
<span class="cm"> *  |  3  |\   \                                          \\  p2m_identity</span>
<span class="cm"> *  |-----| \   \--------------------&gt;/---------------\   /-----------------\</span>
<span class="cm"> *  | ..  +-&gt;+                        | [p2m_identity]+--&gt;| ~0, ~0, ~0, ... |</span>
<span class="cm"> *  \-----/ /                         | [p2m_identity]+--&gt;| ..., ~0         |</span>
<span class="cm"> *         / /---------------\        | ....          |   \-----------------/</span>
<span class="cm"> *        /  | IDENTITY[@0]  |      /-+-[x], ~0, ~0.. |</span>
<span class="cm"> *       /   | IDENTITY[@256]|&lt;----/  \---------------/</span>
<span class="cm"> *      /    | ~0, ~0, ....  |</span>
<span class="cm"> *     |     \---------------/</span>
<span class="cm"> *     |</span>
<span class="cm"> *     p2m_missing             p2m_missing</span>
<span class="cm"> * /------------------\     /------------\</span>
<span class="cm"> * | [p2m_mid_missing]+----&gt;| ~0, ~0, ~0 |</span>
<span class="cm"> * | [p2m_mid_missing]+----&gt;| ..., ~0    |</span>
<span class="cm"> * \------------------/     \------------/</span>
<span class="cm"> *</span>
<span class="cm"> * where ~0 is INVALID_P2M_ENTRY. IDENTITY is (PFN | IDENTITY_BIT)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#include &lt;asm/cache.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="cp">#include &lt;asm/xen/page.h&gt;</span>
<span class="cp">#include &lt;asm/xen/hypercall.h&gt;</span>
<span class="cp">#include &lt;asm/xen/hypervisor.h&gt;</span>
<span class="cp">#include &lt;xen/grant_table.h&gt;</span>

<span class="cp">#include &quot;multicalls.h&quot;</span>
<span class="cp">#include &quot;xen-ops.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">m2p_override_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xen_max_p2m_pfn</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cp">#define P2M_PER_PAGE		(PAGE_SIZE / sizeof(unsigned long))</span>
<span class="cp">#define P2M_MID_PER_PAGE	(PAGE_SIZE / sizeof(unsigned long *))</span>
<span class="cp">#define P2M_TOP_PER_PAGE	(PAGE_SIZE / sizeof(unsigned long **))</span>

<span class="cp">#define MAX_P2M_PFN		(P2M_TOP_PER_PAGE * P2M_MID_PER_PAGE * P2M_PER_PAGE)</span>

<span class="cm">/* Placeholders for holes in the address space */</span>
<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">p2m_missing</span><span class="p">,</span> <span class="n">P2M_PER_PAGE</span><span class="p">);</span>
<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="n">p2m_mid_missing</span><span class="p">,</span> <span class="n">P2M_MID_PER_PAGE</span><span class="p">);</span>
<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">p2m_mid_missing_mfn</span><span class="p">,</span> <span class="n">P2M_MID_PER_PAGE</span><span class="p">);</span>

<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">**</span><span class="p">,</span> <span class="n">p2m_top</span><span class="p">,</span> <span class="n">P2M_TOP_PER_PAGE</span><span class="p">);</span>
<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">p2m_top_mfn</span><span class="p">,</span> <span class="n">P2M_TOP_PER_PAGE</span><span class="p">);</span>
<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="n">p2m_top_mfn_p</span><span class="p">,</span> <span class="n">P2M_TOP_PER_PAGE</span><span class="p">);</span>

<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">p2m_identity</span><span class="p">,</span> <span class="n">P2M_PER_PAGE</span><span class="p">);</span>

<span class="n">RESERVE_BRK</span><span class="p">(</span><span class="n">p2m_mid</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">MAX_DOMAIN_PAGES</span> <span class="o">/</span> <span class="p">(</span><span class="n">P2M_PER_PAGE</span> <span class="o">*</span> <span class="n">P2M_MID_PER_PAGE</span><span class="p">)));</span>
<span class="n">RESERVE_BRK</span><span class="p">(</span><span class="n">p2m_mid_mfn</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">MAX_DOMAIN_PAGES</span> <span class="o">/</span> <span class="p">(</span><span class="n">P2M_PER_PAGE</span> <span class="o">*</span> <span class="n">P2M_MID_PER_PAGE</span><span class="p">)));</span>

<span class="cm">/* We might hit two boundary violations at the start and end, at max each</span>
<span class="cm"> * boundary violation will require three middle nodes. */</span>
<span class="n">RESERVE_BRK</span><span class="p">(</span><span class="n">p2m_mid_identity</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">p2m_top_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">MAX_P2M_PFN</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">/</span> <span class="p">(</span><span class="n">P2M_MID_PER_PAGE</span> <span class="o">*</span> <span class="n">P2M_PER_PAGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">p2m_mid_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">/</span> <span class="n">P2M_PER_PAGE</span><span class="p">)</span> <span class="o">%</span> <span class="n">P2M_MID_PER_PAGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">p2m_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">%</span> <span class="n">P2M_PER_PAGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">p2m_top_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">***</span><span class="n">top</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">P2M_TOP_PER_PAGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2m_mid_missing</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">p2m_top_mfn_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">top</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">P2M_TOP_PER_PAGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">p2m_mid_missing_mfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">p2m_top_mfn_p_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">**</span><span class="n">top</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">P2M_TOP_PER_PAGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2m_mid_missing_mfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">p2m_mid_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">**</span><span class="n">mid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">P2M_MID_PER_PAGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2m_missing</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">p2m_mid_mfn_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">P2M_MID_PER_PAGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">p2m_missing</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">p2m_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p2m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">P2M_MID_PER_PAGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">p2m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_P2M_ENTRY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build the parallel p2m_top_mfn and p2m_mid_mfn structures</span>
<span class="cm"> *</span>
<span class="cm"> * This is called both at boot time, and after resuming from suspend:</span>
<span class="cm"> * - At boot time we&#39;re called very early, and must use extend_brk()</span>
<span class="cm"> *   to allocate memory.</span>
<span class="cm"> *</span>
<span class="cm"> * - After resume we&#39;re called from within stop_machine, but the mfn</span>
<span class="cm"> *   tree should alreay be completely allocated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">xen_build_mfn_list_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="cm">/* Pre-initialize p2m_top_mfn to be completely missing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p2m_top_mfn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p2m_mid_missing_mfn</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">p2m_mid_mfn_init</span><span class="p">(</span><span class="n">p2m_mid_missing_mfn</span><span class="p">);</span>

		<span class="n">p2m_top_mfn_p</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">p2m_top_mfn_p_init</span><span class="p">(</span><span class="n">p2m_top_mfn_p</span><span class="p">);</span>

		<span class="n">p2m_top_mfn</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">p2m_top_mfn_init</span><span class="p">(</span><span class="n">p2m_top_mfn</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reinitialise, mfn&#39;s all change after migration */</span>
		<span class="n">p2m_mid_mfn_init</span><span class="p">(</span><span class="n">p2m_mid_missing_mfn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">xen_max_p2m_pfn</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">+=</span> <span class="n">P2M_PER_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">topidx</span> <span class="o">=</span> <span class="n">p2m_top_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">mididx</span> <span class="o">=</span> <span class="n">p2m_mid_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">**</span><span class="n">mid</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mid_mfn_p</span><span class="p">;</span>

		<span class="n">mid</span> <span class="o">=</span> <span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">];</span>
		<span class="n">mid_mfn_p</span> <span class="o">=</span> <span class="n">p2m_top_mfn_p</span><span class="p">[</span><span class="n">topidx</span><span class="p">];</span>

		<span class="cm">/* Don&#39;t bother allocating any mfn mid levels if</span>
<span class="cm">		 * they&#39;re just missing, just update the stored mfn,</span>
<span class="cm">		 * since all could have changed over a migrate.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">==</span> <span class="n">p2m_mid_missing</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mididx</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mid_mfn_p</span> <span class="o">!=</span> <span class="n">p2m_mid_missing_mfn</span><span class="p">);</span>
			<span class="n">p2m_top_mfn</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">p2m_mid_missing_mfn</span><span class="p">);</span>
			<span class="n">pfn</span> <span class="o">+=</span> <span class="p">(</span><span class="n">P2M_MID_PER_PAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">P2M_PER_PAGE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mid_mfn_p</span> <span class="o">==</span> <span class="n">p2m_mid_missing_mfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * XXX boot-time only!  We should never find</span>
<span class="cm">			 * missing parts of the mfn tree after</span>
<span class="cm">			 * runtime.  extend_brk() will BUG if we call</span>
<span class="cm">			 * it too late.</span>
<span class="cm">			 */</span>
			<span class="n">mid_mfn_p</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="n">p2m_mid_mfn_init</span><span class="p">(</span><span class="n">mid_mfn_p</span><span class="p">);</span>

			<span class="n">p2m_top_mfn_p</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_mfn_p</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">p2m_top_mfn</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">mid_mfn_p</span><span class="p">);</span>
		<span class="n">mid_mfn_p</span><span class="p">[</span><span class="n">mididx</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">mid</span><span class="p">[</span><span class="n">mididx</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xen_setup_mfn_list_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">HYPERVISOR_shared_info</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">xen_dummy_shared_info</span><span class="p">);</span>

	<span class="n">HYPERVISOR_shared_info</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pfn_to_mfn_frame_list_list</span> <span class="o">=</span>
		<span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">p2m_top_mfn</span><span class="p">);</span>
	<span class="n">HYPERVISOR_shared_info</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">max_pfn</span> <span class="o">=</span> <span class="n">xen_max_p2m_pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set up p2m_top to point to the domain-builder provided p2m pages */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_build_dynamic_phys_to_machine</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mfn_list</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">xen_start_info</span><span class="o">-&gt;</span><span class="n">mfn_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pfn</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">MAX_DOMAIN_PAGES</span><span class="p">,</span> <span class="n">xen_start_info</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="n">xen_max_p2m_pfn</span> <span class="o">=</span> <span class="n">max_pfn</span><span class="p">;</span>

	<span class="n">p2m_missing</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">p2m_init</span><span class="p">(</span><span class="n">p2m_missing</span><span class="p">);</span>

	<span class="n">p2m_mid_missing</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">p2m_mid_init</span><span class="p">(</span><span class="n">p2m_mid_missing</span><span class="p">);</span>

	<span class="n">p2m_top</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">p2m_top_init</span><span class="p">(</span><span class="n">p2m_top</span><span class="p">);</span>

	<span class="n">p2m_identity</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">p2m_init</span><span class="p">(</span><span class="n">p2m_identity</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The domain builder gives us a pre-constructed p2m array in</span>
<span class="cm">	 * mfn_list for all the pages initially given to us, so we just</span>
<span class="cm">	 * need to graft that into our tree structure.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">max_pfn</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">+=</span> <span class="n">P2M_PER_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">topidx</span> <span class="o">=</span> <span class="n">p2m_top_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">mididx</span> <span class="o">=</span> <span class="n">p2m_mid_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_mid_missing</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">**</span><span class="n">mid</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="n">p2m_mid_init</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>

			<span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * As long as the mfn_list has enough entries to completely</span>
<span class="cm">		 * fill a p2m page, pointing into the array is ok. But if</span>
<span class="cm">		 * not the entries beyond the last pfn will be undefined.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pfn</span> <span class="o">+</span> <span class="n">P2M_PER_PAGE</span> <span class="o">&gt;</span> <span class="n">max_pfn</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p2midx</span><span class="p">;</span>

			<span class="n">p2midx</span> <span class="o">=</span> <span class="n">max_pfn</span> <span class="o">%</span> <span class="n">P2M_PER_PAGE</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">p2midx</span> <span class="o">&lt;</span> <span class="n">P2M_PER_PAGE</span><span class="p">;</span> <span class="n">p2midx</span><span class="o">++</span><span class="p">)</span>
				<span class="n">mfn_list</span><span class="p">[</span><span class="n">pfn</span> <span class="o">+</span> <span class="n">p2midx</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_P2M_ENTRY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mfn_list</span><span class="p">[</span><span class="n">pfn</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">m2p_override_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_phys_to_machine</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">topidx</span><span class="p">,</span> <span class="n">mididx</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">MAX_P2M_PFN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">INVALID_P2M_ENTRY</span><span class="p">;</span>

	<span class="n">topidx</span> <span class="o">=</span> <span class="n">p2m_top_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">mididx</span> <span class="o">=</span> <span class="n">p2m_mid_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">p2m_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The INVALID_P2M_ENTRY is filled in both p2m_*identity</span>
<span class="cm">	 * and in p2m_*missing, so returning the INVALID_P2M_ENTRY</span>
<span class="cm">	 * would be wrong.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_identity</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IDENTITY_FRAME</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">][</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_phys_to_machine</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_p2m_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_REPEAT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_p2m_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Fully allocate the p2m structure for a given pfn.  We need to check</span>
<span class="cm"> * that both the top and mid levels are allocated, and make sure the</span>
<span class="cm"> * parallel mfn tree is kept in sync.  We may race with other cpus, so</span>
<span class="cm"> * the new pages are installed with cmpxchg; if we lose the race then</span>
<span class="cm"> * simply free the page we allocated and use the one that&#39;s there.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">alloc_p2m</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">topidx</span><span class="p">,</span> <span class="n">mididx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">***</span><span class="n">top_p</span><span class="p">,</span> <span class="o">**</span><span class="n">mid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">top_mfn_p</span><span class="p">,</span> <span class="o">*</span><span class="n">mid_mfn</span><span class="p">;</span>

	<span class="n">topidx</span> <span class="o">=</span> <span class="n">p2m_top_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">mididx</span> <span class="o">=</span> <span class="n">p2m_mid_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="n">top_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">];</span>
	<span class="n">mid</span> <span class="o">=</span> <span class="o">*</span><span class="n">top_p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">==</span> <span class="n">p2m_mid_missing</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Mid level is missing, allocate a new one */</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="n">alloc_p2m_page</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mid</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">p2m_mid_init</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="n">top_p</span><span class="p">,</span> <span class="n">p2m_mid_missing</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">!=</span> <span class="n">p2m_mid_missing</span><span class="p">)</span>
			<span class="n">free_p2m_page</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">top_mfn_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p2m_top_mfn</span><span class="p">[</span><span class="n">topidx</span><span class="p">];</span>
	<span class="n">mid_mfn</span> <span class="o">=</span> <span class="n">p2m_top_mfn_p</span><span class="p">[</span><span class="n">topidx</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">mid_mfn</span><span class="p">)</span> <span class="o">!=</span> <span class="o">*</span><span class="n">top_mfn_p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mid_mfn</span> <span class="o">==</span> <span class="n">p2m_mid_missing_mfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Separately check the mid mfn level */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">missing_mfn</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mid_mfn_mfn</span><span class="p">;</span>

		<span class="n">mid_mfn</span> <span class="o">=</span> <span class="n">alloc_p2m_page</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mid_mfn</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">p2m_mid_mfn_init</span><span class="p">(</span><span class="n">mid_mfn</span><span class="p">);</span>

		<span class="n">missing_mfn</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">p2m_mid_missing_mfn</span><span class="p">);</span>
		<span class="n">mid_mfn_mfn</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">mid_mfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="n">top_mfn_p</span><span class="p">,</span> <span class="n">missing_mfn</span><span class="p">,</span> <span class="n">mid_mfn_mfn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">missing_mfn</span><span class="p">)</span>
			<span class="n">free_p2m_page</span><span class="p">(</span><span class="n">mid_mfn</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">p2m_top_mfn_p</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_mfn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_identity</span> <span class="o">||</span>
	    <span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_missing</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* p2m leaf page is missing */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p2m</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p2m_orig</span> <span class="o">=</span> <span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">];</span>

		<span class="n">p2m</span> <span class="o">=</span> <span class="n">alloc_p2m_page</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p2m</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">p2m_init</span><span class="p">(</span><span class="n">p2m</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mid</span><span class="p">[</span><span class="n">mididx</span><span class="p">],</span> <span class="n">p2m_orig</span><span class="p">,</span> <span class="n">p2m</span><span class="p">)</span> <span class="o">!=</span> <span class="n">p2m_orig</span><span class="p">)</span>
			<span class="n">free_p2m_page</span><span class="p">(</span><span class="n">p2m</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mid_mfn</span><span class="p">[</span><span class="n">mididx</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">p2m</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__init</span> <span class="nf">early_alloc_p2m_middle</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">check_boundary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">topidx</span><span class="p">,</span> <span class="n">mididx</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p2m</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mid_mfn_p</span><span class="p">;</span>

	<span class="n">topidx</span> <span class="o">=</span> <span class="n">p2m_top_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">mididx</span> <span class="o">=</span> <span class="n">p2m_mid_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">p2m_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="cm">/* Pfff.. No boundary cross-over, lets get out. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="n">check_boundary</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">WARN</span><span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_identity</span><span class="p">,</span>
		<span class="s">&quot;P2M[%d][%d] == IDENTITY, should be MISSING (or alloced)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">topidx</span><span class="p">,</span> <span class="n">mididx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Could be done by xen_build_dynamic_phys_to_machine..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p2m_missing</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Boundary cross-over for the edges: */</span>
	<span class="n">p2m</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">p2m_init</span><span class="p">(</span><span class="n">p2m</span><span class="p">);</span>

	<span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2m</span><span class="p">;</span>

	<span class="cm">/* For save/restore we need to MFN of the P2M saved */</span>

	<span class="n">mid_mfn_p</span> <span class="o">=</span> <span class="n">p2m_top_mfn_p</span><span class="p">[</span><span class="n">topidx</span><span class="p">];</span>
	<span class="n">WARN</span><span class="p">(</span><span class="n">mid_mfn_p</span><span class="p">[</span><span class="n">mididx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">p2m_missing</span><span class="p">),</span>
		<span class="s">&quot;P2M_TOP_P[%d][%d] != MFN of p2m_missing!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">topidx</span><span class="p">,</span> <span class="n">mididx</span><span class="p">);</span>
	<span class="n">mid_mfn_p</span><span class="p">[</span><span class="n">mididx</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">p2m</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__init</span> <span class="nf">early_alloc_p2m</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">topidx</span> <span class="o">=</span> <span class="n">p2m_top_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mid_mfn_p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">**</span><span class="n">mid</span><span class="p">;</span>

	<span class="n">mid</span> <span class="o">=</span> <span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">];</span>
	<span class="n">mid_mfn_p</span> <span class="o">=</span> <span class="n">p2m_top_mfn_p</span><span class="p">[</span><span class="n">topidx</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">==</span> <span class="n">p2m_mid_missing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">p2m_mid_init</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>

		<span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mid_mfn_p</span> <span class="o">!=</span> <span class="n">p2m_mid_missing_mfn</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* And the save/restore P2M tables.. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mid_mfn_p</span> <span class="o">==</span> <span class="n">p2m_mid_missing_mfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid_mfn_p</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">p2m_mid_mfn_init</span><span class="p">(</span><span class="n">mid_mfn_p</span><span class="p">);</span>

		<span class="n">p2m_top_mfn_p</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_mfn_p</span><span class="p">;</span>
		<span class="n">p2m_top_mfn</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">mid_mfn_p</span><span class="p">);</span>
		<span class="cm">/* Note: we don&#39;t set mid_mfn_p[midix] here,</span>
<span class="cm">		 * look in early_alloc_p2m_middle */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">bool</span> <span class="n">__init</span> <span class="nf">early_set_phys_to_machine</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">__set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">mfn</span><span class="p">)))</span>  <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">early_alloc_p2m</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">early_alloc_p2m_middle</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="nb">false</span> <span class="cm">/* boundary crossover OK!*/</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">mfn</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">set_phys_range_identity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn_s</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn_e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pfn_s</span> <span class="o">&gt;=</span> <span class="n">MAX_P2M_PFN</span> <span class="o">||</span> <span class="n">pfn_e</span> <span class="o">&gt;=</span> <span class="n">MAX_P2M_PFN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">xen_feature</span><span class="p">(</span><span class="n">XENFEAT_auto_translated_physmap</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">pfn_e</span> <span class="o">-</span> <span class="n">pfn_s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pfn_s</span> <span class="o">&gt;</span> <span class="n">pfn_e</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfn_s</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">P2M_MID_PER_PAGE</span> <span class="o">*</span> <span class="n">P2M_PER_PAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">pfn_e</span><span class="p">,</span> <span class="p">(</span><span class="n">P2M_MID_PER_PAGE</span> <span class="o">*</span> <span class="n">P2M_PER_PAGE</span><span class="p">));</span>
		<span class="n">pfn</span> <span class="o">+=</span> <span class="n">P2M_MID_PER_PAGE</span> <span class="o">*</span> <span class="n">P2M_PER_PAGE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">early_alloc_p2m</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">early_alloc_p2m_middle</span><span class="p">(</span><span class="n">pfn_s</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">early_alloc_p2m_middle</span><span class="p">(</span><span class="n">pfn_e</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">pfn_s</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">pfn_e</span><span class="p">;</span> <span class="n">pfn</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">IDENTITY_FRAME</span><span class="p">(</span><span class="n">pfn</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WARN</span><span class="p">((</span><span class="n">pfn</span> <span class="o">-</span> <span class="n">pfn_s</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">pfn_e</span> <span class="o">-</span> <span class="n">pfn_s</span><span class="p">),</span>
		<span class="s">&quot;Identity mapping failed. We are %ld short of 1-1 mappings!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">pfn_e</span> <span class="o">-</span> <span class="n">pfn_s</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">-</span> <span class="n">pfn_s</span><span class="p">)))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;1-1 mapping on %lx-&gt;%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pfn_s</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pfn</span> <span class="o">-</span> <span class="n">pfn_s</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Try to install p2m mapping; fail if intermediate bits missing */</span>
<span class="n">bool</span> <span class="nf">__set_phys_to_machine</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">topidx</span><span class="p">,</span> <span class="n">mididx</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">xen_feature</span><span class="p">(</span><span class="n">XENFEAT_auto_translated_physmap</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pfn</span> <span class="o">!=</span> <span class="n">mfn</span> <span class="o">&amp;&amp;</span> <span class="n">mfn</span> <span class="o">!=</span> <span class="n">INVALID_P2M_ENTRY</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">MAX_P2M_PFN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mfn</span> <span class="o">!=</span> <span class="n">INVALID_P2M_ENTRY</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">topidx</span> <span class="o">=</span> <span class="n">p2m_top_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">mididx</span> <span class="o">=</span> <span class="n">p2m_mid_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">p2m_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="cm">/* For sparse holes were the p2m leaf has real PFN along with</span>
<span class="cm">	 * PCI holes, stick in the PFN as the MFN value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mfn</span> <span class="o">!=</span> <span class="n">INVALID_P2M_ENTRY</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mfn</span> <span class="o">&amp;</span> <span class="n">IDENTITY_FRAME_BIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_identity</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/* Swap over from MISSING to IDENTITY if needed. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_missing</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">],</span> <span class="n">p2m_missing</span><span class="p">,</span>
				<span class="n">p2m_identity</span><span class="p">)</span> <span class="o">!=</span> <span class="n">p2m_missing</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_missing</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mfn</span> <span class="o">==</span> <span class="n">INVALID_P2M_ENTRY</span><span class="p">;</span>

	<span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mfn</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">set_phys_to_machine</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">__set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">mfn</span><span class="p">)))</span>  <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_p2m</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">mfn</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define M2P_OVERRIDE_HASH_SHIFT	10</span>
<span class="cp">#define M2P_OVERRIDE_HASH	(1 &lt;&lt; M2P_OVERRIDE_HASH_SHIFT)</span>

<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">,</span> <span class="n">m2p_overrides</span><span class="p">,</span> <span class="n">M2P_OVERRIDE_HASH</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">m2p_override_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">m2p_override_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">m2p_overrides</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m2p_overrides</span><span class="p">)</span> <span class="o">*</span> <span class="n">M2P_OVERRIDE_HASH</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M2P_OVERRIDE_HASH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2p_overrides</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mfn_hash</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">mfn</span><span class="p">,</span> <span class="n">M2P_OVERRIDE_HASH_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Add an MFN override for a particular page */</span>
<span class="kt">int</span> <span class="nf">m2p_add_override</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">gnttab_map_grant_ref</span> <span class="o">*</span><span class="n">kmap_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">ptep</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">ptep</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">level</span> <span class="o">!=</span> <span class="n">PG_LEVEL_4K</span><span class="p">,</span>
					<span class="s">&quot;m2p_add_override: pfn %lx not mapped&quot;</span><span class="p">,</span> <span class="n">pfn</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">SetPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_page_private</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mfn</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">pfn_to_mfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">FOREIGN_FRAME</span><span class="p">(</span><span class="n">mfn</span><span class="p">))))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kmap_op</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span> <span class="o">=</span>
				<span class="n">xen_mc_entry</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">kmap_op</span><span class="p">));</span>

			<span class="n">MULTI_grant_table_op</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span>
					<span class="n">GNTTABOP_map_grant_ref</span><span class="p">,</span> <span class="n">kmap_op</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* let&#39;s use dev_bus_addr to record the old mfn instead */</span>
		<span class="n">kmap_op</span><span class="o">-&gt;</span><span class="n">dev_bus_addr</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">kmap_op</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2p_override_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">m2p_overrides</span><span class="p">[</span><span class="n">mfn_hash</span><span class="p">(</span><span class="n">mfn</span><span class="p">)]);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2p_override_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* p2m(m2p(mfn)) == mfn: the mfn is already present somewhere in</span>
<span class="cm">	 * this domain. Set the FOREIGN_FRAME_BIT in the p2m for the other</span>
<span class="cm">	 * pfn so that the following mfn_to_pfn(mfn) calls will return the</span>
<span class="cm">	 * pfn from the m2p_override (the backend pfn) instead.</span>
<span class="cm">	 * We need to do this because the pages shared by the frontend</span>
<span class="cm">	 * (xen-blkfront) can be already locked (lock_page, called by</span>
<span class="cm">	 * do_read_cache_page); when the userspace backend tries to use them</span>
<span class="cm">	 * with direct_IO, mfn_to_pfn returns the pfn of the frontend, so</span>
<span class="cm">	 * do_blockdev_direct_IO is going to try to lock the same pages</span>
<span class="cm">	 * again resulting in a deadlock.</span>
<span class="cm">	 * As a side effect get_user_pages_fast might not be safe on the</span>
<span class="cm">	 * frontend pages while they are being shared with the backend,</span>
<span class="cm">	 * because mfn_to_pfn (that ends up being called by GUPF) will</span>
<span class="cm">	 * return the backend pfn rather than the frontend pfn. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">machine_to_phys_mapping</span><span class="p">[</span><span class="n">mfn</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">get_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">)</span> <span class="o">==</span> <span class="n">mfn</span><span class="p">)</span>
		<span class="n">set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">FOREIGN_FRAME</span><span class="p">(</span><span class="n">mfn</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">m2p_add_override</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">m2p_remove_override</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">bool</span> <span class="n">clear_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">mfn</span> <span class="o">=</span> <span class="n">get_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mfn</span> <span class="o">==</span> <span class="n">INVALID_P2M_ENTRY</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">mfn</span> <span class="o">&amp;</span> <span class="n">FOREIGN_FRAME_BIT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">ptep</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">ptep</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">level</span> <span class="o">!=</span> <span class="n">PG_LEVEL_4K</span><span class="p">,</span>
					<span class="s">&quot;m2p_remove_override: pfn %lx not mapped&quot;</span><span class="p">,</span> <span class="n">pfn</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2p_override_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2p_override_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">ClearPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clear_pte</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gnttab_map_grant_ref</span> <span class="o">*</span><span class="n">map_op</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">gnttab_map_grant_ref</span> <span class="o">*</span><span class="p">)</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">map_op</span><span class="o">-&gt;</span><span class="n">dev_bus_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">gnttab_unmap_grant_ref</span> <span class="o">*</span><span class="n">unmap_op</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * It might be that we queued all the m2p grant table</span>
<span class="cm">			 * hypercalls in a multicall, then m2p_remove_override</span>
<span class="cm">			 * get called before the multicall has actually been</span>
<span class="cm">			 * issued. In this case handle is going to -1 because</span>
<span class="cm">			 * it hasn&#39;t been modified yet.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map_op</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">xen_mc_flush</span><span class="p">();</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now if map_op-&gt;handle is negative it means that the</span>
<span class="cm">			 * hypercall actually returned an error.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map_op</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">==</span> <span class="n">GNTST_general_error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;m2p_remove_override: &quot;</span>
						<span class="s">&quot;pfn %lx mfn %lx, failed to modify kernel mappings&quot;</span><span class="p">,</span>
						<span class="n">pfn</span><span class="p">,</span> <span class="n">mfn</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">mcs</span> <span class="o">=</span> <span class="n">xen_mc_entry</span><span class="p">(</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gnttab_unmap_grant_ref</span><span class="p">));</span>
			<span class="n">unmap_op</span> <span class="o">=</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">;</span>
			<span class="n">unmap_op</span><span class="o">-&gt;</span><span class="n">host_addr</span> <span class="o">=</span> <span class="n">map_op</span><span class="o">-&gt;</span><span class="n">host_addr</span><span class="p">;</span>
			<span class="n">unmap_op</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">map_op</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">;</span>
			<span class="n">unmap_op</span><span class="o">-&gt;</span><span class="n">dev_bus_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">MULTI_grant_table_op</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span>
					<span class="n">GNTTABOP_unmap_grant_ref</span><span class="p">,</span> <span class="n">unmap_op</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>

			<span class="n">set_pte_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span>
					<span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">));</span>
			<span class="n">__flush_tlb_single</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
			<span class="n">map_op</span><span class="o">-&gt;</span><span class="n">host_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="cm">/* p2m(m2p(mfn)) == FOREIGN_FRAME(mfn): the mfn is already present</span>
<span class="cm">	 * somewhere in this domain, even before being added to the</span>
<span class="cm">	 * m2p_override (see comment above in m2p_add_override).</span>
<span class="cm">	 * If there are no other entries in the m2p_override corresponding</span>
<span class="cm">	 * to this mfn, then remove the FOREIGN_FRAME_BIT from the p2m for</span>
<span class="cm">	 * the original pfn (the one shared by the frontend): the backend</span>
<span class="cm">	 * cannot do any IO on this page anymore because it has been</span>
<span class="cm">	 * unshared. Removing the FOREIGN_FRAME_BIT from the p2m entry of</span>
<span class="cm">	 * the original pfn causes mfn_to_pfn(mfn) to return the frontend</span>
<span class="cm">	 * pfn again. */</span>
	<span class="n">mfn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FOREIGN_FRAME_BIT</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">machine_to_phys_mapping</span><span class="p">[</span><span class="n">mfn</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">get_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">)</span> <span class="o">==</span> <span class="n">FOREIGN_FRAME</span><span class="p">(</span><span class="n">mfn</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">m2p_find_override</span><span class="p">(</span><span class="n">mfn</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">set_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">mfn</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">m2p_remove_override</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">m2p_find_override</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">bucket</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m2p_overrides</span><span class="p">[</span><span class="n">mfn_hash</span><span class="p">(</span><span class="n">mfn</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2p_override_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_private</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">mfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2p_override_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">m2p_find_override_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">m2p_find_override</span><span class="p">(</span><span class="n">mfn</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">m2p_find_override_pfn</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_XEN_DEBUG_FS</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &quot;debugfs.h&quot;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">p2m_dump_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">level_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;top&quot;</span><span class="p">,</span> <span class="s">&quot;middle&quot;</span><span class="p">,</span>
						<span class="s">&quot;entry&quot;</span><span class="p">,</span> <span class="s">&quot;abnormal&quot;</span><span class="p">,</span> <span class="s">&quot;error&quot;</span><span class="p">};</span>
<span class="cp">#define TYPE_IDENTITY 0</span>
<span class="cp">#define TYPE_MISSING 1</span>
<span class="cp">#define TYPE_PFN 2</span>
<span class="cp">#define TYPE_UNKNOWN 3</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">type_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">[</span><span class="n">TYPE_IDENTITY</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;identity&quot;</span><span class="p">,</span>
				<span class="p">[</span><span class="n">TYPE_MISSING</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;missing&quot;</span><span class="p">,</span>
				<span class="p">[</span><span class="n">TYPE_PFN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;pfn&quot;</span><span class="p">,</span>
				<span class="p">[</span><span class="n">TYPE_UNKNOWN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;abnormal&quot;</span><span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">prev_pfn_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">prev_pfn_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">prev_level</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">prev_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p2m_top</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">MAX_DOMAIN_PAGES</span><span class="p">;</span> <span class="n">pfn</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">topidx</span> <span class="o">=</span> <span class="n">p2m_top_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">mididx</span> <span class="o">=</span> <span class="n">p2m_mid_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">p2m_index</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">lvl</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>

		<span class="n">lvl</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_UNKNOWN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_mid_missing</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_MISSING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_UNKNOWN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_UNKNOWN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_identity</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_IDENTITY</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2m_missing</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_MISSING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_UNKNOWN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">IDENTITY_FRAME</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_IDENTITY</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">INVALID_P2M_ENTRY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_MISSING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_PFN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2m_top</span><span class="p">[</span><span class="n">topidx</span><span class="p">][</span><span class="n">mididx</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_PFN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prev_level</span> <span class="o">=</span> <span class="n">lvl</span><span class="p">;</span>
			<span class="n">prev_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">==</span> <span class="n">MAX_DOMAIN_PAGES</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lvl</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_UNKNOWN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; [0x%lx-&gt;0x%lx] %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">prev_pfn_type</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">type_name</span><span class="p">[</span><span class="n">prev_type</span><span class="p">]);</span>
			<span class="n">prev_pfn_type</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
			<span class="n">prev_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_level</span> <span class="o">!=</span> <span class="n">lvl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; [0x%lx-&gt;0x%lx] level %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">prev_pfn_level</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">level_name</span><span class="p">[</span><span class="n">prev_level</span><span class="p">]);</span>
			<span class="n">prev_pfn_level</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
			<span class="n">prev_level</span> <span class="o">=</span> <span class="n">lvl</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#undef TYPE_IDENTITY</span>
<span class="cp">#undef TYPE_MISSING</span>
<span class="cp">#undef TYPE_PFN</span>
<span class="cp">#undef TYPE_UNKNOWN</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">p2m_dump_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">p2m_dump_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">p2m_dump_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">p2m_dump_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_mmu_debug</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">xen_p2m_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_xen</span> <span class="o">=</span> <span class="n">xen_init_debugfs</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d_xen</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">d_mmu_debug</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;mmu&quot;</span><span class="p">,</span> <span class="n">d_xen</span><span class="p">);</span>

	<span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;p2m&quot;</span><span class="p">,</span> <span class="mo">0600</span><span class="p">,</span> <span class="n">d_mmu_debug</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p2m_dump_fops</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">xen_p2m_debugfs</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_XEN_DEBUG_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
