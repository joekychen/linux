<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › xen › mmu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mmu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Xen mmu operations</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains the various mmu fetch and update operations.</span>
<span class="cm"> * The most important job they must perform is the mapping between the</span>
<span class="cm"> * domain&#39;s pfn and the overall machine mfns.</span>
<span class="cm"> *</span>
<span class="cm"> * Xen allows guests to directly update the pagetable, in a controlled</span>
<span class="cm"> * fashion.  In other words, the guest modifies the same pagetable</span>
<span class="cm"> * that the CPU actually uses, which eliminates the overhead of having</span>
<span class="cm"> * a separate shadow pagetable.</span>
<span class="cm"> *</span>
<span class="cm"> * In order to allow this, it falls on the guest domain to map its</span>
<span class="cm"> * notion of a &quot;physical&quot; pfn - which is just a domain-local linear</span>
<span class="cm"> * address - into a real &quot;machine address&quot; which the CPU&#39;s MMU can</span>
<span class="cm"> * use.</span>
<span class="cm"> *</span>
<span class="cm"> * A pgd_t/pmd_t/pte_t will typically contain an mfn, and so can be</span>
<span class="cm"> * inserted directly into the pagetable.  When creating a new</span>
<span class="cm"> * pte/pmd/pgd, it converts the passed pfn into an mfn.  Conversely,</span>
<span class="cm"> * when reading the content back with __(pgd|pmd|pte)_val, it converts</span>
<span class="cm"> * the mfn back into a pfn.</span>
<span class="cm"> *</span>
<span class="cm"> * The other constraint is that all pages which make up a pagetable</span>
<span class="cm"> * must be mapped read-only in the guest.  This prevents uncontrolled</span>
<span class="cm"> * guest updates to the pagetable.  Xen strictly enforces this, and</span>
<span class="cm"> * will disallow any pagetable update which will end up mapping a</span>
<span class="cm"> * pagetable page RW, and will disallow using any writable page as a</span>
<span class="cm"> * pagetable.</span>
<span class="cm"> *</span>
<span class="cm"> * Naively, when loading %cr3 with the base of a new pagetable, Xen</span>
<span class="cm"> * would need to validate the whole pagetable before going on.</span>
<span class="cm"> * Naturally, this is quite slow.  The solution is to &quot;pin&quot; a</span>
<span class="cm"> * pagetable, which enforces all the constraints on the pagetable even</span>
<span class="cm"> * when it is not actively in use.  This menas that Xen can be assured</span>
<span class="cm"> * that it is still valid when you do load it into %cr3, and doesn&#39;t</span>
<span class="cm"> * need to revalidate it.</span>
<span class="cm"> *</span>
<span class="cm"> * Jeremy Fitzhardinge &lt;jeremy@xensource.com&gt;, XenSource Inc, 2007</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#include &lt;trace/events/xen.h&gt;</span>

<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/fixmap.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>
<span class="cp">#include &lt;asm/e820.h&gt;</span>
<span class="cp">#include &lt;asm/linkage.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/init.h&gt;</span>
<span class="cp">#include &lt;asm/pat.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>

<span class="cp">#include &lt;asm/xen/hypercall.h&gt;</span>
<span class="cp">#include &lt;asm/xen/hypervisor.h&gt;</span>

<span class="cp">#include &lt;xen/xen.h&gt;</span>
<span class="cp">#include &lt;xen/page.h&gt;</span>
<span class="cp">#include &lt;xen/interface/xen.h&gt;</span>
<span class="cp">#include &lt;xen/interface/hvm/hvm_op.h&gt;</span>
<span class="cp">#include &lt;xen/interface/version.h&gt;</span>
<span class="cp">#include &lt;xen/interface/memory.h&gt;</span>
<span class="cp">#include &lt;xen/hvc-console.h&gt;</span>

<span class="cp">#include &quot;multicalls.h&quot;</span>
<span class="cp">#include &quot;mmu.h&quot;</span>
<span class="cp">#include &quot;debugfs.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Protects atomic reservation decrease/increase against concurrent increases.</span>
<span class="cm"> * Also protects non-atomic updates of current_pages and balloon lists.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">xen_reservation_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Identity map, in addition to plain kernel map.  This needs to be</span>
<span class="cm"> * large enough to allocate page table pages to allocate the rest.</span>
<span class="cm"> * Each page can map 2MB.</span>
<span class="cm"> */</span>
<span class="cp">#define LEVEL1_IDENT_ENTRIES	(PTRS_PER_PTE * 4)</span>
<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="n">pte_t</span><span class="p">,</span> <span class="n">level1_ident_pgt</span><span class="p">,</span> <span class="n">LEVEL1_IDENT_ENTRIES</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cm">/* l3 pud for userspace vsyscall mapping */</span>
<span class="k">static</span> <span class="n">pud_t</span> <span class="n">level3_user_vsyscall</span><span class="p">[</span><span class="n">PTRS_PER_PUD</span><span class="p">]</span> <span class="n">__page_aligned_bss</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Note about cr3 (pagetable base) values:</span>
<span class="cm"> *</span>
<span class="cm"> * xen_cr3 contains the current logical cr3 value; it contains the</span>
<span class="cm"> * last set cr3.  This may not be the current effective cr3, because</span>
<span class="cm"> * its update may be being lazily deferred.  However, a vcpu looking</span>
<span class="cm"> * at its own cr3 can use this value knowing that it everything will</span>
<span class="cm"> * be self-consistent.</span>
<span class="cm"> *</span>
<span class="cm"> * xen_current_cr3 contains the actual vcpu cr3; it is set once the</span>
<span class="cm"> * hypercall to set the vcpu cr3 is complete (so it may be a little</span>
<span class="cm"> * out of date, but it will never be set early).  If one vcpu is</span>
<span class="cm"> * looking at another vcpu&#39;s cr3 value, it should use this variable.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">xen_cr3</span><span class="p">);</span>	 <span class="cm">/* cr3 stored as physaddr */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">xen_current_cr3</span><span class="p">);</span>	 <span class="cm">/* actual vcpu cr3 */</span>


<span class="cm">/*</span>
<span class="cm"> * Just beyond the highest usermode address.  STACK_TOP_MAX has a</span>
<span class="cm"> * redzone above it, so round it up to a PGD boundary.</span>
<span class="cm"> */</span>
<span class="cp">#define USER_LIMIT	((STACK_TOP_MAX + PGDIR_SIZE - 1) &amp; PGDIR_MASK)</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arbitrary_virt_to_mfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xmaddr_t</span> <span class="n">maddr</span> <span class="o">=</span> <span class="n">arbitrary_virt_to_machine</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">maddr</span><span class="p">.</span><span class="n">maddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">xmaddr_t</span> <span class="nf">arbitrary_virt_to_machine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the PFN is in the linear mapped vaddr range, we can just use</span>
<span class="cm">	 * the (quick) virt_to_machine() p2m lookup</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">virt_addr_valid</span><span class="p">(</span><span class="n">vaddr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">virt_to_machine</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

	<span class="cm">/* otherwise we have to do a (slower) full page-table walk */</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">XMADDR</span><span class="p">(((</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">pte_mfn</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">arbitrary_virt_to_machine</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">make_lowmem_page_readonly</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* vaddr missing */</span>

	<span class="n">ptev</span> <span class="o">=</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_update_va_mapping</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">ptev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">make_lowmem_page_readwrite</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* vaddr missing */</span>

	<span class="n">ptev</span> <span class="o">=</span> <span class="n">pte_mkwrite</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_update_va_mapping</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">ptev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">bool</span> <span class="nf">xen_page_pinned</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PagePinned</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xen_set_domain_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">domid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_update</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>

	<span class="n">trace_xen_mmu_set_domain_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">,</span> <span class="n">domid</span><span class="p">);</span>

	<span class="n">mcs</span> <span class="o">=</span> <span class="n">xen_mc_entry</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">));</span>
	<span class="n">u</span> <span class="o">=</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">;</span>

	<span class="cm">/* ptep might be kmapped when using 32-bit HIGHPTE */</span>
	<span class="n">u</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">virt_to_machine</span><span class="p">(</span><span class="n">ptep</span><span class="p">).</span><span class="n">maddr</span><span class="p">;</span>
	<span class="n">u</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">pte_val_ma</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>

	<span class="n">MULTI_mmu_update</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">domid</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xen_set_domain_pte</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_extend_mmu_update</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mmu_update</span> <span class="o">*</span><span class="n">update</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_update</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>

	<span class="n">mcs</span> <span class="o">=</span> <span class="n">xen_mc_extend_args</span><span class="p">(</span><span class="n">__HYPERVISOR_mmu_update</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mcs</span> <span class="o">=</span> <span class="n">__xen_mc_entry</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">));</span>
		<span class="n">MULTI_mmu_update</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DOMID_SELF</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">u</span> <span class="o">=</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">;</span>
	<span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="o">*</span><span class="n">update</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_extend_mmuext_op</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mmuext_op</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmuext_op</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>

	<span class="n">mcs</span> <span class="o">=</span> <span class="n">xen_mc_extend_args</span><span class="p">(</span><span class="n">__HYPERVISOR_mmuext_op</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mcs</span> <span class="o">=</span> <span class="n">__xen_mc_entry</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">u</span><span class="p">));</span>
		<span class="n">MULTI_mmuext_op</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DOMID_SELF</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">u</span> <span class="o">=</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">;</span>
	<span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_set_pmd_hyper</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_update</span> <span class="n">u</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">xen_mc_batch</span><span class="p">();</span>

	<span class="cm">/* ptr may be ioremapped for 64-bit pagetable setup */</span>
	<span class="n">u</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">arbitrary_virt_to_machine</span><span class="p">(</span><span class="n">ptr</span><span class="p">).</span><span class="n">maddr</span><span class="p">;</span>
	<span class="n">u</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">pmd_val_ma</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">xen_extend_mmu_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_set_pmd</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xen_mmu_set_pmd</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* If page is not pinned, we can just update the entry</span>
<span class="cm">	   directly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xen_page_pinned</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xen_set_pmd_hyper</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Associate a virtual page frame with a given physical page frame</span>
<span class="cm"> * and protection flags for that frame.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_pte_mfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte_vaddr</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">mfn_pte</span><span class="p">(</span><span class="n">mfn</span><span class="p">,</span> <span class="n">flags</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">xen_batched_set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_update</span> <span class="n">u</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">paravirt_get_lazy_mode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">PARAVIRT_LAZY_MMU</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">xen_mc_batch</span><span class="p">();</span>

	<span class="n">u</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">virt_to_machine</span><span class="p">(</span><span class="n">ptep</span><span class="p">).</span><span class="n">maddr</span> <span class="o">|</span> <span class="n">MMU_NORMAL_PT_UPDATE</span><span class="p">;</span>
	<span class="n">u</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">pte_val_ma</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>
	<span class="n">xen_extend_mmu_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__xen_set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xen_batched_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">))</span>
		<span class="n">native_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xen_mmu_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
	<span class="n">__xen_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_set_pte_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		    <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xen_mmu_set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
	<span class="n">__xen_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">pte_t</span> <span class="nf">xen_ptep_modify_prot_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Just return the pte as-is.  We preserve the bits on commit */</span>
	<span class="n">trace_xen_mmu_ptep_modify_prot_start</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">xen_ptep_modify_prot_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				 <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_update</span> <span class="n">u</span><span class="p">;</span>

	<span class="n">trace_xen_mmu_ptep_modify_prot_commit</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="n">xen_mc_batch</span><span class="p">();</span>

	<span class="n">u</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">virt_to_machine</span><span class="p">(</span><span class="n">ptep</span><span class="p">).</span><span class="n">maddr</span> <span class="o">|</span> <span class="n">MMU_PT_UPDATE_PRESERVE_AD</span><span class="p">;</span>
	<span class="n">u</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">pte_val_ma</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="n">xen_extend_mmu_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Assume pteval_t is equivalent to all the other *val_t types. */</span>
<span class="k">static</span> <span class="n">pteval_t</span> <span class="nf">pte_mfn_to_pfn</span><span class="p">(</span><span class="n">pteval_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">_PAGE_PRESENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PTE_PFN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">mfn_to_pfn</span><span class="p">(</span><span class="n">mfn</span><span class="p">);</span>

		<span class="n">pteval_t</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">PTE_FLAGS_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pfn</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0</span><span class="p">))</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_PRESENT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">pteval_t</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pteval_t</span> <span class="nf">pte_pfn_to_mfn</span><span class="p">(</span><span class="n">pteval_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">_PAGE_PRESENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PTE_PFN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">pteval_t</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">PTE_FLAGS_MASK</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xen_feature</span><span class="p">(</span><span class="n">XENFEAT_auto_translated_physmap</span><span class="p">))</span>
			<span class="n">mfn</span> <span class="o">=</span> <span class="n">get_phys_to_machine</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mfn</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there&#39;s no mfn for the pfn, then just create an</span>
<span class="cm">		 * empty non-present pte.  Unfortunately this loses</span>
<span class="cm">		 * information about the original pfn, so</span>
<span class="cm">		 * pte_mfn_to_pfn is asymmetric.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mfn</span> <span class="o">==</span> <span class="n">INVALID_P2M_ENTRY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Paramount to do this test _after_ the</span>
<span class="cm">			 * INVALID_P2M_ENTRY as INVALID_P2M_ENTRY &amp;</span>
<span class="cm">			 * IDENTITY_FRAME_BIT resolves to true.</span>
<span class="cm">			 */</span>
			<span class="n">mfn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FOREIGN_FRAME_BIT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mfn</span> <span class="o">&amp;</span> <span class="n">IDENTITY_FRAME_BIT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mfn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IDENTITY_FRAME_BIT</span><span class="p">;</span>
				<span class="n">flags</span> <span class="o">|=</span> <span class="n">_PAGE_IOMAP</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">pteval_t</span><span class="p">)</span><span class="n">mfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pteval_t</span> <span class="nf">iomap_pte</span><span class="p">(</span><span class="n">pteval_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">_PAGE_PRESENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PTE_PFN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">pteval_t</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">PTE_FLAGS_MASK</span><span class="p">;</span>

		<span class="cm">/* We assume the pte frame number is a MFN, so</span>
<span class="cm">		   just use it as-is. */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">pteval_t</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pteval_t</span> <span class="nf">xen_pte_val</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pteval_t</span> <span class="n">pteval</span> <span class="o">=</span> <span class="n">pte</span><span class="p">.</span><span class="n">pte</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* If this is a WC pte, convert back from Xen WC to Linux WC */</span>
<span class="c">	if ((pteval &amp; (_PAGE_PAT | _PAGE_PCD | _PAGE_PWT)) == _PAGE_PAT) {</span>
<span class="c">		WARN_ON(!pat_enabled);</span>
<span class="c">		pteval = (pteval &amp; ~_PAGE_PAT) | _PAGE_PWT;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xen_initial_domain</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pteval</span> <span class="o">&amp;</span> <span class="n">_PAGE_IOMAP</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pteval</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pte_mfn_to_pfn</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">xen_pte_val</span><span class="p">);</span>

<span class="k">static</span> <span class="n">pgdval_t</span> <span class="nf">xen_pgd_val</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_mfn_to_pfn</span><span class="p">(</span><span class="n">pgd</span><span class="p">.</span><span class="n">pgd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">xen_pgd_val</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Xen&#39;s PAT setup is part of its ABI, though I assume entries 6 &amp; 7</span>
<span class="cm"> * are reserved for now, to correspond to the Intel-reserved PAT</span>
<span class="cm"> * types.</span>
<span class="cm"> *</span>
<span class="cm"> * We expect Linux&#39;s PAT set as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * Idx  PTE flags        Linux    Xen    Default</span>
<span class="cm"> * 0                     WB       WB     WB</span>
<span class="cm"> * 1            PWT      WC       WT     WT</span>
<span class="cm"> * 2        PCD          UC-      UC-    UC-</span>
<span class="cm"> * 3        PCD PWT      UC       UC     UC</span>
<span class="cm"> * 4    PAT              WB       WC     WB</span>
<span class="cm"> * 5    PAT     PWT      WC       WP     WT</span>
<span class="cm"> * 6    PAT PCD          UC-      UC     UC-</span>
<span class="cm"> * 7    PAT PCD PWT      UC       UC     UC</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">xen_set_pat</span><span class="p">(</span><span class="n">u64</span> <span class="n">pat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We expect Linux to use a PAT setting of</span>
<span class="cm">	 * UC UC- WC WB (ignoring the PAT flag) */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pat</span> <span class="o">!=</span> <span class="mh">0x0007010600070106ull</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pte_t</span> <span class="nf">xen_make_pte</span><span class="p">(</span><span class="n">pteval_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_PFN_MASK</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* If Linux is trying to set a WC pte, then map to the Xen WC.</span>
<span class="c">	 * If _PAGE_PAT is set, then it probably means it is really</span>
<span class="c">	 * _PAGE_PSE, so avoid fiddling with the PAT mapping and hope</span>
<span class="c">	 * things work out OK...</span>
<span class="c">	 *</span>
<span class="c">	 * (We should never see kernel mappings with _PAGE_PSE set,</span>
<span class="c">	 * but we could see hugetlbfs mappings, I think.).</span>
<span class="c">	 */</span>
<span class="c">	if (pat_enabled &amp;&amp; !WARN_ON(pte &amp; _PAGE_PAT)) {</span>
<span class="c">		if ((pte &amp; (_PAGE_PCD | _PAGE_PWT)) == _PAGE_PWT)</span>
<span class="c">			pte = (pte &amp; ~(_PAGE_PCD | _PAGE_PWT)) | _PAGE_PAT;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unprivileged domains are allowed to do IOMAPpings for</span>
<span class="cm">	 * PCI passthrough, but not map ISA space.  The ISA</span>
<span class="cm">	 * mappings are just dummy local mappings to keep other</span>
<span class="cm">	 * parts of the kernel happy.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">_PAGE_IOMAP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">xen_initial_domain</span><span class="p">()</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">ISA_END_ADDRESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">iomap_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_IOMAP</span><span class="p">;</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_pfn_to_mfn</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">native_make_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">xen_make_pte</span><span class="p">);</span>

<span class="k">static</span> <span class="n">pgd_t</span> <span class="nf">xen_make_pgd</span><span class="p">(</span><span class="n">pgdval_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pte_pfn_to_mfn</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">native_make_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">xen_make_pgd</span><span class="p">);</span>

<span class="k">static</span> <span class="n">pmdval_t</span> <span class="nf">xen_pmd_val</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_mfn_to_pfn</span><span class="p">(</span><span class="n">pmd</span><span class="p">.</span><span class="n">pmd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">xen_pmd_val</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_set_pud_hyper</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pud_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_update</span> <span class="n">u</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">xen_mc_batch</span><span class="p">();</span>

	<span class="cm">/* ptr may be ioremapped for 64-bit pagetable setup */</span>
	<span class="n">u</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">arbitrary_virt_to_machine</span><span class="p">(</span><span class="n">ptr</span><span class="p">).</span><span class="n">maddr</span><span class="p">;</span>
	<span class="n">u</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">pud_val_ma</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">xen_extend_mmu_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_set_pud</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pud_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xen_mmu_set_pud</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* If page is not pinned, we can just update the entry</span>
<span class="cm">	   directly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xen_page_pinned</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xen_set_pud_hyper</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_PAE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_set_pte_atomic</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xen_mmu_set_pte_atomic</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="n">set_64bit</span><span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">ptep</span><span class="p">,</span> <span class="n">native_pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_pte_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xen_mmu_pte_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xen_batched_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">native_make_pte</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
		<span class="n">native_pte_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_pmd_clear</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xen_mmu_pmd_clear</span><span class="p">(</span><span class="n">pmdp</span><span class="p">);</span>
	<span class="n">set_pmd</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_X86_PAE */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">pmd_t</span> <span class="nf">xen_make_pmd</span><span class="p">(</span><span class="n">pmdval_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pte_pfn_to_mfn</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">native_make_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">xen_make_pmd</span><span class="p">);</span>

<span class="cp">#if PAGETABLE_LEVELS == 4</span>
<span class="k">static</span> <span class="n">pudval_t</span> <span class="nf">xen_pud_val</span><span class="p">(</span><span class="n">pud_t</span> <span class="n">pud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_mfn_to_pfn</span><span class="p">(</span><span class="n">pud</span><span class="p">.</span><span class="n">pud</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">xen_pud_val</span><span class="p">);</span>

<span class="k">static</span> <span class="n">pud_t</span> <span class="nf">xen_make_pud</span><span class="p">(</span><span class="n">pudval_t</span> <span class="n">pud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">pte_pfn_to_mfn</span><span class="p">(</span><span class="n">pud</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">native_make_pud</span><span class="p">(</span><span class="n">pud</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">xen_make_pud</span><span class="p">);</span>

<span class="k">static</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="nf">xen_get_user_pgd</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pgd</span> <span class="o">-</span> <span class="n">pgd_page</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">user_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">USER_LIMIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">pgd_page</span><span class="p">);</span>
		<span class="n">user_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_ptr</span><span class="p">)</span>
			<span class="n">user_ptr</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">user_ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__xen_set_pgd_hyper</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_update</span> <span class="n">u</span><span class="p">;</span>

	<span class="n">u</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">virt_to_machine</span><span class="p">(</span><span class="n">ptr</span><span class="p">).</span><span class="n">maddr</span><span class="p">;</span>
	<span class="n">u</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">pgd_val_ma</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">xen_extend_mmu_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Raw hypercall-based set_pgd, intended for in early boot before</span>
<span class="cm"> * there&#39;s a page structure.  This implies:</span>
<span class="cm"> *  1. The only existing pagetable is the kernel&#39;s</span>
<span class="cm"> *  2. It is always pinned</span>
<span class="cm"> *  3. It has no user pagetable attached to it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_set_pgd_hyper</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">xen_mc_batch</span><span class="p">();</span>

	<span class="n">__xen_set_pgd_hyper</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_set_pgd</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">user_ptr</span> <span class="o">=</span> <span class="n">xen_get_user_pgd</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

	<span class="n">trace_xen_mmu_set_pgd</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">user_ptr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* If page is not pinned, we can just update the entry</span>
<span class="cm">	   directly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xen_page_pinned</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">xen_page_pinned</span><span class="p">(</span><span class="n">user_ptr</span><span class="p">));</span>
			<span class="o">*</span><span class="n">user_ptr</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If it&#39;s pinned, then we can at least batch the kernel and</span>
<span class="cm">	   user updates together. */</span>
	<span class="n">xen_mc_batch</span><span class="p">();</span>

	<span class="n">__xen_set_pgd_hyper</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_ptr</span><span class="p">)</span>
		<span class="n">__xen_set_pgd_hyper</span><span class="p">(</span><span class="n">user_ptr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* PAGETABLE_LEVELS == 4 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * (Yet another) pagetable walker.  This one is intended for pinning a</span>
<span class="cm"> * pagetable.  This means that it walks a pagetable and calls the</span>
<span class="cm"> * callback function on each page it finds making up the page table,</span>
<span class="cm"> * at every level.  It walks the entire pagetable, but it only bothers</span>
<span class="cm"> * pinning pte pages which are below limit.  In the normal case this</span>
<span class="cm"> * will be STACK_TOP_MAX, but at boot we need to pin up to</span>
<span class="cm"> * FIXADDR_TOP.</span>
<span class="cm"> *</span>
<span class="cm"> * For 32-bit the important bit is that we don&#39;t pin beyond there,</span>
<span class="cm"> * because then we start getting into Xen&#39;s ptes.</span>
<span class="cm"> *</span>
<span class="cm"> * For 64-bit, we must skip the Xen hole in the middle of the address</span>
<span class="cm"> * space, just after the big x86-64 virtual hole.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__xen_pgd_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">pt_level</span><span class="p">),</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hole_low</span><span class="p">,</span> <span class="n">hole_high</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">pgdidx_limit</span><span class="p">,</span> <span class="n">pudidx_limit</span><span class="p">,</span> <span class="n">pmdidx_limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">pgdidx</span><span class="p">,</span> <span class="n">pudidx</span><span class="p">,</span> <span class="n">pmdidx</span><span class="p">;</span>

	<span class="cm">/* The limit is the last byte to be touched */</span>
	<span class="n">limit</span><span class="o">--</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">limit</span> <span class="o">&gt;=</span> <span class="n">FIXADDR_TOP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xen_feature</span><span class="p">(</span><span class="n">XENFEAT_auto_translated_physmap</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 64-bit has a great big hole in the middle of the address</span>
<span class="cm">	 * space, which contains the Xen mappings.  On 32-bit these</span>
<span class="cm">	 * will end up making a zero-sized hole and so is a no-op.</span>
<span class="cm">	 */</span>
	<span class="n">hole_low</span> <span class="o">=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">USER_LIMIT</span><span class="p">);</span>
	<span class="n">hole_high</span> <span class="o">=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">PAGE_OFFSET</span><span class="p">);</span>

	<span class="n">pgdidx_limit</span> <span class="o">=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>
<span class="cp">#if PTRS_PER_PUD &gt; 1</span>
	<span class="n">pudidx_limit</span> <span class="o">=</span> <span class="n">pud_index</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">pudidx_limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if PTRS_PER_PMD &gt; 1</span>
	<span class="n">pmdidx_limit</span> <span class="o">=</span> <span class="n">pmd_index</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">pmdidx_limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pgdidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pgdidx</span> <span class="o">&lt;=</span> <span class="n">pgdidx_limit</span><span class="p">;</span> <span class="n">pgdidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pgdidx</span> <span class="o">&gt;=</span> <span class="n">hole_low</span> <span class="o">&amp;&amp;</span> <span class="n">pgdidx</span> <span class="o">&lt;</span> <span class="n">hole_high</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">[</span><span class="n">pgdidx</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd</span><span class="p">[</span><span class="n">pgdidx</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PTRS_PER_PUD</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* not folded */</span>
			<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">mm</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">pud</span><span class="p">),</span> <span class="n">PT_PUD</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pudidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pudidx</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PUD</span><span class="p">;</span> <span class="n">pudidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pgdidx</span> <span class="o">==</span> <span class="n">pgdidx_limit</span> <span class="o">&amp;&amp;</span>
			    <span class="n">pudidx</span> <span class="o">&gt;</span> <span class="n">pudidx_limit</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="n">pud</span><span class="p">[</span><span class="n">pudidx</span><span class="p">]))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pud</span><span class="p">[</span><span class="n">pudidx</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">PTRS_PER_PMD</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* not folded */</span>
				<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">mm</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">pmd</span><span class="p">),</span> <span class="n">PT_PMD</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">pmdidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pmdidx</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PMD</span><span class="p">;</span> <span class="n">pmdidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">pgdidx</span> <span class="o">==</span> <span class="n">pgdidx_limit</span> <span class="o">&amp;&amp;</span>
				    <span class="n">pudidx</span> <span class="o">==</span> <span class="n">pudidx_limit</span> <span class="o">&amp;&amp;</span>
				    <span class="n">pmdidx</span> <span class="o">&gt;</span> <span class="n">pmdidx_limit</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="n">pmd</span><span class="p">[</span><span class="n">pmdidx</span><span class="p">]))</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">pte</span> <span class="o">=</span> <span class="n">pmd_page</span><span class="p">(</span><span class="n">pmd</span><span class="p">[</span><span class="n">pmdidx</span><span class="p">]);</span>
				<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">PT_PTE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="cm">/* Do the top level last, so that the callbacks can use it as</span>
<span class="cm">	   a cue to do final things like tlb flushes. */</span>
	<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">mm</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">pgd</span><span class="p">),</span> <span class="n">PT_PGD</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">flush</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xen_pgd_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">enum</span> <span class="n">pt_level</span><span class="p">),</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__xen_pgd_walk</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If we&#39;re using split pte locks, then take the page&#39;s lock and</span>
<span class="cm">   return a pointer to it.  Otherwise return NULL. */</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="nf">xen_pte_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cp">#if USE_SPLIT_PTLOCKS</span>
	<span class="n">ptl</span> <span class="o">=</span> <span class="n">__pte_lockptr</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_lock_nest_lock</span><span class="p">(</span><span class="n">ptl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">ptl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_pte_unlock</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">ptl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_do_pin</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">level</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmuext_op</span> <span class="n">op</span><span class="p">;</span>

	<span class="n">op</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">op</span><span class="p">.</span><span class="n">arg1</span><span class="p">.</span><span class="n">mfn</span> <span class="o">=</span> <span class="n">pfn_to_mfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="n">xen_extend_mmuext_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xen_pin_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">pt_level</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">pgfl</span> <span class="o">=</span> <span class="n">TestSetPagePinned</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">flush</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgfl</span><span class="p">)</span>
		<span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* already pinned */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="cm">/* kmaps need flushing if we found an unpinned</span>
<span class="cm">		   highpage */</span>
		<span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">lowmem_page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span> <span class="o">=</span> <span class="n">__xen_mc_entry</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

		<span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to hold the pagetable lock between the time</span>
<span class="cm">		 * we make the pagetable RO and when we actually pin</span>
<span class="cm">		 * it.  If we don&#39;t, then other users may come in and</span>
<span class="cm">		 * attempt to update the pagetable by writing it,</span>
<span class="cm">		 * which will fail because the memory is RO but not</span>
<span class="cm">		 * pinned, so Xen won&#39;t do the trap&#39;n&#39;emulate.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If we&#39;re using split pte locks, we can&#39;t hold the</span>
<span class="cm">		 * entire pagetable&#39;s worth of locks during the</span>
<span class="cm">		 * traverse, because we may wrap the preempt count (8</span>
<span class="cm">		 * bits).  The solution is to mark RO and pin each PTE</span>
<span class="cm">		 * page while holding the lock.  This means the number</span>
<span class="cm">		 * of locks we end up holding is never more than a</span>
<span class="cm">		 * batch size (~32 entries, at present).</span>
<span class="cm">		 *</span>
<span class="cm">		 * If we&#39;re not using split pte locks, we needn&#39;t pin</span>
<span class="cm">		 * the PTE pages independently, because we&#39;re</span>
<span class="cm">		 * protected by the overall pagetable lock.</span>
<span class="cm">		 */</span>
		<span class="n">ptl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PTE</span><span class="p">)</span>
			<span class="n">ptl</span> <span class="o">=</span> <span class="n">xen_pte_lock</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>

		<span class="n">MULTI_update_va_mapping</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pt</span><span class="p">,</span>
					<span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">),</span>
					<span class="n">level</span> <span class="o">==</span> <span class="n">PT_PGD</span> <span class="o">?</span> <span class="n">UVMF_TLB_FLUSH</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ptl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xen_do_pin</span><span class="p">(</span><span class="n">MMUEXT_PIN_L1_TABLE</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

			<span class="cm">/* Queue a deferred unlock for when this batch</span>
<span class="cm">			   is completed. */</span>
			<span class="n">xen_mc_callback</span><span class="p">(</span><span class="n">xen_pte_unlock</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">flush</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is called just after a mm has been created, but it has not</span>
<span class="cm">   been used yet.  We need to make sure that its pagetable is all</span>
<span class="cm">   read-only, and can be pinned. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__xen_pgd_pin</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xen_mmu_pgd_pin</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">);</span>

	<span class="n">xen_mc_batch</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__xen_pgd_walk</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">xen_pin_page</span><span class="p">,</span> <span class="n">USER_LIMIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* re-enable interrupts for flushing */</span>
		<span class="n">xen_mc_issue</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

		<span class="n">kmap_flush_unused</span><span class="p">();</span>

		<span class="n">xen_mc_batch</span><span class="p">();</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="p">{</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">user_pgd</span> <span class="o">=</span> <span class="n">xen_get_user_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>

		<span class="n">xen_do_pin</span><span class="p">(</span><span class="n">MMUEXT_PIN_L4_TABLE</span><span class="p">,</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pgd</span><span class="p">)));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">user_pgd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xen_pin_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">user_pgd</span><span class="p">),</span> <span class="n">PT_PGD</span><span class="p">);</span>
			<span class="n">xen_do_pin</span><span class="p">(</span><span class="n">MMUEXT_PIN_L4_TABLE</span><span class="p">,</span>
				   <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">user_pgd</span><span class="p">)));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_X86_32 */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_X86_PAE</span>
	<span class="cm">/* Need to make sure unshared kernel PMD is pinnable */</span>
	<span class="n">xen_pin_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_page</span><span class="p">(</span><span class="n">pgd</span><span class="p">[</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">TASK_SIZE</span><span class="p">)]),</span>
		     <span class="n">PT_PMD</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">xen_do_pin</span><span class="p">(</span><span class="n">MMUEXT_PIN_L3_TABLE</span><span class="p">,</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pgd</span><span class="p">)));</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>
	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_pgd_pin</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__xen_pgd_pin</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On save, we need to pin all pagetables to make sure they get their</span>
<span class="cm"> * mfns turned into pfns.  Search the list for any unpinned pgds and pin</span>
<span class="cm"> * them (unpinned pgds are not currently in use, probably because the</span>
<span class="cm"> * process is under construction or destruction).</span>
<span class="cm"> *</span>
<span class="cm"> * Expected to be called in stop_machine() (&quot;equivalent to taking</span>
<span class="cm"> * every spinlock in the system&quot;), so the locking doesn&#39;t really</span>
<span class="cm"> * matter all that much.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xen_mm_pin_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgd_list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PagePinned</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__xen_pgd_pin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">SetPageSavePinned</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The init_mm pagetable is really pinned as soon as its created, but</span>
<span class="cm"> * that&#39;s before we have page structures to store the bits.  So do all</span>
<span class="cm"> * the book-keeping now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">xen_mark_pinned</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">pt_level</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SetPagePinned</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_mark_init_mm_pinned</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xen_pgd_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">xen_mark_pinned</span><span class="p">,</span> <span class="n">FIXADDR_TOP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xen_unpin_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">pt_level</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">pgfl</span> <span class="o">=</span> <span class="n">TestClearPagePinned</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgfl</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">lowmem_page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do the converse to pin_page.  If we&#39;re using split</span>
<span class="cm">		 * pte locks, we must be holding the lock for while</span>
<span class="cm">		 * the pte page is unpinned but still RO to prevent</span>
<span class="cm">		 * concurrent updates from seeing it in this</span>
<span class="cm">		 * partially-pinned state.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PTE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptl</span> <span class="o">=</span> <span class="n">xen_pte_lock</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ptl</span><span class="p">)</span>
				<span class="n">xen_do_pin</span><span class="p">(</span><span class="n">MMUEXT_UNPIN_TABLE</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">mcs</span> <span class="o">=</span> <span class="n">__xen_mc_entry</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

		<span class="n">MULTI_update_va_mapping</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pt</span><span class="p">,</span>
					<span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">),</span>
					<span class="n">level</span> <span class="o">==</span> <span class="n">PT_PGD</span> <span class="o">?</span> <span class="n">UVMF_TLB_FLUSH</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ptl</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* unlock when batch completed */</span>
			<span class="n">xen_mc_callback</span><span class="p">(</span><span class="n">xen_pte_unlock</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* never need to flush on unpin */</span>
<span class="p">}</span>

<span class="cm">/* Release a pagetables pages back as normal RW */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__xen_pgd_unpin</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xen_mmu_pgd_unpin</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">);</span>

	<span class="n">xen_mc_batch</span><span class="p">();</span>

	<span class="n">xen_do_pin</span><span class="p">(</span><span class="n">MMUEXT_UNPIN_TABLE</span><span class="p">,</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pgd</span><span class="p">)));</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="p">{</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">user_pgd</span> <span class="o">=</span> <span class="n">xen_get_user_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">user_pgd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xen_do_pin</span><span class="p">(</span><span class="n">MMUEXT_UNPIN_TABLE</span><span class="p">,</span>
				   <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">user_pgd</span><span class="p">)));</span>
			<span class="n">xen_unpin_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">user_pgd</span><span class="p">),</span> <span class="n">PT_PGD</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_PAE</span>
	<span class="cm">/* Need to make sure unshared kernel PMD is unpinned */</span>
	<span class="n">xen_unpin_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_page</span><span class="p">(</span><span class="n">pgd</span><span class="p">[</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">TASK_SIZE</span><span class="p">)]),</span>
		       <span class="n">PT_PMD</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">__xen_pgd_walk</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">xen_unpin_page</span><span class="p">,</span> <span class="n">USER_LIMIT</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_pgd_unpin</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__xen_pgd_unpin</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On resume, undo any pinning done at save, so that the rest of the</span>
<span class="cm"> * kernel doesn&#39;t see any unexpected pinned pagetables.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xen_mm_unpin_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgd_list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageSavePinned</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PagePinned</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">__xen_pgd_unpin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">ClearPageSavePinned</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_activate_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">xen_pgd_pin</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_dup_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">xen_pgd_pin</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/* Another cpu may still have their %cr3 pointing at the pagetable, so</span>
<span class="cm">   we need to repoint it somewhere else before we can unpin it. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_other_mm_ref</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">active_mm</span><span class="p">;</span>

	<span class="n">active_mm</span> <span class="o">=</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">cpu_tlbstate</span><span class="p">.</span><span class="n">active_mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">active_mm</span> <span class="o">==</span> <span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">cpu_tlbstate</span><span class="p">.</span><span class="n">state</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TLBSTATE_OK</span><span class="p">)</span>
		<span class="n">leave_mm</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="cm">/* If this cpu still has a stale cr3 reference, then make sure</span>
<span class="cm">	   it has been flushed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu_read</span><span class="p">(</span><span class="n">xen_current_cr3</span><span class="p">)</span> <span class="o">==</span> <span class="n">__pa</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">))</span>
		<span class="n">load_cr3</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_drop_mm_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">)</span>
			<span class="n">load_cr3</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">leave_mm</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="cm">/* Get the &quot;official&quot; set of cpus referring to our pagetable. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
			    <span class="o">&amp;&amp;</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">xen_current_cr3</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">drop_other_mm_ref</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>

	<span class="cm">/* It&#39;s possible that a vcpu may have a stale reference to our</span>
<span class="cm">	   cr3, because its in lazy mode, and it hasn&#39;t yet flushed</span>
<span class="cm">	   its set of pending hypercalls yet.  In this case, we can</span>
<span class="cm">	   look at its actual current cr3 value, and force it to flush</span>
<span class="cm">	   if needed. */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">xen_current_cr3</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">__pa</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">))</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
		<span class="n">smp_call_function_many</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">drop_other_mm_ref</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_drop_mm_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">)</span>
		<span class="n">load_cr3</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * While a process runs, Xen pins its pagetables, which means that the</span>
<span class="cm"> * hypervisor forces it to be read-only, and it controls all updates</span>
<span class="cm"> * to it.  This means that all pagetable updates have to go via the</span>
<span class="cm"> * hypervisor, which is moderately expensive.</span>
<span class="cm"> *</span>
<span class="cm"> * Since we&#39;re pulling the pagetable down, we switch to use init_mm,</span>
<span class="cm"> * unpin old process pagetable and mark it all read-write, which</span>
<span class="cm"> * allows further operations on it to be simple memory accesses.</span>
<span class="cm"> *</span>
<span class="cm"> * The only subtle point is that another CPU may be still using the</span>
<span class="cm"> * pagetable because of lazy tlb flushing.  This means we need need to</span>
<span class="cm"> * switch all CPUs off this pagetable before we can unpin it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_exit_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_cpu</span><span class="p">();</span>		<span class="cm">/* make sure we don&#39;t move around */</span>
	<span class="n">xen_drop_mm_ref</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="cm">/* pgd may not be pinned in the error exit path of execve */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xen_page_pinned</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">))</span>
		<span class="n">xen_pgd_unpin</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_pagetable_setup_start</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">xen_mapping_pagetable_reserve</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* reserve the range used */</span>
	<span class="n">native_pagetable_reserve</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="cm">/* set as RW the rest */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;xen: setting RW the range %llx - %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
			<span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pgt_buf_top</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pgt_buf_top</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">make_lowmem_page_readwrite</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">end</span><span class="p">));</span>
		<span class="n">end</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">xen_post_allocator_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_pagetable_setup_done</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xen_setup_shared_info</span><span class="p">();</span>
	<span class="n">xen_post_allocator_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_write_cr2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">this_cpu_read</span><span class="p">(</span><span class="n">xen_vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr2</span> <span class="o">=</span> <span class="n">cr2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">xen_read_cr2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">xen_vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">xen_read_cr2_direct</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">xen_vcpu_info</span><span class="p">.</span><span class="n">arch</span><span class="p">.</span><span class="n">cr2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_flush_tlb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmuext_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>

	<span class="n">trace_xen_mmu_flush_tlb</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">mcs</span> <span class="o">=</span> <span class="n">xen_mc_entry</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">op</span><span class="p">));</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MMUEXT_TLB_FLUSH_LOCAL</span><span class="p">;</span>
	<span class="n">MULTI_mmuext_op</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DOMID_SELF</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_flush_tlb_single</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmuext_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>

	<span class="n">trace_xen_mmu_flush_tlb_single</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">mcs</span> <span class="o">=</span> <span class="n">xen_mc_entry</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">op</span><span class="p">));</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MMUEXT_INVLPG_LOCAL</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">.</span><span class="n">linear_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">MULTI_mmuext_op</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DOMID_SELF</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_flush_tlb_others</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mmuext_op</span> <span class="n">op</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">num_processors</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">NR_CPUS</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>

	<span class="n">trace_xen_mmu_flush_tlb_others</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cpus</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* nothing to do */</span>

	<span class="n">mcs</span> <span class="o">=</span> <span class="n">xen_mc_entry</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">));</span>
	<span class="n">args</span> <span class="o">=</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">arg2</span><span class="p">.</span><span class="n">vcpumask</span> <span class="o">=</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* Remove us, and any offline CPUS. */</span>
	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">to_cpumask</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">),</span> <span class="n">cpus</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">va</span> <span class="o">==</span> <span class="n">TLB_FLUSH_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MMUEXT_TLB_FLUSH_MULTI</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MMUEXT_INVLPG_MULTI</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">arg1</span><span class="p">.</span><span class="n">linear_addr</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">MULTI_mmuext_op</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DOMID_SELF</span><span class="p">);</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">xen_read_cr3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">xen_cr3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_current_cr3</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">this_cpu_write</span><span class="p">(</span><span class="n">xen_current_cr3</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__xen_write_cr3</span><span class="p">(</span><span class="n">bool</span> <span class="n">kernel</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmuext_op</span> <span class="n">op</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">;</span>

	<span class="n">trace_xen_mmu_write_cr3</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">cr3</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cr3</span><span class="p">)</span>
		<span class="n">mfn</span> <span class="o">=</span> <span class="n">pfn_to_mfn</span><span class="p">(</span><span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">cr3</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">mfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">mfn</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">kernel</span><span class="p">);</span>

	<span class="n">op</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">?</span> <span class="n">MMUEXT_NEW_BASEPTR</span> <span class="o">:</span> <span class="n">MMUEXT_NEW_USER_BASEPTR</span><span class="p">;</span>
	<span class="n">op</span><span class="p">.</span><span class="n">arg1</span><span class="p">.</span><span class="n">mfn</span> <span class="o">=</span> <span class="n">mfn</span><span class="p">;</span>

	<span class="n">xen_extend_mmuext_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this_cpu_write</span><span class="p">(</span><span class="n">xen_cr3</span><span class="p">,</span> <span class="n">cr3</span><span class="p">);</span>

		<span class="cm">/* Update xen_current_cr3 once the batch has actually</span>
<span class="cm">		   been submitted. */</span>
		<span class="n">xen_mc_callback</span><span class="p">(</span><span class="n">set_current_cr3</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cr3</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_write_cr3</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>

	<span class="n">xen_mc_batch</span><span class="p">();</span>  <span class="cm">/* disables interrupts */</span>

	<span class="cm">/* Update while interrupts are disabled, so its atomic with</span>
<span class="cm">	   respect to ipis */</span>
	<span class="n">this_cpu_write</span><span class="p">(</span><span class="n">xen_cr3</span><span class="p">,</span> <span class="n">cr3</span><span class="p">);</span>

	<span class="n">__xen_write_cr3</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">cr3</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="p">{</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">user_pgd</span> <span class="o">=</span> <span class="n">xen_get_user_pgd</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">cr3</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_pgd</span><span class="p">)</span>
			<span class="n">__xen_write_cr3</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">user_pgd</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">__xen_write_cr3</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_CPU</span><span class="p">);</span>  <span class="cm">/* interrupts restored */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xen_pgd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PagePinned</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">pgd</span><span class="p">)));</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">user_pgd</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">user_pgd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">user_pgd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">user_pgd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">user_pgd</span><span class="p">[</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">VSYSCALL_START</span><span class="p">)]</span> <span class="o">=</span>
				<span class="n">__pgd</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">level3_user_vsyscall</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_TABLE</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PagePinned</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">xen_get_user_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">))));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_pgd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">user_pgd</span> <span class="o">=</span> <span class="n">xen_get_user_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_pgd</span><span class="p">)</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">user_pgd</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="k">static</span> <span class="n">pte_t</span> <span class="n">__init</span> <span class="nf">mask_rw_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If there&#39;s an existing pte, then don&#39;t allow _PAGE_RW to be set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_val_ma</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_PRESENT</span><span class="p">)</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">__pte_ma</span><span class="p">(((</span><span class="n">pte_val_ma</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_RW</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">_PAGE_RW</span><span class="p">)</span> <span class="o">&amp;</span>
			       <span class="n">pte_val_ma</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>
<span class="k">static</span> <span class="n">pte_t</span> <span class="n">__init</span> <span class="nf">mask_rw_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the new pfn is within the range of the newly allocated</span>
<span class="cm">	 * kernel pagetable, and it isn&#39;t being mapped into an</span>
<span class="cm">	 * early_ioremap fixmap slot as a freshly allocated page, make sure</span>
<span class="cm">	 * it is RO.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="o">!</span><span class="n">is_early_ioremap_ptep</span><span class="p">(</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">pgt_buf_start</span> <span class="o">&amp;&amp;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">pgt_buf_top</span><span class="p">))</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">is_early_ioremap_ptep</span><span class="p">(</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pfn</span> <span class="o">!=</span> <span class="p">(</span><span class="n">pgt_buf_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>

<span class="cm">/* Init-time set_pte while constructing initial pagetables, which</span>
<span class="cm">   doesn&#39;t allow RO pagetable pages to be remapped RW */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_set_pte_init</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">mask_rw_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>

	<span class="n">xen_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pin_pagetable_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmuext_op</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">op</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">op</span><span class="p">.</span><span class="n">arg1</span><span class="p">.</span><span class="n">mfn</span> <span class="o">=</span> <span class="n">pfn_to_mfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_mmuext_op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DOMID_SELF</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Early in boot, while setting up the initial pagetable, assume</span>
<span class="cm">   everything is pinned. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_alloc_pte_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FLATMEM</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mem_map</span><span class="p">);</span>	<span class="cm">/* should only be used early */</span>
<span class="cp">#endif</span>
	<span class="n">make_lowmem_page_readonly</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pfn</span><span class="p">)));</span>
	<span class="n">pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_PIN_L1_TABLE</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used for pmd and pud */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_alloc_pmd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FLATMEM</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mem_map</span><span class="p">);</span>	<span class="cm">/* should only be used early */</span>
<span class="cp">#endif</span>
	<span class="n">make_lowmem_page_readonly</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pfn</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/* Early release_pte assumes that all pts are pinned, since there&#39;s</span>
<span class="cm">   only init_mm and anything attached to that is pinned. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_release_pte_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_UNPIN_TABLE</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="n">make_lowmem_page_readwrite</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pfn</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_release_pmd_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">make_lowmem_page_readwrite</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pfn</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__pin_pagetable_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmuext_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="n">mcs</span> <span class="o">=</span> <span class="n">__xen_mc_entry</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">op</span><span class="p">));</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">arg1</span><span class="p">.</span><span class="n">mfn</span> <span class="o">=</span> <span class="n">pfn_to_mfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="n">MULTI_mmuext_op</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="n">mcs</span><span class="p">.</span><span class="n">args</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DOMID_SELF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__set_pfn_prot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">mcs</span> <span class="o">=</span> <span class="n">__xen_mc_entry</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">MULTI_update_va_mapping</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span>
				<span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prot</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This needs to make sure the new pte page is pinned iff its being</span>
<span class="cm">   attached to a pinned pagetable. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xen_alloc_ptpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">pinned</span> <span class="o">=</span> <span class="n">PagePinned</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">));</span>

	<span class="n">trace_xen_mmu_alloc_ptpage</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">pinned</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinned</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

		<span class="n">SetPagePinned</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xen_mc_batch</span><span class="p">();</span>

			<span class="n">__set_pfn_prot</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PTE</span> <span class="o">&amp;&amp;</span> <span class="n">USE_SPLIT_PTLOCKS</span><span class="p">)</span>
				<span class="n">__pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_PIN_L1_TABLE</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

			<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* make sure there are no stray mappings of</span>
<span class="cm">			   this page */</span>
			<span class="n">kmap_flush_unused</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_alloc_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xen_alloc_ptpage</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">PT_PTE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_alloc_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xen_alloc_ptpage</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">PT_PMD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This should never happen until we&#39;re OK to use struct page */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xen_release_ptpage</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">pinned</span> <span class="o">=</span> <span class="n">PagePinned</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">trace_xen_mmu_release_ptpage</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">pinned</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinned</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xen_mc_batch</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PTE</span> <span class="o">&amp;&amp;</span> <span class="n">USE_SPLIT_PTLOCKS</span><span class="p">)</span>
				<span class="n">__pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_UNPIN_TABLE</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

			<span class="n">__set_pfn_prot</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>

			<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_MMU</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ClearPagePinned</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_release_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xen_release_ptpage</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PT_PTE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_release_pmd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xen_release_ptpage</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PT_PMD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if PAGETABLE_LEVELS == 4</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_alloc_pud</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xen_alloc_ptpage</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">PT_PUD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_release_pud</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xen_release_ptpage</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PT_PUD</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_reserve_top</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">top</span> <span class="o">=</span> <span class="n">HYPERVISOR_VIRT_START</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xen_platform_parameters</span> <span class="n">pp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_xen_version</span><span class="p">(</span><span class="n">XENVER_platform_parameters</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">top</span> <span class="o">=</span> <span class="n">pp</span><span class="p">.</span><span class="n">virt_start</span><span class="p">;</span>

	<span class="n">reserve_top_address</span><span class="p">(</span><span class="o">-</span><span class="n">top</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_X86_32 */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Like __va(), but returns address in the kernel mapping (which is</span>
<span class="cm"> * all we have until the physical memory mapping has been set up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__ka</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">paddr</span> <span class="o">+</span> <span class="n">__START_KERNEL_map</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Convert a machine address to physical address */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">m2p</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">maddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">paddr</span><span class="p">;</span>

	<span class="n">maddr</span> <span class="o">&amp;=</span> <span class="n">PTE_PFN_MASK</span><span class="p">;</span>
	<span class="n">paddr</span> <span class="o">=</span> <span class="n">mfn_to_pfn</span><span class="p">(</span><span class="n">maddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">paddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a machine address to kernel virtual */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">m2v</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">maddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ka</span><span class="p">(</span><span class="n">m2p</span><span class="p">(</span><span class="n">maddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Set the page permissions on an identity-mapped pages */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_page_prot</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_update_va_mapping</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_map_identity_early</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">pmdidx</span><span class="p">,</span> <span class="n">pteidx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ident_pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="n">level1_ident_pgt</span> <span class="o">=</span> <span class="n">extend_brk</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">LEVEL1_IDENT_ENTRIES</span><span class="p">,</span>
				      <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">ident_pte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pmdidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pmdidx</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PMD</span> <span class="o">&amp;&amp;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">max_pfn</span><span class="p">;</span> <span class="n">pmdidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte_page</span><span class="p">;</span>

		<span class="cm">/* Reuse or allocate a page of ptes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_present</span><span class="p">(</span><span class="n">pmd</span><span class="p">[</span><span class="n">pmdidx</span><span class="p">]))</span>
			<span class="n">pte_page</span> <span class="o">=</span> <span class="n">m2v</span><span class="p">(</span><span class="n">pmd</span><span class="p">[</span><span class="n">pmdidx</span><span class="p">].</span><span class="n">pmd</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Check for free pte pages */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ident_pte</span> <span class="o">==</span> <span class="n">LEVEL1_IDENT_ENTRIES</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">pte_page</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">level1_ident_pgt</span><span class="p">[</span><span class="n">ident_pte</span><span class="p">];</span>
			<span class="n">ident_pte</span> <span class="o">+=</span> <span class="n">PTRS_PER_PTE</span><span class="p">;</span>

			<span class="n">pmd</span><span class="p">[</span><span class="n">pmdidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pmd</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pte_page</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_TABLE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Install mappings */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pteidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pteidx</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="p">;</span> <span class="n">pteidx</span><span class="o">++</span><span class="p">,</span> <span class="n">pfn</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;</span> <span class="n">max_pfn_mapped</span><span class="p">)</span>
				<span class="n">max_pfn_mapped</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
<span class="cp">#endif</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="n">pte_page</span><span class="p">[</span><span class="n">pteidx</span><span class="p">]))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">pte</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_KERNEL_EXEC</span><span class="p">);</span>
			<span class="n">pte_page</span><span class="p">[</span><span class="n">pteidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pteidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pteidx</span> <span class="o">&lt;</span> <span class="n">ident_pte</span><span class="p">;</span> <span class="n">pteidx</span> <span class="o">+=</span> <span class="n">PTRS_PER_PTE</span><span class="p">)</span>
		<span class="n">set_page_prot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">level1_ident_pgt</span><span class="p">[</span><span class="n">pteidx</span><span class="p">],</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>

	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_setup_machphys_mapping</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xen_machphys_mapping</span> <span class="n">mapping</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_memory_op</span><span class="p">(</span><span class="n">XENMEM_machphys_mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">machine_to_phys_mapping</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">mapping</span><span class="p">.</span><span class="n">v_start</span><span class="p">;</span>
		<span class="n">machine_to_phys_nr</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">.</span><span class="n">max_mfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">machine_to_phys_nr</span> <span class="o">=</span> <span class="n">MACH2PHYS_NR_ENTRIES</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">machine_to_phys_mapping</span> <span class="o">+</span> <span class="p">(</span><span class="n">machine_to_phys_nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="o">&lt;</span> <span class="n">machine_to_phys_mapping</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">convert_pfn_mfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* All levels are converted the same way, so just treat them</span>
<span class="cm">	   as ptes. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pte</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xen_make_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up the initial kernel pagetable.</span>
<span class="cm"> *</span>
<span class="cm"> * We can construct this by grafting the Xen provided pagetable into</span>
<span class="cm"> * head_64.S&#39;s preconstructed pagetables.  We copy the Xen L2&#39;s into</span>
<span class="cm"> * level2_ident_pgt, level2_kernel_pgt and level2_fixmap_pgt.  This</span>
<span class="cm"> * means that only the kernel has a physical mapping to start with -</span>
<span class="cm"> * but that&#39;s enough to get __va working.  We need to fill in the rest</span>
<span class="cm"> * of the physical mapping once some sort of allocator has been set</span>
<span class="cm"> * up.</span>
<span class="cm"> */</span>
<span class="n">pgd_t</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">xen_setup_kernel_pagetable</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">l2</span><span class="p">;</span>

	<span class="cm">/* max_pfn_mapped is the last pfn mapped in the initial memory</span>
<span class="cm">	 * mappings. Considering that on Xen after the kernel mappings we</span>
<span class="cm">	 * have the mappings of some pages that don&#39;t exist in pfn space, we</span>
<span class="cm">	 * set max_pfn_mapped to the last real pfn mapped. */</span>
	<span class="n">max_pfn_mapped</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">xen_start_info</span><span class="o">-&gt;</span><span class="n">mfn_list</span><span class="p">));</span>

	<span class="cm">/* Zap identity mapping */</span>
	<span class="n">init_level4_pgt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgd</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Pre-constructed entries are in pfn, so convert to mfn */</span>
	<span class="n">convert_pfn_mfn</span><span class="p">(</span><span class="n">init_level4_pgt</span><span class="p">);</span>
	<span class="n">convert_pfn_mfn</span><span class="p">(</span><span class="n">level3_ident_pgt</span><span class="p">);</span>
	<span class="n">convert_pfn_mfn</span><span class="p">(</span><span class="n">level3_kernel_pgt</span><span class="p">);</span>

	<span class="n">l3</span> <span class="o">=</span> <span class="n">m2v</span><span class="p">(</span><span class="n">pgd</span><span class="p">[</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">__START_KERNEL_map</span><span class="p">)].</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">l2</span> <span class="o">=</span> <span class="n">m2v</span><span class="p">(</span><span class="n">l3</span><span class="p">[</span><span class="n">pud_index</span><span class="p">(</span><span class="n">__START_KERNEL_map</span><span class="p">)].</span><span class="n">pud</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">level2_ident_pgt</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTRS_PER_PMD</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">level2_kernel_pgt</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTRS_PER_PMD</span><span class="p">);</span>

	<span class="n">l3</span> <span class="o">=</span> <span class="n">m2v</span><span class="p">(</span><span class="n">pgd</span><span class="p">[</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">)].</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">l2</span> <span class="o">=</span> <span class="n">m2v</span><span class="p">(</span><span class="n">l3</span><span class="p">[</span><span class="n">pud_index</span><span class="p">(</span><span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">)].</span><span class="n">pud</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">level2_fixmap_pgt</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTRS_PER_PMD</span><span class="p">);</span>

	<span class="cm">/* Set up identity map */</span>
	<span class="n">xen_map_identity_early</span><span class="p">(</span><span class="n">level2_ident_pgt</span><span class="p">,</span> <span class="n">max_pfn</span><span class="p">);</span>

	<span class="cm">/* Make pagetable pieces RO */</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">init_level4_pgt</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">level3_ident_pgt</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">level3_kernel_pgt</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">level3_user_vsyscall</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">level2_kernel_pgt</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">level2_fixmap_pgt</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>

	<span class="cm">/* Pin down new L4 */</span>
	<span class="n">pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_PIN_L4_TABLE</span><span class="p">,</span>
			  <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">init_level4_pgt</span><span class="p">)));</span>

	<span class="cm">/* Unpin Xen-provided one */</span>
	<span class="n">pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_UNPIN_TABLE</span><span class="p">,</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pgd</span><span class="p">)));</span>

	<span class="cm">/* Switch over */</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">init_level4_pgt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this stage there can be no user pgd, and no page</span>
<span class="cm">	 * structure to attach it to, so make sure we just set kernel</span>
<span class="cm">	 * pgd.</span>
<span class="cm">	 */</span>
	<span class="n">xen_mc_batch</span><span class="p">();</span>
	<span class="n">__xen_write_cr3</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pgd</span><span class="p">));</span>
	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="n">PARAVIRT_LAZY_CPU</span><span class="p">);</span>

	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">xen_start_info</span><span class="o">-&gt;</span><span class="n">pt_base</span><span class="p">),</span>
			 <span class="n">xen_start_info</span><span class="o">-&gt;</span><span class="n">nr_pt_frames</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pgd</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* !CONFIG_X86_64 */</span><span class="cp"></span>
<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">,</span> <span class="n">initial_kernel_pmd</span><span class="p">,</span> <span class="n">PTRS_PER_PMD</span><span class="p">);</span>
<span class="k">static</span> <span class="n">RESERVE_BRK_ARRAY</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">,</span> <span class="n">swapper_kernel_pmd</span><span class="p">,</span> <span class="n">PTRS_PER_PMD</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_write_cr3_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">));</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">read_cr3</span><span class="p">()</span> <span class="o">!=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">initial_page_table</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cr3</span> <span class="o">!=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are switching to swapper_pg_dir for the first time (from</span>
<span class="cm">	 * initial_page_table) and therefore need to mark that page</span>
<span class="cm">	 * read-only and then pin it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Xen disallows sharing of kernel PMDs for PAE</span>
<span class="cm">	 * guests. Therefore we must copy the kernel PMD from</span>
<span class="cm">	 * initial_page_table into a new kernel PMD to be used in</span>
<span class="cm">	 * swapper_pg_dir.</span>
<span class="cm">	 */</span>
	<span class="n">swapper_kernel_pmd</span> <span class="o">=</span>
		<span class="n">extend_brk</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTRS_PER_PMD</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">swapper_kernel_pmd</span><span class="p">,</span> <span class="n">initial_kernel_pmd</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTRS_PER_PMD</span><span class="p">);</span>
	<span class="n">swapper_pg_dir</span><span class="p">[</span><span class="n">KERNEL_PGD_BOUNDARY</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">__pgd</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">swapper_kernel_pmd</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT</span><span class="p">);</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">swapper_kernel_pmd</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>

	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>
	<span class="n">xen_write_cr3</span><span class="p">(</span><span class="n">cr3</span><span class="p">);</span>
	<span class="n">pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_PIN_L3_TABLE</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

	<span class="n">pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_UNPIN_TABLE</span><span class="p">,</span>
			  <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">initial_page_table</span><span class="p">)));</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">initial_page_table</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">initial_kernel_pmd</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>

	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">write_cr3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xen_write_cr3</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pgd_t</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">xen_setup_kernel_pagetable</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">kernel_pmd</span><span class="p">;</span>

	<span class="n">initial_kernel_pmd</span> <span class="o">=</span>
		<span class="n">extend_brk</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTRS_PER_PMD</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">max_pfn_mapped</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">xen_start_info</span><span class="o">-&gt;</span><span class="n">pt_base</span><span class="p">)</span> <span class="o">+</span>
				  <span class="n">xen_start_info</span><span class="o">-&gt;</span><span class="n">nr_pt_frames</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">+</span>
				  <span class="mi">512</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>

	<span class="n">kernel_pmd</span> <span class="o">=</span> <span class="n">m2v</span><span class="p">(</span><span class="n">pgd</span><span class="p">[</span><span class="n">KERNEL_PGD_BOUNDARY</span><span class="p">].</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">initial_kernel_pmd</span><span class="p">,</span> <span class="n">kernel_pmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTRS_PER_PMD</span><span class="p">);</span>

	<span class="n">xen_map_identity_early</span><span class="p">(</span><span class="n">initial_kernel_pmd</span><span class="p">,</span> <span class="n">max_pfn</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">initial_page_table</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pgd_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTRS_PER_PGD</span><span class="p">);</span>
	<span class="n">initial_page_table</span><span class="p">[</span><span class="n">KERNEL_PGD_BOUNDARY</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">__pgd</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">initial_kernel_pmd</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT</span><span class="p">);</span>

	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">initial_kernel_pmd</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">initial_page_table</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>
	<span class="n">set_page_prot</span><span class="p">(</span><span class="n">empty_zero_page</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">);</span>

	<span class="n">pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_UNPIN_TABLE</span><span class="p">,</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pgd</span><span class="p">)));</span>

	<span class="n">pin_pagetable_pfn</span><span class="p">(</span><span class="n">MMUEXT_PIN_L3_TABLE</span><span class="p">,</span>
			  <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">initial_page_table</span><span class="p">)));</span>
	<span class="n">xen_write_cr3</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">initial_page_table</span><span class="p">));</span>

	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">xen_start_info</span><span class="o">-&gt;</span><span class="n">pt_base</span><span class="p">),</span>
			 <span class="n">xen_start_info</span><span class="o">-&gt;</span><span class="n">nr_pt_frames</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">initial_page_table</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dummy_mapping</span><span class="p">[</span><span class="n">PAGE_SIZE</span><span class="p">]</span> <span class="n">__page_aligned_bss</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_set_fixmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">phys</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>

	<span class="n">phys</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FIX_BTMAP_END</span> <span class="p">...</span> <span class="n">FIX_BTMAP_BEGIN</span>:
<span class="cp">#ifdef CONFIG_X86_F00F_BUG</span>
	<span class="k">case</span> <span class="n">FIX_F00F_IDT</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">case</span> <span class="n">FIX_WP_TEST</span>:
	<span class="k">case</span> <span class="n">FIX_VDSO</span>:
<span class="cp"># ifdef CONFIG_HIGHMEM</span>
	<span class="k">case</span> <span class="n">FIX_KMAP_BEGIN</span> <span class="p">...</span> <span class="n">FIX_KMAP_END</span>:
<span class="cp"># endif</span>
<span class="cp">#else</span>
	<span class="k">case</span> <span class="n">VSYSCALL_LAST_PAGE</span> <span class="p">...</span> <span class="n">VSYSCALL_FIRST_PAGE</span>:
	<span class="k">case</span> <span class="n">VVAR_PAGE</span>:
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">FIX_TEXT_POKE0</span>:
	<span class="k">case</span> <span class="n">FIX_TEXT_POKE1</span>:
		<span class="cm">/* All local page mappings */</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
	<span class="k">case</span> <span class="n">FIX_APIC_BASE</span>:	<span class="cm">/* maps dummy local APIC */</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">dummy_mapping</span><span class="p">)),</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_IO_APIC</span>
	<span class="k">case</span> <span class="n">FIX_IO_APIC_BASE_0</span> <span class="p">...</span> <span class="n">FIX_IO_APIC_BASE_END</span>:
		<span class="cm">/*</span>
<span class="cm">		 * We just don&#39;t map the IO APIC - all access is via</span>
<span class="cm">		 * hypercalls.  Keep the address in the pte for reference.</span>
<span class="cm">		 */</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">dummy_mapping</span><span class="p">)),</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">case</span> <span class="n">FIX_PARAVIRT_BOOTMAP</span>:
		<span class="cm">/* This is an MFN, but it isn&#39;t an IO mapping from the</span>
<span class="cm">		   IO domain */</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">mfn_pte</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* By default, set_fixmap is used for hardware mappings */</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">mfn_pte</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_IOMAP</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__native_set_fixmap</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="cm">/* Replicate changes to map the vsyscall page into the user</span>
<span class="cm">	   pagetable vsyscall mapping. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">VSYSCALL_LAST_PAGE</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">VSYSCALL_FIRST_PAGE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">idx</span> <span class="o">==</span> <span class="n">VVAR_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
		<span class="n">set_pte_vaddr_pud</span><span class="p">(</span><span class="n">level3_user_vsyscall</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_post_allocator_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">set_pte</span> <span class="o">=</span> <span class="n">xen_set_pte</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">set_pmd</span> <span class="o">=</span> <span class="n">xen_set_pmd</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">set_pud</span> <span class="o">=</span> <span class="n">xen_set_pud</span><span class="p">;</span>
<span class="cp">#if PAGETABLE_LEVELS == 4</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">set_pgd</span> <span class="o">=</span> <span class="n">xen_set_pgd</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* This will work as long as patching hasn&#39;t happened yet</span>
<span class="cm">	   (which it hasn&#39;t) */</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">alloc_pte</span> <span class="o">=</span> <span class="n">xen_alloc_pte</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">alloc_pmd</span> <span class="o">=</span> <span class="n">xen_alloc_pmd</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">release_pte</span> <span class="o">=</span> <span class="n">xen_release_pte</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">release_pmd</span> <span class="o">=</span> <span class="n">xen_release_pmd</span><span class="p">;</span>
<span class="cp">#if PAGETABLE_LEVELS == 4</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">alloc_pud</span> <span class="o">=</span> <span class="n">xen_alloc_pud</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">release_pud</span> <span class="o">=</span> <span class="n">xen_release_pud</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">SetPagePinned</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">level3_user_vsyscall</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">xen_mark_init_mm_pinned</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_leave_lazy_mmu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">xen_mc_flush</span><span class="p">();</span>
	<span class="n">paravirt_leave_lazy_mmu</span><span class="p">();</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pv_mmu_ops</span> <span class="n">xen_mmu_ops</span> <span class="n">__initconst</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read_cr2</span> <span class="o">=</span> <span class="n">xen_read_cr2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_cr2</span> <span class="o">=</span> <span class="n">xen_write_cr2</span><span class="p">,</span>

	<span class="p">.</span><span class="n">read_cr3</span> <span class="o">=</span> <span class="n">xen_read_cr3</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="p">.</span><span class="n">write_cr3</span> <span class="o">=</span> <span class="n">xen_write_cr3_init</span><span class="p">,</span>
<span class="cp">#else</span>
	<span class="p">.</span><span class="n">write_cr3</span> <span class="o">=</span> <span class="n">xen_write_cr3</span><span class="p">,</span>
<span class="cp">#endif</span>

	<span class="p">.</span><span class="n">flush_tlb_user</span> <span class="o">=</span> <span class="n">xen_flush_tlb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_tlb_kernel</span> <span class="o">=</span> <span class="n">xen_flush_tlb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_tlb_single</span> <span class="o">=</span> <span class="n">xen_flush_tlb_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_tlb_others</span> <span class="o">=</span> <span class="n">xen_flush_tlb_others</span><span class="p">,</span>

	<span class="p">.</span><span class="n">pte_update</span> <span class="o">=</span> <span class="n">paravirt_nop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pte_update_defer</span> <span class="o">=</span> <span class="n">paravirt_nop</span><span class="p">,</span>

	<span class="p">.</span><span class="n">pgd_alloc</span> <span class="o">=</span> <span class="n">xen_pgd_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pgd_free</span> <span class="o">=</span> <span class="n">xen_pgd_free</span><span class="p">,</span>

	<span class="p">.</span><span class="n">alloc_pte</span> <span class="o">=</span> <span class="n">xen_alloc_pte_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_pte</span> <span class="o">=</span> <span class="n">xen_release_pte_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_pmd</span> <span class="o">=</span> <span class="n">xen_alloc_pmd_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_pmd</span> <span class="o">=</span> <span class="n">xen_release_pmd_init</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_pte</span> <span class="o">=</span> <span class="n">xen_set_pte_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_pte_at</span> <span class="o">=</span> <span class="n">xen_set_pte_at</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_pmd</span> <span class="o">=</span> <span class="n">xen_set_pmd_hyper</span><span class="p">,</span>

	<span class="p">.</span><span class="n">ptep_modify_prot_start</span> <span class="o">=</span> <span class="n">__ptep_modify_prot_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ptep_modify_prot_commit</span> <span class="o">=</span> <span class="n">__ptep_modify_prot_commit</span><span class="p">,</span>

	<span class="p">.</span><span class="n">pte_val</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">xen_pte_val</span><span class="p">),</span>
	<span class="p">.</span><span class="n">pgd_val</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">xen_pgd_val</span><span class="p">),</span>

	<span class="p">.</span><span class="n">make_pte</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">xen_make_pte</span><span class="p">),</span>
	<span class="p">.</span><span class="n">make_pgd</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">xen_make_pgd</span><span class="p">),</span>

<span class="cp">#ifdef CONFIG_X86_PAE</span>
	<span class="p">.</span><span class="n">set_pte_atomic</span> <span class="o">=</span> <span class="n">xen_set_pte_atomic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pte_clear</span> <span class="o">=</span> <span class="n">xen_pte_clear</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pmd_clear</span> <span class="o">=</span> <span class="n">xen_pmd_clear</span><span class="p">,</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_X86_PAE */</span><span class="cp"></span>
	<span class="p">.</span><span class="n">set_pud</span> <span class="o">=</span> <span class="n">xen_set_pud_hyper</span><span class="p">,</span>

	<span class="p">.</span><span class="n">make_pmd</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">xen_make_pmd</span><span class="p">),</span>
	<span class="p">.</span><span class="n">pmd_val</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">xen_pmd_val</span><span class="p">),</span>

<span class="cp">#if PAGETABLE_LEVELS == 4</span>
	<span class="p">.</span><span class="n">pud_val</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">xen_pud_val</span><span class="p">),</span>
	<span class="p">.</span><span class="n">make_pud</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">xen_make_pud</span><span class="p">),</span>
	<span class="p">.</span><span class="n">set_pgd</span> <span class="o">=</span> <span class="n">xen_set_pgd_hyper</span><span class="p">,</span>

	<span class="p">.</span><span class="n">alloc_pud</span> <span class="o">=</span> <span class="n">xen_alloc_pmd_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_pud</span> <span class="o">=</span> <span class="n">xen_release_pmd_init</span><span class="p">,</span>
<span class="cp">#endif	</span><span class="cm">/* PAGETABLE_LEVELS == 4 */</span><span class="cp"></span>

	<span class="p">.</span><span class="n">activate_mm</span> <span class="o">=</span> <span class="n">xen_activate_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dup_mmap</span> <span class="o">=</span> <span class="n">xen_dup_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit_mmap</span> <span class="o">=</span> <span class="n">xen_exit_mmap</span><span class="p">,</span>

	<span class="p">.</span><span class="n">lazy_mode</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="n">paravirt_enter_lazy_mmu</span><span class="p">,</span>
		<span class="p">.</span><span class="n">leave</span> <span class="o">=</span> <span class="n">xen_leave_lazy_mmu</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">.</span><span class="n">set_fixmap</span> <span class="o">=</span> <span class="n">xen_set_fixmap</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_init_mmu_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x86_init</span><span class="p">.</span><span class="n">mapping</span><span class="p">.</span><span class="n">pagetable_reserve</span> <span class="o">=</span> <span class="n">xen_mapping_pagetable_reserve</span><span class="p">;</span>
	<span class="n">x86_init</span><span class="p">.</span><span class="n">paging</span><span class="p">.</span><span class="n">pagetable_setup_start</span> <span class="o">=</span> <span class="n">xen_pagetable_setup_start</span><span class="p">;</span>
	<span class="n">x86_init</span><span class="p">.</span><span class="n">paging</span><span class="p">.</span><span class="n">pagetable_setup_done</span> <span class="o">=</span> <span class="n">xen_pagetable_setup_done</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span> <span class="o">=</span> <span class="n">xen_mmu_ops</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">dummy_mapping</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Protected by xen_reservation_lock. */</span>
<span class="cp">#define MAX_CONTIG_ORDER 9 </span><span class="cm">/* 2MB */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">discontig_frames</span><span class="p">[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">MAX_CONTIG_ORDER</span><span class="p">];</span>

<span class="cp">#define VOID_PTE (mfn_pte(0, __pgprot(0)))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_zap_pfn_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">in_frames</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">out_frames</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>

	<span class="n">xen_mc_batch</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="n">order</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcs</span> <span class="o">=</span> <span class="n">__xen_mc_entry</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_frames</span><span class="p">)</span>
			<span class="n">in_frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

		<span class="n">MULTI_update_va_mapping</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">VOID_PTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">__set_phys_to_machine</span><span class="p">(</span><span class="n">virt_to_pfn</span><span class="p">(</span><span class="n">vaddr</span><span class="p">),</span> <span class="n">INVALID_P2M_ENTRY</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">out_frames</span><span class="p">)</span>
			<span class="n">out_frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_pfn</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the pfn-to-mfn mappings for a virtual address range, either to</span>
<span class="cm"> * point to an array of mfns, or contiguously from a single starting</span>
<span class="cm"> * mfn.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_remap_exchanged_ptes</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mfns</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_mfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">;</span>

	<span class="n">xen_mc_batch</span><span class="p">();</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">multicall_space</span> <span class="n">mcs</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">mcs</span> <span class="o">=</span> <span class="n">__xen_mc_entry</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mfns</span><span class="p">)</span>
			<span class="n">mfn</span> <span class="o">=</span> <span class="n">mfns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">mfn</span> <span class="o">=</span> <span class="n">first_mfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">flags</span> <span class="o">=</span> <span class="n">UVMF_INVLPG</span> <span class="o">|</span> <span class="n">UVMF_ALL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">flags</span> <span class="o">=</span> <span class="n">UVMF_TLB_FLUSH</span> <span class="o">|</span> <span class="n">UVMF_ALL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">MULTI_update_va_mapping</span><span class="p">(</span><span class="n">mcs</span><span class="p">.</span><span class="n">mc</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span>
				<span class="n">mfn_pte</span><span class="p">(</span><span class="n">mfn</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">set_phys_to_machine</span><span class="p">(</span><span class="n">virt_to_pfn</span><span class="p">(</span><span class="n">vaddr</span><span class="p">),</span> <span class="n">mfn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xen_mc_issue</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform the hypercall to exchange a region of our pfns to point to</span>
<span class="cm"> * memory with the required contiguous alignment.  Takes the pfns as</span>
<span class="cm"> * input, and populates mfns as output.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a success code indicating whether the hypervisor was able to</span>
<span class="cm"> * satisfy the request or not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xen_exchange_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">extents_in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order_in</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pfns_in</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">extents_out</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order_out</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mfns_out</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">success</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xen_memory_exchange</span> <span class="n">exchange</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">in</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">nr_extents</span>   <span class="o">=</span> <span class="n">extents_in</span><span class="p">,</span>
			<span class="p">.</span><span class="n">extent_order</span> <span class="o">=</span> <span class="n">order_in</span><span class="p">,</span>
			<span class="p">.</span><span class="n">extent_start</span> <span class="o">=</span> <span class="n">pfns_in</span><span class="p">,</span>
			<span class="p">.</span><span class="n">domid</span>        <span class="o">=</span> <span class="n">DOMID_SELF</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">out</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">nr_extents</span>   <span class="o">=</span> <span class="n">extents_out</span><span class="p">,</span>
			<span class="p">.</span><span class="n">extent_order</span> <span class="o">=</span> <span class="n">order_out</span><span class="p">,</span>
			<span class="p">.</span><span class="n">extent_start</span> <span class="o">=</span> <span class="n">mfns_out</span><span class="p">,</span>
			<span class="p">.</span><span class="n">address_bits</span> <span class="o">=</span> <span class="n">address_bits</span><span class="p">,</span>
			<span class="p">.</span><span class="n">domid</span>        <span class="o">=</span> <span class="n">DOMID_SELF</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">extents_in</span> <span class="o">&lt;&lt;</span> <span class="n">order_in</span> <span class="o">!=</span> <span class="n">extents_out</span> <span class="o">&lt;&lt;</span> <span class="n">order_out</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_memory_op</span><span class="p">(</span><span class="n">XENMEM_exchange</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exchange</span><span class="p">);</span>
	<span class="n">success</span> <span class="o">=</span> <span class="p">(</span><span class="n">exchange</span><span class="p">.</span><span class="n">nr_exchanged</span> <span class="o">==</span> <span class="n">extents_in</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">exchange</span><span class="p">.</span><span class="n">nr_exchanged</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xen_create_contiguous_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">in_frames</span> <span class="o">=</span> <span class="n">discontig_frames</span><span class="p">,</span> <span class="n">out_frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>            <span class="n">success</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Currently an auto-translated guest will not perform I/O, nor will</span>
<span class="cm">	 * it require PAE page directories below 4GB. Therefore any calls to</span>
<span class="cm">	 * this function are redundant and can be ignored.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xen_feature</span><span class="p">(</span><span class="n">XENFEAT_auto_translated_physmap</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="n">MAX_CONTIG_ORDER</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">vstart</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xen_reservation_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* 1. Zap current PTEs, remembering MFNs. */</span>
	<span class="n">xen_zap_pfn_range</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">in_frames</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* 2. Get a new contiguous memory extent. */</span>
	<span class="n">out_frame</span> <span class="o">=</span> <span class="n">virt_to_pfn</span><span class="p">(</span><span class="n">vstart</span><span class="p">);</span>
	<span class="n">success</span> <span class="o">=</span> <span class="n">xen_exchange_memory</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">in_frames</span><span class="p">,</span>
				      <span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_frame</span><span class="p">,</span>
				      <span class="n">address_bits</span><span class="p">);</span>

	<span class="cm">/* 3. Map the new extent in place of old pages. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span>
		<span class="n">xen_remap_exchanged_ptes</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">out_frame</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xen_remap_exchanged_ptes</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">in_frames</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xen_reservation_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">success</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xen_create_contiguous_region</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">xen_destroy_contiguous_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">out_frames</span> <span class="o">=</span> <span class="n">discontig_frames</span><span class="p">,</span> <span class="n">in_frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">success</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xen_feature</span><span class="p">(</span><span class="n">XENFEAT_auto_translated_physmap</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="n">MAX_CONTIG_ORDER</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">vstart</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xen_reservation_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* 1. Find start MFN of contiguous extent. */</span>
	<span class="n">in_frame</span> <span class="o">=</span> <span class="n">virt_to_mfn</span><span class="p">(</span><span class="n">vstart</span><span class="p">);</span>

	<span class="cm">/* 2. Zap current PTEs. */</span>
	<span class="n">xen_zap_pfn_range</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">out_frames</span><span class="p">);</span>

	<span class="cm">/* 3. Do the exchange for non-contiguous MFNs. */</span>
	<span class="n">success</span> <span class="o">=</span> <span class="n">xen_exchange_memory</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_frame</span><span class="p">,</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">out_frames</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* 4. Map new pages in place of old pages. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span>
		<span class="n">xen_remap_exchanged_ptes</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">out_frames</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xen_remap_exchanged_ptes</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">in_frame</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xen_reservation_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xen_destroy_contiguous_region</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_XEN_PVHVM</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xen_hvm_exit_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xen_hvm_pagetable_dying</span> <span class="n">a</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">a</span><span class="p">.</span><span class="n">domid</span> <span class="o">=</span> <span class="n">DOMID_SELF</span><span class="p">;</span>
	<span class="n">a</span><span class="p">.</span><span class="n">gpa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_hvm_op</span><span class="p">(</span><span class="n">HVMOP_pagetable_dying</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_pagetable_dying_supported</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xen_hvm_pagetable_dying</span> <span class="n">a</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">a</span><span class="p">.</span><span class="n">domid</span> <span class="o">=</span> <span class="n">DOMID_SELF</span><span class="p">;</span>
	<span class="n">a</span><span class="p">.</span><span class="n">gpa</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">HYPERVISOR_hvm_op</span><span class="p">(</span><span class="n">HVMOP_pagetable_dying</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;HVMOP_pagetable_dying not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">xen_hvm_init_mmu_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_pagetable_dying_supported</span><span class="p">())</span>
		<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">exit_mmap</span> <span class="o">=</span> <span class="n">xen_hvm_exit_mmap</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define REMAP_BATCH_SIZE 16</span>

<span class="k">struct</span> <span class="n">remap_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">;</span>
	<span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_update</span> <span class="o">*</span><span class="n">mmu_update</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remap_area_mfn_pte_fn</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgtable_t</span> <span class="n">token</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">remap_data</span> <span class="o">*</span><span class="n">rmd</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pte_mkspecial</span><span class="p">(</span><span class="n">pfn_pte</span><span class="p">(</span><span class="n">rmd</span><span class="o">-&gt;</span><span class="n">mfn</span><span class="o">++</span><span class="p">,</span> <span class="n">rmd</span><span class="o">-&gt;</span><span class="n">prot</span><span class="p">));</span>

	<span class="n">rmd</span><span class="o">-&gt;</span><span class="n">mmu_update</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">virt_to_machine</span><span class="p">(</span><span class="n">ptep</span><span class="p">).</span><span class="n">maddr</span><span class="p">;</span>
	<span class="n">rmd</span><span class="o">-&gt;</span><span class="n">mmu_update</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">pte_val_ma</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="n">rmd</span><span class="o">-&gt;</span><span class="n">mmu_update</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">xen_remap_domain_mfn_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span>
			       <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">domid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">remap_data</span> <span class="n">rmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_update</span> <span class="n">mmu_update</span><span class="p">[</span><span class="n">REMAP_BATCH_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">batch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">prot</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_IOMAP</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_PFNMAP</span> <span class="o">|</span> <span class="n">VM_RESERVED</span> <span class="o">|</span> <span class="n">VM_IO</span><span class="p">))</span> <span class="o">==</span>
				<span class="p">(</span><span class="n">VM_PFNMAP</span> <span class="o">|</span> <span class="n">VM_RESERVED</span> <span class="o">|</span> <span class="n">VM_IO</span><span class="p">)));</span>

	<span class="n">rmd</span><span class="p">.</span><span class="n">mfn</span> <span class="o">=</span> <span class="n">mfn</span><span class="p">;</span>
	<span class="n">rmd</span><span class="p">.</span><span class="n">prot</span> <span class="o">=</span> <span class="n">prot</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">batch</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">REMAP_BATCH_SIZE</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
		<span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">batch</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="n">rmd</span><span class="p">.</span><span class="n">mmu_update</span> <span class="o">=</span> <span class="n">mmu_update</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">apply_to_page_range</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span>
					  <span class="n">remap_area_mfn_pte_fn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HYPERVISOR_mmu_update</span><span class="p">(</span><span class="n">mmu_update</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">domid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">nr</span> <span class="o">-=</span> <span class="n">batch</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">range</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>

	<span class="n">flush_tlb_all</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">xen_remap_domain_mfn_range</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
