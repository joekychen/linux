<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › math-emu › float.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>float.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux/PA-RISC Project (http://www.parisc-linux.org/)</span>
<span class="cm"> *</span>
<span class="cm"> * Floating-point emulation code</span>
<span class="cm"> *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *    the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *    any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *    GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *    You should have received a copy of the GNU General Public License</span>
<span class="cm"> *    along with this program; if not, write to the Free Software</span>
<span class="cm"> *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * BEGIN_DESC</span>
<span class="cm"> * </span>
<span class="cm"> *  File: </span>
<span class="cm"> *      @(#)	pa/spmath/float.h		$Revision: 1.1 $</span>
<span class="cm"> * </span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *      &lt;&lt;please update with a synopis of the functionality provided by this file&gt;&gt;</span>
<span class="cm"> * </span>
<span class="cm"> *  BE header:  no</span>
<span class="cm"> *</span>
<span class="cm"> *  Shipped:  yes</span>
<span class="cm"> *	/usr/conf/pa/spmath/float.h</span>
<span class="cm"> *</span>
<span class="cm"> * END_DESC  </span>
<span class="cm">*/</span>

<span class="cp">#ifdef __NO_PA_HDRS</span>
    <span class="n">PA</span> <span class="n">header</span> <span class="n">file</span> <span class="o">--</span> <span class="k">do</span> <span class="n">not</span> <span class="n">include</span> <span class="n">this</span> <span class="n">header</span> <span class="n">file</span> <span class="k">for</span> <span class="n">non</span><span class="o">-</span><span class="n">PA</span> <span class="n">builds</span><span class="p">.</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;fpbits.h&quot;</span>
<span class="cp">#include &quot;hppa.h&quot;</span>
<span class="cm">/*</span>
<span class="cm"> * Want to pick up the FPU capability flags, not the PDC structures.</span>
<span class="cm"> * &#39;LOCORE&#39; isn&#39;t really true in this case, but we don&#39;t want the C structures</span>
<span class="cm"> * so it suits our purposes</span>
<span class="cm"> */</span>
<span class="cp">#define LOCORE</span>
<span class="cp">#include &quot;fpu.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Declare the basic structures for the 3 different</span>
<span class="cm"> * floating-point precisions.</span>
<span class="cm"> *        </span>
<span class="cm"> * Single number  </span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |s|       exp     |               mantissa                      |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> */</span>
<span class="cp">#define	Sall(object) (object)</span>
<span class="cp">#define	Ssign(object) Bitfield_extract( 0,  1,object)</span>
<span class="cp">#define	Ssignedsign(object) Bitfield_signed_extract( 0,  1,object)</span>
<span class="cp">#define	Sexponent(object) Bitfield_extract( 1,  8,object)</span>
<span class="cp">#define	Smantissa(object) Bitfield_mask( 9, 23,object)</span>
<span class="cp">#define	Ssignaling(object) Bitfield_extract( 9,  1,object)</span>
<span class="cp">#define	Ssignalingnan(object) Bitfield_extract( 1,  9,object)</span>
<span class="cp">#define	Shigh2mantissa(object) Bitfield_extract( 9,  2,object)</span>
<span class="cp">#define	Sexponentmantissa(object) Bitfield_mask( 1, 31,object)</span>
<span class="cp">#define	Ssignexponent(object) Bitfield_extract( 0,  9,object)</span>
<span class="cp">#define	Shidden(object) Bitfield_extract( 8,  1,object)</span>
<span class="cp">#define	Shiddenoverflow(object) Bitfield_extract( 7,  1,object)</span>
<span class="cp">#define	Shiddenhigh7mantissa(object) Bitfield_extract( 8,  8,object)</span>
<span class="cp">#define	Shiddenhigh3mantissa(object) Bitfield_extract( 8,  4,object)</span>
<span class="cp">#define	Slow(object) Bitfield_mask( 31,  1,object)</span>
<span class="cp">#define	Slow4(object) Bitfield_mask( 28,  4,object)</span>
<span class="cp">#define	Slow31(object) Bitfield_mask( 1, 31,object)</span>
<span class="cp">#define	Shigh31(object) Bitfield_extract( 0, 31,object)</span>
<span class="cp">#define	Ssignedhigh31(object) Bitfield_signed_extract( 0, 31,object)</span>
<span class="cp">#define	Shigh4(object) Bitfield_extract( 0,  4,object)</span>
<span class="cp">#define	Sbit24(object) Bitfield_extract( 24,  1,object)</span>
<span class="cp">#define	Sbit28(object) Bitfield_extract( 28,  1,object)</span>
<span class="cp">#define	Sbit29(object) Bitfield_extract( 29,  1,object)</span>
<span class="cp">#define	Sbit30(object) Bitfield_extract( 30,  1,object)</span>
<span class="cp">#define	Sbit31(object) Bitfield_mask( 31,  1,object)</span>

<span class="cp">#define Deposit_ssign(object,value) Bitfield_deposit(value,0,1,object)</span>
<span class="cp">#define Deposit_sexponent(object,value) Bitfield_deposit(value,1,8,object)</span>
<span class="cp">#define Deposit_smantissa(object,value) Bitfield_deposit(value,9,23,object)</span>
<span class="cp">#define Deposit_shigh2mantissa(object,value) Bitfield_deposit(value,9,2,object)</span>
<span class="cp">#define Deposit_sexponentmantissa(object,value) \</span>
<span class="cp">    Bitfield_deposit(value,1,31,object)</span>
<span class="cp">#define Deposit_ssignexponent(object,value) Bitfield_deposit(value,0,9,object)</span>
<span class="cp">#define Deposit_slow(object,value) Bitfield_deposit(value,31,1,object)</span>
<span class="cp">#define Deposit_shigh4(object,value) Bitfield_deposit(value,0,4,object)</span>

<span class="cp">#define	Is_ssign(object) Bitfield_mask( 0,  1,object)</span>
<span class="cp">#define	Is_ssignaling(object) Bitfield_mask( 9,  1,object)</span>
<span class="cp">#define	Is_shidden(object) Bitfield_mask( 8,  1,object)</span>
<span class="cp">#define	Is_shiddenoverflow(object) Bitfield_mask( 7,  1,object)</span>
<span class="cp">#define	Is_slow(object) Bitfield_mask( 31,  1,object)</span>
<span class="cp">#define	Is_sbit24(object) Bitfield_mask( 24,  1,object)</span>
<span class="cp">#define	Is_sbit28(object) Bitfield_mask( 28,  1,object)</span>
<span class="cp">#define	Is_sbit29(object) Bitfield_mask( 29,  1,object)</span>
<span class="cp">#define	Is_sbit30(object) Bitfield_mask( 30,  1,object)</span>
<span class="cp">#define	Is_sbit31(object) Bitfield_mask( 31,  1,object)</span>

<span class="cm">/* </span>
<span class="cm"> * Double number.</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |s|       exponent      |          mantissa part 1              |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> *</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |                    mantissa part 2                            |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> */</span>
<span class="cp">#define Dallp1(object) (object)</span>
<span class="cp">#define Dsign(object) Bitfield_extract( 0,  1,object)</span>
<span class="cp">#define Dsignedsign(object) Bitfield_signed_extract( 0,  1,object)</span>
<span class="cp">#define Dexponent(object) Bitfield_extract( 1,  11,object)</span>
<span class="cp">#define Dmantissap1(object) Bitfield_mask( 12, 20,object)</span>
<span class="cp">#define Dsignaling(object) Bitfield_extract( 12,  1,object)</span>
<span class="cp">#define Dsignalingnan(object) Bitfield_extract( 1,  12,object)</span>
<span class="cp">#define Dhigh2mantissa(object) Bitfield_extract( 12,  2,object)</span>
<span class="cp">#define Dexponentmantissap1(object) Bitfield_mask( 1, 31,object)</span>
<span class="cp">#define Dsignexponent(object) Bitfield_extract( 0, 12,object)</span>
<span class="cp">#define Dhidden(object) Bitfield_extract( 11,  1,object)</span>
<span class="cp">#define Dhiddenoverflow(object) Bitfield_extract( 10,  1,object)</span>
<span class="cp">#define Dhiddenhigh7mantissa(object) Bitfield_extract( 11,  8,object)</span>
<span class="cp">#define Dhiddenhigh3mantissa(object) Bitfield_extract( 11,  4,object)</span>
<span class="cp">#define Dlowp1(object) Bitfield_mask( 31,  1,object)</span>
<span class="cp">#define Dlow31p1(object) Bitfield_mask( 1, 31,object)</span>
<span class="cp">#define Dhighp1(object) Bitfield_extract( 0,  1,object)</span>
<span class="cp">#define Dhigh4p1(object) Bitfield_extract( 0,  4,object)</span>
<span class="cp">#define Dhigh31p1(object) Bitfield_extract( 0, 31,object)</span>
<span class="cp">#define Dsignedhigh31p1(object) Bitfield_signed_extract( 0, 31,object)</span>
<span class="cp">#define Dbit3p1(object) Bitfield_extract( 3,  1,object)</span>

<span class="cp">#define Deposit_dsign(object,value) Bitfield_deposit(value,0,1,object)</span>
<span class="cp">#define Deposit_dexponent(object,value) Bitfield_deposit(value,1,11,object)</span>
<span class="cp">#define Deposit_dmantissap1(object,value) Bitfield_deposit(value,12,20,object)</span>
<span class="cp">#define Deposit_dhigh2mantissa(object,value) Bitfield_deposit(value,12,2,object)</span>
<span class="cp">#define Deposit_dexponentmantissap1(object,value) \</span>
<span class="cp">    Bitfield_deposit(value,1,31,object)</span>
<span class="cp">#define Deposit_dsignexponent(object,value) Bitfield_deposit(value,0,12,object)</span>
<span class="cp">#define Deposit_dlowp1(object,value) Bitfield_deposit(value,31,1,object)</span>
<span class="cp">#define Deposit_dhigh4p1(object,value) Bitfield_deposit(value,0,4,object)</span>

<span class="cp">#define Is_dsign(object) Bitfield_mask( 0,  1,object)</span>
<span class="cp">#define Is_dsignaling(object) Bitfield_mask( 12,  1,object)</span>
<span class="cp">#define Is_dhidden(object) Bitfield_mask( 11,  1,object)</span>
<span class="cp">#define Is_dhiddenoverflow(object) Bitfield_mask( 10,  1,object)</span>
<span class="cp">#define Is_dlowp1(object) Bitfield_mask( 31,  1,object)</span>
<span class="cp">#define Is_dhighp1(object) Bitfield_mask( 0,  1,object)</span>
<span class="cp">#define Is_dbit3p1(object) Bitfield_mask( 3,  1,object)</span>

<span class="cp">#define Dallp2(object) (object)</span>
<span class="cp">#define Dmantissap2(object) (object)</span>
<span class="cp">#define Dlowp2(object) Bitfield_mask( 31,  1,object)</span>
<span class="cp">#define Dlow4p2(object) Bitfield_mask( 28,  4,object)</span>
<span class="cp">#define Dlow31p2(object) Bitfield_mask( 1, 31,object)</span>
<span class="cp">#define Dhighp2(object) Bitfield_extract( 0,  1,object)</span>
<span class="cp">#define Dhigh31p2(object) Bitfield_extract( 0, 31,object)</span>
<span class="cp">#define Dbit2p2(object) Bitfield_extract( 2,  1,object)</span>
<span class="cp">#define Dbit3p2(object) Bitfield_extract( 3,  1,object)</span>
<span class="cp">#define Dbit21p2(object) Bitfield_extract( 21,  1,object)</span>
<span class="cp">#define Dbit28p2(object) Bitfield_extract( 28,  1,object)</span>
<span class="cp">#define Dbit29p2(object) Bitfield_extract( 29,  1,object)</span>
<span class="cp">#define Dbit30p2(object) Bitfield_extract( 30,  1,object)</span>
<span class="cp">#define Dbit31p2(object) Bitfield_mask( 31,  1,object)</span>

<span class="cp">#define Deposit_dlowp2(object,value) Bitfield_deposit(value,31,1,object)</span>

<span class="cp">#define Is_dlowp2(object) Bitfield_mask( 31,  1,object)</span>
<span class="cp">#define Is_dhighp2(object) Bitfield_mask( 0,  1,object)</span>
<span class="cp">#define Is_dbit2p2(object) Bitfield_mask( 2,  1,object)</span>
<span class="cp">#define Is_dbit3p2(object) Bitfield_mask( 3,  1,object)</span>
<span class="cp">#define Is_dbit21p2(object) Bitfield_mask( 21,  1,object)</span>
<span class="cp">#define Is_dbit28p2(object) Bitfield_mask( 28,  1,object)</span>
<span class="cp">#define Is_dbit29p2(object) Bitfield_mask( 29,  1,object)</span>
<span class="cp">#define Is_dbit30p2(object) Bitfield_mask( 30,  1,object)</span>
<span class="cp">#define Is_dbit31p2(object) Bitfield_mask( 31,  1,object)</span>

<span class="cm">/* </span>
<span class="cm"> * Quad number.</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |s|          exponent           |      mantissa part 1          |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> *</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |                    mantissa part 2                            |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> *</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |                    mantissa part 3                            |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> *</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |                    mantissa part 4                            |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
    <span class="p">{</span>
    <span class="k">union</span>
	<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="n">qallp1</span><span class="p">;</span> <span class="p">}</span> <span class="n">u_qallp1</span><span class="p">;</span>
<span class="cm">/* Not needed for now...</span>
<span class="cm">	Bitfield_extract( 0,  1,u_qsign,qsign)</span>
<span class="cm">	Bitfield_signed_extract( 0,  1,u_qsignedsign,qsignedsign)</span>
<span class="cm">	Bitfield_extract( 1, 15,u_qexponent,qexponent)</span>
<span class="cm">	Bitfield_extract(16, 16,u_qmantissap1,qmantissap1)</span>
<span class="cm">	Bitfield_extract(16,  1,u_qsignaling,qsignaling)</span>
<span class="cm">	Bitfield_extract(1,  16,u_qsignalingnan,qsignalingnan)</span>
<span class="cm">	Bitfield_extract(16,  2,u_qhigh2mantissa,qhigh2mantissa)</span>
<span class="cm">	Bitfield_extract( 1, 31,u_qexponentmantissap1,qexponentmantissap1)</span>
<span class="cm">	Bitfield_extract( 0, 16,u_qsignexponent,qsignexponent)</span>
<span class="cm">	Bitfield_extract(15,  1,u_qhidden,qhidden)</span>
<span class="cm">	Bitfield_extract(14,  1,u_qhiddenoverflow,qhiddenoverflow)</span>
<span class="cm">	Bitfield_extract(15,  8,u_qhiddenhigh7mantissa,qhiddenhigh7mantissa)</span>
<span class="cm">	Bitfield_extract(15,  4,u_qhiddenhigh3mantissa,qhiddenhigh3mantissa)</span>
<span class="cm">	Bitfield_extract(31,  1,u_qlowp1,qlowp1)</span>
<span class="cm">	Bitfield_extract( 1, 31,u_qlow31p1,qlow31p1)</span>
<span class="cm">	Bitfield_extract( 0,  1,u_qhighp1,qhighp1)</span>
<span class="cm">	Bitfield_extract( 0,  4,u_qhigh4p1,qhigh4p1)</span>
<span class="cm">	Bitfield_extract( 0, 31,u_qhigh31p1,qhigh31p1)</span>
<span class="cm">  */</span>
	<span class="p">}</span> <span class="n">quad_u1</span><span class="p">;</span>
    <span class="k">union</span>
	<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="n">qallp2</span><span class="p">;</span> <span class="p">}</span> <span class="n">u_qallp2</span><span class="p">;</span>
  <span class="cm">/* Not needed for now...</span>
<span class="cm">	Bitfield_extract(31,  1,u_qlowp2,qlowp2)</span>
<span class="cm">	Bitfield_extract( 1, 31,u_qlow31p2,qlow31p2)</span>
<span class="cm">	Bitfield_extract( 0,  1,u_qhighp2,qhighp2)</span>
<span class="cm">	Bitfield_extract( 0, 31,u_qhigh31p2,qhigh31p2)</span>
<span class="cm">   */</span>
	<span class="p">}</span> <span class="n">quad_u2</span><span class="p">;</span>
    <span class="k">union</span>
	<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="n">qallp3</span><span class="p">;</span> <span class="p">}</span> <span class="n">u_qallp3</span><span class="p">;</span>
  <span class="cm">/* Not needed for now...</span>
<span class="cm">	Bitfield_extract(31,  1,u_qlowp3,qlowp3)</span>
<span class="cm">	Bitfield_extract( 1, 31,u_qlow31p3,qlow31p3)</span>
<span class="cm">	Bitfield_extract( 0,  1,u_qhighp3,qhighp3)</span>
<span class="cm">	Bitfield_extract( 0, 31,u_qhigh31p3,qhigh31p3)</span>
<span class="cm">   */</span> 
	<span class="p">}</span> <span class="n">quad_u3</span><span class="p">;</span>
    <span class="k">union</span>
	<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="n">qallp4</span><span class="p">;</span> <span class="p">}</span> <span class="n">u_qallp4</span><span class="p">;</span>
    <span class="cm">/* Not need for now...</span>
<span class="cm">	Bitfield_extract(31,  1,u_qlowp4,qlowp4)</span>
<span class="cm">	Bitfield_extract( 1, 31,u_qlow31p4,qlow31p4)</span>
<span class="cm">	Bitfield_extract( 0,  1,u_qhighp4,qhighp4)</span>
<span class="cm">	Bitfield_extract( 0, 31,u_qhigh31p4,qhigh31p4)</span>
<span class="cm">     */</span>
	<span class="p">}</span> <span class="n">quad_u4</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">quad_floating_point</span><span class="p">;</span>

<span class="cm">/* Extension - An additional structure to hold the guard, round and</span>
<span class="cm"> *             sticky bits during computations.</span>
<span class="cm"> */</span>
<span class="cp">#define Extall(object) (object)</span>
<span class="cp">#define Extsign(object) Bitfield_extract( 0,  1,object)</span>
<span class="cp">#define Exthigh31(object) Bitfield_extract( 0, 31,object)</span>
<span class="cp">#define Extlow31(object) Bitfield_extract( 1, 31,object)</span>
<span class="cp">#define Extlow(object) Bitfield_extract( 31,  1,object)</span>

<span class="cm">/*</span>
<span class="cm"> * Single extended - The upper word is just like single precision,</span>
<span class="cm"> *                 but one additional word of mantissa is needed.</span>
<span class="cm"> */</span>
<span class="cp">#define Sextallp1(object) (object)</span>
<span class="cp">#define Sextallp2(object) (object)</span>
<span class="cp">#define Sextlowp1(object) Bitfield_extract( 31,  1,object)</span>
<span class="cp">#define Sexthighp2(object) Bitfield_extract( 0,  1,object)</span>
<span class="cp">#define Sextlow31p2(object) Bitfield_extract( 1, 31,object)</span>
<span class="cp">#define Sexthiddenoverflow(object) Bitfield_extract( 4,  1,object)</span>
<span class="cp">#define Is_sexthiddenoverflow(object) Bitfield_mask( 4,  1,object)</span>

<span class="cm">/*</span>
<span class="cm"> * Double extended - The upper two words are just like double precision,</span>
<span class="cm"> *		     but two additional words of mantissa are needed.</span>
<span class="cm"> */</span>
<span class="cp">#define Dextallp1(object) (object)</span>
<span class="cp">#define Dextallp2(object) (object)</span>
<span class="cp">#define Dextallp3(object) (object)</span>
<span class="cp">#define Dextallp4(object) (object)</span>
<span class="cp">#define Dextlowp2(object) Bitfield_extract( 31,  1,object)</span>
<span class="cp">#define Dexthighp3(object) Bitfield_extract( 0,  1,object)</span>
<span class="cp">#define Dextlow31p3(object) Bitfield_extract( 1, 31,object)</span>
<span class="cp">#define Dexthiddenoverflow(object) Bitfield_extract( 10,  1,object)</span>
<span class="cp">#define Is_dexthiddenoverflow(object) Bitfield_mask( 10,  1,object)</span>
<span class="cp">#define Deposit_dextlowp4(object,value) Bitfield_deposit(value,31,1,object)</span>

<span class="cm">/*</span>
<span class="cm"> * Declare the basic structures for the 3 different</span>
<span class="cm"> * fixed-point precisions.</span>
<span class="cm"> *        </span>
<span class="cm"> * Single number  </span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |s|                    integer                                  |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">sgl_integer</span><span class="p">;</span>

<span class="cm">/* </span>
<span class="cm"> * Double number.</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |s|                     high integer                            |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> *</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |                       low integer                             |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dint</span> <span class="p">{</span>
        <span class="kt">int</span>  <span class="n">wd0</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wd1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dblwd</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wd0</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wd1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* </span>
<span class="cm"> * Quad number.</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |s|                  integer part1                              |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> *</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |                    integer part 2                             |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> *</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |                    integer part 3                             |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> *</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |                    integer part 4                             |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">quadwd</span> <span class="p">{</span>
        <span class="kt">int</span>  <span class="n">wd0</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wd1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wd2</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wd3</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">quadwd</span> <span class="n">quad_integer</span><span class="p">;</span>


<span class="cm">/* useful typedefs */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sgl_floating_point</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dblwd</span> <span class="n">dbl_floating_point</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dint</span> <span class="n">dbl_integer</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dblwd</span> <span class="n">dbl_unsigned</span><span class="p">;</span>

<span class="cm">/* </span>
<span class="cm"> * Define the different precisions&#39; parameters.</span>
<span class="cm"> */</span>
<span class="cp">#define SGL_BITLENGTH 32</span>
<span class="cp">#define SGL_EMAX 127</span>
<span class="cp">#define SGL_EMIN (-126)</span>
<span class="cp">#define SGL_BIAS 127</span>
<span class="cp">#define SGL_WRAP 192</span>
<span class="cp">#define SGL_INFINITY_EXPONENT (SGL_EMAX+SGL_BIAS+1)</span>
<span class="cp">#define SGL_THRESHOLD 32</span>
<span class="cp">#define SGL_EXP_LENGTH 8</span>
<span class="cp">#define SGL_P 24</span>

<span class="cp">#define DBL_BITLENGTH 64</span>
<span class="cp">#define DBL_EMAX 1023</span>
<span class="cp">#define DBL_EMIN (-1022)</span>
<span class="cp">#define DBL_BIAS 1023</span>
<span class="cp">#define DBL_WRAP 1536</span>
<span class="cp">#define DBL_INFINITY_EXPONENT (DBL_EMAX+DBL_BIAS+1)</span>
<span class="cp">#define DBL_THRESHOLD 64</span>
<span class="cp">#define DBL_EXP_LENGTH 11</span>
<span class="cp">#define DBL_P 53</span>

<span class="cp">#define QUAD_BITLENGTH 128</span>
<span class="cp">#define QUAD_EMAX 16383</span>
<span class="cp">#define QUAD_EMIN (-16382)</span>
<span class="cp">#define QUAD_BIAS 16383</span>
<span class="cp">#define QUAD_WRAP 24576</span>
<span class="cp">#define QUAD_INFINITY_EXPONENT (QUAD_EMAX+QUAD_BIAS+1)</span>
<span class="cp">#define QUAD_P 113</span>

<span class="cm">/* Boolean Values etc. */</span>
<span class="cp">#define FALSE 0</span>
<span class="cp">#define TRUE (!FALSE)</span>
<span class="cp">#define NOT !</span>
<span class="cp">#define XOR ^</span>

<span class="cm">/* other constants */</span>
<span class="cp">#undef NULL</span>
<span class="cp">#define NULL 0</span>
<span class="cp">#define NIL 0</span>
<span class="cp">#define SGL 0</span>
<span class="cp">#define DBL 1</span>
<span class="cp">#define BADFMT 2</span>
<span class="cp">#define QUAD 3</span>


<span class="cm">/* Types */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">boolean</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">FORMAT</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">VOID</span><span class="p">;</span>


<span class="cm">/* Declare status register equivalent to FPUs architecture.</span>
<span class="cm"> *</span>
<span class="cm"> *  0 1 2 3 4 5 6 7 8 910 1 2 3 4 5 6 7 8 920 1 2 3 4 5 6 7 8 930 1</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |V|Z|O|U|I|C|  rsv  |  model    | version |RM |rsv|T|r|V|Z|O|U|I|</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> */</span>
<span class="cp">#define Cbit(object) Bitfield_extract( 5, 1,object)</span>
<span class="cp">#define Tbit(object) Bitfield_extract( 25, 1,object)</span>
<span class="cp">#define Roundingmode(object) Bitfield_extract( 21, 2,object)</span>
<span class="cp">#define Invalidtrap(object) Bitfield_extract( 27, 1,object)</span>
<span class="cp">#define Divisionbyzerotrap(object) Bitfield_extract( 28, 1,object)</span>
<span class="cp">#define Overflowtrap(object) Bitfield_extract( 29, 1,object)</span>
<span class="cp">#define Underflowtrap(object) Bitfield_extract( 30, 1,object)</span>
<span class="cp">#define Inexacttrap(object) Bitfield_extract( 31, 1,object)</span>
<span class="cp">#define Invalidflag(object) Bitfield_extract( 0, 1,object)</span>
<span class="cp">#define Divisionbyzeroflag(object) Bitfield_extract( 1, 1,object)</span>
<span class="cp">#define Overflowflag(object) Bitfield_extract( 2, 1,object)</span>
<span class="cp">#define Underflowflag(object) Bitfield_extract( 3, 1,object)</span>
<span class="cp">#define Inexactflag(object) Bitfield_extract( 4, 1,object)</span>
<span class="cp">#define Allflags(object) Bitfield_extract( 0, 5,object)</span>

<span class="cm">/* Definitions relevant to the status register */</span>

<span class="cm">/* Rounding Modes */</span>
<span class="cp">#define ROUNDNEAREST 0</span>
<span class="cp">#define ROUNDZERO    1</span>
<span class="cp">#define ROUNDPLUS    2</span>
<span class="cp">#define ROUNDMINUS   3</span>

<span class="cm">/* Exceptions */</span>
<span class="cp">#define NOEXCEPTION		0x0</span>
<span class="cp">#define INVALIDEXCEPTION	0x20</span>
<span class="cp">#define DIVISIONBYZEROEXCEPTION	0x10</span>
<span class="cp">#define OVERFLOWEXCEPTION	0x08</span>
<span class="cp">#define UNDERFLOWEXCEPTION	0x04</span>
<span class="cp">#define INEXACTEXCEPTION	0x02</span>
<span class="cp">#define UNIMPLEMENTEDEXCEPTION	0x01</span>

<span class="cm">/* New exceptions for the 2E Opcode */</span>
<span class="cp">#define OPC_2E_INVALIDEXCEPTION     0x30</span>
<span class="cp">#define OPC_2E_OVERFLOWEXCEPTION    0x18</span>
<span class="cp">#define OPC_2E_UNDERFLOWEXCEPTION   0x0c</span>
<span class="cp">#define OPC_2E_INEXACTEXCEPTION     0x12</span>

<span class="cm">/* Declare exception registers equivalent to FPUs architecture </span>
<span class="cm"> *</span>
<span class="cm"> *  0 1 2 3 4 5 6 7 8 910 1 2 3 4 5 6 7 8 920 1 2 3 4 5 6 7 8 930 1</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |excepttype |  r1     | r2/ext  |  operation  |parm |n| t/cond  |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> */</span>
<span class="cp">#define Allexception(object) (object)</span>
<span class="cp">#define Exceptiontype(object) Bitfield_extract( 0, 6,object)</span>
<span class="cp">#define Instructionfield(object) Bitfield_mask( 6,26,object)</span>
<span class="cp">#define Parmfield(object) Bitfield_extract( 23, 3,object)</span>
<span class="cp">#define Rabit(object) Bitfield_extract( 24, 1,object)</span>
<span class="cp">#define Ibit(object) Bitfield_extract( 25, 1,object)</span>

<span class="cp">#define Set_exceptiontype(object,value) Bitfield_deposit(value, 0, 6,object)</span>
<span class="cp">#define Set_parmfield(object,value) Bitfield_deposit(value, 23, 3,object)</span>
<span class="cp">#define Set_exceptiontype_and_instr_field(exception,instruction,object) \</span>
<span class="cp">    object = exception &lt;&lt; 26 | instruction</span>

<span class="cm">/* Declare the condition field</span>
<span class="cm"> *</span>
<span class="cm"> *  0 1 2 3 4 5 6 7 8 910 1 2 3 4 5 6 7 8 920 1 2 3 4 5 6 7 8 930 1</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> * |                                                     |G|L|E|U|X|</span>
<span class="cm"> * +-------+-------+-------+-------+-------+-------+-------+-------+</span>
<span class="cm"> */</span>
<span class="cp">#define Allexception(object) (object)</span>
<span class="cp">#define Greaterthanbit(object) Bitfield_extract( 27, 1,object)</span>
<span class="cp">#define Lessthanbit(object) Bitfield_extract( 28, 1,object)</span>
<span class="cp">#define Equalbit(object) Bitfield_extract( 29, 1,object)</span>
<span class="cp">#define Unorderedbit(object) Bitfield_extract( 30, 1,object)</span>
<span class="cp">#define Exceptionbit(object) Bitfield_extract( 31, 1,object)</span>

<span class="cm">/* An alias name for the status register */</span>
<span class="cp">#define Fpustatus_register (*status)</span>

<span class="cm">/**************************************************</span>
<span class="cm"> * Status register referencing and manipulation.  *</span>
<span class="cm"> **************************************************/</span>

<span class="cm">/* Rounding mode */</span>
<span class="cp">#define Rounding_mode()  Roundingmode(Fpustatus_register)</span>
<span class="cp">#define Is_rounding_mode(rmode) \</span>
<span class="cp">    (Roundingmode(Fpustatus_register) == rmode)</span>
<span class="cp">#define Set_rounding_mode(value) \</span>
<span class="cp">    Bitfield_deposit(value,21,2,Fpustatus_register)</span>

<span class="cm">/* Boolean testing of the trap enable bits */</span>
<span class="cp">#define Is_invalidtrap_enabled() Invalidtrap(Fpustatus_register)</span>
<span class="cp">#define Is_divisionbyzerotrap_enabled() Divisionbyzerotrap(Fpustatus_register)</span>
<span class="cp">#define Is_overflowtrap_enabled() Overflowtrap(Fpustatus_register)</span>
<span class="cp">#define Is_underflowtrap_enabled() Underflowtrap(Fpustatus_register)</span>
<span class="cp">#define Is_inexacttrap_enabled() Inexacttrap(Fpustatus_register)</span>

<span class="cm">/* Set the indicated flags in the status register */</span>
<span class="cp">#define Set_invalidflag() Bitfield_deposit(1,0,1,Fpustatus_register)</span>
<span class="cp">#define Set_divisionbyzeroflag() Bitfield_deposit(1,1,1,Fpustatus_register)</span>
<span class="cp">#define Set_overflowflag() Bitfield_deposit(1,2,1,Fpustatus_register)</span>
<span class="cp">#define Set_underflowflag() Bitfield_deposit(1,3,1,Fpustatus_register)</span>
<span class="cp">#define Set_inexactflag() Bitfield_deposit(1,4,1,Fpustatus_register)</span>

<span class="cp">#define Clear_all_flags() Bitfield_deposit(0,0,5,Fpustatus_register)</span>

<span class="cm">/* Manipulate the trap and condition code bits (tbit and cbit) */</span>
<span class="cp">#define Set_tbit() Bitfield_deposit(1,25,1,Fpustatus_register)</span>
<span class="cp">#define Clear_tbit() Bitfield_deposit(0,25,1,Fpustatus_register)</span>
<span class="cp">#define Is_tbit_set() Tbit(Fpustatus_register)</span>
<span class="cp">#define Is_cbit_set() Cbit(Fpustatus_register)</span>

<span class="cp">#define Set_status_cbit(value)  \</span>
<span class="cp">        Bitfield_deposit(value,5,1,Fpustatus_register)</span>

<span class="cm">/*******************************</span>
<span class="cm"> * Condition field referencing *</span>
<span class="cm"> *******************************/</span>
<span class="cp">#define Unordered(cond) Unorderedbit(cond)</span>
<span class="cp">#define Equal(cond) Equalbit(cond)</span>
<span class="cp">#define Lessthan(cond) Lessthanbit(cond)</span>
<span class="cp">#define Greaterthan(cond) Greaterthanbit(cond)</span>
<span class="cp">#define Exception(cond) Exceptionbit(cond)</span>


<span class="cm">/* Defines for the extension */</span>
<span class="cp">#define Ext_isone_sign(extent) (Extsign(extent))</span>
<span class="cp">#define Ext_isnotzero(extent) \</span>
<span class="cp">    (Extall(extent))</span>
<span class="cp">#define Ext_isnotzero_lower(extent) \</span>
<span class="cp">    (Extlow31(extent))</span>
<span class="cp">#define Ext_leftshiftby1(extent) \</span>
<span class="cp">    Extall(extent) &lt;&lt;= 1</span>
<span class="cp">#define Ext_negate(extent) \</span>
<span class="cp">    (int )Extall(extent) = 0 - (int )Extall(extent)</span>
<span class="cp">#define Ext_setone_low(extent) Bitfield_deposit(1,31,1,extent)</span>
<span class="cp">#define Ext_setzero(extent) Extall(extent) = 0</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">operation</span><span class="p">;</span>

<span class="cm">/* error messages */</span>

<span class="cp">#define		NONE		0</span>
<span class="cp">#define		UNDEFFPINST	1</span>

<span class="cm">/* Function definitions: opcode, opclass */</span>
<span class="cp">#define FTEST	(1&lt;&lt;2) | 0</span>
<span class="cp">#define FCPY	(2&lt;&lt;2) | 0</span>
<span class="cp">#define FABS	(3&lt;&lt;2) | 0</span>
<span class="cp">#define FSQRT   (4&lt;&lt;2) | 0</span>
<span class="cp">#define FRND    (5&lt;&lt;2) | 0</span>

<span class="cp">#define FCNVFF	(0&lt;&lt;2) | 1</span>
<span class="cp">#define FCNVXF	(1&lt;&lt;2) | 1</span>
<span class="cp">#define FCNVFX	(2&lt;&lt;2) | 1</span>
<span class="cp">#define FCNVFXT	(3&lt;&lt;2) | 1</span>

<span class="cp">#define FCMP    (0&lt;&lt;2) | 2</span>

<span class="cp">#define FADD	(0&lt;&lt;2) | 3</span>
<span class="cp">#define FSUB	(1&lt;&lt;2) | 3</span>
<span class="cp">#define FMPY	(2&lt;&lt;2) | 3</span>
<span class="cp">#define FDIV	(3&lt;&lt;2) | 3</span>
<span class="cp">#define FREM	(4&lt;&lt;2) | 3</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
