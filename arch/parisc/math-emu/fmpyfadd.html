<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › math-emu › fmpyfadd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fmpyfadd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux/PA-RISC Project (http://www.parisc-linux.org/)</span>
<span class="cm"> *</span>
<span class="cm"> * Floating-point emulation code</span>
<span class="cm"> *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *    the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *    any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *    GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *    You should have received a copy of the GNU General Public License</span>
<span class="cm"> *    along with this program; if not, write to the Free Software</span>
<span class="cm"> *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * BEGIN_DESC</span>
<span class="cm"> *</span>
<span class="cm"> *  File:</span>
<span class="cm"> *	@(#)	pa/spmath/fmpyfadd.c		$Revision: 1.1 $</span>
<span class="cm"> *</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *	Double Floating-point Multiply Fused Add</span>
<span class="cm"> *	Double Floating-point Multiply Negate Fused Add</span>
<span class="cm"> *	Single Floating-point Multiply Fused Add</span>
<span class="cm"> *	Single Floating-point Multiply Negate Fused Add</span>
<span class="cm"> *</span>
<span class="cm"> *  External Interfaces:</span>
<span class="cm"> *	dbl_fmpyfadd(src1ptr,src2ptr,src3ptr,status,dstptr)</span>
<span class="cm"> *	dbl_fmpynfadd(src1ptr,src2ptr,src3ptr,status,dstptr)</span>
<span class="cm"> *	sgl_fmpyfadd(src1ptr,src2ptr,src3ptr,status,dstptr)</span>
<span class="cm"> *	sgl_fmpynfadd(src1ptr,src2ptr,src3ptr,status,dstptr)</span>
<span class="cm"> *</span>
<span class="cm"> *  Internal Interfaces:</span>
<span class="cm"> *</span>
<span class="cm"> *  Theory:</span>
<span class="cm"> *	&lt;&lt;please update with a overview of the operation of this file&gt;&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * END_DESC</span>
<span class="cm">*/</span>


<span class="cp">#include &quot;float.h&quot;</span>
<span class="cp">#include &quot;sgl_float.h&quot;</span>
<span class="cp">#include &quot;dbl_float.h&quot;</span>


<span class="cm">/*</span>
<span class="cm"> *  Double Floating-point Multiply Fused Add</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">dbl_fmpyfadd</span><span class="p">(</span>
	    <span class="n">dbl_floating_point</span> <span class="o">*</span><span class="n">src1ptr</span><span class="p">,</span>
	    <span class="n">dbl_floating_point</span> <span class="o">*</span><span class="n">src2ptr</span><span class="p">,</span>
	    <span class="n">dbl_floating_point</span> <span class="o">*</span><span class="n">src3ptr</span><span class="p">,</span>
	    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span>
	    <span class="n">dbl_floating_point</span> <span class="o">*</span><span class="n">dstptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opnd1p1</span><span class="p">,</span> <span class="n">opnd1p2</span><span class="p">,</span> <span class="n">opnd2p1</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="p">,</span> <span class="n">opnd3p1</span><span class="p">,</span> <span class="n">opnd3p2</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rightp1</span><span class="p">,</span> <span class="n">rightp2</span><span class="p">,</span> <span class="n">rightp3</span><span class="p">,</span> <span class="n">rightp4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resultp1</span><span class="p">,</span> <span class="n">resultp2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">resultp3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">resultp4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">mpy_exponent</span><span class="p">,</span> <span class="n">add_exponent</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">boolean</span> <span class="n">inexact</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">is_tiny</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">signlessleft1</span><span class="p">,</span> <span class="n">signlessright1</span><span class="p">,</span> <span class="n">save</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">result_exponent</span><span class="p">,</span> <span class="n">diff_exponent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sign_save</span><span class="p">,</span> <span class="n">jumpsize</span><span class="p">;</span>
	
	<span class="n">Dbl_copyfromptr</span><span class="p">(</span><span class="n">src1ptr</span><span class="p">,</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">);</span>
	<span class="n">Dbl_copyfromptr</span><span class="p">(</span><span class="n">src2ptr</span><span class="p">,</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">);</span>
	<span class="n">Dbl_copyfromptr</span><span class="p">(</span><span class="n">src3ptr</span><span class="p">,</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * set sign bit of result of multiply</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_sign</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Dbl_sign</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> 
		<span class="n">Dbl_setnegativezerop1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span> 
	<span class="k">else</span> <span class="n">Dbl_setzerop1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate multiply exponent </span>
<span class="cm">	 */</span>
	<span class="n">mpy_exponent</span> <span class="o">=</span> <span class="n">Dbl_exponent</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Dbl_exponent</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">DBL_BIAS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check first operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isnotnan</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">Dbl_isnotnan</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since operands are infinity </span>
<span class="cm">					 * and zero </span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Dbl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
					<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * Check third operand for infinity with a</span>
<span class="cm">				 *  sign opposite of the multiply result</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">Dbl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Dbl_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since attempting a magnitude</span>
<span class="cm">					 * subtraction of infinities</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Dbl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
					<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">			 	 * return infinity</span>
<span class="cm">			 	 */</span>
				<span class="n">Dbl_setinfinity_exponentmantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * is NaN; signaling or quiet?</span>
<span class="cm">		 	 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_signaling</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span> 
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is second operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_is_signalingnan</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is third operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_is_signalingnan</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * return quiet NaN</span>
<span class="cm">		 	 */</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check second operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isnotnan</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since multiply operands are</span>
<span class="cm">					 * zero &amp; infinity</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Dbl_makequietnan</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">);</span>
					<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Check third operand for infinity with a</span>
<span class="cm">				 *  sign opposite of the multiply result</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">Dbl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Dbl_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since attempting a magnitude</span>
<span class="cm">					 * subtraction of infinities</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
				       		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				       	<span class="n">Set_invalidflag</span><span class="p">();</span>
				       	<span class="n">Dbl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
					<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * return infinity</span>
<span class="cm">				 */</span>
				<span class="n">Dbl_setinfinity_exponentmantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * is NaN; signaling or quiet?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_signaling</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
					<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is third operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_is_signalingnan</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">))</span> <span class="p">{</span>
			       	<span class="cm">/* trap if INVALIDTRAP enabled */</span>
			       	<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
				   		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
			       	<span class="cm">/* make NaN quiet */</span>
			       	<span class="n">Set_invalidflag</span><span class="p">();</span>
			       	<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
		       		<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * return quiet NaN</span>
<span class="cm">			 */</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check third operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* return infinity */</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * is NaN; signaling or quiet?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_signaling</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
					<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * return quiet NaN</span>
<span class="cm"> 			 */</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
    	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate multiply mantissa</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isnotzero_exponent</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* set hidden bit */</span>
		<span class="n">Dbl_clear_signexponent_set_hidden</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Perform the add opnd3 with zero here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">Dbl_or_signs</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">Dbl_and_signs</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now let&#39;s check for trapped underflow case.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			         <span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                    		<span class="cm">/* need to normalize results mantissa */</span>
                    		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">);</span>
                    		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
                    		<span class="n">Dbl_set_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                    		<span class="n">Dbl_setwrapped_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span>
							<span class="n">unfl</span><span class="p">);</span>
                    		<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                    		<span class="cm">/* inexact = FALSE */</span>
                    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* is denormalized, adjust exponent */</span>
		<span class="n">Dbl_clear_signexponent</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">);</span>
		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">);</span>
		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">,</span><span class="n">mpy_exponent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* opnd2 needs to have hidden bit set with msb in hidden bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isnotzero_exponent</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">Dbl_clear_signexponent_set_hidden</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Perform the add opnd3 with zero here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">Dbl_or_signs</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">Dbl_and_signs</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now let&#39;s check for trapped underflow case.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                    		<span class="cm">/* need to normalize results mantissa */</span>
                    		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">);</span>
                    		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
                    		<span class="n">Dbl_set_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                    		<span class="n">Dbl_setwrapped_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span>
							<span class="n">unfl</span><span class="p">);</span>
                    		<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                    		<span class="cm">/* inexact = FALSE */</span>
				<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* is denormalized; want to normalize */</span>
		<span class="n">Dbl_clear_signexponent</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">);</span>
		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">);</span>
		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">,</span><span class="n">mpy_exponent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Multiply the first two source mantissas together */</span>

	<span class="cm">/* </span>
<span class="cm">	 * The intermediate result will be kept in tmpres,</span>
<span class="cm">	 * which needs enough room for 106 bits of mantissa,</span>
<span class="cm">	 * so lets call it a Double extended.</span>
<span class="cm">	 */</span>
	<span class="n">Dblext_setzero</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * Four bits at a time are inspected in each loop, and a </span>
<span class="cm">	 * simple shift and add multiply algorithm is used. </span>
<span class="cm">	 */</span> 
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="n">DBL_P</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Dblext_rightshiftby4</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbit28p2</span><span class="p">(</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
	 		<span class="cm">/* Fourword_add should be an ADD followed by 3 ADDC&#39;s */</span>
			<span class="n">Fourword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">,</span> 
			 <span class="n">opnd2p1</span><span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="o">|</span> <span class="n">opnd2p2</span><span class="o">&gt;&gt;</span><span class="mi">29</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbit29p2</span><span class="p">(</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Fourword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">,</span>
			 <span class="n">opnd2p1</span><span class="o">&lt;&lt;</span><span class="mi">2</span> <span class="o">|</span> <span class="n">opnd2p2</span><span class="o">&gt;&gt;</span><span class="mi">30</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbit30p2</span><span class="p">(</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Fourword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">,</span>
			 <span class="n">opnd2p1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="o">|</span> <span class="n">opnd2p2</span><span class="o">&gt;&gt;</span><span class="mi">31</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbit31p2</span><span class="p">(</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Fourword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">,</span>
			 <span class="n">opnd2p1</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">Dbl_rightshiftby4</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Is_dexthiddenoverflow</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* result mantissa &gt;= 2 (mantissa overflow) */</span>
		<span class="n">mpy_exponent</span><span class="o">++</span><span class="p">;</span>
		<span class="n">Dblext_rightshiftby1</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the sign of the mpy result which was saved in resultp1.</span>
<span class="cm">	 * The exponent will continue to be kept in mpy_exponent.</span>
<span class="cm">	 */</span>
	<span class="n">Dblext_set_sign</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">Dbl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * No rounding is required, since the result of the multiply</span>
<span class="cm">	 * is exact in the extended format.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we are ready to perform the add portion of the operation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The exponents need to be kept as integers for now, since the</span>
<span class="cm">	 * multiply result might not fit into the exponent field.  We</span>
<span class="cm">	 * can&#39;t overflow or underflow because of this yet, since the</span>
<span class="cm">	 * add could bring the final result back into range.</span>
<span class="cm">	 */</span>
	<span class="n">add_exponent</span> <span class="o">=</span> <span class="n">Dbl_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for denormalized or zero add operand.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">add_exponent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* right is zero */</span>
			<span class="cm">/* Left can&#39;t be zero and must be result.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The final result is now in tmpres and mpy_exponent,</span>
<span class="cm">			 * and needs to be rounded and squeezed back into</span>
<span class="cm">			 * double precision format from double extended.</span>
<span class="cm">			 */</span>
			<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span><span class="p">;</span>
			<span class="n">Dblext_copy</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">,</span>
				<span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
			<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span><span class="cm">/*save sign*/</span>
			<span class="k">goto</span> <span class="n">round</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* </span>
<span class="cm">		 * Neither are zeroes.  </span>
<span class="cm">		 * Adjust exponent and normalize add operand.</span>
<span class="cm">		 */</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>	<span class="cm">/* save sign */</span>
		<span class="n">Dbl_clear_signexponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">);</span>
		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">add_exponent</span><span class="p">);</span>
		<span class="n">Dbl_set_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">sign_save</span><span class="p">);</span>	<span class="cm">/* restore sign */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">Dbl_clear_exponent_set_hidden</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy opnd3 to the double extended variable called right.</span>
<span class="cm">	 */</span>
	<span class="n">Dbl_copyto_dblext</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A zero &quot;save&quot; helps discover equal operands (for later),</span>
<span class="cm">	 * and is used in swapping operands (if needed).</span>
<span class="cm">	 */</span>
	<span class="n">Dblext_xortointp1</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">save</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compare magnitude of operands.</span>
<span class="cm">	 */</span>
	<span class="n">Dblext_copytoint_exponentmantissap1</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">signlessleft1</span><span class="p">);</span>
	<span class="n">Dblext_copytoint_exponentmantissap1</span><span class="p">(</span><span class="n">rightp1</span><span class="p">,</span><span class="n">signlessright1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpy_exponent</span> <span class="o">&lt;</span> <span class="n">add_exponent</span> <span class="o">||</span> <span class="n">mpy_exponent</span> <span class="o">==</span> <span class="n">add_exponent</span> <span class="o">&amp;&amp;</span>
	    <span class="n">Dblext_ismagnitudeless</span><span class="p">(</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">signlessleft1</span><span class="p">,</span><span class="n">signlessright1</span><span class="p">)){</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the left operand to the larger one by XOR swap.</span>
<span class="cm">		 * First finish the first word &quot;save&quot;.</span>
<span class="cm">		 */</span>
		<span class="n">Dblext_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">rightp1</span><span class="p">);</span>
		<span class="n">Dblext_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">tmpresp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">tmpresp1</span><span class="p">);</span>
		<span class="n">Dblext_swap_lower</span><span class="p">(</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">,</span>
			<span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">);</span>
		<span class="cm">/* also setup exponents used in rest of routine */</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">add_exponent</span> <span class="o">-</span> <span class="n">mpy_exponent</span><span class="p">;</span>
		<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">add_exponent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* also setup exponents used in rest of routine */</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span> <span class="o">-</span> <span class="n">add_exponent</span><span class="p">;</span>
		<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Invariant: left is not smaller than right. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Special case alignment of operands that would force alignment</span>
<span class="cm">	 * beyond the extent of the extension.  A further optimization</span>
<span class="cm">	 * could special case this but only reduces the path length for</span>
<span class="cm">	 * this infrequent case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff_exponent</span> <span class="o">&gt;</span> <span class="n">DBLEXT_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">DBLEXT_THRESHOLD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Align right operand by shifting it to the right */</span>
	<span class="n">Dblext_clear_sign</span><span class="p">(</span><span class="n">rightp1</span><span class="p">);</span>
	<span class="n">Dblext_right_align</span><span class="p">(</span><span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">,</span>
		<span class="cm">/*shifted by*/</span><span class="n">diff_exponent</span><span class="p">);</span>
	
	<span class="cm">/* Treat sum and difference of the operands separately. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">save</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Difference of the two operands.  Overflow can occur if the</span>
<span class="cm">		 * multiply overflowed.  A borrow can occur out of the hidden</span>
<span class="cm">		 * bit and force a post normalization phase.</span>
<span class="cm">		 */</span>
		<span class="n">Dblext_subtract</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">,</span>
			<span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">,</span>
			<span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_hidden</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Handle normalization */</span>
		<span class="cm">/* A straightforward algorithm would now shift the</span>
<span class="cm">		 * result and extension left until the hidden bit</span>
<span class="cm">		 * becomes one.  Not all of the extension bits need</span>
<span class="cm">		 * participate in the shift.  Only the two most </span>
<span class="cm">		 * significant bits (round and guard) are needed.</span>
<span class="cm">		 * If only a single shift is needed then the guard</span>
<span class="cm">		 * bit becomes a significant low order bit and the</span>
<span class="cm">		 * extension must participate in the rounding.</span>
<span class="cm">		 * If more than a single shift is needed, then all</span>
<span class="cm">		 * bits to the right of the guard bit are zeros, </span>
<span class="cm">		 * and the guard bit may or may not be zero. */</span>
			<span class="n">Dblext_leftshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
				<span class="n">resultp4</span><span class="p">);</span>

			<span class="cm">/* Need to check for a zero result.  The sign and</span>
<span class="cm">			 * exponent fields have already been zeroed.  The more</span>
<span class="cm">			 * efficient test of the full object can be used.</span>
<span class="cm">			 */</span>
			 <span class="k">if</span><span class="p">(</span><span class="n">Dblext_iszero</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">)){</span>
				<span class="cm">/* Must have been &quot;x-x&quot; or &quot;x+(-x)&quot;. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span>
					<span class="n">Dbl_setone_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">result_exponent</span><span class="o">--</span><span class="p">;</span>

			<span class="cm">/* Look to see if normalization is finished. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_hidden</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* No further normalization is needed */</span>
				<span class="k">goto</span> <span class="n">round</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Discover first one bit to determine shift amount.</span>
<span class="cm">			 * Use a modified binary search.  We have already</span>
<span class="cm">			 * shifted the result one position right and still</span>
<span class="cm">			 * not found a one so the remainder of the extension</span>
<span class="cm">			 * must be zero and simplifies rounding. */</span>
			<span class="cm">/* Scan bytes */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">Dbl_iszero_hiddenhigh7mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">Dblext_leftshiftby8</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Now narrow it down to the nibble */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* The lower nibble contains the</span>
<span class="cm">				 * normalizing one */</span>
				<span class="n">Dblext_leftshiftby4</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Select case where first bit is set (already</span>
<span class="cm">			 * normalized) otherwise select the proper shift. */</span>
			<span class="n">jumpsize</span> <span class="o">=</span> <span class="n">Dbl_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jumpsize</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">)</span> <span class="k">switch</span><span class="p">(</span><span class="n">jumpsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">Dblext_leftshiftby3</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
					<span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">Dblext_leftshiftby2</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
					<span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">4</span>:
			<span class="k">case</span> <span class="mi">5</span>:
			<span class="k">case</span> <span class="mi">6</span>:
			<span class="k">case</span> <span class="mi">7</span>:
				<span class="n">Dblext_leftshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
					<span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="cm">/* end if (hidden...)... */</span>
	<span class="cm">/* Fall through and round */</span>
	<span class="p">}</span> <span class="cm">/* end if (save &lt; 0)... */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Add magnitudes */</span>
		<span class="n">Dblext_addition</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">,</span>
			<span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">,</span>
			<span class="cm">/*to*/</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
	    		<span class="cm">/* Prenormalization required. */</span>
	    		<span class="n">Dblext_arithrightshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
				<span class="n">resultp4</span><span class="p">);</span>
	    		<span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* end if hiddenoverflow... */</span>
	<span class="p">}</span> <span class="cm">/* end else ...add magnitudes... */</span>

	<span class="cm">/* Round the result.  If the extension and lower two words are</span>
<span class="cm">	 * all zeros, then the result is exact.  Otherwise round in the</span>
<span class="cm">	 * correct direction.  Underflow is possible. If a postnormalization</span>
<span class="cm">	 * is necessary, then the mantissa is all zeros so no shift is needed.</span>
<span class="cm">	 */</span>
  <span class="nl">round:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">Dblext_denormalize</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">,</span>
			<span class="n">result_exponent</span><span class="p">,</span><span class="n">is_tiny</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">Dbl_set_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dblext_isnotzero_mantissap3</span><span class="p">(</span><span class="n">resultp3</span><span class="p">)</span> <span class="o">||</span> 
	    <span class="n">Dblext_isnotzero_mantissap4</span><span class="p">(</span><span class="n">resultp4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">Rounding_mode</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ROUNDNEAREST</span>: <span class="cm">/* The default. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dblext_isone_highp3</span><span class="p">(</span><span class="n">resultp3</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* at least 1/2 ulp */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dblext_isnotzero_low31p3</span><span class="p">(</span><span class="n">resultp3</span><span class="p">)</span> <span class="o">||</span>
				    <span class="n">Dblext_isnotzero_mantissap4</span><span class="p">(</span><span class="n">resultp4</span><span class="p">)</span> <span class="o">||</span>
				    <span class="n">Dblext_isone_lowp2</span><span class="p">(</span><span class="n">resultp2</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* either exactly half way and odd or</span>
<span class="cm">					 * more than 1/2ulp */</span>
					<span class="n">Dbl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
	    		<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ROUNDPLUS</span>:
	    		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Round up positive results */</span>
				<span class="n">Dbl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
	    
		<span class="k">case</span> <span class="n">ROUNDMINUS</span>:
	    		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Round down negative results */</span>
				<span class="n">Dbl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
			<span class="p">}</span>
	    
		<span class="k">case</span> <span class="n">ROUNDZERO</span>:<span class="p">;</span>
			<span class="cm">/* truncate is simple */</span>
		<span class="p">}</span> <span class="cm">/* end switch... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&gt;=</span> <span class="n">DBL_INFINITY_EXPONENT</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* trap if OVERFLOWTRAP enabled */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Is_overflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                        <span class="cm">/*</span>
<span class="cm">                         * Adjust bias of result</span>
<span class="cm">                         */</span>
                        <span class="n">Dbl_setwrapped_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">ovfl</span><span class="p">);</span>
                        <span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span>
                                <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_OVERFLOWEXCEPTION</span> <span class="o">|</span>
					<span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
                            <span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_OVERFLOWEXCEPTION</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
                <span class="n">Set_overflowflag</span><span class="p">();</span>
                <span class="cm">/* set result to infinity or largest number */</span>
                <span class="n">Dbl_setoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* underflow case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                        <span class="cm">/*</span>
<span class="cm">                         * Adjust bias of result</span>
<span class="cm">                         */</span>
                	<span class="n">Dbl_setwrapped_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">unfl</span><span class="p">);</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span>
                                <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span> <span class="o">|</span>
					<span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
                            <span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
	    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span> <span class="o">&amp;&amp;</span> <span class="n">is_tiny</span><span class="p">)</span> <span class="n">Set_underflowflag</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="n">Dbl_set_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
	<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span> <span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
		<span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
    	<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Double Floating-point Multiply Negate Fused Add</span>
<span class="cm"> */</span>

<span class="n">dbl_fmpynfadd</span><span class="p">(</span><span class="n">src1ptr</span><span class="p">,</span><span class="n">src2ptr</span><span class="p">,</span><span class="n">src3ptr</span><span class="p">,</span><span class="n">status</span><span class="p">,</span><span class="n">dstptr</span><span class="p">)</span>

<span class="n">dbl_floating_point</span> <span class="o">*</span><span class="n">src1ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">src2ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">src3ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">dstptr</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opnd1p1</span><span class="p">,</span> <span class="n">opnd1p2</span><span class="p">,</span> <span class="n">opnd2p1</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="p">,</span> <span class="n">opnd3p1</span><span class="p">,</span> <span class="n">opnd3p2</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rightp1</span><span class="p">,</span> <span class="n">rightp2</span><span class="p">,</span> <span class="n">rightp3</span><span class="p">,</span> <span class="n">rightp4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resultp1</span><span class="p">,</span> <span class="n">resultp2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">resultp3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">resultp4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">mpy_exponent</span><span class="p">,</span> <span class="n">add_exponent</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">boolean</span> <span class="n">inexact</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">is_tiny</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">signlessleft1</span><span class="p">,</span> <span class="n">signlessright1</span><span class="p">,</span> <span class="n">save</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">result_exponent</span><span class="p">,</span> <span class="n">diff_exponent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sign_save</span><span class="p">,</span> <span class="n">jumpsize</span><span class="p">;</span>
	
	<span class="n">Dbl_copyfromptr</span><span class="p">(</span><span class="n">src1ptr</span><span class="p">,</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">);</span>
	<span class="n">Dbl_copyfromptr</span><span class="p">(</span><span class="n">src2ptr</span><span class="p">,</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">);</span>
	<span class="n">Dbl_copyfromptr</span><span class="p">(</span><span class="n">src3ptr</span><span class="p">,</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * set sign bit of result of multiply</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_sign</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Dbl_sign</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> 
		<span class="n">Dbl_setzerop1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">Dbl_setnegativezerop1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span> 

	<span class="cm">/*</span>
<span class="cm">	 * Generate multiply exponent </span>
<span class="cm">	 */</span>
	<span class="n">mpy_exponent</span> <span class="o">=</span> <span class="n">Dbl_exponent</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Dbl_exponent</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">DBL_BIAS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check first operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isnotnan</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">Dbl_isnotnan</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since operands are infinity </span>
<span class="cm">					 * and zero </span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Dbl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
					<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * Check third operand for infinity with a</span>
<span class="cm">				 *  sign opposite of the multiply result</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">Dbl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Dbl_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since attempting a magnitude</span>
<span class="cm">					 * subtraction of infinities</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Dbl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
					<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">			 	 * return infinity</span>
<span class="cm">			 	 */</span>
				<span class="n">Dbl_setinfinity_exponentmantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * is NaN; signaling or quiet?</span>
<span class="cm">		 	 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_signaling</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span> 
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is second operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_is_signalingnan</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is third operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_is_signalingnan</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * return quiet NaN</span>
<span class="cm">		 	 */</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check second operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isnotnan</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since multiply operands are</span>
<span class="cm">					 * zero &amp; infinity</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Dbl_makequietnan</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">);</span>
					<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Check third operand for infinity with a</span>
<span class="cm">				 *  sign opposite of the multiply result</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">Dbl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Dbl_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since attempting a magnitude</span>
<span class="cm">					 * subtraction of infinities</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
				       		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				       	<span class="n">Set_invalidflag</span><span class="p">();</span>
				       	<span class="n">Dbl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
					<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * return infinity</span>
<span class="cm">				 */</span>
				<span class="n">Dbl_setinfinity_exponentmantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * is NaN; signaling or quiet?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_signaling</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
					<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is third operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_is_signalingnan</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">))</span> <span class="p">{</span>
			       	<span class="cm">/* trap if INVALIDTRAP enabled */</span>
			       	<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
				   		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
			       	<span class="cm">/* make NaN quiet */</span>
			       	<span class="n">Set_invalidflag</span><span class="p">();</span>
			       	<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
		       		<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * return quiet NaN</span>
<span class="cm">			 */</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check third operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* return infinity */</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * is NaN; signaling or quiet?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_signaling</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
					<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Dbl_set_quiet</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * return quiet NaN</span>
<span class="cm"> 			 */</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
    	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate multiply mantissa</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isnotzero_exponent</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* set hidden bit */</span>
		<span class="n">Dbl_clear_signexponent_set_hidden</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Perform the add opnd3 with zero here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">Dbl_or_signs</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">Dbl_and_signs</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now let&#39;s check for trapped underflow case.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			         <span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                    		<span class="cm">/* need to normalize results mantissa */</span>
                    		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">);</span>
                    		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
                    		<span class="n">Dbl_set_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                    		<span class="n">Dbl_setwrapped_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span>
							<span class="n">unfl</span><span class="p">);</span>
                    		<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                    		<span class="cm">/* inexact = FALSE */</span>
                    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* is denormalized, adjust exponent */</span>
		<span class="n">Dbl_clear_signexponent</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">);</span>
		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">);</span>
		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">,</span><span class="n">mpy_exponent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* opnd2 needs to have hidden bit set with msb in hidden bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isnotzero_exponent</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">Dbl_clear_signexponent_set_hidden</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Perform the add opnd3 with zero here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">Dbl_or_signs</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">Dbl_and_signs</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now let&#39;s check for trapped underflow case.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                    		<span class="cm">/* need to normalize results mantissa */</span>
                    		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">);</span>
                    		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
                    		<span class="n">Dbl_set_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                    		<span class="n">Dbl_setwrapped_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span>
							<span class="n">unfl</span><span class="p">);</span>
                    		<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                    		<span class="cm">/* inexact = FALSE */</span>
                    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* is denormalized; want to normalize */</span>
		<span class="n">Dbl_clear_signexponent</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">);</span>
		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">);</span>
		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd2p1</span><span class="p">,</span><span class="n">opnd2p2</span><span class="p">,</span><span class="n">mpy_exponent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Multiply the first two source mantissas together */</span>

	<span class="cm">/* </span>
<span class="cm">	 * The intermediate result will be kept in tmpres,</span>
<span class="cm">	 * which needs enough room for 106 bits of mantissa,</span>
<span class="cm">	 * so lets call it a Double extended.</span>
<span class="cm">	 */</span>
	<span class="n">Dblext_setzero</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * Four bits at a time are inspected in each loop, and a </span>
<span class="cm">	 * simple shift and add multiply algorithm is used. </span>
<span class="cm">	 */</span> 
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="n">DBL_P</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Dblext_rightshiftby4</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbit28p2</span><span class="p">(</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
	 		<span class="cm">/* Fourword_add should be an ADD followed by 3 ADDC&#39;s */</span>
			<span class="n">Fourword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">,</span> 
			 <span class="n">opnd2p1</span><span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="o">|</span> <span class="n">opnd2p2</span><span class="o">&gt;&gt;</span><span class="mi">29</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbit29p2</span><span class="p">(</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Fourword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">,</span>
			 <span class="n">opnd2p1</span><span class="o">&lt;&lt;</span><span class="mi">2</span> <span class="o">|</span> <span class="n">opnd2p2</span><span class="o">&gt;&gt;</span><span class="mi">30</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbit30p2</span><span class="p">(</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Fourword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">,</span>
			 <span class="n">opnd2p1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="o">|</span> <span class="n">opnd2p2</span><span class="o">&gt;&gt;</span><span class="mi">31</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbit31p2</span><span class="p">(</span><span class="n">opnd1p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Fourword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">tmpresp3</span><span class="p">,</span> <span class="n">tmpresp4</span><span class="p">,</span>
			 <span class="n">opnd2p1</span><span class="p">,</span> <span class="n">opnd2p2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">Dbl_rightshiftby4</span><span class="p">(</span><span class="n">opnd1p1</span><span class="p">,</span><span class="n">opnd1p2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Is_dexthiddenoverflow</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* result mantissa &gt;= 2 (mantissa overflow) */</span>
		<span class="n">mpy_exponent</span><span class="o">++</span><span class="p">;</span>
		<span class="n">Dblext_rightshiftby1</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the sign of the mpy result which was saved in resultp1.</span>
<span class="cm">	 * The exponent will continue to be kept in mpy_exponent.</span>
<span class="cm">	 */</span>
	<span class="n">Dblext_set_sign</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">Dbl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * No rounding is required, since the result of the multiply</span>
<span class="cm">	 * is exact in the extended format.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we are ready to perform the add portion of the operation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The exponents need to be kept as integers for now, since the</span>
<span class="cm">	 * multiply result might not fit into the exponent field.  We</span>
<span class="cm">	 * can&#39;t overflow or underflow because of this yet, since the</span>
<span class="cm">	 * add could bring the final result back into range.</span>
<span class="cm">	 */</span>
	<span class="n">add_exponent</span> <span class="o">=</span> <span class="n">Dbl_exponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for denormalized or zero add operand.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">add_exponent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* right is zero */</span>
			<span class="cm">/* Left can&#39;t be zero and must be result.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The final result is now in tmpres and mpy_exponent,</span>
<span class="cm">			 * and needs to be rounded and squeezed back into</span>
<span class="cm">			 * double precision format from double extended.</span>
<span class="cm">			 */</span>
			<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span><span class="p">;</span>
			<span class="n">Dblext_copy</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">,</span>
				<span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
			<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span><span class="cm">/*save sign*/</span>
			<span class="k">goto</span> <span class="n">round</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* </span>
<span class="cm">		 * Neither are zeroes.  </span>
<span class="cm">		 * Adjust exponent and normalize add operand.</span>
<span class="cm">		 */</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>	<span class="cm">/* save sign */</span>
		<span class="n">Dbl_clear_signexponent</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
		<span class="n">Dbl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">);</span>
		<span class="n">Dbl_normalize</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">add_exponent</span><span class="p">);</span>
		<span class="n">Dbl_set_sign</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">sign_save</span><span class="p">);</span>	<span class="cm">/* restore sign */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">Dbl_clear_exponent_set_hidden</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy opnd3 to the double extended variable called right.</span>
<span class="cm">	 */</span>
	<span class="n">Dbl_copyto_dblext</span><span class="p">(</span><span class="n">opnd3p1</span><span class="p">,</span><span class="n">opnd3p2</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A zero &quot;save&quot; helps discover equal operands (for later),</span>
<span class="cm">	 * and is used in swapping operands (if needed).</span>
<span class="cm">	 */</span>
	<span class="n">Dblext_xortointp1</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">save</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compare magnitude of operands.</span>
<span class="cm">	 */</span>
	<span class="n">Dblext_copytoint_exponentmantissap1</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">signlessleft1</span><span class="p">);</span>
	<span class="n">Dblext_copytoint_exponentmantissap1</span><span class="p">(</span><span class="n">rightp1</span><span class="p">,</span><span class="n">signlessright1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpy_exponent</span> <span class="o">&lt;</span> <span class="n">add_exponent</span> <span class="o">||</span> <span class="n">mpy_exponent</span> <span class="o">==</span> <span class="n">add_exponent</span> <span class="o">&amp;&amp;</span>
	    <span class="n">Dblext_ismagnitudeless</span><span class="p">(</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">signlessleft1</span><span class="p">,</span><span class="n">signlessright1</span><span class="p">)){</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the left operand to the larger one by XOR swap.</span>
<span class="cm">		 * First finish the first word &quot;save&quot;.</span>
<span class="cm">		 */</span>
		<span class="n">Dblext_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">rightp1</span><span class="p">);</span>
		<span class="n">Dblext_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">tmpresp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">tmpresp1</span><span class="p">);</span>
		<span class="n">Dblext_swap_lower</span><span class="p">(</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">,</span>
			<span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">);</span>
		<span class="cm">/* also setup exponents used in rest of routine */</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">add_exponent</span> <span class="o">-</span> <span class="n">mpy_exponent</span><span class="p">;</span>
		<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">add_exponent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* also setup exponents used in rest of routine */</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span> <span class="o">-</span> <span class="n">add_exponent</span><span class="p">;</span>
		<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Invariant: left is not smaller than right. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Special case alignment of operands that would force alignment</span>
<span class="cm">	 * beyond the extent of the extension.  A further optimization</span>
<span class="cm">	 * could special case this but only reduces the path length for</span>
<span class="cm">	 * this infrequent case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff_exponent</span> <span class="o">&gt;</span> <span class="n">DBLEXT_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">DBLEXT_THRESHOLD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Align right operand by shifting it to the right */</span>
	<span class="n">Dblext_clear_sign</span><span class="p">(</span><span class="n">rightp1</span><span class="p">);</span>
	<span class="n">Dblext_right_align</span><span class="p">(</span><span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">,</span>
		<span class="cm">/*shifted by*/</span><span class="n">diff_exponent</span><span class="p">);</span>
	
	<span class="cm">/* Treat sum and difference of the operands separately. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">save</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Difference of the two operands.  Overflow can occur if the</span>
<span class="cm">		 * multiply overflowed.  A borrow can occur out of the hidden</span>
<span class="cm">		 * bit and force a post normalization phase.</span>
<span class="cm">		 */</span>
		<span class="n">Dblext_subtract</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">,</span>
			<span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">,</span>
			<span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_hidden</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Handle normalization */</span>
		<span class="cm">/* A straightforward algorithm would now shift the</span>
<span class="cm">		 * result and extension left until the hidden bit</span>
<span class="cm">		 * becomes one.  Not all of the extension bits need</span>
<span class="cm">		 * participate in the shift.  Only the two most </span>
<span class="cm">		 * significant bits (round and guard) are needed.</span>
<span class="cm">		 * If only a single shift is needed then the guard</span>
<span class="cm">		 * bit becomes a significant low order bit and the</span>
<span class="cm">		 * extension must participate in the rounding.</span>
<span class="cm">		 * If more than a single shift is needed, then all</span>
<span class="cm">		 * bits to the right of the guard bit are zeros, </span>
<span class="cm">		 * and the guard bit may or may not be zero. */</span>
			<span class="n">Dblext_leftshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
				<span class="n">resultp4</span><span class="p">);</span>

			<span class="cm">/* Need to check for a zero result.  The sign and</span>
<span class="cm">			 * exponent fields have already been zeroed.  The more</span>
<span class="cm">			 * efficient test of the full object can be used.</span>
<span class="cm">			 */</span>
			 <span class="k">if</span> <span class="p">(</span><span class="n">Dblext_iszero</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Must have been &quot;x-x&quot; or &quot;x+(-x)&quot;. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span>
					<span class="n">Dbl_setone_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">result_exponent</span><span class="o">--</span><span class="p">;</span>

			<span class="cm">/* Look to see if normalization is finished. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_hidden</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* No further normalization is needed */</span>
				<span class="k">goto</span> <span class="n">round</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Discover first one bit to determine shift amount.</span>
<span class="cm">			 * Use a modified binary search.  We have already</span>
<span class="cm">			 * shifted the result one position right and still</span>
<span class="cm">			 * not found a one so the remainder of the extension</span>
<span class="cm">			 * must be zero and simplifies rounding. */</span>
			<span class="cm">/* Scan bytes */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">Dbl_iszero_hiddenhigh7mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">Dblext_leftshiftby8</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Now narrow it down to the nibble */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* The lower nibble contains the</span>
<span class="cm">				 * normalizing one */</span>
				<span class="n">Dblext_leftshiftby4</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Select case where first bit is set (already</span>
<span class="cm">			 * normalized) otherwise select the proper shift. */</span>
			<span class="n">jumpsize</span> <span class="o">=</span> <span class="n">Dbl_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jumpsize</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">)</span> <span class="k">switch</span><span class="p">(</span><span class="n">jumpsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">Dblext_leftshiftby3</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
					<span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">Dblext_leftshiftby2</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
					<span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">4</span>:
			<span class="k">case</span> <span class="mi">5</span>:
			<span class="k">case</span> <span class="mi">6</span>:
			<span class="k">case</span> <span class="mi">7</span>:
				<span class="n">Dblext_leftshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
					<span class="n">resultp4</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="cm">/* end if (hidden...)... */</span>
	<span class="cm">/* Fall through and round */</span>
	<span class="p">}</span> <span class="cm">/* end if (save &lt; 0)... */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Add magnitudes */</span>
		<span class="n">Dblext_addition</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">tmpresp3</span><span class="p">,</span><span class="n">tmpresp4</span><span class="p">,</span>
			<span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="n">rightp3</span><span class="p">,</span><span class="n">rightp4</span><span class="p">,</span>
			<span class="cm">/*to*/</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">);</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Dbl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
	    		<span class="cm">/* Prenormalization required. */</span>
	    		<span class="n">Dblext_arithrightshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span>
				<span class="n">resultp4</span><span class="p">);</span>
	    		<span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* end if hiddenoverflow... */</span>
	<span class="p">}</span> <span class="cm">/* end else ...add magnitudes... */</span>

	<span class="cm">/* Round the result.  If the extension and lower two words are</span>
<span class="cm">	 * all zeros, then the result is exact.  Otherwise round in the</span>
<span class="cm">	 * correct direction.  Underflow is possible. If a postnormalization</span>
<span class="cm">	 * is necessary, then the mantissa is all zeros so no shift is needed.</span>
<span class="cm">	 */</span>
  <span class="nl">round:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">Dblext_denormalize</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">resultp3</span><span class="p">,</span><span class="n">resultp4</span><span class="p">,</span>
			<span class="n">result_exponent</span><span class="p">,</span><span class="n">is_tiny</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">Dbl_set_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Dblext_isnotzero_mantissap3</span><span class="p">(</span><span class="n">resultp3</span><span class="p">)</span> <span class="o">||</span> 
	    <span class="n">Dblext_isnotzero_mantissap4</span><span class="p">(</span><span class="n">resultp4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">Rounding_mode</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ROUNDNEAREST</span>: <span class="cm">/* The default. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dblext_isone_highp3</span><span class="p">(</span><span class="n">resultp3</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* at least 1/2 ulp */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Dblext_isnotzero_low31p3</span><span class="p">(</span><span class="n">resultp3</span><span class="p">)</span> <span class="o">||</span>
				    <span class="n">Dblext_isnotzero_mantissap4</span><span class="p">(</span><span class="n">resultp4</span><span class="p">)</span> <span class="o">||</span>
				    <span class="n">Dblext_isone_lowp2</span><span class="p">(</span><span class="n">resultp2</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* either exactly half way and odd or</span>
<span class="cm">					 * more than 1/2ulp */</span>
					<span class="n">Dbl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
	    		<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ROUNDPLUS</span>:
	    		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_iszero_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Round up positive results */</span>
				<span class="n">Dbl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
	    
		<span class="k">case</span> <span class="n">ROUNDMINUS</span>:
	    		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Round down negative results */</span>
				<span class="n">Dbl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
			<span class="p">}</span>
	    
		<span class="k">case</span> <span class="n">ROUNDZERO</span>:<span class="p">;</span>
			<span class="cm">/* truncate is simple */</span>
		<span class="p">}</span> <span class="cm">/* end switch... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Dbl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&gt;=</span> <span class="n">DBL_INFINITY_EXPONENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Overflow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_overflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                        <span class="cm">/*</span>
<span class="cm">                         * Adjust bias of result</span>
<span class="cm">                         */</span>
                        <span class="n">Dbl_setwrapped_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">ovfl</span><span class="p">);</span>
                        <span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span>
                                <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_OVERFLOWEXCEPTION</span> <span class="o">|</span>
					<span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
                            <span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_OVERFLOWEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">Set_overflowflag</span><span class="p">();</span>
		<span class="n">Dbl_setoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* underflow case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                        <span class="cm">/*</span>
<span class="cm">                         * Adjust bias of result</span>
<span class="cm">                         */</span>
                	<span class="n">Dbl_setwrapped_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">unfl</span><span class="p">);</span>
			<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span>
                                <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span> <span class="o">|</span>
					<span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
                            <span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
	    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span> <span class="o">&amp;&amp;</span> <span class="n">is_tiny</span><span class="p">)</span> <span class="n">Set_underflowflag</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="n">Dbl_set_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
	<span class="n">Dbl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span> <span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
		<span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
    	<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Single Floating-point Multiply Fused Add</span>
<span class="cm"> */</span>

<span class="n">sgl_fmpyfadd</span><span class="p">(</span><span class="n">src1ptr</span><span class="p">,</span><span class="n">src2ptr</span><span class="p">,</span><span class="n">src3ptr</span><span class="p">,</span><span class="n">status</span><span class="p">,</span><span class="n">dstptr</span><span class="p">)</span>

<span class="n">sgl_floating_point</span> <span class="o">*</span><span class="n">src1ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">src2ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">src3ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">dstptr</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opnd1</span><span class="p">,</span> <span class="n">opnd2</span><span class="p">,</span> <span class="n">opnd3</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rightp1</span><span class="p">,</span> <span class="n">rightp2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resultp1</span><span class="p">,</span> <span class="n">resultp2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">mpy_exponent</span><span class="p">,</span> <span class="n">add_exponent</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">boolean</span> <span class="n">inexact</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">is_tiny</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">signlessleft1</span><span class="p">,</span> <span class="n">signlessright1</span><span class="p">,</span> <span class="n">save</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">result_exponent</span><span class="p">,</span> <span class="n">diff_exponent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sign_save</span><span class="p">,</span> <span class="n">jumpsize</span><span class="p">;</span>
	
	<span class="n">Sgl_copyfromptr</span><span class="p">(</span><span class="n">src1ptr</span><span class="p">,</span><span class="n">opnd1</span><span class="p">);</span>
	<span class="n">Sgl_copyfromptr</span><span class="p">(</span><span class="n">src2ptr</span><span class="p">,</span><span class="n">opnd2</span><span class="p">);</span>
	<span class="n">Sgl_copyfromptr</span><span class="p">(</span><span class="n">src3ptr</span><span class="p">,</span><span class="n">opnd3</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * set sign bit of result of multiply</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_sign</span><span class="p">(</span><span class="n">opnd1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Sgl_sign</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> 
		<span class="n">Sgl_setnegativezero</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span> 
	<span class="k">else</span> <span class="n">Sgl_setzero</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate multiply exponent </span>
<span class="cm">	 */</span>
	<span class="n">mpy_exponent</span> <span class="o">=</span> <span class="n">Sgl_exponent</span><span class="p">(</span><span class="n">opnd1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Sgl_exponent</span><span class="p">(</span><span class="n">opnd2</span><span class="p">)</span> <span class="o">-</span> <span class="n">SGL_BIAS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check first operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isnotnan</span><span class="p">(</span><span class="n">opnd2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Sgl_isnotnan</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since operands are infinity </span>
<span class="cm">					 * and zero </span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Sgl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
					<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * Check third operand for infinity with a</span>
<span class="cm">				 *  sign opposite of the multiply result</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">Sgl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Sgl_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since attempting a magnitude</span>
<span class="cm">					 * subtraction of infinities</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Sgl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
					<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">			 	 * return infinity</span>
<span class="cm">			 	 */</span>
				<span class="n">Sgl_setinfinity_exponentmantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * is NaN; signaling or quiet?</span>
<span class="cm">		 	 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_signaling</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span> 
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is second operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_is_signalingnan</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is third operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_is_signalingnan</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * return quiet NaN</span>
<span class="cm">		 	 */</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check second operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isnotnan</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since multiply operands are</span>
<span class="cm">					 * zero &amp; infinity</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Sgl_makequietnan</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
					<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Check third operand for infinity with a</span>
<span class="cm">				 *  sign opposite of the multiply result</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">Sgl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Sgl_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since attempting a magnitude</span>
<span class="cm">					 * subtraction of infinities</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
				       		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				       	<span class="n">Set_invalidflag</span><span class="p">();</span>
				       	<span class="n">Sgl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
					<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * return infinity</span>
<span class="cm">				 */</span>
				<span class="n">Sgl_setinfinity_exponentmantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * is NaN; signaling or quiet?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_signaling</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
					<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is third operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_is_signalingnan</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
			       	<span class="cm">/* trap if INVALIDTRAP enabled */</span>
			       	<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
				   		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
			       	<span class="cm">/* make NaN quiet */</span>
			       	<span class="n">Set_invalidflag</span><span class="p">();</span>
			       	<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
		       		<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * return quiet NaN</span>
<span class="cm">			 */</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check third operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* return infinity */</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * is NaN; signaling or quiet?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_signaling</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
					<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * return quiet NaN</span>
<span class="cm"> 			 */</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
    	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate multiply mantissa</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isnotzero_exponent</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* set hidden bit */</span>
		<span class="n">Sgl_clear_signexponent_set_hidden</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Perform the add opnd3 with zero here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">Sgl_or_signs</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">Sgl_and_signs</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now let&#39;s check for trapped underflow case.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			         <span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                    		<span class="cm">/* need to normalize results mantissa */</span>
                    		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
                    		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
                    		<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                    		<span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span>
							<span class="n">unfl</span><span class="p">);</span>
                    		<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                    		<span class="cm">/* inexact = FALSE */</span>
                    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* is denormalized, adjust exponent */</span>
		<span class="n">Sgl_clear_signexponent</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd1</span><span class="p">,</span><span class="n">mpy_exponent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* opnd2 needs to have hidden bit set with msb in hidden bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isnotzero_exponent</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">Sgl_clear_signexponent_set_hidden</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Perform the add opnd3 with zero here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">Sgl_or_signs</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">Sgl_and_signs</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now let&#39;s check for trapped underflow case.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                    		<span class="cm">/* need to normalize results mantissa */</span>
                    		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
                    		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
                    		<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                    		<span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span>
							<span class="n">unfl</span><span class="p">);</span>
                    		<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                    		<span class="cm">/* inexact = FALSE */</span>
                    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* is denormalized; want to normalize */</span>
		<span class="n">Sgl_clear_signexponent</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd2</span><span class="p">,</span><span class="n">mpy_exponent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Multiply the first two source mantissas together */</span>

	<span class="cm">/* </span>
<span class="cm">	 * The intermediate result will be kept in tmpres,</span>
<span class="cm">	 * which needs enough room for 106 bits of mantissa,</span>
<span class="cm">	 * so lets call it a Double extended.</span>
<span class="cm">	 */</span>
	<span class="n">Sglext_setzero</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * Four bits at a time are inspected in each loop, and a </span>
<span class="cm">	 * simple shift and add multiply algorithm is used. </span>
<span class="cm">	 */</span> 
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="n">SGL_P</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Sglext_rightshiftby4</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sbit28</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
	 		<span class="cm">/* Twoword_add should be an ADD followed by 2 ADDC&#39;s */</span>
			<span class="n">Twoword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">opnd2</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sbit29</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Twoword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">opnd2</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sbit30</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Twoword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">opnd2</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sbit31</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Twoword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">opnd2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">Sgl_rightshiftby4</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Is_sexthiddenoverflow</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* result mantissa &gt;= 2 (mantissa overflow) */</span>
		<span class="n">mpy_exponent</span><span class="o">++</span><span class="p">;</span>
		<span class="n">Sglext_rightshiftby4</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">Sglext_rightshiftby3</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the sign of the mpy result which was saved in resultp1.</span>
<span class="cm">	 * The exponent will continue to be kept in mpy_exponent.</span>
<span class="cm">	 */</span>
	<span class="n">Sglext_set_sign</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">Sgl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * No rounding is required, since the result of the multiply</span>
<span class="cm">	 * is exact in the extended format.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we are ready to perform the add portion of the operation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The exponents need to be kept as integers for now, since the</span>
<span class="cm">	 * multiply result might not fit into the exponent field.  We</span>
<span class="cm">	 * can&#39;t overflow or underflow because of this yet, since the</span>
<span class="cm">	 * add could bring the final result back into range.</span>
<span class="cm">	 */</span>
	<span class="n">add_exponent</span> <span class="o">=</span> <span class="n">Sgl_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for denormalized or zero add operand.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">add_exponent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* right is zero */</span>
			<span class="cm">/* Left can&#39;t be zero and must be result.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The final result is now in tmpres and mpy_exponent,</span>
<span class="cm">			 * and needs to be rounded and squeezed back into</span>
<span class="cm">			 * double precision format from double extended.</span>
<span class="cm">			 */</span>
			<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span><span class="p">;</span>
			<span class="n">Sglext_copy</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
			<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span><span class="cm">/*save sign*/</span>
			<span class="k">goto</span> <span class="n">round</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* </span>
<span class="cm">		 * Neither are zeroes.  </span>
<span class="cm">		 * Adjust exponent and normalize add operand.</span>
<span class="cm">		 */</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>	<span class="cm">/* save sign */</span>
		<span class="n">Sgl_clear_signexponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">add_exponent</span><span class="p">);</span>
		<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">sign_save</span><span class="p">);</span>		<span class="cm">/* restore sign */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">Sgl_clear_exponent_set_hidden</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy opnd3 to the double extended variable called right.</span>
<span class="cm">	 */</span>
	<span class="n">Sgl_copyto_sglext</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A zero &quot;save&quot; helps discover equal operands (for later),</span>
<span class="cm">	 * and is used in swapping operands (if needed).</span>
<span class="cm">	 */</span>
	<span class="n">Sglext_xortointp1</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">save</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compare magnitude of operands.</span>
<span class="cm">	 */</span>
	<span class="n">Sglext_copytoint_exponentmantissa</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">signlessleft1</span><span class="p">);</span>
	<span class="n">Sglext_copytoint_exponentmantissa</span><span class="p">(</span><span class="n">rightp1</span><span class="p">,</span><span class="n">signlessright1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpy_exponent</span> <span class="o">&lt;</span> <span class="n">add_exponent</span> <span class="o">||</span> <span class="n">mpy_exponent</span> <span class="o">==</span> <span class="n">add_exponent</span> <span class="o">&amp;&amp;</span>
	    <span class="n">Sglext_ismagnitudeless</span><span class="p">(</span><span class="n">signlessleft1</span><span class="p">,</span><span class="n">signlessright1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the left operand to the larger one by XOR swap.</span>
<span class="cm">		 * First finish the first word &quot;save&quot;.</span>
<span class="cm">		 */</span>
		<span class="n">Sglext_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">rightp1</span><span class="p">);</span>
		<span class="n">Sglext_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">tmpresp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">tmpresp1</span><span class="p">);</span>
		<span class="n">Sglext_swap_lower</span><span class="p">(</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">rightp2</span><span class="p">);</span>
		<span class="cm">/* also setup exponents used in rest of routine */</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">add_exponent</span> <span class="o">-</span> <span class="n">mpy_exponent</span><span class="p">;</span>
		<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">add_exponent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* also setup exponents used in rest of routine */</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span> <span class="o">-</span> <span class="n">add_exponent</span><span class="p">;</span>
		<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Invariant: left is not smaller than right. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Special case alignment of operands that would force alignment</span>
<span class="cm">	 * beyond the extent of the extension.  A further optimization</span>
<span class="cm">	 * could special case this but only reduces the path length for</span>
<span class="cm">	 * this infrequent case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff_exponent</span> <span class="o">&gt;</span> <span class="n">SGLEXT_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">SGLEXT_THRESHOLD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Align right operand by shifting it to the right */</span>
	<span class="n">Sglext_clear_sign</span><span class="p">(</span><span class="n">rightp1</span><span class="p">);</span>
	<span class="n">Sglext_right_align</span><span class="p">(</span><span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="cm">/*shifted by*/</span><span class="n">diff_exponent</span><span class="p">);</span>
	
	<span class="cm">/* Treat sum and difference of the operands separately. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">save</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Difference of the two operands.  Overflow can occur if the</span>
<span class="cm">		 * multiply overflowed.  A borrow can occur out of the hidden</span>
<span class="cm">		 * bit and force a post normalization phase.</span>
<span class="cm">		 */</span>
		<span class="n">Sglext_subtract</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span> <span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span>
			<span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_hidden</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Handle normalization */</span>
		<span class="cm">/* A straightforward algorithm would now shift the</span>
<span class="cm">		 * result and extension left until the hidden bit</span>
<span class="cm">		 * becomes one.  Not all of the extension bits need</span>
<span class="cm">		 * participate in the shift.  Only the two most </span>
<span class="cm">		 * significant bits (round and guard) are needed.</span>
<span class="cm">		 * If only a single shift is needed then the guard</span>
<span class="cm">		 * bit becomes a significant low order bit and the</span>
<span class="cm">		 * extension must participate in the rounding.</span>
<span class="cm">		 * If more than a single shift is needed, then all</span>
<span class="cm">		 * bits to the right of the guard bit are zeros, </span>
<span class="cm">		 * and the guard bit may or may not be zero. */</span>
			<span class="n">Sglext_leftshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>

			<span class="cm">/* Need to check for a zero result.  The sign and</span>
<span class="cm">			 * exponent fields have already been zeroed.  The more</span>
<span class="cm">			 * efficient test of the full object can be used.</span>
<span class="cm">			 */</span>
			 <span class="k">if</span> <span class="p">(</span><span class="n">Sglext_iszero</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Must have been &quot;x-x&quot; or &quot;x+(-x)&quot;. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span>
					<span class="n">Sgl_setone_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">result_exponent</span><span class="o">--</span><span class="p">;</span>

			<span class="cm">/* Look to see if normalization is finished. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_hidden</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* No further normalization is needed */</span>
				<span class="k">goto</span> <span class="n">round</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Discover first one bit to determine shift amount.</span>
<span class="cm">			 * Use a modified binary search.  We have already</span>
<span class="cm">			 * shifted the result one position right and still</span>
<span class="cm">			 * not found a one so the remainder of the extension</span>
<span class="cm">			 * must be zero and simplifies rounding. */</span>
			<span class="cm">/* Scan bytes */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">Sgl_iszero_hiddenhigh7mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">Sglext_leftshiftby8</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Now narrow it down to the nibble */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* The lower nibble contains the</span>
<span class="cm">				 * normalizing one */</span>
				<span class="n">Sglext_leftshiftby4</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Select case where first bit is set (already</span>
<span class="cm">			 * normalized) otherwise select the proper shift. */</span>
			<span class="n">jumpsize</span> <span class="o">=</span> <span class="n">Sgl_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jumpsize</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">)</span> <span class="k">switch</span><span class="p">(</span><span class="n">jumpsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">Sglext_leftshiftby3</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">Sglext_leftshiftby2</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">4</span>:
			<span class="k">case</span> <span class="mi">5</span>:
			<span class="k">case</span> <span class="mi">6</span>:
			<span class="k">case</span> <span class="mi">7</span>:
				<span class="n">Sglext_leftshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="cm">/* end if (hidden...)... */</span>
	<span class="cm">/* Fall through and round */</span>
	<span class="p">}</span> <span class="cm">/* end if (save &lt; 0)... */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Add magnitudes */</span>
		<span class="n">Sglext_addition</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span>
			<span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span> <span class="cm">/*to*/</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
	    		<span class="cm">/* Prenormalization required. */</span>
	    		<span class="n">Sglext_arithrightshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
	    		<span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* end if hiddenoverflow... */</span>
	<span class="p">}</span> <span class="cm">/* end else ...add magnitudes... */</span>

	<span class="cm">/* Round the result.  If the extension and lower two words are</span>
<span class="cm">	 * all zeros, then the result is exact.  Otherwise round in the</span>
<span class="cm">	 * correct direction.  Underflow is possible. If a postnormalization</span>
<span class="cm">	 * is necessary, then the mantissa is all zeros so no shift is needed.</span>
<span class="cm">	 */</span>
  <span class="nl">round:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">Sglext_denormalize</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">is_tiny</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sglext_isnotzero_mantissap2</span><span class="p">(</span><span class="n">resultp2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">Rounding_mode</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ROUNDNEAREST</span>: <span class="cm">/* The default. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sglext_isone_highp2</span><span class="p">(</span><span class="n">resultp2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* at least 1/2 ulp */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sglext_isnotzero_low31p2</span><span class="p">(</span><span class="n">resultp2</span><span class="p">)</span> <span class="o">||</span>
				    <span class="n">Sglext_isone_lowp1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* either exactly half way and odd or</span>
<span class="cm">					 * more than 1/2ulp */</span>
					<span class="n">Sgl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
	    		<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ROUNDPLUS</span>:
	    		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Round up positive results */</span>
				<span class="n">Sgl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
	    
		<span class="k">case</span> <span class="n">ROUNDMINUS</span>:
	    		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Round down negative results */</span>
				<span class="n">Sgl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
			<span class="p">}</span>
	    
		<span class="k">case</span> <span class="n">ROUNDZERO</span>:<span class="p">;</span>
			<span class="cm">/* truncate is simple */</span>
		<span class="p">}</span> <span class="cm">/* end switch... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&gt;=</span> <span class="n">SGL_INFINITY_EXPONENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Overflow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_overflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                        <span class="cm">/*</span>
<span class="cm">                         * Adjust bias of result</span>
<span class="cm">                         */</span>
                        <span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">ovfl</span><span class="p">);</span>
                        <span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span>
                                <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_OVERFLOWEXCEPTION</span> <span class="o">|</span>
					<span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
                            <span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_OVERFLOWEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">Set_overflowflag</span><span class="p">();</span>
		<span class="n">Sgl_setoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* underflow case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                        <span class="cm">/*</span>
<span class="cm">                         * Adjust bias of result</span>
<span class="cm">                         */</span>
                	<span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">unfl</span><span class="p">);</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span>
                                <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span> <span class="o">|</span>
					<span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
                            <span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
	    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span> <span class="o">&amp;&amp;</span> <span class="n">is_tiny</span><span class="p">)</span> <span class="n">Set_underflowflag</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="n">Sgl_set_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
	<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span> <span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
		<span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
    	<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Single Floating-point Multiply Negate Fused Add</span>
<span class="cm"> */</span>

<span class="n">sgl_fmpynfadd</span><span class="p">(</span><span class="n">src1ptr</span><span class="p">,</span><span class="n">src2ptr</span><span class="p">,</span><span class="n">src3ptr</span><span class="p">,</span><span class="n">status</span><span class="p">,</span><span class="n">dstptr</span><span class="p">)</span>

<span class="n">sgl_floating_point</span> <span class="o">*</span><span class="n">src1ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">src2ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">src3ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">dstptr</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opnd1</span><span class="p">,</span> <span class="n">opnd2</span><span class="p">,</span> <span class="n">opnd3</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rightp1</span><span class="p">,</span> <span class="n">rightp2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resultp1</span><span class="p">,</span> <span class="n">resultp2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">mpy_exponent</span><span class="p">,</span> <span class="n">add_exponent</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">boolean</span> <span class="n">inexact</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">is_tiny</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">signlessleft1</span><span class="p">,</span> <span class="n">signlessright1</span><span class="p">,</span> <span class="n">save</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">result_exponent</span><span class="p">,</span> <span class="n">diff_exponent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sign_save</span><span class="p">,</span> <span class="n">jumpsize</span><span class="p">;</span>
	
	<span class="n">Sgl_copyfromptr</span><span class="p">(</span><span class="n">src1ptr</span><span class="p">,</span><span class="n">opnd1</span><span class="p">);</span>
	<span class="n">Sgl_copyfromptr</span><span class="p">(</span><span class="n">src2ptr</span><span class="p">,</span><span class="n">opnd2</span><span class="p">);</span>
	<span class="n">Sgl_copyfromptr</span><span class="p">(</span><span class="n">src3ptr</span><span class="p">,</span><span class="n">opnd3</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * set sign bit of result of multiply</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_sign</span><span class="p">(</span><span class="n">opnd1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Sgl_sign</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> 
		<span class="n">Sgl_setzero</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
	<span class="k">else</span> 
		<span class="n">Sgl_setnegativezero</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span> 

	<span class="cm">/*</span>
<span class="cm">	 * Generate multiply exponent </span>
<span class="cm">	 */</span>
	<span class="n">mpy_exponent</span> <span class="o">=</span> <span class="n">Sgl_exponent</span><span class="p">(</span><span class="n">opnd1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Sgl_exponent</span><span class="p">(</span><span class="n">opnd2</span><span class="p">)</span> <span class="o">-</span> <span class="n">SGL_BIAS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check first operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isnotnan</span><span class="p">(</span><span class="n">opnd2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Sgl_isnotnan</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since operands are infinity </span>
<span class="cm">					 * and zero </span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Sgl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
					<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * Check third operand for infinity with a</span>
<span class="cm">				 *  sign opposite of the multiply result</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">Sgl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Sgl_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since attempting a magnitude</span>
<span class="cm">					 * subtraction of infinities</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Sgl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
					<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">			 	 * return infinity</span>
<span class="cm">			 	 */</span>
				<span class="n">Sgl_setinfinity_exponentmantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * is NaN; signaling or quiet?</span>
<span class="cm">		 	 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_signaling</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span> 
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is second operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_is_signalingnan</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is third operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_is_signalingnan</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
			    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * return quiet NaN</span>
<span class="cm">		 	 */</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check second operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isnotnan</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since multiply operands are</span>
<span class="cm">					 * zero &amp; infinity</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
						<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
					<span class="n">Set_invalidflag</span><span class="p">();</span>
					<span class="n">Sgl_makequietnan</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
					<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Check third operand for infinity with a</span>
<span class="cm">				 *  sign opposite of the multiply result</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">Sgl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Sgl_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* </span>
<span class="cm">					 * invalid since attempting a magnitude</span>
<span class="cm">					 * subtraction of infinities</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
				       		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				       	<span class="n">Set_invalidflag</span><span class="p">();</span>
				       	<span class="n">Sgl_makequietnan</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
					<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
					<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * return infinity</span>
<span class="cm">				 */</span>
				<span class="n">Sgl_setinfinity_exponentmantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * is NaN; signaling or quiet?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_signaling</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
					<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* </span>
<span class="cm">			 * is third operand a signaling NaN? </span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_is_signalingnan</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
			       	<span class="cm">/* trap if INVALIDTRAP enabled */</span>
			       	<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
				   		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
			       	<span class="cm">/* make NaN quiet */</span>
			       	<span class="n">Set_invalidflag</span><span class="p">();</span>
			       	<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
		       		<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * return quiet NaN</span>
<span class="cm">			 */</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd2</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check third operand for NaN&#39;s or infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* return infinity */</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * is NaN; signaling or quiet?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_signaling</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* trap if INVALIDTRAP enabled */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span>
					<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INVALIDEXCEPTION</span><span class="p">);</span>
				<span class="cm">/* make NaN quiet */</span>
				<span class="n">Set_invalidflag</span><span class="p">();</span>
				<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * return quiet NaN</span>
<span class="cm"> 			 */</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
    	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate multiply mantissa</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isnotzero_exponent</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* set hidden bit */</span>
		<span class="n">Sgl_clear_signexponent_set_hidden</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Perform the add opnd3 with zero here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">Sgl_or_signs</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">Sgl_and_signs</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now let&#39;s check for trapped underflow case.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			         <span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                    		<span class="cm">/* need to normalize results mantissa */</span>
                    		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
                    		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
                    		<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                    		<span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span>
							<span class="n">unfl</span><span class="p">);</span>
                    		<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                    		<span class="cm">/* inexact = FALSE */</span>
                    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* is denormalized, adjust exponent */</span>
		<span class="n">Sgl_clear_signexponent</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd1</span><span class="p">,</span><span class="n">mpy_exponent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* opnd2 needs to have hidden bit set with msb in hidden bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isnotzero_exponent</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">Sgl_clear_signexponent_set_hidden</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Perform the add opnd3 with zero here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">Sgl_or_signs</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">Sgl_and_signs</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now let&#39;s check for trapped underflow case.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                    		<span class="cm">/* need to normalize results mantissa */</span>
                    		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
                    		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
                    		<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                    		<span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span>
							<span class="n">unfl</span><span class="p">);</span>
                    		<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                    		<span class="cm">/* inexact = FALSE */</span>
                    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* is denormalized; want to normalize */</span>
		<span class="n">Sgl_clear_signexponent</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd2</span><span class="p">);</span>
		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd2</span><span class="p">,</span><span class="n">mpy_exponent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Multiply the first two source mantissas together */</span>

	<span class="cm">/* </span>
<span class="cm">	 * The intermediate result will be kept in tmpres,</span>
<span class="cm">	 * which needs enough room for 106 bits of mantissa,</span>
<span class="cm">	 * so lets call it a Double extended.</span>
<span class="cm">	 */</span>
	<span class="n">Sglext_setzero</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * Four bits at a time are inspected in each loop, and a </span>
<span class="cm">	 * simple shift and add multiply algorithm is used. </span>
<span class="cm">	 */</span> 
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="n">SGL_P</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Sglext_rightshiftby4</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sbit28</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
	 		<span class="cm">/* Twoword_add should be an ADD followed by 2 ADDC&#39;s */</span>
			<span class="n">Twoword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">opnd2</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sbit29</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Twoword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">opnd2</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sbit30</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Twoword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">opnd2</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sbit31</span><span class="p">(</span><span class="n">opnd1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Twoword_add</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span> <span class="n">tmpresp2</span><span class="p">,</span> <span class="n">opnd2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">Sgl_rightshiftby4</span><span class="p">(</span><span class="n">opnd1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Is_sexthiddenoverflow</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* result mantissa &gt;= 2 (mantissa overflow) */</span>
		<span class="n">mpy_exponent</span><span class="o">++</span><span class="p">;</span>
		<span class="n">Sglext_rightshiftby4</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">Sglext_rightshiftby3</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the sign of the mpy result which was saved in resultp1.</span>
<span class="cm">	 * The exponent will continue to be kept in mpy_exponent.</span>
<span class="cm">	 */</span>
	<span class="n">Sglext_set_sign</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">Sgl_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">));</span>

	<span class="cm">/* </span>
<span class="cm">	 * No rounding is required, since the result of the multiply</span>
<span class="cm">	 * is exact in the extended format.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we are ready to perform the add portion of the operation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The exponents need to be kept as integers for now, since the</span>
<span class="cm">	 * multiply result might not fit into the exponent field.  We</span>
<span class="cm">	 * can&#39;t overflow or underflow because of this yet, since the</span>
<span class="cm">	 * add could bring the final result back into range.</span>
<span class="cm">	 */</span>
	<span class="n">add_exponent</span> <span class="o">=</span> <span class="n">Sgl_exponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for denormalized or zero add operand.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">add_exponent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check for zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">opnd3</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* right is zero */</span>
			<span class="cm">/* Left can&#39;t be zero and must be result.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The final result is now in tmpres and mpy_exponent,</span>
<span class="cm">			 * and needs to be rounded and squeezed back into</span>
<span class="cm">			 * double precision format from double extended.</span>
<span class="cm">			 */</span>
			<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span><span class="p">;</span>
			<span class="n">Sglext_copy</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
			<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span><span class="cm">/*save sign*/</span>
			<span class="k">goto</span> <span class="n">round</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* </span>
<span class="cm">		 * Neither are zeroes.  </span>
<span class="cm">		 * Adjust exponent and normalize add operand.</span>
<span class="cm">		 */</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>	<span class="cm">/* save sign */</span>
		<span class="n">Sgl_clear_signexponent</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">add_exponent</span><span class="p">);</span>
		<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">sign_save</span><span class="p">);</span>		<span class="cm">/* restore sign */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">Sgl_clear_exponent_set_hidden</span><span class="p">(</span><span class="n">opnd3</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy opnd3 to the double extended variable called right.</span>
<span class="cm">	 */</span>
	<span class="n">Sgl_copyto_sglext</span><span class="p">(</span><span class="n">opnd3</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A zero &quot;save&quot; helps discover equal operands (for later),</span>
<span class="cm">	 * and is used in swapping operands (if needed).</span>
<span class="cm">	 */</span>
	<span class="n">Sglext_xortointp1</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">save</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compare magnitude of operands.</span>
<span class="cm">	 */</span>
	<span class="n">Sglext_copytoint_exponentmantissa</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">signlessleft1</span><span class="p">);</span>
	<span class="n">Sglext_copytoint_exponentmantissa</span><span class="p">(</span><span class="n">rightp1</span><span class="p">,</span><span class="n">signlessright1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpy_exponent</span> <span class="o">&lt;</span> <span class="n">add_exponent</span> <span class="o">||</span> <span class="n">mpy_exponent</span> <span class="o">==</span> <span class="n">add_exponent</span> <span class="o">&amp;&amp;</span>
	    <span class="n">Sglext_ismagnitudeless</span><span class="p">(</span><span class="n">signlessleft1</span><span class="p">,</span><span class="n">signlessright1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the left operand to the larger one by XOR swap.</span>
<span class="cm">		 * First finish the first word &quot;save&quot;.</span>
<span class="cm">		 */</span>
		<span class="n">Sglext_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">rightp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">rightp1</span><span class="p">);</span>
		<span class="n">Sglext_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">tmpresp1</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">tmpresp1</span><span class="p">);</span>
		<span class="n">Sglext_swap_lower</span><span class="p">(</span><span class="n">tmpresp2</span><span class="p">,</span><span class="n">rightp2</span><span class="p">);</span>
		<span class="cm">/* also setup exponents used in rest of routine */</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">add_exponent</span> <span class="o">-</span> <span class="n">mpy_exponent</span><span class="p">;</span>
		<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">add_exponent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* also setup exponents used in rest of routine */</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span> <span class="o">-</span> <span class="n">add_exponent</span><span class="p">;</span>
		<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">mpy_exponent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Invariant: left is not smaller than right. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Special case alignment of operands that would force alignment</span>
<span class="cm">	 * beyond the extent of the extension.  A further optimization</span>
<span class="cm">	 * could special case this but only reduces the path length for</span>
<span class="cm">	 * this infrequent case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff_exponent</span> <span class="o">&gt;</span> <span class="n">SGLEXT_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">SGLEXT_THRESHOLD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Align right operand by shifting it to the right */</span>
	<span class="n">Sglext_clear_sign</span><span class="p">(</span><span class="n">rightp1</span><span class="p">);</span>
	<span class="n">Sglext_right_align</span><span class="p">(</span><span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span><span class="cm">/*shifted by*/</span><span class="n">diff_exponent</span><span class="p">);</span>
	
	<span class="cm">/* Treat sum and difference of the operands separately. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">save</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Difference of the two operands.  Overflow can occur if the</span>
<span class="cm">		 * multiply overflowed.  A borrow can occur out of the hidden</span>
<span class="cm">		 * bit and force a post normalization phase.</span>
<span class="cm">		 */</span>
		<span class="n">Sglext_subtract</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span> <span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span>
			<span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_hidden</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Handle normalization */</span>
		<span class="cm">/* A straightforward algorithm would now shift the</span>
<span class="cm">		 * result and extension left until the hidden bit</span>
<span class="cm">		 * becomes one.  Not all of the extension bits need</span>
<span class="cm">		 * participate in the shift.  Only the two most </span>
<span class="cm">		 * significant bits (round and guard) are needed.</span>
<span class="cm">		 * If only a single shift is needed then the guard</span>
<span class="cm">		 * bit becomes a significant low order bit and the</span>
<span class="cm">		 * extension must participate in the rounding.</span>
<span class="cm">		 * If more than a single shift is needed, then all</span>
<span class="cm">		 * bits to the right of the guard bit are zeros, </span>
<span class="cm">		 * and the guard bit may or may not be zero. */</span>
			<span class="n">Sglext_leftshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>

			<span class="cm">/* Need to check for a zero result.  The sign and</span>
<span class="cm">			 * exponent fields have already been zeroed.  The more</span>
<span class="cm">			 * efficient test of the full object can be used.</span>
<span class="cm">			 */</span>
			 <span class="k">if</span> <span class="p">(</span><span class="n">Sglext_iszero</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Must have been &quot;x-x&quot; or &quot;x+(-x)&quot;. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span>
					<span class="n">Sgl_setone_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">result_exponent</span><span class="o">--</span><span class="p">;</span>

			<span class="cm">/* Look to see if normalization is finished. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_hidden</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* No further normalization is needed */</span>
				<span class="k">goto</span> <span class="n">round</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Discover first one bit to determine shift amount.</span>
<span class="cm">			 * Use a modified binary search.  We have already</span>
<span class="cm">			 * shifted the result one position right and still</span>
<span class="cm">			 * not found a one so the remainder of the extension</span>
<span class="cm">			 * must be zero and simplifies rounding. */</span>
			<span class="cm">/* Scan bytes */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">Sgl_iszero_hiddenhigh7mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">Sglext_leftshiftby8</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Now narrow it down to the nibble */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* The lower nibble contains the</span>
<span class="cm">				 * normalizing one */</span>
				<span class="n">Sglext_leftshiftby4</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Select case where first bit is set (already</span>
<span class="cm">			 * normalized) otherwise select the proper shift. */</span>
			<span class="n">jumpsize</span> <span class="o">=</span> <span class="n">Sgl_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jumpsize</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">)</span> <span class="k">switch</span><span class="p">(</span><span class="n">jumpsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">Sglext_leftshiftby3</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">Sglext_leftshiftby2</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">4</span>:
			<span class="k">case</span> <span class="mi">5</span>:
			<span class="k">case</span> <span class="mi">6</span>:
			<span class="k">case</span> <span class="mi">7</span>:
				<span class="n">Sglext_leftshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
				<span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="cm">/* end if (hidden...)... */</span>
	<span class="cm">/* Fall through and round */</span>
	<span class="p">}</span> <span class="cm">/* end if (save &lt; 0)... */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Add magnitudes */</span>
		<span class="n">Sglext_addition</span><span class="p">(</span><span class="n">tmpresp1</span><span class="p">,</span><span class="n">tmpresp2</span><span class="p">,</span>
			<span class="n">rightp1</span><span class="p">,</span><span class="n">rightp2</span><span class="p">,</span> <span class="cm">/*to*/</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
		<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
	    		<span class="cm">/* Prenormalization required. */</span>
	    		<span class="n">Sglext_arithrightshiftby1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">);</span>
	    		<span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* end if hiddenoverflow... */</span>
	<span class="p">}</span> <span class="cm">/* end else ...add magnitudes... */</span>

	<span class="cm">/* Round the result.  If the extension and lower two words are</span>
<span class="cm">	 * all zeros, then the result is exact.  Otherwise round in the</span>
<span class="cm">	 * correct direction.  Underflow is possible. If a postnormalization</span>
<span class="cm">	 * is necessary, then the mantissa is all zeros so no shift is needed.</span>
<span class="cm">	 */</span>
  <span class="nl">round:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">Sglext_denormalize</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">resultp2</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">is_tiny</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sglext_isnotzero_mantissap2</span><span class="p">(</span><span class="n">resultp2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">Rounding_mode</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ROUNDNEAREST</span>: <span class="cm">/* The default. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Sglext_isone_highp2</span><span class="p">(</span><span class="n">resultp2</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* at least 1/2 ulp */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">Sglext_isnotzero_low31p2</span><span class="p">(</span><span class="n">resultp2</span><span class="p">)</span> <span class="o">||</span>
				    <span class="n">Sglext_isone_lowp1</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* either exactly half way and odd or</span>
<span class="cm">					 * more than 1/2ulp */</span>
					<span class="n">Sgl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
	    		<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ROUNDPLUS</span>:
	    		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Round up positive results */</span>
				<span class="n">Sgl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
	    
		<span class="k">case</span> <span class="n">ROUNDMINUS</span>:
	    		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_sign</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Round down negative results */</span>
				<span class="n">Sgl_increment</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
			<span class="p">}</span>
	    
		<span class="k">case</span> <span class="n">ROUNDZERO</span>:<span class="p">;</span>
			<span class="cm">/* truncate is simple */</span>
		<span class="p">}</span> <span class="cm">/* end switch... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">))</span> <span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&gt;=</span> <span class="n">SGL_INFINITY_EXPONENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Overflow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_overflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                        <span class="cm">/*</span>
<span class="cm">                         * Adjust bias of result</span>
<span class="cm">                         */</span>
                        <span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">ovfl</span><span class="p">);</span>
                        <span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span>
                                <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_OVERFLOWEXCEPTION</span> <span class="o">|</span>
					<span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
                            <span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_OVERFLOWEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">Set_overflowflag</span><span class="p">();</span>
		<span class="n">Sgl_setoverflow</span><span class="p">(</span><span class="n">resultp1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* underflow case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
                        <span class="cm">/*</span>
<span class="cm">                         * Adjust bias of result</span>
<span class="cm">                         */</span>
                	<span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">unfl</span><span class="p">);</span>
			<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span>
                                <span class="k">return</span> <span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span> <span class="o">|</span>
					<span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
                            <span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
	    		<span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_UNDERFLOWEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span> <span class="o">&amp;&amp;</span> <span class="n">is_tiny</span><span class="p">)</span> <span class="n">Set_underflowflag</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="n">Sgl_set_exponent</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
	<span class="n">Sgl_copytoptr</span><span class="p">(</span><span class="n">resultp1</span><span class="p">,</span><span class="n">dstptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span> <span class="k">return</span><span class="p">(</span><span class="n">OPC_2E_INEXACTEXCEPTION</span><span class="p">);</span>
		<span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
    	<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
