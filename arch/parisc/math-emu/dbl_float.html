<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › math-emu › dbl_float.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dbl_float.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux/PA-RISC Project (http://www.parisc-linux.org/)</span>
<span class="cm"> *</span>
<span class="cm"> * Floating-point emulation code</span>
<span class="cm"> *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *    the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *    any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *    GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *    You should have received a copy of the GNU General Public License</span>
<span class="cm"> *    along with this program; if not, write to the Free Software</span>
<span class="cm"> *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __NO_PA_HDRS</span>
    <span class="n">PA</span> <span class="n">header</span> <span class="n">file</span> <span class="o">--</span> <span class="k">do</span> <span class="n">not</span> <span class="n">include</span> <span class="n">this</span> <span class="n">header</span> <span class="n">file</span> <span class="k">for</span> <span class="n">non</span><span class="o">-</span><span class="n">PA</span> <span class="n">builds</span><span class="p">.</span>
<span class="cp">#endif</span>

<span class="cm">/* 32-bit word grabbing functions */</span>
<span class="cp">#define Dbl_firstword(value) Dallp1(value)</span>
<span class="cp">#define Dbl_secondword(value) Dallp2(value)</span>
<span class="cp">#define Dbl_thirdword(value) dummy_location</span>
<span class="cp">#define Dbl_fourthword(value) dummy_location</span>

<span class="cp">#define Dbl_sign(object) Dsign(object)</span>
<span class="cp">#define Dbl_exponent(object) Dexponent(object)</span>
<span class="cp">#define Dbl_signexponent(object) Dsignexponent(object)</span>
<span class="cp">#define Dbl_mantissap1(object) Dmantissap1(object)</span>
<span class="cp">#define Dbl_mantissap2(object) Dmantissap2(object)</span>
<span class="cp">#define Dbl_exponentmantissap1(object) Dexponentmantissap1(object)</span>
<span class="cp">#define Dbl_allp1(object) Dallp1(object)</span>
<span class="cp">#define Dbl_allp2(object) Dallp2(object)</span>

<span class="cm">/* dbl_and_signs ANDs the sign bits of each argument and puts the result</span>
<span class="cm"> * into the first argument. dbl_or_signs ors those same sign bits */</span>
<span class="cp">#define Dbl_and_signs( src1dst, src2)		\</span>
<span class="cp">    Dallp1(src1dst) = (Dallp1(src2)|~((unsigned int)1&lt;&lt;31)) &amp; Dallp1(src1dst)</span>
<span class="cp">#define Dbl_or_signs( src1dst, src2)		\</span>
<span class="cp">    Dallp1(src1dst) = (Dallp1(src2)&amp;((unsigned int)1&lt;&lt;31)) | Dallp1(src1dst)</span>

<span class="cm">/* The hidden bit is always the low bit of the exponent */</span>
<span class="cp">#define Dbl_clear_exponent_set_hidden(srcdst) Deposit_dexponent(srcdst,1)</span>
<span class="cp">#define Dbl_clear_signexponent_set_hidden(srcdst) \</span>
<span class="cp">    Deposit_dsignexponent(srcdst,1)</span>
<span class="cp">#define Dbl_clear_sign(srcdst) Dallp1(srcdst) &amp;= ~((unsigned int)1&lt;&lt;31)</span>
<span class="cp">#define Dbl_clear_signexponent(srcdst) \</span>
<span class="cp">    Dallp1(srcdst) &amp;= Dmantissap1((unsigned int)-1)</span>

<span class="cm">/* Exponent field for doubles has already been cleared and may be</span>
<span class="cm"> * included in the shift.  Here we need to generate two double width</span>
<span class="cm"> * variable shifts.  The insignificant bits can be ignored.</span>
<span class="cm"> *      MTSAR f(varamount)</span>
<span class="cm"> *      VSHD	srcdst.high,srcdst.low =&gt; srcdst.low</span>
<span class="cm"> *	VSHD	0,srcdst.high =&gt; srcdst.high </span>
<span class="cm"> * This is very difficult to model with C expressions since the shift amount</span>
<span class="cm"> * could exceed 32.  */</span>
<span class="cm">/* varamount must be less than 64 */</span>
<span class="cp">#define Dbl_rightshift(srcdstA, srcdstB, varamount)			\</span>
<span class="cp">    {if((varamount) &gt;= 32) {						\</span>
<span class="cp">        Dallp2(srcdstB) = Dallp1(srcdstA) &gt;&gt; (varamount-32);		\</span>
<span class="cp">        Dallp1(srcdstA)=0;						\</span>
<span class="cp">    }									\</span>
<span class="cp">    else if(varamount &gt; 0) {						\</span>
<span class="cp">	Variable_shift_double(Dallp1(srcdstA), Dallp2(srcdstB), 	\</span>
<span class="cp">	  (varamount), Dallp2(srcdstB));				\</span>
<span class="cp">	Dallp1(srcdstA) &gt;&gt;= varamount;					\</span>
<span class="cp">    } }</span>
<span class="cm">/* varamount must be less than 64 */</span>
<span class="cp">#define Dbl_rightshift_exponentmantissa(srcdstA, srcdstB, varamount)	\</span>
<span class="cp">    {if((varamount) &gt;= 32) {						\</span>
<span class="cp">        Dallp2(srcdstB) = Dexponentmantissap1(srcdstA) &gt;&gt; (varamount-32); \</span>
<span class="cp">	Dallp1(srcdstA) &amp;= ((unsigned int)1&lt;&lt;31);  </span><span class="cm">/* clear expmant field */</span><span class="cp"> \</span>
<span class="cp">    }									\</span>
<span class="cp">    else if(varamount &gt; 0) {						\</span>
<span class="cp">	Variable_shift_double(Dexponentmantissap1(srcdstA), Dallp2(srcdstB), \</span>
<span class="cp">	(varamount), Dallp2(srcdstB));					\</span>
<span class="cp">	Deposit_dexponentmantissap1(srcdstA,				\</span>
<span class="cp">	    (Dexponentmantissap1(srcdstA)&gt;&gt;varamount));			\</span>
<span class="cp">    } }</span>
<span class="cm">/* varamount must be less than 64 */</span>
<span class="cp">#define Dbl_leftshift(srcdstA, srcdstB, varamount)			\</span>
<span class="cp">    {if((varamount) &gt;= 32) {						\</span>
<span class="cp">	Dallp1(srcdstA) = Dallp2(srcdstB) &lt;&lt; (varamount-32);		\</span>
<span class="cp">	Dallp2(srcdstB)=0;						\</span>
<span class="cp">    }									\</span>
<span class="cp">    else {								\</span>
<span class="cp">	if ((varamount) &gt; 0) {						\</span>
<span class="cp">	    Dallp1(srcdstA) = (Dallp1(srcdstA) &lt;&lt; (varamount)) |	\</span>
<span class="cp">		(Dallp2(srcdstB) &gt;&gt; (32-(varamount)));			\</span>
<span class="cp">	    Dallp2(srcdstB) &lt;&lt;= varamount;				\</span>
<span class="cp">	}								\</span>
<span class="cp">    } }</span>
<span class="cp">#define Dbl_leftshiftby1_withextent(lefta,leftb,right,resulta,resultb)	\</span>
<span class="cp">    Shiftdouble(Dallp1(lefta), Dallp2(leftb), 31, Dallp1(resulta));	\</span>
<span class="cp">    Shiftdouble(Dallp2(leftb), Extall(right), 31, Dallp2(resultb)) </span>
    
<span class="cp">#define Dbl_rightshiftby1_withextent(leftb,right,dst)		\</span>
<span class="cp">    Extall(dst) = (Dallp2(leftb) &lt;&lt; 31) | ((unsigned int)Extall(right) &gt;&gt; 1) | \</span>
<span class="cp">		  Extlow(right)</span>

<span class="cp">#define Dbl_arithrightshiftby1(srcdstA,srcdstB)			\</span>
<span class="cp">    Shiftdouble(Dallp1(srcdstA),Dallp2(srcdstB),1,Dallp2(srcdstB));\</span>
<span class="cp">    Dallp1(srcdstA) = (int)Dallp1(srcdstA) &gt;&gt; 1</span>
   
<span class="cm">/* Sign extend the sign bit with an integer destination */</span>
<span class="cp">#define Dbl_signextendedsign(value)  Dsignedsign(value)</span>

<span class="cp">#define Dbl_isone_hidden(dbl_value) (Is_dhidden(dbl_value)!=0)</span>
<span class="cm">/* Singles and doubles may include the sign and exponent fields.  The</span>
<span class="cm"> * hidden bit and the hidden overflow must be included. */</span>
<span class="cp">#define Dbl_increment(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    if( (Dallp2(dbl_valueB) += 1) == 0 )  Dallp1(dbl_valueA) += 1</span>
<span class="cp">#define Dbl_increment_mantissa(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    if( (Dmantissap2(dbl_valueB) += 1) == 0 )  \</span>
<span class="cp">    Deposit_dmantissap1(dbl_valueA,dbl_valueA+1)</span>
<span class="cp">#define Dbl_decrement(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    if( Dallp2(dbl_valueB) == 0 )  Dallp1(dbl_valueA) -= 1; \</span>
<span class="cp">    Dallp2(dbl_valueB) -= 1</span>

<span class="cp">#define Dbl_isone_sign(dbl_value) (Is_dsign(dbl_value)!=0)</span>
<span class="cp">#define Dbl_isone_hiddenoverflow(dbl_value) (Is_dhiddenoverflow(dbl_value)!=0)</span>
<span class="cp">#define Dbl_isone_lowmantissap1(dbl_valueA) (Is_dlowp1(dbl_valueA)!=0)</span>
<span class="cp">#define Dbl_isone_lowmantissap2(dbl_valueB) (Is_dlowp2(dbl_valueB)!=0)</span>
<span class="cp">#define Dbl_isone_signaling(dbl_value) (Is_dsignaling(dbl_value)!=0)</span>
<span class="cp">#define Dbl_is_signalingnan(dbl_value) (Dsignalingnan(dbl_value)==0xfff)</span>
<span class="cp">#define Dbl_isnotzero(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    (Dallp1(dbl_valueA) || Dallp2(dbl_valueB))</span>
<span class="cp">#define Dbl_isnotzero_hiddenhigh7mantissa(dbl_value) \</span>
<span class="cp">    (Dhiddenhigh7mantissa(dbl_value)!=0)</span>
<span class="cp">#define Dbl_isnotzero_exponent(dbl_value) (Dexponent(dbl_value)!=0)</span>
<span class="cp">#define Dbl_isnotzero_mantissa(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    (Dmantissap1(dbl_valueA) || Dmantissap2(dbl_valueB))</span>
<span class="cp">#define Dbl_isnotzero_mantissap1(dbl_valueA) (Dmantissap1(dbl_valueA)!=0)</span>
<span class="cp">#define Dbl_isnotzero_mantissap2(dbl_valueB) (Dmantissap2(dbl_valueB)!=0)</span>
<span class="cp">#define Dbl_isnotzero_exponentmantissa(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    (Dexponentmantissap1(dbl_valueA) || Dmantissap2(dbl_valueB))</span>
<span class="cp">#define Dbl_isnotzero_low4p2(dbl_value) (Dlow4p2(dbl_value)!=0)</span>
<span class="cp">#define Dbl_iszero(dbl_valueA,dbl_valueB) (Dallp1(dbl_valueA)==0 &amp;&amp; \</span>
<span class="cp">    Dallp2(dbl_valueB)==0)</span>
<span class="cp">#define Dbl_iszero_allp1(dbl_value) (Dallp1(dbl_value)==0)</span>
<span class="cp">#define Dbl_iszero_allp2(dbl_value) (Dallp2(dbl_value)==0)</span>
<span class="cp">#define Dbl_iszero_hidden(dbl_value) (Is_dhidden(dbl_value)==0)</span>
<span class="cp">#define Dbl_iszero_hiddenoverflow(dbl_value) (Is_dhiddenoverflow(dbl_value)==0)</span>
<span class="cp">#define Dbl_iszero_hiddenhigh3mantissa(dbl_value) \</span>
<span class="cp">    (Dhiddenhigh3mantissa(dbl_value)==0)</span>
<span class="cp">#define Dbl_iszero_hiddenhigh7mantissa(dbl_value) \</span>
<span class="cp">    (Dhiddenhigh7mantissa(dbl_value)==0)</span>
<span class="cp">#define Dbl_iszero_sign(dbl_value) (Is_dsign(dbl_value)==0)</span>
<span class="cp">#define Dbl_iszero_exponent(dbl_value) (Dexponent(dbl_value)==0)</span>
<span class="cp">#define Dbl_iszero_mantissa(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    (Dmantissap1(dbl_valueA)==0 &amp;&amp; Dmantissap2(dbl_valueB)==0)</span>
<span class="cp">#define Dbl_iszero_exponentmantissa(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    (Dexponentmantissap1(dbl_valueA)==0 &amp;&amp; Dmantissap2(dbl_valueB)==0)</span>
<span class="cp">#define Dbl_isinfinity_exponent(dbl_value)		\</span>
<span class="cp">    (Dexponent(dbl_value)==DBL_INFINITY_EXPONENT)</span>
<span class="cp">#define Dbl_isnotinfinity_exponent(dbl_value)		\</span>
<span class="cp">    (Dexponent(dbl_value)!=DBL_INFINITY_EXPONENT)</span>
<span class="cp">#define Dbl_isinfinity(dbl_valueA,dbl_valueB)			\</span>
<span class="cp">    (Dexponent(dbl_valueA)==DBL_INFINITY_EXPONENT &amp;&amp;	\</span>
<span class="cp">    Dmantissap1(dbl_valueA)==0 &amp;&amp; Dmantissap2(dbl_valueB)==0)</span>
<span class="cp">#define Dbl_isnan(dbl_valueA,dbl_valueB)		\</span>
<span class="cp">    (Dexponent(dbl_valueA)==DBL_INFINITY_EXPONENT &amp;&amp;	\</span>
<span class="cp">    (Dmantissap1(dbl_valueA)!=0 || Dmantissap2(dbl_valueB)!=0))</span>
<span class="cp">#define Dbl_isnotnan(dbl_valueA,dbl_valueB)		\</span>
<span class="cp">    (Dexponent(dbl_valueA)!=DBL_INFINITY_EXPONENT ||	\</span>
<span class="cp">    (Dmantissap1(dbl_valueA)==0 &amp;&amp; Dmantissap2(dbl_valueB)==0))</span>

<span class="cp">#define Dbl_islessthan(dbl_op1a,dbl_op1b,dbl_op2a,dbl_op2b)	\</span>
<span class="cp">    (Dallp1(dbl_op1a) &lt; Dallp1(dbl_op2a) ||			\</span>
<span class="cp">     (Dallp1(dbl_op1a) == Dallp1(dbl_op2a) &amp;&amp;			\</span>
<span class="cp">      Dallp2(dbl_op1b) &lt; Dallp2(dbl_op2b)))</span>
<span class="cp">#define Dbl_isgreaterthan(dbl_op1a,dbl_op1b,dbl_op2a,dbl_op2b)	\</span>
<span class="cp">    (Dallp1(dbl_op1a) &gt; Dallp1(dbl_op2a) ||			\</span>
<span class="cp">     (Dallp1(dbl_op1a) == Dallp1(dbl_op2a) &amp;&amp;			\</span>
<span class="cp">      Dallp2(dbl_op1b) &gt; Dallp2(dbl_op2b)))</span>
<span class="cp">#define Dbl_isnotlessthan(dbl_op1a,dbl_op1b,dbl_op2a,dbl_op2b)	\</span>
<span class="cp">    (Dallp1(dbl_op1a) &gt; Dallp1(dbl_op2a) ||			\</span>
<span class="cp">     (Dallp1(dbl_op1a) == Dallp1(dbl_op2a) &amp;&amp;			\</span>
<span class="cp">      Dallp2(dbl_op1b) &gt;= Dallp2(dbl_op2b)))</span>
<span class="cp">#define Dbl_isnotgreaterthan(dbl_op1a,dbl_op1b,dbl_op2a,dbl_op2b) \</span>
<span class="cp">    (Dallp1(dbl_op1a) &lt; Dallp1(dbl_op2a) ||			\</span>
<span class="cp">     (Dallp1(dbl_op1a) == Dallp1(dbl_op2a) &amp;&amp;			\</span>
<span class="cp">      Dallp2(dbl_op1b) &lt;= Dallp2(dbl_op2b)))</span>
<span class="cp">#define Dbl_isequal(dbl_op1a,dbl_op1b,dbl_op2a,dbl_op2b)	\</span>
<span class="cp">     ((Dallp1(dbl_op1a) == Dallp1(dbl_op2a)) &amp;&amp;			\</span>
<span class="cp">      (Dallp2(dbl_op1b) == Dallp2(dbl_op2b)))</span>

<span class="cp">#define Dbl_leftshiftby8(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),24,Dallp1(dbl_valueA)); \</span>
<span class="cp">    Dallp2(dbl_valueB) &lt;&lt;= 8</span>
<span class="cp">#define Dbl_leftshiftby7(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),25,Dallp1(dbl_valueA)); \</span>
<span class="cp">    Dallp2(dbl_valueB) &lt;&lt;= 7</span>
<span class="cp">#define Dbl_leftshiftby4(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),28,Dallp1(dbl_valueA)); \</span>
<span class="cp">    Dallp2(dbl_valueB) &lt;&lt;= 4</span>
<span class="cp">#define Dbl_leftshiftby3(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),29,Dallp1(dbl_valueA)); \</span>
<span class="cp">    Dallp2(dbl_valueB) &lt;&lt;= 3</span>
<span class="cp">#define Dbl_leftshiftby2(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),30,Dallp1(dbl_valueA)); \</span>
<span class="cp">    Dallp2(dbl_valueB) &lt;&lt;= 2</span>
<span class="cp">#define Dbl_leftshiftby1(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),31,Dallp1(dbl_valueA)); \</span>
<span class="cp">    Dallp2(dbl_valueB) &lt;&lt;= 1</span>

<span class="cp">#define Dbl_rightshiftby8(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),8,Dallp2(dbl_valueB)); \</span>
<span class="cp">    Dallp1(dbl_valueA) &gt;&gt;= 8</span>
<span class="cp">#define Dbl_rightshiftby4(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),4,Dallp2(dbl_valueB)); \</span>
<span class="cp">    Dallp1(dbl_valueA) &gt;&gt;= 4</span>
<span class="cp">#define Dbl_rightshiftby2(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),2,Dallp2(dbl_valueB)); \</span>
<span class="cp">    Dallp1(dbl_valueA) &gt;&gt;= 2</span>
<span class="cp">#define Dbl_rightshiftby1(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),1,Dallp2(dbl_valueB)); \</span>
<span class="cp">    Dallp1(dbl_valueA) &gt;&gt;= 1</span>
    
<span class="cm">/* This magnitude comparison uses the signless first words and</span>
<span class="cm"> * the regular part2 words.  The comparison is graphically:</span>
<span class="cm"> *</span>
<span class="cm"> *       1st greater?  -------------</span>
<span class="cm"> *                                 |</span>
<span class="cm"> *       1st less?-----------------+---------</span>
<span class="cm"> *                                 |        |</span>
<span class="cm"> *       2nd greater or equal-----&gt;|        |</span>
<span class="cm"> *                               False     True</span>
<span class="cm"> */</span>
<span class="cp">#define Dbl_ismagnitudeless(leftB,rightB,signlessleft,signlessright)	\</span>
<span class="cp">      ((signlessleft &lt;= signlessright) &amp;&amp;				\</span>
<span class="cp">       ( (signlessleft &lt; signlessright) || (Dallp2(leftB)&lt;Dallp2(rightB)) ))</span>
    
<span class="cp">#define Dbl_copytoint_exponentmantissap1(src,dest) \</span>
<span class="cp">    dest = Dexponentmantissap1(src)</span>

<span class="cm">/* A quiet NaN has the high mantissa bit clear and at least on other (in this</span>
<span class="cm"> * case the adjacent bit) bit set. */</span>
<span class="cp">#define Dbl_set_quiet(dbl_value) Deposit_dhigh2mantissa(dbl_value,1)</span>
<span class="cp">#define Dbl_set_exponent(dbl_value, exp) Deposit_dexponent(dbl_value,exp)</span>

<span class="cp">#define Dbl_set_mantissa(desta,destb,valuea,valueb)	\</span>
<span class="cp">    Deposit_dmantissap1(desta,valuea);			\</span>
<span class="cp">    Dmantissap2(destb) = Dmantissap2(valueb)</span>
<span class="cp">#define Dbl_set_mantissap1(desta,valuea)		\</span>
<span class="cp">    Deposit_dmantissap1(desta,valuea)</span>
<span class="cp">#define Dbl_set_mantissap2(destb,valueb)		\</span>
<span class="cp">    Dmantissap2(destb) = Dmantissap2(valueb)</span>

<span class="cp">#define Dbl_set_exponentmantissa(desta,destb,valuea,valueb)	\</span>
<span class="cp">    Deposit_dexponentmantissap1(desta,valuea);			\</span>
<span class="cp">    Dmantissap2(destb) = Dmantissap2(valueb)</span>
<span class="cp">#define Dbl_set_exponentmantissap1(dest,value)			\</span>
<span class="cp">    Deposit_dexponentmantissap1(dest,value)</span>

<span class="cp">#define Dbl_copyfromptr(src,desta,destb) \</span>
<span class="cp">    Dallp1(desta) = src-&gt;wd0;		\</span>
<span class="cp">    Dallp2(destb) = src-&gt;wd1 </span>
<span class="cp">#define Dbl_copytoptr(srca,srcb,dest)	\</span>
<span class="cp">    dest-&gt;wd0 = Dallp1(srca);		\</span>
<span class="cp">    dest-&gt;wd1 = Dallp2(srcb)</span>

<span class="cm">/*  An infinity is represented with the max exponent and a zero mantissa */</span>
<span class="cp">#define Dbl_setinfinity_exponent(dbl_value) \</span>
<span class="cp">    Deposit_dexponent(dbl_value,DBL_INFINITY_EXPONENT)</span>
<span class="cp">#define Dbl_setinfinity_exponentmantissa(dbl_valueA,dbl_valueB)	\</span>
<span class="cp">    Deposit_dexponentmantissap1(dbl_valueA, 			\</span>
<span class="cp">    (DBL_INFINITY_EXPONENT &lt;&lt; (32-(1+DBL_EXP_LENGTH))));	\</span>
<span class="cp">    Dmantissap2(dbl_valueB) = 0</span>
<span class="cp">#define Dbl_setinfinitypositive(dbl_valueA,dbl_valueB)		\</span>
<span class="cp">    Dallp1(dbl_valueA) 						\</span>
<span class="cp">        = (DBL_INFINITY_EXPONENT &lt;&lt; (32-(1+DBL_EXP_LENGTH)));	\</span>
<span class="cp">    Dmantissap2(dbl_valueB) = 0</span>
<span class="cp">#define Dbl_setinfinitynegative(dbl_valueA,dbl_valueB)		\</span>
<span class="cp">    Dallp1(dbl_valueA) = ((unsigned int)1&lt;&lt;31) |		\</span>
<span class="cp">         (DBL_INFINITY_EXPONENT &lt;&lt; (32-(1+DBL_EXP_LENGTH)));	\</span>
<span class="cp">    Dmantissap2(dbl_valueB) = 0</span>
<span class="cp">#define Dbl_setinfinity(dbl_valueA,dbl_valueB,sign)		\</span>
<span class="cp">    Dallp1(dbl_valueA) = ((unsigned int)sign &lt;&lt; 31) | 		\</span>
<span class="cp">	(DBL_INFINITY_EXPONENT &lt;&lt; (32-(1+DBL_EXP_LENGTH)));	\</span>
<span class="cp">    Dmantissap2(dbl_valueB) = 0</span>

<span class="cp">#define Dbl_sethigh4bits(dbl_value, extsign) Deposit_dhigh4p1(dbl_value,extsign)</span>
<span class="cp">#define Dbl_set_sign(dbl_value,sign) Deposit_dsign(dbl_value,sign)</span>
<span class="cp">#define Dbl_invert_sign(dbl_value) Deposit_dsign(dbl_value,~Dsign(dbl_value))</span>
<span class="cp">#define Dbl_setone_sign(dbl_value) Deposit_dsign(dbl_value,1)</span>
<span class="cp">#define Dbl_setone_lowmantissap2(dbl_value) Deposit_dlowp2(dbl_value,1)</span>
<span class="cp">#define Dbl_setzero_sign(dbl_value) Dallp1(dbl_value) &amp;= 0x7fffffff</span>
<span class="cp">#define Dbl_setzero_exponent(dbl_value) 		\</span>
<span class="cp">    Dallp1(dbl_value) &amp;= 0x800fffff</span>
<span class="cp">#define Dbl_setzero_mantissa(dbl_valueA,dbl_valueB)	\</span>
<span class="cp">    Dallp1(dbl_valueA) &amp;= 0xfff00000; 			\</span>
<span class="cp">    Dallp2(dbl_valueB) = 0</span>
<span class="cp">#define Dbl_setzero_mantissap1(dbl_value) Dallp1(dbl_value) &amp;= 0xfff00000</span>
<span class="cp">#define Dbl_setzero_mantissap2(dbl_value) Dallp2(dbl_value) = 0</span>
<span class="cp">#define Dbl_setzero_exponentmantissa(dbl_valueA,dbl_valueB)	\</span>
<span class="cp">    Dallp1(dbl_valueA) &amp;= 0x80000000;		\</span>
<span class="cp">    Dallp2(dbl_valueB) = 0</span>
<span class="cp">#define Dbl_setzero_exponentmantissap1(dbl_valueA)	\</span>
<span class="cp">    Dallp1(dbl_valueA) &amp;= 0x80000000</span>
<span class="cp">#define Dbl_setzero(dbl_valueA,dbl_valueB) \</span>
<span class="cp">    Dallp1(dbl_valueA) = 0; Dallp2(dbl_valueB) = 0</span>
<span class="cp">#define Dbl_setzerop1(dbl_value) Dallp1(dbl_value) = 0</span>
<span class="cp">#define Dbl_setzerop2(dbl_value) Dallp2(dbl_value) = 0</span>
<span class="cp">#define Dbl_setnegativezero(dbl_value) \</span>
<span class="cp">    Dallp1(dbl_value) = (unsigned int)1 &lt;&lt; 31; Dallp2(dbl_value) = 0</span>
<span class="cp">#define Dbl_setnegativezerop1(dbl_value) Dallp1(dbl_value) = (unsigned int)1&lt;&lt;31</span>

<span class="cm">/* Use the following macro for both overflow &amp; underflow conditions */</span>
<span class="cp">#define ovfl -</span>
<span class="cp">#define unfl +</span>
<span class="cp">#define Dbl_setwrapped_exponent(dbl_value,exponent,op) \</span>
<span class="cp">    Deposit_dexponent(dbl_value,(exponent op DBL_WRAP))</span>

<span class="cp">#define Dbl_setlargestpositive(dbl_valueA,dbl_valueB) 			\</span>
<span class="cp">    Dallp1(dbl_valueA) = ((DBL_EMAX+DBL_BIAS) &lt;&lt; (32-(1+DBL_EXP_LENGTH))) \</span>
<span class="cp">			| ((1&lt;&lt;(32-(1+DBL_EXP_LENGTH))) - 1 );		\</span>
<span class="cp">    Dallp2(dbl_valueB) = 0xFFFFFFFF</span>
<span class="cp">#define Dbl_setlargestnegative(dbl_valueA,dbl_valueB) 			\</span>
<span class="cp">    Dallp1(dbl_valueA) = ((DBL_EMAX+DBL_BIAS) &lt;&lt; (32-(1+DBL_EXP_LENGTH))) \</span>
<span class="cp">			| ((1&lt;&lt;(32-(1+DBL_EXP_LENGTH))) - 1 )		\</span>
<span class="cp">			| ((unsigned int)1&lt;&lt;31);			\</span>
<span class="cp">    Dallp2(dbl_valueB) = 0xFFFFFFFF</span>
<span class="cp">#define Dbl_setlargest_exponentmantissa(dbl_valueA,dbl_valueB)		\</span>
<span class="cp">    Deposit_dexponentmantissap1(dbl_valueA,				\</span>
<span class="cp">	(((DBL_EMAX+DBL_BIAS) &lt;&lt; (32-(1+DBL_EXP_LENGTH)))		\</span>
<span class="cp">			| ((1&lt;&lt;(32-(1+DBL_EXP_LENGTH))) - 1 )));	\</span>
<span class="cp">    Dallp2(dbl_valueB) = 0xFFFFFFFF</span>

<span class="cp">#define Dbl_setnegativeinfinity(dbl_valueA,dbl_valueB) 			\</span>
<span class="cp">    Dallp1(dbl_valueA) = ((1&lt;&lt;DBL_EXP_LENGTH) | DBL_INFINITY_EXPONENT) 	\</span>
<span class="cp">			 &lt;&lt; (32-(1+DBL_EXP_LENGTH)) ; 			\</span>
<span class="cp">    Dallp2(dbl_valueB) = 0</span>
<span class="cp">#define Dbl_setlargest(dbl_valueA,dbl_valueB,sign)			\</span>
<span class="cp">    Dallp1(dbl_valueA) = ((unsigned int)sign &lt;&lt; 31) |			\</span>
<span class="cp">         ((DBL_EMAX+DBL_BIAS) &lt;&lt; (32-(1+DBL_EXP_LENGTH))) |	 	\</span>
<span class="cp">	 ((1 &lt;&lt; (32-(1+DBL_EXP_LENGTH))) - 1 );				\</span>
<span class="cp">    Dallp2(dbl_valueB) = 0xFFFFFFFF</span>
    

<span class="cm">/* The high bit is always zero so arithmetic or logical shifts will work. */</span>
<span class="cp">#define Dbl_right_align(srcdstA,srcdstB,shift,extent)			\</span>
<span class="cp">    if( shift &gt;= 32 ) 							\</span>
<span class="cp">	{								\</span>
<span class="cp">	</span><span class="cm">/* Big shift requires examining the portion shift off 		\</span>
<span class="cm">	the end to properly set inexact.  */</span><span class="cp">				\</span>
<span class="cp">	if(shift &lt; 64)							\</span>
<span class="cp">	    {								\</span>
<span class="cp">	    if(shift &gt; 32)						\</span>
<span class="cp">		{							\</span>
<span class="cp">	        Variable_shift_double(Dallp1(srcdstA),Dallp2(srcdstB),	\</span>
<span class="cp">		 shift-32, Extall(extent));				\</span>
<span class="cp">	        if(Dallp2(srcdstB) &lt;&lt; 64 - (shift)) Ext_setone_low(extent); \</span>
<span class="cp">	        }							\</span>
<span class="cp">	    else Extall(extent) = Dallp2(srcdstB);			\</span>
<span class="cp">	    Dallp2(srcdstB) = Dallp1(srcdstA) &gt;&gt; (shift - 32);		\</span>
<span class="cp">	    }								\</span>
<span class="cp">	else								\</span>
<span class="cp">	    {								\</span>
<span class="cp">	    Extall(extent) = Dallp1(srcdstA);				\</span>
<span class="cp">	    if(Dallp2(srcdstB)) Ext_setone_low(extent);			\</span>
<span class="cp">	    Dallp2(srcdstB) = 0;					\</span>
<span class="cp">	    }								\</span>
<span class="cp">	Dallp1(srcdstA) = 0;						\</span>
<span class="cp">	}								\</span>
<span class="cp">    else								\</span>
<span class="cp">	{								\</span>
<span class="cp">	</span><span class="cm">/* Small alignment is simpler.  Extension is easily set. */</span><span class="cp">	\</span>
<span class="cp">	if (shift &gt; 0)							\</span>
<span class="cp">	    {								\</span>
<span class="cp">	    Extall(extent) = Dallp2(srcdstB) &lt;&lt; 32 - (shift);		\</span>
<span class="cp">	    Variable_shift_double(Dallp1(srcdstA),Dallp2(srcdstB),shift, \</span>
<span class="cp">	     Dallp2(srcdstB));						\</span>
<span class="cp">	    Dallp1(srcdstA) &gt;&gt;= shift;					\</span>
<span class="cp">	    }								\</span>
<span class="cp">	else Extall(extent) = 0;					\</span>
<span class="cp">	}</span>

<span class="cm">/* </span>
<span class="cm"> * Here we need to shift the result right to correct for an overshift</span>
<span class="cm"> * (due to the exponent becoming negative) during normalization.</span>
<span class="cm"> */</span>
<span class="cp">#define Dbl_fix_overshift(srcdstA,srcdstB,shift,extent)			\</span>
<span class="cp">	    Extall(extent) = Dallp2(srcdstB) &lt;&lt; 32 - (shift);		\</span>
<span class="cp">	    Dallp2(srcdstB) = (Dallp1(srcdstA) &lt;&lt; 32 - (shift)) |	\</span>
<span class="cp">		(Dallp2(srcdstB) &gt;&gt; (shift));				\</span>
<span class="cp">	    Dallp1(srcdstA) = Dallp1(srcdstA) &gt;&gt; shift</span>

<span class="cp">#define Dbl_hiddenhigh3mantissa(dbl_value) Dhiddenhigh3mantissa(dbl_value)</span>
<span class="cp">#define Dbl_hidden(dbl_value) Dhidden(dbl_value)</span>
<span class="cp">#define Dbl_lowmantissap2(dbl_value) Dlowp2(dbl_value)</span>

<span class="cm">/* The left argument is never smaller than the right argument */</span>
<span class="cp">#define Dbl_subtract(lefta,leftb,righta,rightb,resulta,resultb)			\</span>
<span class="cp">    if( Dallp2(rightb) &gt; Dallp2(leftb) ) Dallp1(lefta)--;	\</span>
<span class="cp">    Dallp2(resultb) = Dallp2(leftb) - Dallp2(rightb);		\</span>
<span class="cp">    Dallp1(resulta) = Dallp1(lefta) - Dallp1(righta)</span>

<span class="cm">/* Subtract right augmented with extension from left augmented with zeros and</span>
<span class="cm"> * store into result and extension. */</span>
<span class="cp">#define Dbl_subtract_withextension(lefta,leftb,righta,rightb,extent,resulta,resultb)	\</span>
<span class="cp">    Dbl_subtract(lefta,leftb,righta,rightb,resulta,resultb);		\</span>
<span class="cp">    if( (Extall(extent) = 0-Extall(extent)) )				\</span>
<span class="cp">        {								\</span>
<span class="cp">        if((Dallp2(resultb)--) == 0) Dallp1(resulta)--;			\</span>
<span class="cp">        }</span>

<span class="cp">#define Dbl_addition(lefta,leftb,righta,rightb,resulta,resultb)		\</span>
<span class="cp">    </span><span class="cm">/* If the sum of the low words is less than either source, then	\</span>
<span class="cm">     * an overflow into the next word occurred. */</span><span class="cp">			\</span>
<span class="cp">    Dallp1(resulta) = Dallp1(lefta) + Dallp1(righta);			\</span>
<span class="cp">    if((Dallp2(resultb) = Dallp2(leftb) + Dallp2(rightb)) &lt; Dallp2(rightb)) \</span>
<span class="cp">	Dallp1(resulta)++</span>

<span class="cp">#define Dbl_xortointp1(left,right,result)			\</span>
<span class="cp">    result = Dallp1(left) XOR Dallp1(right)</span>

<span class="cp">#define Dbl_xorfromintp1(left,right,result)			\</span>
<span class="cp">    Dallp1(result) = left XOR Dallp1(right)</span>

<span class="cp">#define Dbl_swap_lower(left,right)				\</span>
<span class="cp">    Dallp2(left)  = Dallp2(left) XOR Dallp2(right);		\</span>
<span class="cp">    Dallp2(right) = Dallp2(left) XOR Dallp2(right);		\</span>
<span class="cp">    Dallp2(left)  = Dallp2(left) XOR Dallp2(right)</span>

<span class="cm">/* Need to Initialize */</span>
<span class="cp">#define Dbl_makequietnan(desta,destb)					\</span>
<span class="cp">    Dallp1(desta) = ((DBL_EMAX+DBL_BIAS)+1)&lt;&lt; (32-(1+DBL_EXP_LENGTH))	\</span>
<span class="cp">                 | (1&lt;&lt;(32-(1+DBL_EXP_LENGTH+2)));			\</span>
<span class="cp">    Dallp2(destb) = 0</span>
<span class="cp">#define Dbl_makesignalingnan(desta,destb)				\</span>
<span class="cp">    Dallp1(desta) = ((DBL_EMAX+DBL_BIAS)+1)&lt;&lt; (32-(1+DBL_EXP_LENGTH))	\</span>
<span class="cp">                 | (1&lt;&lt;(32-(1+DBL_EXP_LENGTH+1)));			\</span>
<span class="cp">    Dallp2(destb) = 0</span>

<span class="cp">#define Dbl_normalize(dbl_opndA,dbl_opndB,exponent)			\</span>
<span class="cp">	while(Dbl_iszero_hiddenhigh7mantissa(dbl_opndA)) {		\</span>
<span class="cp">		Dbl_leftshiftby8(dbl_opndA,dbl_opndB);			\</span>
<span class="cp">		exponent -= 8;						\</span>
<span class="cp">	}								\</span>
<span class="cp">	if(Dbl_iszero_hiddenhigh3mantissa(dbl_opndA)) {			\</span>
<span class="cp">		Dbl_leftshiftby4(dbl_opndA,dbl_opndB);			\</span>
<span class="cp">		exponent -= 4;						\</span>
<span class="cp">	}								\</span>
<span class="cp">	while(Dbl_iszero_hidden(dbl_opndA)) {				\</span>
<span class="cp">		Dbl_leftshiftby1(dbl_opndA,dbl_opndB);			\</span>
<span class="cp">		exponent -= 1;						\</span>
<span class="cp">	}</span>

<span class="cp">#define Twoword_add(src1dstA,src1dstB,src2A,src2B)		\</span>
<span class="cp">	</span><span class="cm">/* 							\</span>
<span class="cm">	 * want this macro to generate:				\</span>
<span class="cm">	 *	ADD	src1dstB,src2B,src1dstB;		\</span>
<span class="cm">	 *	ADDC	src1dstA,src2A,src1dstA;		\</span>
<span class="cm">	 */</span><span class="cp">							\</span>
<span class="cp">	if ((src1dstB) + (src2B) &lt; (src1dstB)) Dallp1(src1dstA)++; \</span>
<span class="cp">	Dallp1(src1dstA) += (src2A);				\</span>
<span class="cp">	Dallp2(src1dstB) += (src2B)</span>

<span class="cp">#define Twoword_subtract(src1dstA,src1dstB,src2A,src2B)		\</span>
<span class="cp">	</span><span class="cm">/* 							\</span>
<span class="cm">	 * want this macro to generate:				\</span>
<span class="cm">	 *	SUB	src1dstB,src2B,src1dstB;		\</span>
<span class="cm">	 *	SUBB	src1dstA,src2A,src1dstA;		\</span>
<span class="cm">	 */</span><span class="cp">							\</span>
<span class="cp">	if ((src1dstB) &lt; (src2B)) Dallp1(src1dstA)--;		\</span>
<span class="cp">	Dallp1(src1dstA) -= (src2A);				\</span>
<span class="cp">	Dallp2(src1dstB) -= (src2B)</span>

<span class="cp">#define Dbl_setoverflow(resultA,resultB)				\</span>
<span class="cp">	</span><span class="cm">/* set result to infinity or largest number */</span><span class="cp">			\</span>
<span class="cp">	switch (Rounding_mode()) {					\</span>
<span class="cp">		case ROUNDPLUS:						\</span>
<span class="cp">			if (Dbl_isone_sign(resultA)) {			\</span>
<span class="cp">				Dbl_setlargestnegative(resultA,resultB); \</span>
<span class="cp">			}						\</span>
<span class="cp">			else {						\</span>
<span class="cp">				Dbl_setinfinitypositive(resultA,resultB); \</span>
<span class="cp">			}						\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case ROUNDMINUS:					\</span>
<span class="cp">			if (Dbl_iszero_sign(resultA)) {			\</span>
<span class="cp">				Dbl_setlargestpositive(resultA,resultB); \</span>
<span class="cp">			}						\</span>
<span class="cp">			else {						\</span>
<span class="cp">				Dbl_setinfinitynegative(resultA,resultB); \</span>
<span class="cp">			}						\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case ROUNDNEAREST:					\</span>
<span class="cp">			Dbl_setinfinity_exponentmantissa(resultA,resultB); \</span>
<span class="cp">			break;						\</span>
<span class="cp">		case ROUNDZERO:						\</span>
<span class="cp">			Dbl_setlargest_exponentmantissa(resultA,resultB); \</span>
<span class="cp">	}</span>

<span class="cp">#define Dbl_denormalize(opndp1,opndp2,exponent,guard,sticky,inexact)	\</span>
<span class="cp">    Dbl_clear_signexponent_set_hidden(opndp1);				\</span>
<span class="cp">    if (exponent &gt;= (1-DBL_P)) {					\</span>
<span class="cp">	if (exponent &gt;= -31) {						\</span>
<span class="cp">	    guard = (Dallp2(opndp2) &gt;&gt; -exponent) &amp; 1;			\</span>
<span class="cp">	    if (exponent &lt; 0) sticky |= Dallp2(opndp2) &lt;&lt; (32+exponent); \</span>
<span class="cp">	    if (exponent &gt; -31) {					\</span>
<span class="cp">		Variable_shift_double(opndp1,opndp2,1-exponent,opndp2);	\</span>
<span class="cp">		Dallp1(opndp1) &gt;&gt;= 1-exponent;				\</span>
<span class="cp">	    }								\</span>
<span class="cp">	    else {							\</span>
<span class="cp">		Dallp2(opndp2) = Dallp1(opndp1);			\</span>
<span class="cp">		Dbl_setzerop1(opndp1);					\</span>
<span class="cp">	    }								\</span>
<span class="cp">	}								\</span>
<span class="cp">	else {								\</span>
<span class="cp">	    guard = (Dallp1(opndp1) &gt;&gt; -32-exponent) &amp; 1;		\</span>
<span class="cp">	    if (exponent == -32) sticky |= Dallp2(opndp2);		\</span>
<span class="cp">	    else sticky |= (Dallp2(opndp2) | Dallp1(opndp1) &lt;&lt; 64+exponent); \</span>
<span class="cp">	    Dallp2(opndp2) = Dallp1(opndp1) &gt;&gt; -31-exponent;		\</span>
<span class="cp">	    Dbl_setzerop1(opndp1);					\</span>
<span class="cp">	}								\</span>
<span class="cp">	inexact = guard | sticky;					\</span>
<span class="cp">    }									\</span>
<span class="cp">    else {								\</span>
<span class="cp">	guard = 0;							\</span>
<span class="cp">	sticky |= (Dallp1(opndp1) | Dallp2(opndp2));			\</span>
<span class="cp">	Dbl_setzero(opndp1,opndp2);					\</span>
<span class="cp">	inexact = sticky;						\</span>
<span class="cp">    }</span>

<span class="cm">/* </span>
<span class="cm"> * The fused multiply add instructions requires a double extended format,</span>
<span class="cm"> * with 106 bits of mantissa.</span>
<span class="cm"> */</span>
<span class="cp">#define DBLEXT_THRESHOLD 106</span>

<span class="cp">#define Dblext_setzero(valA,valB,valC,valD)	\</span>
<span class="cp">    Dextallp1(valA) = 0; Dextallp2(valB) = 0;	\</span>
<span class="cp">    Dextallp3(valC) = 0; Dextallp4(valD) = 0</span>


<span class="cp">#define Dblext_isnotzero_mantissap3(valC) (Dextallp3(valC)!=0)</span>
<span class="cp">#define Dblext_isnotzero_mantissap4(valD) (Dextallp3(valD)!=0)</span>
<span class="cp">#define Dblext_isone_lowp2(val) (Dextlowp2(val)!=0)</span>
<span class="cp">#define Dblext_isone_highp3(val) (Dexthighp3(val)!=0)</span>
<span class="cp">#define Dblext_isnotzero_low31p3(val) (Dextlow31p3(val)!=0)</span>
<span class="cp">#define Dblext_iszero(valA,valB,valC,valD) (Dextallp1(valA)==0 &amp;&amp; \</span>
<span class="cp">    Dextallp2(valB)==0 &amp;&amp; Dextallp3(valC)==0 &amp;&amp; Dextallp4(valD)==0)</span>

<span class="cp">#define Dblext_copy(srca,srcb,srcc,srcd,desta,destb,destc,destd) \</span>
<span class="cp">    Dextallp1(desta) = Dextallp4(srca);	\</span>
<span class="cp">    Dextallp2(destb) = Dextallp4(srcb);	\</span>
<span class="cp">    Dextallp3(destc) = Dextallp4(srcc);	\</span>
<span class="cp">    Dextallp4(destd) = Dextallp4(srcd)</span>

<span class="cp">#define Dblext_swap_lower(leftp2,leftp3,leftp4,rightp2,rightp3,rightp4)  \</span>
<span class="cp">    Dextallp2(leftp2)  = Dextallp2(leftp2) XOR Dextallp2(rightp2);  \</span>
<span class="cp">    Dextallp2(rightp2) = Dextallp2(leftp2) XOR Dextallp2(rightp2);  \</span>
<span class="cp">    Dextallp2(leftp2)  = Dextallp2(leftp2) XOR Dextallp2(rightp2);  \</span>
<span class="cp">    Dextallp3(leftp3)  = Dextallp3(leftp3) XOR Dextallp3(rightp3);  \</span>
<span class="cp">    Dextallp3(rightp3) = Dextallp3(leftp3) XOR Dextallp3(rightp3);  \</span>
<span class="cp">    Dextallp3(leftp3)  = Dextallp3(leftp3) XOR Dextallp3(rightp3);  \</span>
<span class="cp">    Dextallp4(leftp4)  = Dextallp4(leftp4) XOR Dextallp4(rightp4);  \</span>
<span class="cp">    Dextallp4(rightp4) = Dextallp4(leftp4) XOR Dextallp4(rightp4);  \</span>
<span class="cp">    Dextallp4(leftp4)  = Dextallp4(leftp4) XOR Dextallp4(rightp4)</span>

<span class="cp">#define Dblext_setone_lowmantissap4(dbl_value) Deposit_dextlowp4(dbl_value,1)</span>

<span class="cm">/* The high bit is always zero so arithmetic or logical shifts will work. */</span>
<span class="cp">#define Dblext_right_align(srcdstA,srcdstB,srcdstC,srcdstD,shift) \</span>
<span class="cp">  {int shiftamt, sticky;						\</span>
<span class="cp">    shiftamt = shift % 32;						\</span>
<span class="cp">    sticky = 0;								\</span>
<span class="cp">    switch (shift/32) {							\</span>
<span class="cp">     case 0: if (shiftamt &gt; 0) {					\</span>
<span class="cp">	        sticky = Dextallp4(srcdstD) &lt;&lt; 32 - (shiftamt); 	\</span>
<span class="cp">                Variable_shift_double(Dextallp3(srcdstC),		\</span>
<span class="cp">		 Dextallp4(srcdstD),shiftamt,Dextallp4(srcdstD));	\</span>
<span class="cp">                Variable_shift_double(Dextallp2(srcdstB),		\</span>
<span class="cp">		 Dextallp3(srcdstC),shiftamt,Dextallp3(srcdstC));	\</span>
<span class="cp">                Variable_shift_double(Dextallp1(srcdstA),		\</span>
<span class="cp">		 Dextallp2(srcdstB),shiftamt,Dextallp2(srcdstB));	\</span>
<span class="cp">	        Dextallp1(srcdstA) &gt;&gt;= shiftamt;			\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     break;							\</span>
<span class="cp">     case 1: if (shiftamt &gt; 0) {					\</span>
<span class="cp">                sticky = (Dextallp3(srcdstC) &lt;&lt; 31 - shiftamt) |	\</span>
<span class="cp">			 Dextallp4(srcdstD);				\</span>
<span class="cp">                Variable_shift_double(Dextallp2(srcdstB),		\</span>
<span class="cp">		 Dextallp3(srcdstC),shiftamt,Dextallp4(srcdstD));	\</span>
<span class="cp">                Variable_shift_double(Dextallp1(srcdstA),		\</span>
<span class="cp">		 Dextallp2(srcdstB),shiftamt,Dextallp3(srcdstC));	\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     else {							\</span>
<span class="cp">		sticky = Dextallp4(srcdstD);				\</span>
<span class="cp">		Dextallp4(srcdstD) = Dextallp3(srcdstC);		\</span>
<span class="cp">		Dextallp3(srcdstC) = Dextallp2(srcdstB);		\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     Dextallp2(srcdstB) = Dextallp1(srcdstA) &gt;&gt; shiftamt;	\</span>
<span class="cp">	     Dextallp1(srcdstA) = 0;					\</span>
<span class="cp">	     break;							\</span>
<span class="cp">     case 2: if (shiftamt &gt; 0) {					\</span>
<span class="cp">                sticky = (Dextallp2(srcdstB) &lt;&lt; 31 - shiftamt) |	\</span>
<span class="cp">			 Dextallp3(srcdstC) | Dextallp4(srcdstD);	\</span>
<span class="cp">                Variable_shift_double(Dextallp1(srcdstA),		\</span>
<span class="cp">		 Dextallp2(srcdstB),shiftamt,Dextallp4(srcdstD));	\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     else {							\</span>
<span class="cp">		sticky = Dextallp3(srcdstC) | Dextallp4(srcdstD);	\</span>
<span class="cp">		Dextallp4(srcdstD) = Dextallp2(srcdstB);		\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     Dextallp3(srcdstC) = Dextallp1(srcdstA) &gt;&gt; shiftamt;	\</span>
<span class="cp">	     Dextallp1(srcdstA) = Dextallp2(srcdstB) = 0;		\</span>
<span class="cp">	     break;							\</span>
<span class="cp">     case 3: if (shiftamt &gt; 0) {					\</span>
<span class="cp">                sticky = (Dextallp1(srcdstA) &lt;&lt; 31 - shiftamt) |	\</span>
<span class="cp">			 Dextallp2(srcdstB) | Dextallp3(srcdstC) |	\</span>
<span class="cp">			 Dextallp4(srcdstD);				\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     else {							\</span>
<span class="cp">		sticky = Dextallp2(srcdstB) | Dextallp3(srcdstC) |	\</span>
<span class="cp">		    Dextallp4(srcdstD);					\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     Dextallp4(srcdstD) = Dextallp1(srcdstA) &gt;&gt; shiftamt;	\</span>
<span class="cp">	     Dextallp1(srcdstA) = Dextallp2(srcdstB) = 0;		\</span>
<span class="cp">	     Dextallp3(srcdstC) = 0;					\</span>
<span class="cp">	     break;							\</span>
<span class="cp">    }									\</span>
<span class="cp">    if (sticky) Dblext_setone_lowmantissap4(srcdstD);			\</span>
<span class="cp">  }</span>

<span class="cm">/* The left argument is never smaller than the right argument */</span>
<span class="cp">#define Dblext_subtract(lefta,leftb,leftc,leftd,righta,rightb,rightc,rightd,resulta,resultb,resultc,resultd) \</span>
<span class="cp">    if( Dextallp4(rightd) &gt; Dextallp4(leftd) ) 			\</span>
<span class="cp">	if( (Dextallp3(leftc)--) == 0)				\</span>
<span class="cp">	    if( (Dextallp2(leftb)--) == 0) Dextallp1(lefta)--;	\</span>
<span class="cp">    Dextallp4(resultd) = Dextallp4(leftd) - Dextallp4(rightd);	\</span>
<span class="cp">    if( Dextallp3(rightc) &gt; Dextallp3(leftc) ) 			\</span>
<span class="cp">        if( (Dextallp2(leftb)--) == 0) Dextallp1(lefta)--;	\</span>
<span class="cp">    Dextallp3(resultc) = Dextallp3(leftc) - Dextallp3(rightc);	\</span>
<span class="cp">    if( Dextallp2(rightb) &gt; Dextallp2(leftb) ) Dextallp1(lefta)--; \</span>
<span class="cp">    Dextallp2(resultb) = Dextallp2(leftb) - Dextallp2(rightb);	\</span>
<span class="cp">    Dextallp1(resulta) = Dextallp1(lefta) - Dextallp1(righta)</span>

<span class="cp">#define Dblext_addition(lefta,leftb,leftc,leftd,righta,rightb,rightc,rightd,resulta,resultb,resultc,resultd) \</span>
<span class="cp">    </span><span class="cm">/* If the sum of the low words is less than either source, then \</span>
<span class="cm">     * an overflow into the next word occurred. */</span><span class="cp"> \</span>
<span class="cp">    if ((Dextallp4(resultd) = Dextallp4(leftd)+Dextallp4(rightd)) &lt; \</span>
<span class="cp">	Dextallp4(rightd)) \</span>
<span class="cp">	if((Dextallp3(resultc) = Dextallp3(leftc)+Dextallp3(rightc)+1) &lt;= \</span>
<span class="cp">	    Dextallp3(rightc)) \</span>
<span class="cp">	    if((Dextallp2(resultb) = Dextallp2(leftb)+Dextallp2(rightb)+1) \</span>
<span class="cp">	        &lt;= Dextallp2(rightb))  \</span>
<span class="cp">		    Dextallp1(resulta) = Dextallp1(lefta)+Dextallp1(righta)+1; \</span>
<span class="cp">	    else Dextallp1(resulta) = Dextallp1(lefta)+Dextallp1(righta); \</span>
<span class="cp">	else \</span>
<span class="cp">	    if ((Dextallp2(resultb) = Dextallp2(leftb)+Dextallp2(rightb)) &lt; \</span>
<span class="cp">	        Dextallp2(rightb)) \</span>
<span class="cp">		    Dextallp1(resulta) = Dextallp1(lefta)+Dextallp1(righta)+1; \</span>
<span class="cp">	    else Dextallp1(resulta) = Dextallp1(lefta)+Dextallp1(righta); \</span>
<span class="cp">    else \</span>
<span class="cp">	if ((Dextallp3(resultc) = Dextallp3(leftc)+Dextallp3(rightc)) &lt; \</span>
<span class="cp">	    Dextallp3(rightc))  \</span>
<span class="cp">	    if ((Dextallp2(resultb) = Dextallp2(leftb)+Dextallp2(rightb)+1) \</span>
<span class="cp">	        &lt;= Dextallp2(rightb)) \</span>
<span class="cp">		    Dextallp1(resulta) = Dextallp1(lefta)+Dextallp1(righta)+1; \</span>
<span class="cp">	    else Dextallp1(resulta) = Dextallp1(lefta)+Dextallp1(righta); \</span>
<span class="cp">	else \</span>
<span class="cp">	    if ((Dextallp2(resultb) = Dextallp2(leftb)+Dextallp2(rightb)) &lt; \</span>
<span class="cp">	        Dextallp2(rightb)) \</span>
<span class="cp">		    Dextallp1(resulta) = Dextallp1(lefta)+Dextallp1(righta)+1; \</span>
<span class="cp">	    else Dextallp1(resulta) = Dextallp1(lefta)+Dextallp1(righta)</span>


<span class="cp">#define Dblext_arithrightshiftby1(srcdstA,srcdstB,srcdstC,srcdstD)	\</span>
<span class="cp">    Shiftdouble(Dextallp3(srcdstC),Dextallp4(srcdstD),1,Dextallp4(srcdstD)); \</span>
<span class="cp">    Shiftdouble(Dextallp2(srcdstB),Dextallp3(srcdstC),1,Dextallp3(srcdstC)); \</span>
<span class="cp">    Shiftdouble(Dextallp1(srcdstA),Dextallp2(srcdstB),1,Dextallp2(srcdstB)); \</span>
<span class="cp">    Dextallp1(srcdstA) = (int)Dextallp1(srcdstA) &gt;&gt; 1</span>
   
<span class="cp">#define Dblext_leftshiftby8(valA,valB,valC,valD) \</span>
<span class="cp">    Shiftdouble(Dextallp1(valA),Dextallp2(valB),24,Dextallp1(valA)); \</span>
<span class="cp">    Shiftdouble(Dextallp2(valB),Dextallp3(valC),24,Dextallp2(valB)); \</span>
<span class="cp">    Shiftdouble(Dextallp3(valC),Dextallp4(valD),24,Dextallp3(valC)); \</span>
<span class="cp">    Dextallp4(valD) &lt;&lt;= 8</span>
<span class="cp">#define Dblext_leftshiftby4(valA,valB,valC,valD) \</span>
<span class="cp">    Shiftdouble(Dextallp1(valA),Dextallp2(valB),28,Dextallp1(valA)); \</span>
<span class="cp">    Shiftdouble(Dextallp2(valB),Dextallp3(valC),28,Dextallp2(valB)); \</span>
<span class="cp">    Shiftdouble(Dextallp3(valC),Dextallp4(valD),28,Dextallp3(valC)); \</span>
<span class="cp">    Dextallp4(valD) &lt;&lt;= 4</span>
<span class="cp">#define Dblext_leftshiftby3(valA,valB,valC,valD) \</span>
<span class="cp">    Shiftdouble(Dextallp1(valA),Dextallp2(valB),29,Dextallp1(valA)); \</span>
<span class="cp">    Shiftdouble(Dextallp2(valB),Dextallp3(valC),29,Dextallp2(valB)); \</span>
<span class="cp">    Shiftdouble(Dextallp3(valC),Dextallp4(valD),29,Dextallp3(valC)); \</span>
<span class="cp">    Dextallp4(valD) &lt;&lt;= 3</span>
<span class="cp">#define Dblext_leftshiftby2(valA,valB,valC,valD) \</span>
<span class="cp">    Shiftdouble(Dextallp1(valA),Dextallp2(valB),30,Dextallp1(valA)); \</span>
<span class="cp">    Shiftdouble(Dextallp2(valB),Dextallp3(valC),30,Dextallp2(valB)); \</span>
<span class="cp">    Shiftdouble(Dextallp3(valC),Dextallp4(valD),30,Dextallp3(valC)); \</span>
<span class="cp">    Dextallp4(valD) &lt;&lt;= 2</span>
<span class="cp">#define Dblext_leftshiftby1(valA,valB,valC,valD) \</span>
<span class="cp">    Shiftdouble(Dextallp1(valA),Dextallp2(valB),31,Dextallp1(valA)); \</span>
<span class="cp">    Shiftdouble(Dextallp2(valB),Dextallp3(valC),31,Dextallp2(valB)); \</span>
<span class="cp">    Shiftdouble(Dextallp3(valC),Dextallp4(valD),31,Dextallp3(valC)); \</span>
<span class="cp">    Dextallp4(valD) &lt;&lt;= 1</span>

<span class="cp">#define Dblext_rightshiftby4(valueA,valueB,valueC,valueD) \</span>
<span class="cp">    Shiftdouble(Dextallp3(valueC),Dextallp4(valueD),4,Dextallp4(valueD)); \</span>
<span class="cp">    Shiftdouble(Dextallp2(valueB),Dextallp3(valueC),4,Dextallp3(valueC)); \</span>
<span class="cp">    Shiftdouble(Dextallp1(valueA),Dextallp2(valueB),4,Dextallp2(valueB)); \</span>
<span class="cp">    Dextallp1(valueA) &gt;&gt;= 4</span>
<span class="cp">#define Dblext_rightshiftby1(valueA,valueB,valueC,valueD) \</span>
<span class="cp">    Shiftdouble(Dextallp3(valueC),Dextallp4(valueD),1,Dextallp4(valueD)); \</span>
<span class="cp">    Shiftdouble(Dextallp2(valueB),Dextallp3(valueC),1,Dextallp3(valueC)); \</span>
<span class="cp">    Shiftdouble(Dextallp1(valueA),Dextallp2(valueB),1,Dextallp2(valueB)); \</span>
<span class="cp">    Dextallp1(valueA) &gt;&gt;= 1</span>

<span class="cp">#define Dblext_xortointp1(left,right,result) Dbl_xortointp1(left,right,result)</span>

<span class="cp">#define Dblext_xorfromintp1(left,right,result) \</span>
<span class="cp">	Dbl_xorfromintp1(left,right,result)</span>

<span class="cp">#define Dblext_copytoint_exponentmantissap1(src,dest) \</span>
<span class="cp">	Dbl_copytoint_exponentmantissap1(src,dest)</span>

<span class="cp">#define Dblext_ismagnitudeless(leftB,rightB,signlessleft,signlessright) \</span>
<span class="cp">	Dbl_ismagnitudeless(leftB,rightB,signlessleft,signlessright)</span>

<span class="cp">#define Dbl_copyto_dblext(src1,src2,dest1,dest2,dest3,dest4) \</span>
<span class="cp">	Dextallp1(dest1) = Dallp1(src1); Dextallp2(dest2) = Dallp2(src2); \</span>
<span class="cp">	Dextallp3(dest3) = 0; Dextallp4(dest4) = 0</span>

<span class="cp">#define Dblext_set_sign(dbl_value,sign)  Dbl_set_sign(dbl_value,sign)  </span>
<span class="cp">#define Dblext_clear_signexponent_set_hidden(srcdst) \</span>
<span class="cp">	Dbl_clear_signexponent_set_hidden(srcdst) </span>
<span class="cp">#define Dblext_clear_signexponent(srcdst) Dbl_clear_signexponent(srcdst) </span>
<span class="cp">#define Dblext_clear_sign(srcdst) Dbl_clear_sign(srcdst) </span>
<span class="cp">#define Dblext_isone_hidden(dbl_value) Dbl_isone_hidden(dbl_value) </span>

<span class="cm">/*</span>
<span class="cm"> * The Fourword_add() macro assumes that integers are 4 bytes in size.</span>
<span class="cm"> * It will break if this is not the case.</span>
<span class="cm"> */</span>

<span class="cp">#define Fourword_add(src1dstA,src1dstB,src1dstC,src1dstD,src2A,src2B,src2C,src2D) \</span>
<span class="cp">	</span><span class="cm">/* 								\</span>
<span class="cm">	 * want this macro to generate:					\</span>
<span class="cm">	 *	ADD	src1dstD,src2D,src1dstD;			\</span>
<span class="cm">	 *	ADDC	src1dstC,src2C,src1dstC;			\</span>
<span class="cm">	 *	ADDC	src1dstB,src2B,src1dstB;			\</span>
<span class="cm">	 *	ADDC	src1dstA,src2A,src1dstA;			\</span>
<span class="cm">	 */</span><span class="cp">								\</span>
<span class="cp">	if ((unsigned int)(src1dstD += (src2D)) &lt; (unsigned int)(src2D)) { \</span>
<span class="cp">	   if ((unsigned int)(src1dstC += (src2C) + 1) &lt;=		\</span>
<span class="cp">	       (unsigned int)(src2C)) {					\</span>
<span class="cp">	     if ((unsigned int)(src1dstB += (src2B) + 1) &lt;=		\</span>
<span class="cp">		 (unsigned int)(src2B)) src1dstA++;			\</span>
<span class="cp">	   }								\</span>
<span class="cp">	   else if ((unsigned int)(src1dstB += (src2B)) &lt; 		\</span>
<span class="cp">		    (unsigned int)(src2B)) src1dstA++;			\</span>
<span class="cp">	}								\</span>
<span class="cp">	else {								\</span>
<span class="cp">	   if ((unsigned int)(src1dstC += (src2C)) &lt;			\</span>
<span class="cp">	       (unsigned int)(src2C)) {					\</span>
<span class="cp">	      if ((unsigned int)(src1dstB += (src2B) + 1) &lt;=		\</span>
<span class="cp">		  (unsigned int)(src2B)) src1dstA++;			\</span>
<span class="cp">	   }								\</span>
<span class="cp">	   else if ((unsigned int)(src1dstB += (src2B)) &lt;		\</span>
<span class="cp">		    (unsigned int)(src2B)) src1dstA++;			\</span>
<span class="cp">	}								\</span>
<span class="cp">	src1dstA += (src2A)</span>

<span class="cp">#define Dblext_denormalize(opndp1,opndp2,opndp3,opndp4,exponent,is_tiny) \</span>
<span class="cp">  {int shiftamt, sticky;						\</span>
<span class="cp">    is_tiny = TRUE;							\</span>
<span class="cp">    if (exponent == 0 &amp;&amp; (Dextallp3(opndp3) || Dextallp4(opndp4))) {	\</span>
<span class="cp">	switch (Rounding_mode()) {					\</span>
<span class="cp">	case ROUNDPLUS:							\</span>
<span class="cp">		if (Dbl_iszero_sign(opndp1)) {				\</span>
<span class="cp">			Dbl_increment(opndp1,opndp2);			\</span>
<span class="cp">			if (Dbl_isone_hiddenoverflow(opndp1))		\</span>
<span class="cp">				is_tiny = FALSE;			\</span>
<span class="cp">			Dbl_decrement(opndp1,opndp2);			\</span>
<span class="cp">		}							\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case ROUNDMINUS:						\</span>
<span class="cp">		if (Dbl_isone_sign(opndp1)) {				\</span>
<span class="cp">			Dbl_increment(opndp1,opndp2);			\</span>
<span class="cp">			if (Dbl_isone_hiddenoverflow(opndp1))		\</span>
<span class="cp">				is_tiny = FALSE;			\</span>
<span class="cp">			Dbl_decrement(opndp1,opndp2);			\</span>
<span class="cp">		}							\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case ROUNDNEAREST:						\</span>
<span class="cp">		if (Dblext_isone_highp3(opndp3) &amp;&amp;			\</span>
<span class="cp">		    (Dblext_isone_lowp2(opndp2) || 			\</span>
<span class="cp">		     Dblext_isnotzero_low31p3(opndp3)))	{		\</span>
<span class="cp">			Dbl_increment(opndp1,opndp2);			\</span>
<span class="cp">			if (Dbl_isone_hiddenoverflow(opndp1))		\</span>
<span class="cp">				is_tiny = FALSE;			\</span>
<span class="cp">			Dbl_decrement(opndp1,opndp2);			\</span>
<span class="cp">		}							\</span>
<span class="cp">		break;							\</span>
<span class="cp">	}								\</span>
<span class="cp">    }									\</span>
<span class="cp">    Dblext_clear_signexponent_set_hidden(opndp1);			\</span>
<span class="cp">    if (exponent &gt;= (1-QUAD_P)) {					\</span>
<span class="cp">	shiftamt = (1-exponent) % 32;					\</span>
<span class="cp">	switch((1-exponent)/32) {					\</span>
<span class="cp">	  case 0: sticky = Dextallp4(opndp4) &lt;&lt; 32-(shiftamt);		\</span>
<span class="cp">		  Variableshiftdouble(opndp3,opndp4,shiftamt,opndp4);	\</span>
<span class="cp">		  Variableshiftdouble(opndp2,opndp3,shiftamt,opndp3);	\</span>
<span class="cp">		  Variableshiftdouble(opndp1,opndp2,shiftamt,opndp2);	\</span>
<span class="cp">		  Dextallp1(opndp1) &gt;&gt;= shiftamt;			\</span>
<span class="cp">		  break;						\</span>
<span class="cp">	  case 1: sticky = (Dextallp3(opndp3) &lt;&lt; 32-(shiftamt)) | 	\</span>
<span class="cp">			   Dextallp4(opndp4);				\</span>
<span class="cp">		  Variableshiftdouble(opndp2,opndp3,shiftamt,opndp4);	\</span>
<span class="cp">		  Variableshiftdouble(opndp1,opndp2,shiftamt,opndp3);	\</span>
<span class="cp">		  Dextallp2(opndp2) = Dextallp1(opndp1) &gt;&gt; shiftamt;	\</span>
<span class="cp">		  Dextallp1(opndp1) = 0;				\</span>
<span class="cp">		  break;						\</span>
<span class="cp">	  case 2: sticky = (Dextallp2(opndp2) &lt;&lt; 32-(shiftamt)) |	\</span>
<span class="cp">			    Dextallp3(opndp3) | Dextallp4(opndp4);	\</span>
<span class="cp">		  Variableshiftdouble(opndp1,opndp2,shiftamt,opndp4);	\</span>
<span class="cp">		  Dextallp3(opndp3) = Dextallp1(opndp1) &gt;&gt; shiftamt;	\</span>
<span class="cp">		  Dextallp1(opndp1) = Dextallp2(opndp2) = 0;		\</span>
<span class="cp">		  break;						\</span>
<span class="cp">	  case 3: sticky = (Dextallp1(opndp1) &lt;&lt; 32-(shiftamt)) |	\</span>
<span class="cp">		  	Dextallp2(opndp2) | Dextallp3(opndp3) | 	\</span>
<span class="cp">			Dextallp4(opndp4);				\</span>
<span class="cp">		  Dextallp4(opndp4) = Dextallp1(opndp1) &gt;&gt; shiftamt;	\</span>
<span class="cp">		  Dextallp1(opndp1) = Dextallp2(opndp2) = 0;		\</span>
<span class="cp">		  Dextallp3(opndp3) = 0;				\</span>
<span class="cp">		  break;						\</span>
<span class="cp">	}								\</span>
<span class="cp">    }									\</span>
<span class="cp">    else {								\</span>
<span class="cp">	sticky = Dextallp1(opndp1) | Dextallp2(opndp2) |		\</span>
<span class="cp">		 Dextallp3(opndp3) | Dextallp4(opndp4);			\</span>
<span class="cp">	Dblext_setzero(opndp1,opndp2,opndp3,opndp4);			\</span>
<span class="cp">    }									\</span>
<span class="cp">    if (sticky) Dblext_setone_lowmantissap4(opndp4);			\</span>
<span class="cp">    exponent = 0;							\</span>
<span class="cp">  }</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
