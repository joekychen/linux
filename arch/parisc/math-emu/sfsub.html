<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › math-emu › sfsub.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sfsub.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux/PA-RISC Project (http://www.parisc-linux.org/)</span>
<span class="cm"> *</span>
<span class="cm"> * Floating-point emulation code</span>
<span class="cm"> *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *    the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *    any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *    GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *    You should have received a copy of the GNU General Public License</span>
<span class="cm"> *    along with this program; if not, write to the Free Software</span>
<span class="cm"> *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * BEGIN_DESC</span>
<span class="cm"> *</span>
<span class="cm"> *  File:</span>
<span class="cm"> *	@(#)	pa/spmath/sfsub.c		$Revision: 1.1 $</span>
<span class="cm"> *</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *	Single_subtract: subtract two single precision values.</span>
<span class="cm"> *</span>
<span class="cm"> *  External Interfaces:</span>
<span class="cm"> *	sgl_fsub(leftptr, rightptr, dstptr, status)</span>
<span class="cm"> *</span>
<span class="cm"> *  Internal Interfaces:</span>
<span class="cm"> *</span>
<span class="cm"> *  Theory:</span>
<span class="cm"> *	&lt;&lt;please update with a overview of the operation of this file&gt;&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * END_DESC</span>
<span class="cm">*/</span>


<span class="cp">#include &quot;float.h&quot;</span>
<span class="cp">#include &quot;sgl_float.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Single_subtract: subtract two single precision values.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">sgl_fsub</span><span class="p">(</span>
	    <span class="n">sgl_floating_point</span> <span class="o">*</span><span class="n">leftptr</span><span class="p">,</span>
	    <span class="n">sgl_floating_point</span> <span class="o">*</span><span class="n">rightptr</span><span class="p">,</span>
	    <span class="n">sgl_floating_point</span> <span class="o">*</span><span class="n">dstptr</span><span class="p">,</span>
	    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">extent</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">signless_upper_left</span><span class="p">,</span> <span class="n">signless_upper_right</span><span class="p">,</span> <span class="n">save</span><span class="p">;</span>
    
    <span class="k">register</span> <span class="kt">int</span> <span class="n">result_exponent</span><span class="p">,</span> <span class="n">right_exponent</span><span class="p">,</span> <span class="n">diff_exponent</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">int</span> <span class="n">sign_save</span><span class="p">,</span> <span class="n">jumpsize</span><span class="p">;</span>
    <span class="k">register</span> <span class="n">boolean</span> <span class="n">inexact</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">underflowtrap</span><span class="p">;</span>
        
    <span class="cm">/* Create local copies of the numbers */</span>
    <span class="n">left</span> <span class="o">=</span> <span class="o">*</span><span class="n">leftptr</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="o">*</span><span class="n">rightptr</span><span class="p">;</span>

    <span class="cm">/* A zero &quot;save&quot; helps discover equal operands (for later),  *</span>
<span class="cm">     * and is used in swapping operands (if needed).             */</span>
    <span class="n">Sgl_xortointp1</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">save</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * check first operand for NaN&#39;s or infinity</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">result_exponent</span> <span class="o">=</span> <span class="n">Sgl_exponent</span><span class="p">(</span><span class="n">left</span><span class="p">))</span> <span class="o">==</span> <span class="n">SGL_INFINITY_EXPONENT</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">left</span><span class="p">))</span> 
	    <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isnotnan</span><span class="p">(</span><span class="n">right</span><span class="p">))</span> 
		<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">save</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> 
		    <span class="p">{</span>
		    <span class="cm">/* </span>
<span class="cm">		     * invalid since operands are same signed infinity&#39;s</span>
<span class="cm">		     */</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span> <span class="k">return</span><span class="p">(</span><span class="n">INVALIDEXCEPTION</span><span class="p">);</span>
                    <span class="n">Set_invalidflag</span><span class="p">();</span>
                    <span class="n">Sgl_makequietnan</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		    <span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		    <span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">	 	 * return infinity</span>
<span class="cm">	 	 */</span>
		<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	    <span class="p">}</span>
	<span class="k">else</span> 
	    <span class="p">{</span>
            <span class="cm">/*</span>
<span class="cm">             * is NaN; signaling or quiet?</span>
<span class="cm">             */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_signaling</span><span class="p">(</span><span class="n">left</span><span class="p">))</span> 
		<span class="p">{</span>
               	<span class="cm">/* trap if INVALIDTRAP enabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span> <span class="k">return</span><span class="p">(</span><span class="n">INVALIDEXCEPTION</span><span class="p">);</span>
        	<span class="cm">/* make NaN quiet */</span>
        	<span class="n">Set_invalidflag</span><span class="p">();</span>
        	<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
        	<span class="p">}</span>
	    <span class="cm">/* </span>
<span class="cm">	     * is second operand a signaling NaN? </span>
<span class="cm">	     */</span>
	    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_is_signalingnan</span><span class="p">(</span><span class="n">right</span><span class="p">))</span> 
		<span class="p">{</span>
        	<span class="cm">/* trap if INVALIDTRAP enabled */</span>
               	<span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span> <span class="k">return</span><span class="p">(</span><span class="n">INVALIDEXCEPTION</span><span class="p">);</span>
		<span class="cm">/* make NaN quiet */</span>
		<span class="n">Set_invalidflag</span><span class="p">();</span>
		<span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	    <span class="cm">/*</span>
<span class="cm"> 	     * return quiet NaN</span>
<span class="cm"> 	     */</span>
 	    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
 	    <span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
	    <span class="p">}</span>
	<span class="p">}</span> <span class="cm">/* End left NaN or Infinity processing */</span>
    <span class="cm">/*</span>
<span class="cm">     * check second operand for NaN&#39;s or infinity</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isinfinity_exponent</span><span class="p">(</span><span class="n">right</span><span class="p">))</span> 
	<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">right</span><span class="p">))</span> 
	    <span class="p">{</span>
	    <span class="cm">/* return infinity */</span>
	    <span class="n">Sgl_invert_sign</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
	    <span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
	    <span class="p">}</span>
        <span class="cm">/*</span>
<span class="cm">         * is NaN; signaling or quiet?</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Sgl_isone_signaling</span><span class="p">(</span><span class="n">right</span><span class="p">))</span> 
	    <span class="p">{</span>
            <span class="cm">/* trap if INVALIDTRAP enabled */</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">Is_invalidtrap_enabled</span><span class="p">())</span> <span class="k">return</span><span class="p">(</span><span class="n">INVALIDEXCEPTION</span><span class="p">);</span>
	    <span class="cm">/* make NaN quiet */</span>
	    <span class="n">Set_invalidflag</span><span class="p">();</span>
	    <span class="n">Sgl_set_quiet</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	    <span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * return quiet NaN</span>
<span class="cm"> 	 */</span>
	<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
    	<span class="p">}</span> <span class="cm">/* End right NaN or Infinity processing */</span>

    <span class="cm">/* Invariant: Must be dealing with finite numbers */</span>

    <span class="cm">/* Compare operands by removing the sign */</span>
    <span class="n">Sgl_copytoint_exponentmantissa</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">signless_upper_left</span><span class="p">);</span>
    <span class="n">Sgl_copytoint_exponentmantissa</span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="n">signless_upper_right</span><span class="p">);</span>

    <span class="cm">/* sign difference selects sub or add operation. */</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Sgl_ismagnitudeless</span><span class="p">(</span><span class="n">signless_upper_left</span><span class="p">,</span><span class="n">signless_upper_right</span><span class="p">))</span>
	<span class="p">{</span>
	<span class="cm">/* Set the left operand to the larger one by XOR swap *</span>
<span class="cm">	 *  First finish the first word using &quot;save&quot;          */</span>
	<span class="n">Sgl_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">right</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">right</span><span class="p">);</span>
	<span class="n">Sgl_xorfromintp1</span><span class="p">(</span><span class="n">save</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">left</span><span class="p">);</span>
	<span class="n">result_exponent</span> <span class="o">=</span> <span class="n">Sgl_exponent</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="n">Sgl_invert_sign</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="cm">/* Invariant:  left is not smaller than right. */</span> 

    <span class="k">if</span><span class="p">((</span><span class="n">right_exponent</span> <span class="o">=</span> <span class="n">Sgl_exponent</span><span class="p">(</span><span class="n">right</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
	<span class="cm">/* Denormalized operands.  First look for zeroes */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">right</span><span class="p">))</span> 
	    <span class="p">{</span>
	    <span class="cm">/* right is zero */</span>
	    <span class="k">if</span><span class="p">(</span><span class="n">Sgl_iszero_exponentmantissa</span><span class="p">(</span><span class="n">left</span><span class="p">))</span>
		<span class="p">{</span>
		<span class="cm">/* Both operands are zeros */</span>
		<span class="n">Sgl_invert_sign</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span>
		    <span class="p">{</span>
		    <span class="n">Sgl_or_signs</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="cm">/*with*/</span><span class="n">right</span><span class="p">);</span>
		    <span class="p">}</span>
		<span class="k">else</span>
		    <span class="p">{</span>
		    <span class="n">Sgl_and_signs</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="cm">/*with*/</span><span class="n">right</span><span class="p">);</span>
		    <span class="p">}</span>
		<span class="p">}</span>
	    <span class="k">else</span> 
		<span class="p">{</span>
		<span class="cm">/* Left is not a zero and must be the result.  Trapped</span>
<span class="cm">		 * underflows are signaled if left is denormalized.  Result</span>
<span class="cm">		 * is always exact. */</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">result_exponent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Is_underflowtrap_enabled</span><span class="p">()</span> <span class="p">)</span>
		    <span class="p">{</span>
		    <span class="cm">/* need to normalize results mantissa */</span>
	    	    <span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		    <span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		    <span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
		    <span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                    <span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">unfl</span><span class="p">);</span>
		    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
		    <span class="cm">/* inexact = FALSE */</span>
		    <span class="k">return</span><span class="p">(</span><span class="n">UNDERFLOWEXCEPTION</span><span class="p">);</span>
		    <span class="p">}</span>
		<span class="p">}</span>
	    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
	    <span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
	    <span class="p">}</span>

	<span class="cm">/* Neither are zeroes */</span>
	<span class="n">Sgl_clear_sign</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>	<span class="cm">/* Exponent is already cleared */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">result_exponent</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
	    <span class="p">{</span>
	    <span class="cm">/* Both operands are denormalized.  The result must be exact</span>
<span class="cm">	     * and is simply calculated.  A sum could become normalized and a</span>
<span class="cm">	     * difference could cancel to a true zero. */</span>
	    <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="cm">/*signed*/</span><span class="kt">int</span><span class="p">)</span> <span class="n">save</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="p">{</span>
		<span class="n">Sgl_subtract</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="cm">/*minus*/</span><span class="n">right</span><span class="p">,</span><span class="cm">/*into*/</span><span class="n">result</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Sgl_iszero_mantissa</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		    <span class="p">{</span>
		    <span class="k">if</span><span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span>
			<span class="p">{</span>
			<span class="n">Sgl_setone_sign</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
			<span class="p">}</span>
		    <span class="k">else</span>
			<span class="p">{</span>
			<span class="n">Sgl_setzero_sign</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
			<span class="p">}</span>
		    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		    <span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		    <span class="p">}</span>
		<span class="p">}</span>
	    <span class="k">else</span>
		<span class="p">{</span>
		<span class="n">Sgl_addition</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">,</span><span class="cm">/*into*/</span><span class="n">result</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Sgl_isone_hidden</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		    <span class="p">{</span>
		    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		    <span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		    <span class="p">}</span>
		<span class="p">}</span>
	    <span class="k">if</span><span class="p">(</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span>
		<span class="p">{</span>
		<span class="cm">/* need to normalize result */</span>
	    	<span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="n">Sgl_normalize</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
		<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
                <span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">unfl</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		<span class="cm">/* inexact = FALSE */</span>
		<span class="k">return</span><span class="p">(</span><span class="n">UNDERFLOWEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	    <span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
	    <span class="p">}</span>
	<span class="n">right_exponent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Set exponent to reflect different bias</span>
<span class="cm">				 * with denomalized numbers. */</span>
	<span class="p">}</span>
    <span class="k">else</span>
	<span class="p">{</span>
	<span class="n">Sgl_clear_signexponent_set_hidden</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="n">Sgl_clear_exponent_set_hidden</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
    <span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">result_exponent</span> <span class="o">-</span> <span class="n">right_exponent</span><span class="p">;</span>

    <span class="cm">/* </span>
<span class="cm">     * Special case alignment of operands that would force alignment </span>
<span class="cm">     * beyond the extent of the extension.  A further optimization</span>
<span class="cm">     * could special case this but only reduces the path length for this</span>
<span class="cm">     * infrequent case.</span>
<span class="cm">     */</span>
    <span class="k">if</span><span class="p">(</span><span class="n">diff_exponent</span> <span class="o">&gt;</span> <span class="n">SGL_THRESHOLD</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="n">diff_exponent</span> <span class="o">=</span> <span class="n">SGL_THRESHOLD</span><span class="p">;</span>
	<span class="p">}</span>
    
    <span class="cm">/* Align right operand by shifting to right */</span>
    <span class="n">Sgl_right_align</span><span class="p">(</span><span class="cm">/*operand*/</span><span class="n">right</span><span class="p">,</span><span class="cm">/*shifted by*/</span><span class="n">diff_exponent</span><span class="p">,</span>
      <span class="cm">/*and lower to*/</span><span class="n">extent</span><span class="p">);</span>

    <span class="cm">/* Treat sum and difference of the operands separately. */</span>
    <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="cm">/*signed*/</span><span class="kt">int</span><span class="p">)</span> <span class="n">save</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
	<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Difference of the two operands.  Their can be no overflow.  A</span>
<span class="cm">	 * borrow can occur out of the hidden bit and force a post</span>
<span class="cm">	 * normalization phase.</span>
<span class="cm">	 */</span>
	<span class="n">Sgl_subtract_withextension</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="cm">/*minus*/</span><span class="n">right</span><span class="p">,</span><span class="cm">/*with*/</span><span class="n">extent</span><span class="p">,</span><span class="cm">/*into*/</span><span class="n">result</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Sgl_iszero_hidden</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
	    <span class="p">{</span>
	    <span class="cm">/* Handle normalization */</span>
	    <span class="cm">/* A straightforward algorithm would now shift the result</span>
<span class="cm">	     * and extension left until the hidden bit becomes one.  Not</span>
<span class="cm">	     * all of the extension bits need participate in the shift.</span>
<span class="cm">	     * Only the two most significant bits (round and guard) are</span>
<span class="cm">	     * needed.  If only a single shift is needed then the guard</span>
<span class="cm">	     * bit becomes a significant low order bit and the extension</span>
<span class="cm">	     * must participate in the rounding.  If more than a single </span>
<span class="cm">	     * shift is needed, then all bits to the right of the guard </span>
<span class="cm">	     * bit are zeros, and the guard bit may or may not be zero. */</span>
	    <span class="n">sign_save</span> <span class="o">=</span> <span class="n">Sgl_signextendedsign</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="n">Sgl_leftshiftby1_withextent</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">extent</span><span class="p">,</span><span class="n">result</span><span class="p">);</span>

            <span class="cm">/* Need to check for a zero result.  The sign and exponent</span>
<span class="cm">	     * fields have already been zeroed.  The more efficient test</span>
<span class="cm">	     * of the full object can be used.</span>
<span class="cm">	     */</span>
    	    <span class="k">if</span><span class="p">(</span><span class="n">Sgl_iszero</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		<span class="cm">/* Must have been &quot;x-x&quot; or &quot;x+(-x)&quot;. */</span>
		<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Is_rounding_mode</span><span class="p">(</span><span class="n">ROUNDMINUS</span><span class="p">))</span> <span class="n">Sgl_setone_sign</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	    <span class="n">result_exponent</span><span class="o">--</span><span class="p">;</span>
	    <span class="cm">/* Look to see if normalization is finished. */</span>
	    <span class="k">if</span><span class="p">(</span><span class="n">Sgl_isone_hidden</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">result_exponent</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		    <span class="p">{</span>
		    <span class="cm">/* Denormalized, exponent should be zero.  Left operand *</span>
<span class="cm"> 		     * was normalized, so extent (guard, round) was zero    */</span>
		    <span class="k">goto</span> <span class="n">underflow</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="k">else</span>
		    <span class="p">{</span>
		    <span class="cm">/* No further normalization is needed. */</span>
		    <span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
	    	    <span class="n">Ext_leftshiftby1</span><span class="p">(</span><span class="n">extent</span><span class="p">);</span>
		    <span class="k">goto</span> <span class="n">round</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="p">}</span>

	    <span class="cm">/* Check for denormalized, exponent should be zero.  Left    *</span>
<span class="cm">	     * operand was normalized, so extent (guard, round) was zero */</span>
	    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">underflowtrap</span> <span class="o">=</span> <span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
	       <span class="n">result_exponent</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">underflow</span><span class="p">;</span>

	    <span class="cm">/* Shift extension to complete one bit of normalization and</span>
<span class="cm">	     * update exponent. */</span>
	    <span class="n">Ext_leftshiftby1</span><span class="p">(</span><span class="n">extent</span><span class="p">);</span>

	    <span class="cm">/* Discover first one bit to determine shift amount.  Use a</span>
<span class="cm">	     * modified binary search.  We have already shifted the result</span>
<span class="cm">	     * one position right and still not found a one so the remainder</span>
<span class="cm">	     * of the extension must be zero and simplifies rounding. */</span>
	    <span class="cm">/* Scan bytes */</span>
	    <span class="k">while</span><span class="p">(</span><span class="n">Sgl_iszero_hiddenhigh7mantissa</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		<span class="p">{</span>
		<span class="n">Sgl_leftshiftby8</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="k">if</span><span class="p">((</span><span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">underflowtrap</span><span class="p">)</span>
		    <span class="k">goto</span> <span class="n">underflow</span><span class="p">;</span>
		<span class="p">}</span>
	    <span class="cm">/* Now narrow it down to the nibble */</span>
	    <span class="k">if</span><span class="p">(</span><span class="n">Sgl_iszero_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		<span class="p">{</span>
		<span class="cm">/* The lower nibble contains the normalizing one */</span>
		<span class="n">Sgl_leftshiftby4</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="k">if</span><span class="p">((</span><span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">underflowtrap</span><span class="p">)</span>
		    <span class="k">goto</span> <span class="n">underflow</span><span class="p">;</span>
		<span class="p">}</span>
	    <span class="cm">/* Select case were first bit is set (already normalized)</span>
<span class="cm">	     * otherwise select the proper shift. */</span>
	    <span class="k">if</span><span class="p">((</span><span class="n">jumpsize</span> <span class="o">=</span> <span class="n">Sgl_hiddenhigh3mantissa</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="cm">/* Already normalized */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">result_exponent</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">underflow</span><span class="p">;</span>
		<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
		<span class="n">Sgl_set_exponent</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">result_exponent</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	    <span class="n">Sgl_sethigh4bits</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">sign_save</span><span class="p">);</span>
	    <span class="k">switch</span><span class="p">(</span><span class="n">jumpsize</span><span class="p">)</span> 
		<span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
		    <span class="p">{</span>
		    <span class="n">Sgl_leftshiftby3</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		    <span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
		    <span class="k">break</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">case</span> <span class="mi">3</span>:
		    <span class="p">{</span>
		    <span class="n">Sgl_leftshiftby2</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		    <span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		    <span class="k">break</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">case</span> <span class="mi">5</span>:
		<span class="k">case</span> <span class="mi">6</span>:
		<span class="k">case</span> <span class="mi">7</span>:
		    <span class="p">{</span>
		    <span class="n">Sgl_leftshiftby1</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		    <span class="n">result_exponent</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		    <span class="k">break</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="p">}</span>
	    <span class="k">if</span><span class="p">(</span><span class="n">result_exponent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> 
		<span class="p">{</span>
		<span class="n">Sgl_set_exponent</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="cm">/*using*/</span><span class="n">result_exponent</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>	<span class="cm">/* Sign bit is already set */</span>
		<span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	    <span class="cm">/* Fixup potential underflows */</span>
	  <span class="nl">underflow:</span>
	    <span class="k">if</span><span class="p">(</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span>
		<span class="p">{</span>
		<span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">sign_save</span><span class="p">);</span>
                <span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">unfl</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		<span class="cm">/* inexact = FALSE */</span>
		<span class="k">return</span><span class="p">(</span><span class="n">UNDERFLOWEXCEPTION</span><span class="p">);</span>
		<span class="p">}</span>
	    <span class="cm">/*</span>
<span class="cm">	     * Since we cannot get an inexact denormalized result,</span>
<span class="cm">	     * we can now return.</span>
<span class="cm">	     */</span>
	    <span class="n">Sgl_right_align</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="cm">/*by*/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">result_exponent</span><span class="p">),</span><span class="n">extent</span><span class="p">);</span>
	    <span class="n">Sgl_clear_signexponent</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
	    <span class="n">Sgl_set_sign</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">sign_save</span><span class="p">);</span>
	    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	    <span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
	    <span class="p">}</span> <span class="cm">/* end if(hidden...)... */</span>
	<span class="cm">/* Fall through and round */</span>
	<span class="p">}</span> <span class="cm">/* end if(save &gt;= 0)... */</span>
    <span class="k">else</span> 
	<span class="p">{</span>
	<span class="cm">/* Add magnitudes */</span>
	<span class="n">Sgl_addition</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">,</span><span class="cm">/*to*/</span><span class="n">result</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Sgl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
	    <span class="p">{</span>
	    <span class="cm">/* Prenormalization required. */</span>
	    <span class="n">Sgl_rightshiftby1_withextent</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">extent</span><span class="p">,</span><span class="n">extent</span><span class="p">);</span>
	    <span class="n">Sgl_arithrightshiftby1</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
	    <span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
	    <span class="p">}</span> <span class="cm">/* end if hiddenoverflow... */</span>
	<span class="p">}</span> <span class="cm">/* end else ...sub magnitudes... */</span>
    
    <span class="cm">/* Round the result.  If the extension is all zeros,then the result is</span>
<span class="cm">     * exact.  Otherwise round in the correct direction.  No underflow is</span>
<span class="cm">     * possible. If a postnormalization is necessary, then the mantissa is</span>
<span class="cm">     * all zeros so no shift is needed. */</span>
  <span class="nl">round:</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Ext_isnotzero</span><span class="p">(</span><span class="n">extent</span><span class="p">))</span>
	<span class="p">{</span>
	<span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">Rounding_mode</span><span class="p">())</span>
	    <span class="p">{</span>
	    <span class="k">case</span> <span class="n">ROUNDNEAREST</span>: <span class="cm">/* The default. */</span>
	    <span class="k">if</span><span class="p">(</span><span class="n">Ext_isone_sign</span><span class="p">(</span><span class="n">extent</span><span class="p">))</span>
		<span class="p">{</span>
		<span class="cm">/* at least 1/2 ulp */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">Ext_isnotzero_lower</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span>  <span class="o">||</span>
		  <span class="n">Sgl_isone_lowmantissa</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		    <span class="p">{</span>
		    <span class="cm">/* either exactly half way and odd or more than 1/2ulp */</span>
		    <span class="n">Sgl_increment</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		    <span class="p">}</span>
		<span class="p">}</span>
	    <span class="k">break</span><span class="p">;</span>

	    <span class="k">case</span> <span class="n">ROUNDPLUS</span>:
	    <span class="k">if</span><span class="p">(</span><span class="n">Sgl_iszero_sign</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		<span class="p">{</span>
		<span class="cm">/* Round up positive results */</span>
		<span class="n">Sgl_increment</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="p">}</span>
	    <span class="k">break</span><span class="p">;</span>
	    
	    <span class="k">case</span> <span class="n">ROUNDMINUS</span>:
	    <span class="k">if</span><span class="p">(</span><span class="n">Sgl_isone_sign</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		<span class="p">{</span>
		<span class="cm">/* Round down negative results */</span>
		<span class="n">Sgl_increment</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="p">}</span>
	    
	    <span class="k">case</span> <span class="n">ROUNDZERO</span>:<span class="p">;</span>
	    <span class="cm">/* truncate is simple */</span>
	    <span class="p">}</span> <span class="cm">/* end switch... */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Sgl_isone_hiddenoverflow</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="n">result_exponent</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">result_exponent</span> <span class="o">==</span> <span class="n">SGL_INFINITY_EXPONENT</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="cm">/* Overflow */</span>
        <span class="k">if</span><span class="p">(</span><span class="n">Is_overflowtrap_enabled</span><span class="p">())</span>
	    <span class="p">{</span>
	    <span class="n">Sgl_setwrapped_exponent</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">,</span><span class="n">ovfl</span><span class="p">);</span>
	    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span>
		    <span class="k">return</span><span class="p">(</span><span class="n">OVERFLOWEXCEPTION</span> <span class="o">|</span> <span class="n">INEXACTEXCEPTION</span><span class="p">);</span>
		<span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
	    <span class="k">return</span><span class="p">(</span><span class="n">OVERFLOWEXCEPTION</span><span class="p">);</span>
	    <span class="p">}</span>
        <span class="k">else</span>
	    <span class="p">{</span>
	    <span class="n">Set_overflowflag</span><span class="p">();</span>
	    <span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	    <span class="n">Sgl_setoverflow</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="k">else</span> <span class="n">Sgl_set_exponent</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">result_exponent</span><span class="p">);</span>
    <span class="o">*</span><span class="n">dstptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">inexact</span><span class="p">)</span> 
	<span class="k">if</span><span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span> <span class="k">return</span><span class="p">(</span><span class="n">INEXACTEXCEPTION</span><span class="p">);</span>
	<span class="k">else</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
    <span class="k">return</span><span class="p">(</span><span class="n">NOEXCEPTION</span><span class="p">);</span>
    <span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
