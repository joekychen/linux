<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › math-emu › decode_exc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>decode_exc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux/PA-RISC Project (http://www.parisc-linux.org/)</span>
<span class="cm"> *</span>
<span class="cm"> * Floating-point emulation code</span>
<span class="cm"> *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *    the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *    any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *    GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *    You should have received a copy of the GNU General Public License</span>
<span class="cm"> *    along with this program; if not, write to the Free Software</span>
<span class="cm"> *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * BEGIN_DESC</span>
<span class="cm"> *</span>
<span class="cm"> *  File:</span>
<span class="cm"> *	@(#)	pa/fp/decode_exc.c		$ Revision: $</span>
<span class="cm"> *</span>
<span class="cm"> *  Purpose:</span>
<span class="cm"> *	&lt;&lt;please update with a synopsis of the functionality provided by this file&gt;&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  External Interfaces:</span>
<span class="cm"> *	&lt;&lt;the following list was autogenerated, please review&gt;&gt;</span>
<span class="cm"> *	decode_fpu(Fpu_register, trap_counts)</span>
<span class="cm"> *</span>
<span class="cm"> *  Internal Interfaces:</span>
<span class="cm"> *	&lt;&lt;please update&gt;&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Theory:</span>
<span class="cm"> *	&lt;&lt;please update with a overview of the operation of this file&gt;&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * END_DESC</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &quot;float.h&quot;</span>
<span class="cp">#include &quot;sgl_float.h&quot;</span>
<span class="cp">#include &quot;dbl_float.h&quot;</span>
<span class="cp">#include &quot;cnv_float.h&quot;</span>
<span class="cm">/* #include &quot;types.h&quot; */</span>
<span class="cp">#include &lt;asm/signal.h&gt;</span>
<span class="cp">#include &lt;asm/siginfo.h&gt;</span>
<span class="cm">/* #include &lt;machine/sys/mdep_private.h&gt; */</span>

<span class="cp">#undef Fpustatus_register</span>
<span class="cp">#define Fpustatus_register Fpu_register[0]</span>

<span class="cm">/* General definitions */</span>
<span class="cp">#define DOESTRAP 1</span>
<span class="cp">#define NOTRAP 0</span>
<span class="cp">#define SIGNALCODE(signal, code) ((signal) &lt;&lt; 24 | (code))</span>
<span class="cp">#define copropbit	1&lt;&lt;31-2	</span><span class="cm">/* bit position 2 */</span><span class="cp"></span>
<span class="cp">#define opclass		9	</span><span class="cm">/* bits 21 &amp; 22 */</span><span class="cp"></span>
<span class="cp">#define fmt		11	</span><span class="cm">/* bits 19 &amp; 20 */</span><span class="cp"></span>
<span class="cp">#define df		13	</span><span class="cm">/* bits 17 &amp; 18 */</span><span class="cp"></span>
<span class="cp">#define twobits		3	</span><span class="cm">/* mask low-order 2 bits */</span><span class="cp"></span>
<span class="cp">#define fivebits	31	</span><span class="cm">/* mask low-order 5 bits */</span><span class="cp"></span>
<span class="cp">#define MAX_EXCP_REG	7	</span><span class="cm">/* number of excpeption registers to check */</span><span class="cp"></span>

<span class="cm">/* Exception register definitions */</span>
<span class="cp">#define Excp_type(index) Exceptiontype(Fpu_register[index])</span>
<span class="cp">#define Excp_instr(index) Instructionfield(Fpu_register[index])</span>
<span class="cp">#define Clear_excp_register(index) Allexception(Fpu_register[index]) = 0</span>
<span class="cp">#define Excp_format() \</span>
<span class="cp">    (current_ir &gt;&gt; ((current_ir&gt;&gt;opclass &amp; twobits)==1 ? df : fmt) &amp; twobits)</span>

<span class="cm">/* Miscellaneous definitions */</span>
<span class="cp">#define Fpu_sgl(index) Fpu_register[index*2]</span>

<span class="cp">#define Fpu_dblp1(index) Fpu_register[index*2]</span>
<span class="cp">#define Fpu_dblp2(index) Fpu_register[(index*2)+1]</span>

<span class="cp">#define Fpu_quadp1(index) Fpu_register[index*2]</span>
<span class="cp">#define Fpu_quadp2(index) Fpu_register[(index*2)+1]</span>
<span class="cp">#define Fpu_quadp3(index) Fpu_register[(index*2)+2]</span>
<span class="cp">#define Fpu_quadp4(index) Fpu_register[(index*2)+3]</span>

<span class="cm">/* Single precision floating-point definitions */</span>
<span class="cp">#ifndef Sgl_decrement</span>
<span class="cp"># define Sgl_decrement(sgl_value) Sall(sgl_value)--</span>
<span class="cp">#endif</span>

<span class="cm">/* Double precision floating-point definitions */</span>
<span class="cp">#ifndef Dbl_decrement</span>
<span class="cp"># define Dbl_decrement(dbl_valuep1,dbl_valuep2) \</span>
<span class="cp">    if ((Dallp2(dbl_valuep2)--) == 0) Dallp1(dbl_valuep1)-- </span>
<span class="cp">#endif</span>


<span class="cp">#define update_trap_counts(Fpu_register, aflags, bflags, trap_counts) {	\</span>
<span class="cp">	aflags=(Fpu_register[0])&gt;&gt;27;	</span><span class="cm">/* assumes zero fill. 32 bit */</span><span class="cp">	\</span>
<span class="cp">	Fpu_register[0] |= bflags;					\</span>
<span class="cp">}</span>

<span class="n">u_int</span>
<span class="nf">decode_fpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Fpu_register</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trap_counts</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_ir</span><span class="p">,</span> <span class="n">excp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">exception_index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">boolean</span> <span class="n">inexact</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">aflags</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bflags</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">excptype</span><span class="p">;</span>


    <span class="cm">/* Keep stats on how many floating point exceptions (based on type)</span>
<span class="cm">     * that happen.  Want to keep this overhead low, but still provide</span>
<span class="cm">     * some information to the customer.  All exits from this routine</span>
<span class="cm">     * need to restore Fpu_register[0]</span>
<span class="cm">    */</span>

    <span class="n">bflags</span><span class="o">=</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf8000000</span><span class="p">);</span>
    <span class="n">Fpu_register</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0x07ffffff</span><span class="p">;</span>

    <span class="cm">/* exception_index is used to index the exception register queue.  It</span>
<span class="cm">     *   always points at the last register that contains a valid exception.  A</span>
<span class="cm">     *   zero value implies no exceptions (also the initialized value).  Setting</span>
<span class="cm">     *   the T-bit resets the exception_index to zero.</span>
<span class="cm">     */</span>

    <span class="cm">/*</span>
<span class="cm">     * Check for reserved-op exception.  A reserved-op exception does not </span>
<span class="cm">     * set any exception registers nor does it set the T-bit.  If the T-bit</span>
<span class="cm">     * is not set then a reserved-op exception occurred.</span>
<span class="cm">     *</span>
<span class="cm">     * At some point, we may want to report reserved op exceptions as</span>
<span class="cm">     * illegal instructions.</span>
<span class="cm">     */</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Is_tbit_set</span><span class="p">())</span> <span class="p">{</span>
	<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> <span class="n">trap_counts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">ILL_COPROC</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* </span>
<span class="cm">     * Is a coprocessor op. </span>
<span class="cm">     *</span>
<span class="cm">     * Now we need to determine what type of exception occurred.</span>
<span class="cm">     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">exception_index</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">exception_index</span><span class="o">&lt;=</span><span class="n">MAX_EXCP_REG</span><span class="p">;</span> <span class="n">exception_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">current_ir</span> <span class="o">=</span> <span class="n">Excp_instr</span><span class="p">(</span><span class="n">exception_index</span><span class="p">);</span>
	  <span class="cm">/*</span>
<span class="cm">	   * On PA89: there are 5 different unimplemented exception</span>
<span class="cm">	   * codes: 0x1, 0x9, 0xb, 0x3, and 0x23.  PA-RISC 2.0 adds</span>
<span class="cm">	   * another, 0x2b.  Only these have the low order bit set.</span>
<span class="cm">	   */</span>
	<span class="n">excptype</span> <span class="o">=</span> <span class="n">Excp_type</span><span class="p">(</span><span class="n">exception_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">excptype</span> <span class="o">&amp;</span> <span class="n">UNIMPLEMENTEDEXCEPTION</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear T-bit and exception register so that</span>
<span class="cm">		 * we can tell if a trap really occurs while </span>
<span class="cm">		 * emulating the instruction.</span>
<span class="cm">		 */</span>
		<span class="n">Clear_tbit</span><span class="p">();</span>
		<span class="n">Clear_excp_register</span><span class="p">(</span><span class="n">exception_index</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now emulate this instruction.  If a trap occurs,</span>
<span class="cm">		 * fpudispatch will return a non-zero number </span>
<span class="cm">		 */</span>
		<span class="n">excp</span> <span class="o">=</span> <span class="n">fpudispatch</span><span class="p">(</span><span class="n">current_ir</span><span class="p">,</span><span class="n">excptype</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">Fpu_register</span><span class="p">);</span>
		<span class="cm">/* accumulate the status flags, don&#39;t lose them as in hpux */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">excp</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We now need to make sure that the T-bit and the</span>
<span class="cm">			 * exception register contain the correct values</span>
<span class="cm">			 * before continuing.</span>
<span class="cm">			 */</span>
			<span class="cm">/*</span>
<span class="cm">			 * Set t-bit since it might still be needed for a</span>
<span class="cm">			 * subsequent real trap (I don&#39;t understand fully -PB)</span>
<span class="cm">			 */</span>
			<span class="n">Set_tbit</span><span class="p">();</span>
			<span class="cm">/* some of the following code uses</span>
<span class="cm">			 * Excp_type(exception_index) so fix that up */</span>
			<span class="n">Set_exceptiontype_and_instr_field</span><span class="p">(</span><span class="n">excp</span><span class="p">,</span><span class="n">current_ir</span><span class="p">,</span>
			 <span class="n">Fpu_register</span><span class="p">[</span><span class="n">exception_index</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">excp</span> <span class="o">==</span> <span class="n">UNIMPLEMENTEDEXCEPTION</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">			 	 * it is really unimplemented, so restore the</span>
<span class="cm">			 	 * TIMEX extended unimplemented exception code</span>
<span class="cm">			 	 */</span>
				<span class="n">excp</span> <span class="o">=</span> <span class="n">excptype</span><span class="p">;</span>
				<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> 
					   <span class="n">trap_counts</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">ILL_COPROC</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* some of the following code uses excptype, so</span>
<span class="cm">			 * fix that up too */</span>
			<span class="n">excptype</span> <span class="o">=</span> <span class="n">excp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* handle exceptions other than the real UNIMPLIMENTED the</span>
<span class="cm">		 * same way as if the hardware had caused them */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">excp</span> <span class="o">==</span> <span class="n">NOEXCEPTION</span><span class="p">)</span>
			<span class="cm">/* For now use &#39;break&#39;, should technically be &#39;continue&#39; */</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	  <span class="cm">/*</span>
<span class="cm">	   * In PA89, the underflow exception has been extended to encode</span>
<span class="cm">	   * additional information.  The exception looks like pp01x0,</span>
<span class="cm">	   * where x is 1 if inexact and pp represent the inexact bit (I)</span>
<span class="cm">	   * and the round away bit (RA)</span>
<span class="cm">	   */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">excptype</span> <span class="o">&amp;</span> <span class="n">UNDERFLOWEXCEPTION</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check for underflow trap enabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_underflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> 
					   <span class="n">trap_counts</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="n">FPE_FLTUND</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		    <span class="cm">/*</span>
<span class="cm">		     * Isn&#39;t a real trap; we need to </span>
<span class="cm">		     * return the default value.</span>
<span class="cm">		     */</span>
		    <span class="n">target</span> <span class="o">=</span> <span class="n">current_ir</span> <span class="o">&amp;</span> <span class="n">fivebits</span><span class="p">;</span>
<span class="cp">#ifndef lint</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">Ibit</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">[</span><span class="n">exception_index</span><span class="p">]))</span> <span class="n">inexact</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		    <span class="k">else</span> <span class="n">inexact</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="cp">#endif</span>
		    <span class="k">switch</span> <span class="p">(</span><span class="n">Excp_format</span><span class="p">())</span> <span class="p">{</span>
		      <span class="k">case</span> <span class="n">SGL</span>:
		        <span class="cm">/*</span>
<span class="cm">		         * If ra (round-away) is set, will </span>
<span class="cm">		         * want to undo the rounding done</span>
<span class="cm">		         * by the hardware.</span>
<span class="cm">		         */</span>
		        <span class="k">if</span> <span class="p">(</span><span class="n">Rabit</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">[</span><span class="n">exception_index</span><span class="p">]))</span> 
				<span class="n">Sgl_decrement</span><span class="p">(</span><span class="n">Fpu_sgl</span><span class="p">(</span><span class="n">target</span><span class="p">));</span>

			<span class="cm">/* now denormalize */</span>
			<span class="n">sgl_denormalize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Fpu_sgl</span><span class="p">(</span><span class="n">target</span><span class="p">),</span><span class="o">&amp;</span><span class="n">inexact</span><span class="p">,</span><span class="n">Rounding_mode</span><span class="p">());</span>
		    	<span class="k">break</span><span class="p">;</span>
		      <span class="k">case</span> <span class="n">DBL</span>:
		    	<span class="cm">/*</span>
<span class="cm">		    	 * If ra (round-away) is set, will </span>
<span class="cm">		    	 * want to undo the rounding done</span>
<span class="cm">		    	 * by the hardware.</span>
<span class="cm">		    	 */</span>
		    	<span class="k">if</span> <span class="p">(</span><span class="n">Rabit</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">[</span><span class="n">exception_index</span><span class="p">]))</span> 
				<span class="n">Dbl_decrement</span><span class="p">(</span><span class="n">Fpu_dblp1</span><span class="p">(</span><span class="n">target</span><span class="p">),</span><span class="n">Fpu_dblp2</span><span class="p">(</span><span class="n">target</span><span class="p">));</span>

			<span class="cm">/* now denormalize */</span>
			<span class="n">dbl_denormalize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Fpu_dblp1</span><span class="p">(</span><span class="n">target</span><span class="p">),</span><span class="o">&amp;</span><span class="n">Fpu_dblp2</span><span class="p">(</span><span class="n">target</span><span class="p">),</span>
			  <span class="o">&amp;</span><span class="n">inexact</span><span class="p">,</span><span class="n">Rounding_mode</span><span class="p">());</span>
		    	<span class="k">break</span><span class="p">;</span>
		    <span class="p">}</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span> <span class="n">Set_underflowflag</span><span class="p">();</span>
		    <span class="cm">/* </span>
<span class="cm">		     * Underflow can generate an inexact</span>
<span class="cm">		     * exception.  If inexact trap is enabled,</span>
<span class="cm">		     * want to do an inexact trap, otherwise </span>
<span class="cm">		     * set inexact flag.</span>
<span class="cm">		     */</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">inexact</span> <span class="o">&amp;&amp;</span> <span class="n">Is_inexacttrap_enabled</span><span class="p">())</span> <span class="p">{</span>
		    	<span class="cm">/*</span>
<span class="cm">		    	 * Set exception field of exception register</span>
<span class="cm">		    	 * to inexact, parm field to zero.</span>
<span class="cm">			 * Underflow bit should be cleared.</span>
<span class="cm">		    	 */</span>
		    	<span class="n">Set_exceptiontype</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">[</span><span class="n">exception_index</span><span class="p">],</span>
			 <span class="n">INEXACTEXCEPTION</span><span class="p">);</span>
			<span class="n">Set_parmfield</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">[</span><span class="n">exception_index</span><span class="p">],</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> 
					   <span class="n">trap_counts</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="n">FPE_FLTRES</span><span class="p">);</span>
		    <span class="p">}</span>
		    <span class="k">else</span> <span class="p">{</span>
		    	<span class="cm">/*</span>
<span class="cm">		    	 * Exception register needs to be cleared.  </span>
<span class="cm">			 * Inexact flag needs to be set if inexact.</span>
<span class="cm">		    	 */</span>
		    	<span class="n">Clear_excp_register</span><span class="p">(</span><span class="n">exception_index</span><span class="p">);</span>
		    	<span class="k">if</span> <span class="p">(</span><span class="n">inexact</span><span class="p">)</span> <span class="n">Set_inexactflag</span><span class="p">();</span>
		    <span class="p">}</span>
		<span class="p">}</span>
		<span class="k">continue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">Excp_type</span><span class="p">(</span><span class="n">exception_index</span><span class="p">))</span> <span class="p">{</span>
	  <span class="k">case</span> <span class="n">OVERFLOWEXCEPTION</span>:
	  <span class="k">case</span> <span class="n">OVERFLOWEXCEPTION</span> <span class="o">|</span> <span class="n">INEXACTEXCEPTION</span>:
		<span class="cm">/* check for overflow trap enabled */</span>
			<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> 
					   <span class="n">trap_counts</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Is_overflowtrap_enabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> 
					   <span class="n">trap_counts</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="n">FPE_FLTOVF</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Isn&#39;t a real trap; we need to </span>
<span class="cm">			 * return the default value.</span>
<span class="cm">			 */</span>
			<span class="n">target</span> <span class="o">=</span> <span class="n">current_ir</span> <span class="o">&amp;</span> <span class="n">fivebits</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">Excp_format</span><span class="p">())</span> <span class="p">{</span>
			  <span class="k">case</span> <span class="n">SGL</span>: 
				<span class="n">Sgl_setoverflow</span><span class="p">(</span><span class="n">Fpu_sgl</span><span class="p">(</span><span class="n">target</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			  <span class="k">case</span> <span class="n">DBL</span>:
				<span class="n">Dbl_setoverflow</span><span class="p">(</span><span class="n">Fpu_dblp1</span><span class="p">(</span><span class="n">target</span><span class="p">),</span><span class="n">Fpu_dblp2</span><span class="p">(</span><span class="n">target</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">Set_overflowflag</span><span class="p">();</span>
			<span class="cm">/* </span>
<span class="cm">			 * Overflow always generates an inexact</span>
<span class="cm">			 * exception.  If inexact trap is enabled,</span>
<span class="cm">			 * want to do an inexact trap, otherwise </span>
<span class="cm">			 * set inexact flag.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Is_inexacttrap_enabled</span><span class="p">())</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Set exception field of exception</span>
<span class="cm">				 * register to inexact.  Overflow</span>
<span class="cm">				 * bit should be cleared.</span>
<span class="cm">				 */</span>
				<span class="n">Set_exceptiontype</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">[</span><span class="n">exception_index</span><span class="p">],</span>
				 <span class="n">INEXACTEXCEPTION</span><span class="p">);</span>
				<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span>
					   <span class="n">trap_counts</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="n">FPE_FLTRES</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Exception register needs to be cleared.  </span>
<span class="cm">				 * Inexact flag needs to be set.</span>
<span class="cm">				 */</span>
				<span class="n">Clear_excp_register</span><span class="p">(</span><span class="n">exception_index</span><span class="p">);</span>
				<span class="n">Set_inexactflag</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	  <span class="k">case</span> <span class="n">INVALIDEXCEPTION</span>:
	  <span class="k">case</span> <span class="n">OPC_2E_INVALIDEXCEPTION</span>:
		<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> <span class="n">trap_counts</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="n">FPE_FLTINV</span><span class="p">);</span>
	  <span class="k">case</span> <span class="n">DIVISIONBYZEROEXCEPTION</span>:
		<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> <span class="n">trap_counts</span><span class="p">);</span>
		<span class="n">Clear_excp_register</span><span class="p">(</span><span class="n">exception_index</span><span class="p">);</span>
	  	<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="n">FPE_FLTDIV</span><span class="p">);</span>
	  <span class="k">case</span> <span class="n">INEXACTEXCEPTION</span>:
		<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> <span class="n">trap_counts</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="n">FPE_FLTRES</span><span class="p">);</span>
	  <span class="nl">default:</span>
		<span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> <span class="n">trap_counts</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d) Unknown FPU exception 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span>
			<span class="n">__LINE__</span><span class="p">,</span> <span class="n">Excp_type</span><span class="p">(</span><span class="n">exception_index</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SIGNALCODE</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">ILL_COPROC</span><span class="p">);</span>
	  <span class="k">case</span> <span class="n">NOEXCEPTION</span>:	<span class="cm">/* no exception */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear exception register in case </span>
<span class="cm">		 * other fields are non-zero.</span>
<span class="cm">		 */</span>
		<span class="n">Clear_excp_register</span><span class="p">(</span><span class="n">exception_index</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/*</span>
<span class="cm">     * No real exceptions occurred.</span>
<span class="cm">     */</span>
    <span class="n">Clear_tbit</span><span class="p">();</span>
    <span class="n">update_trap_counts</span><span class="p">(</span><span class="n">Fpu_register</span><span class="p">,</span> <span class="n">aflags</span><span class="p">,</span> <span class="n">bflags</span><span class="p">,</span> <span class="n">trap_counts</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">NOTRAP</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
