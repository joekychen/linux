<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › math-emu › sgl_float.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sgl_float.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux/PA-RISC Project (http://www.parisc-linux.org/)</span>
<span class="cm"> *</span>
<span class="cm"> * Floating-point emulation code</span>
<span class="cm"> *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *    the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *    any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *    GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *    You should have received a copy of the GNU General Public License</span>
<span class="cm"> *    along with this program; if not, write to the Free Software</span>
<span class="cm"> *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __NO_PA_HDRS</span>
    <span class="n">PA</span> <span class="n">header</span> <span class="n">file</span> <span class="o">--</span> <span class="k">do</span> <span class="n">not</span> <span class="n">include</span> <span class="n">this</span> <span class="n">header</span> <span class="n">file</span> <span class="k">for</span> <span class="n">non</span><span class="o">-</span><span class="n">PA</span> <span class="n">builds</span><span class="p">.</span>
<span class="cp">#endif</span>

<span class="cm">/* 32-bit word grabbing functions */</span>
<span class="cp">#define Sgl_firstword(value) Sall(value)</span>
<span class="cp">#define Sgl_secondword(value) dummy_location</span>
<span class="cp">#define Sgl_thirdword(value) dummy_location</span>
<span class="cp">#define Sgl_fourthword(value) dummy_location</span>

<span class="cp">#define Sgl_sign(object) Ssign(object)</span>
<span class="cp">#define Sgl_exponent(object) Sexponent(object)</span>
<span class="cp">#define Sgl_signexponent(object) Ssignexponent(object)</span>
<span class="cp">#define Sgl_mantissa(object) Smantissa(object)</span>
<span class="cp">#define Sgl_exponentmantissa(object) Sexponentmantissa(object)</span>
<span class="cp">#define Sgl_all(object) Sall(object)</span>

<span class="cm">/* sgl_and_signs ANDs the sign bits of each argument and puts the result</span>
<span class="cm"> * into the first argument. sgl_or_signs ors those same sign bits */</span>
<span class="cp">#define Sgl_and_signs( src1dst, src2)		\</span>
<span class="cp">    Sall(src1dst) = (Sall(src2)|~((unsigned int)1&lt;&lt;31)) &amp; Sall(src1dst)</span>
<span class="cp">#define Sgl_or_signs( src1dst, src2)		\</span>
<span class="cp">    Sall(src1dst) = (Sall(src2)&amp;((unsigned int)1&lt;&lt;31)) | Sall(src1dst)</span>

<span class="cm">/* The hidden bit is always the low bit of the exponent */</span>
<span class="cp">#define Sgl_clear_exponent_set_hidden(srcdst) Deposit_sexponent(srcdst,1)</span>
<span class="cp">#define Sgl_clear_signexponent_set_hidden(srcdst) \</span>
<span class="cp">    Deposit_ssignexponent(srcdst,1)</span>
<span class="cp">#define Sgl_clear_sign(srcdst) Sall(srcdst) &amp;= ~((unsigned int)1&lt;&lt;31)</span>
<span class="cp">#define Sgl_clear_signexponent(srcdst) Sall(srcdst) &amp;= 0x007fffff</span>

<span class="cm">/* varamount must be less than 32 for the next three functions */</span>
<span class="cp">#define Sgl_rightshift(srcdst, varamount)	\</span>
<span class="cp">    Sall(srcdst) &gt;&gt;= varamount</span>
<span class="cp">#define Sgl_leftshift(srcdst, varamount)	\</span>
<span class="cp">    Sall(srcdst) &lt;&lt;= varamount</span>
<span class="cp">#define Sgl_rightshift_exponentmantissa(srcdst, varamount) \</span>
<span class="cp">    Sall(srcdst) = \</span>
<span class="cp">	(Sexponentmantissa(srcdst) &gt;&gt; varamount) | \</span>
<span class="cp">	(Sall(srcdst) &amp; ((unsigned int)1&lt;&lt;31))</span>

<span class="cp">#define Sgl_leftshiftby1_withextent(left,right,result) \</span>
<span class="cp">    Shiftdouble(Sall(left),Extall(right),31,Sall(result))</span>
    
<span class="cp">#define Sgl_rightshiftby1_withextent(left,right,dst)		\</span>
<span class="cp">    Shiftdouble(Sall(left),Extall(right),1,Extall(right))</span>
<span class="cp">#define Sgl_arithrightshiftby1(srcdst)	\</span>
<span class="cp">    Sall(srcdst) = (int)Sall(srcdst) &gt;&gt; 1</span>
    
<span class="cm">/* Sign extend the sign bit with an integer destination */</span>
<span class="cp">#define Sgl_signextendedsign(value) Ssignedsign(value)</span>

<span class="cp">#define Sgl_isone_hidden(sgl_value) (Shidden(sgl_value))</span>
<span class="cp">#define Sgl_increment(sgl_value) Sall(sgl_value) += 1</span>
<span class="cp">#define Sgl_increment_mantissa(sgl_value) \</span>
<span class="cp">    Deposit_smantissa(sgl_value,sgl_value+1)</span>
<span class="cp">#define Sgl_decrement(sgl_value) Sall(sgl_value) -= 1</span>

<span class="cp">#define Sgl_isone_sign(sgl_value) (Is_ssign(sgl_value)!=0)</span>
<span class="cp">#define Sgl_isone_hiddenoverflow(sgl_value) \</span>
<span class="cp">    (Is_shiddenoverflow(sgl_value)!=0)</span>
<span class="cp">#define Sgl_isone_lowmantissa(sgl_value) (Is_slow(sgl_value)!=0)</span>
<span class="cp">#define Sgl_isone_signaling(sgl_value) (Is_ssignaling(sgl_value)!=0)</span>
<span class="cp">#define Sgl_is_signalingnan(sgl_value) (Ssignalingnan(sgl_value)==0x1ff)</span>
<span class="cp">#define Sgl_isnotzero(sgl_value) (Sall(sgl_value)!=0)</span>
<span class="cp">#define Sgl_isnotzero_hiddenhigh7mantissa(sgl_value) \</span>
<span class="cp">    (Shiddenhigh7mantissa(sgl_value)!=0)</span>
<span class="cp">#define Sgl_isnotzero_low4(sgl_value) (Slow4(sgl_value)!=0)</span>
<span class="cp">#define Sgl_isnotzero_exponent(sgl_value) (Sexponent(sgl_value)!=0)</span>
<span class="cp">#define Sgl_isnotzero_mantissa(sgl_value) (Smantissa(sgl_value)!=0)</span>
<span class="cp">#define Sgl_isnotzero_exponentmantissa(sgl_value) \</span>
<span class="cp">    (Sexponentmantissa(sgl_value)!=0)</span>
<span class="cp">#define Sgl_iszero(sgl_value) (Sall(sgl_value)==0)</span>
<span class="cp">#define Sgl_iszero_signaling(sgl_value) (Is_ssignaling(sgl_value)==0)</span>
<span class="cp">#define Sgl_iszero_hidden(sgl_value) (Is_shidden(sgl_value)==0)</span>
<span class="cp">#define Sgl_iszero_hiddenoverflow(sgl_value) \</span>
<span class="cp">    (Is_shiddenoverflow(sgl_value)==0)</span>
<span class="cp">#define Sgl_iszero_hiddenhigh3mantissa(sgl_value) \</span>
<span class="cp">    (Shiddenhigh3mantissa(sgl_value)==0)</span>
<span class="cp">#define Sgl_iszero_hiddenhigh7mantissa(sgl_value) \</span>
<span class="cp">    (Shiddenhigh7mantissa(sgl_value)==0)</span>
<span class="cp">#define Sgl_iszero_sign(sgl_value) (Is_ssign(sgl_value)==0)</span>
<span class="cp">#define Sgl_iszero_exponent(sgl_value) (Sexponent(sgl_value)==0)</span>
<span class="cp">#define Sgl_iszero_mantissa(sgl_value) (Smantissa(sgl_value)==0)</span>
<span class="cp">#define Sgl_iszero_exponentmantissa(sgl_value) \</span>
<span class="cp">    (Sexponentmantissa(sgl_value)==0)</span>
<span class="cp">#define Sgl_isinfinity_exponent(sgl_value) 		\</span>
<span class="cp">    (Sgl_exponent(sgl_value)==SGL_INFINITY_EXPONENT)</span>
<span class="cp">#define Sgl_isnotinfinity_exponent(sgl_value) 		\</span>
<span class="cp">    (Sgl_exponent(sgl_value)!=SGL_INFINITY_EXPONENT)</span>
<span class="cp">#define Sgl_isinfinity(sgl_value)			\</span>
<span class="cp">    (Sgl_exponent(sgl_value)==SGL_INFINITY_EXPONENT &amp;&amp;	\</span>
<span class="cp">    Sgl_mantissa(sgl_value)==0)</span>
<span class="cp">#define Sgl_isnan(sgl_value)				\</span>
<span class="cp">    (Sgl_exponent(sgl_value)==SGL_INFINITY_EXPONENT &amp;&amp;	\</span>
<span class="cp">    Sgl_mantissa(sgl_value)!=0)</span>
<span class="cp">#define Sgl_isnotnan(sgl_value)				\</span>
<span class="cp">    (Sgl_exponent(sgl_value)!=SGL_INFINITY_EXPONENT ||	\</span>
<span class="cp">    Sgl_mantissa(sgl_value)==0)</span>
<span class="cp">#define Sgl_islessthan(sgl_op1,sgl_op2)			\</span>
<span class="cp">    (Sall(sgl_op1) &lt; Sall(sgl_op2))</span>
<span class="cp">#define Sgl_isgreaterthan(sgl_op1,sgl_op2)		\</span>
<span class="cp">    (Sall(sgl_op1) &gt; Sall(sgl_op2))</span>
<span class="cp">#define Sgl_isnotlessthan(sgl_op1,sgl_op2)		\</span>
<span class="cp">    (Sall(sgl_op1) &gt;= Sall(sgl_op2))</span>
<span class="cp">#define Sgl_isequal(sgl_op1,sgl_op2)			\</span>
<span class="cp">    (Sall(sgl_op1) == Sall(sgl_op2))</span>

<span class="cp">#define Sgl_leftshiftby8(sgl_value) \</span>
<span class="cp">    Sall(sgl_value) &lt;&lt;= 8</span>
<span class="cp">#define Sgl_leftshiftby4(sgl_value) \</span>
<span class="cp">    Sall(sgl_value) &lt;&lt;= 4</span>
<span class="cp">#define Sgl_leftshiftby3(sgl_value) \</span>
<span class="cp">    Sall(sgl_value) &lt;&lt;= 3</span>
<span class="cp">#define Sgl_leftshiftby2(sgl_value) \</span>
<span class="cp">    Sall(sgl_value) &lt;&lt;= 2</span>
<span class="cp">#define Sgl_leftshiftby1(sgl_value) \</span>
<span class="cp">    Sall(sgl_value) &lt;&lt;= 1</span>
<span class="cp">#define Sgl_rightshiftby1(sgl_value) \</span>
<span class="cp">    Sall(sgl_value) &gt;&gt;= 1</span>
<span class="cp">#define Sgl_rightshiftby4(sgl_value) \</span>
<span class="cp">    Sall(sgl_value) &gt;&gt;= 4</span>
<span class="cp">#define Sgl_rightshiftby8(sgl_value) \</span>
<span class="cp">    Sall(sgl_value) &gt;&gt;= 8</span>
    
<span class="cp">#define Sgl_ismagnitudeless(signlessleft,signlessright)			\</span>
<span class="cm">/*  unsigned int signlessleft, signlessright; */</span><span class="cp">			\</span>
<span class="cp">      (signlessleft &lt; signlessright)  </span>
    

<span class="cp">#define Sgl_copytoint_exponentmantissa(source,dest)     \</span>
<span class="cp">    dest = Sexponentmantissa(source)</span>

<span class="cm">/* A quiet NaN has the high mantissa bit clear and at least on other (in this</span>
<span class="cm"> * case the adjacent bit) bit set. */</span>
<span class="cp">#define Sgl_set_quiet(sgl_value) Deposit_shigh2mantissa(sgl_value,1)</span>
<span class="cp">#define Sgl_set_exponent(sgl_value,exp) Deposit_sexponent(sgl_value,exp)</span>

<span class="cp">#define Sgl_set_mantissa(dest,value) Deposit_smantissa(dest,value)</span>
<span class="cp">#define Sgl_set_exponentmantissa(dest,value) \</span>
<span class="cp">    Deposit_sexponentmantissa(dest,value)</span>

<span class="cm">/*  An infinity is represented with the max exponent and a zero mantissa */</span>
<span class="cp">#define Sgl_setinfinity_exponent(sgl_value) \</span>
<span class="cp">    Deposit_sexponent(sgl_value,SGL_INFINITY_EXPONENT)</span>
<span class="cp">#define Sgl_setinfinity_exponentmantissa(sgl_value)	\</span>
<span class="cp">    Deposit_sexponentmantissa(sgl_value, \</span>
<span class="cp">	(SGL_INFINITY_EXPONENT &lt;&lt; (32-(1+SGL_EXP_LENGTH))))</span>
<span class="cp">#define Sgl_setinfinitypositive(sgl_value)		\</span>
<span class="cp">    Sall(sgl_value) = (SGL_INFINITY_EXPONENT &lt;&lt; (32-(1+SGL_EXP_LENGTH)))</span>
<span class="cp">#define Sgl_setinfinitynegative(sgl_value)		\</span>
<span class="cp">    Sall(sgl_value) = (SGL_INFINITY_EXPONENT &lt;&lt; (32-(1+SGL_EXP_LENGTH))) \</span>
<span class="cp">    | ((unsigned int)1&lt;&lt;31)</span>
<span class="cp">#define Sgl_setinfinity(sgl_value,sign)					\</span>
<span class="cp">    Sall(sgl_value) = (SGL_INFINITY_EXPONENT &lt;&lt; (32-(1+SGL_EXP_LENGTH))) | \</span>
<span class="cp">     ((unsigned int)sign &lt;&lt; 31)</span>
<span class="cp">#define Sgl_sethigh4bits(sgl_value, extsign)  \</span>
<span class="cp">    Deposit_shigh4(sgl_value,extsign)</span>
<span class="cp">#define Sgl_set_sign(sgl_value,sign) Deposit_ssign(sgl_value,sign)</span>
<span class="cp">#define Sgl_invert_sign(sgl_value)  \</span>
<span class="cp">    Deposit_ssign(sgl_value,~Ssign(sgl_value))</span>
<span class="cp">#define Sgl_setone_sign(sgl_value) Deposit_ssign(sgl_value,1)</span>
<span class="cp">#define Sgl_setone_lowmantissa(sgl_value) Deposit_slow(sgl_value,1)</span>
<span class="cp">#define Sgl_setzero_sign(sgl_value)  Sall(sgl_value) &amp;= 0x7fffffff</span>
<span class="cp">#define Sgl_setzero_exponent(sgl_value) Sall(sgl_value) &amp;= 0x807fffff</span>
<span class="cp">#define Sgl_setzero_mantissa(sgl_value) Sall(sgl_value) &amp;= 0xff800000</span>
<span class="cp">#define Sgl_setzero_exponentmantissa(sgl_value)  Sall(sgl_value) &amp;= 0x80000000</span>
<span class="cp">#define Sgl_setzero(sgl_value) Sall(sgl_value) = 0</span>
<span class="cp">#define Sgl_setnegativezero(sgl_value) Sall(sgl_value) = (unsigned int)1 &lt;&lt; 31</span>

<span class="cm">/* Use following macro for both overflow &amp; underflow conditions */</span>
<span class="cp">#define ovfl -</span>
<span class="cp">#define unfl +</span>
<span class="cp">#define Sgl_setwrapped_exponent(sgl_value,exponent,op) \</span>
<span class="cp">    Deposit_sexponent(sgl_value,(exponent op SGL_WRAP))</span>

<span class="cp">#define Sgl_setlargestpositive(sgl_value) 				\</span>
<span class="cp">    Sall(sgl_value) = ((SGL_EMAX+SGL_BIAS) &lt;&lt; (32-(1+SGL_EXP_LENGTH)))	\</span>
<span class="cp">                      | ((1&lt;&lt;(32-(1+SGL_EXP_LENGTH))) - 1 )</span>
<span class="cp">#define Sgl_setlargestnegative(sgl_value)				\</span>
<span class="cp">    Sall(sgl_value) = ((SGL_EMAX+SGL_BIAS) &lt;&lt; (32-(1+SGL_EXP_LENGTH)))	\</span>
<span class="cp">                      | ((1&lt;&lt;(32-(1+SGL_EXP_LENGTH))) - 1 )		\</span>
<span class="cp">		      | ((unsigned int)1&lt;&lt;31)</span>

<span class="cp">#define Sgl_setnegativeinfinity(sgl_value)	\</span>
<span class="cp">    Sall(sgl_value) = 				\</span>
<span class="cp">    ((1&lt;&lt;SGL_EXP_LENGTH) | SGL_INFINITY_EXPONENT) &lt;&lt; (32-(1+SGL_EXP_LENGTH))</span>
<span class="cp">#define Sgl_setlargest(sgl_value,sign) 					\</span>
<span class="cp">    Sall(sgl_value) = (unsigned int)sign &lt;&lt; 31 |			\</span>
<span class="cp">        (((SGL_EMAX+SGL_BIAS) &lt;&lt; (32-(1+SGL_EXP_LENGTH)))		\</span>
<span class="cp">	  | ((1 &lt;&lt; (32-(1+SGL_EXP_LENGTH))) - 1 ))</span>
<span class="cp">#define Sgl_setlargest_exponentmantissa(sgl_value)			\</span>
<span class="cp">    Sall(sgl_value) = Sall(sgl_value) &amp; ((unsigned int)1&lt;&lt;31) |		\</span>
<span class="cp">        (((SGL_EMAX+SGL_BIAS) &lt;&lt; (32-(1+SGL_EXP_LENGTH)))		\</span>
<span class="cp">	  | ((1 &lt;&lt; (32-(1+SGL_EXP_LENGTH))) - 1 ))</span>

<span class="cm">/* The high bit is always zero so arithmetic or logical shifts will work. */</span>
<span class="cp">#define Sgl_right_align(srcdst,shift,extent)				\</span>
<span class="cp">    </span><span class="cm">/* sgl_floating_point srcdst; int shift; extension extent */</span><span class="cp">	\</span>
<span class="cp">    if (shift &lt; 32) {							\</span>
<span class="cp">	Extall(extent) = Sall(srcdst) &lt;&lt; (32-(shift));			\</span>
<span class="cp">    	Sall(srcdst) &gt;&gt;= shift;						\</span>
<span class="cp">    }									\</span>
<span class="cp">    else {								\</span>
<span class="cp">	Extall(extent) = Sall(srcdst);					\</span>
<span class="cp">	Sall(srcdst) = 0;						\</span>
<span class="cp">    }</span>
<span class="cp">#define Sgl_hiddenhigh3mantissa(sgl_value) Shiddenhigh3mantissa(sgl_value)</span>
<span class="cp">#define Sgl_hidden(sgl_value) Shidden(sgl_value)</span>
<span class="cp">#define Sgl_lowmantissa(sgl_value) Slow(sgl_value)</span>

<span class="cm">/* The left argument is never smaller than the right argument */</span>
<span class="cp">#define Sgl_subtract(sgl_left,sgl_right,sgl_result) \</span>
<span class="cp">    Sall(sgl_result) = Sall(sgl_left) - Sall(sgl_right)</span>

<span class="cm">/* Subtract right augmented with extension from left augmented with zeros and</span>
<span class="cm"> * store into result and extension. */</span>
<span class="cp">#define Sgl_subtract_withextension(left,right,extent,result)		\</span>
<span class="cp">    </span><span class="cm">/* sgl_floating_point left,right,result; extension extent */</span><span class="cp">	\</span>
<span class="cp">  Sgl_subtract(left,right,result);					\</span>
<span class="cp">  if((Extall(extent) = 0-Extall(extent)))				\</span>
<span class="cp">      Sall(result) = Sall(result)-1</span>

<span class="cp">#define Sgl_addition(sgl_left,sgl_right,sgl_result) \</span>
<span class="cp">    Sall(sgl_result) = Sall(sgl_left) + Sall(sgl_right)</span>

<span class="cp">#define Sgl_xortointp1(left,right,result)			\</span>
<span class="cp">    result = Sall(left) XOR Sall(right);</span>

<span class="cp">#define Sgl_xorfromintp1(left,right,result)			\</span>
<span class="cp">    Sall(result) = left XOR Sall(right)</span>

<span class="cm">/* Need to Initialize */</span>
<span class="cp">#define Sgl_makequietnan(dest)						\</span>
<span class="cp">    Sall(dest) = ((SGL_EMAX+SGL_BIAS)+1)&lt;&lt; (32-(1+SGL_EXP_LENGTH))	\</span>
<span class="cp">                 | (1&lt;&lt;(32-(1+SGL_EXP_LENGTH+2)))</span>
<span class="cp">#define Sgl_makesignalingnan(dest)					\</span>
<span class="cp">    Sall(dest) = ((SGL_EMAX+SGL_BIAS)+1)&lt;&lt; (32-(1+SGL_EXP_LENGTH))	\</span>
<span class="cp">                 | (1&lt;&lt;(32-(1+SGL_EXP_LENGTH+1)))</span>

<span class="cp">#define Sgl_normalize(sgl_opnd,exponent)			\</span>
<span class="cp">	while(Sgl_iszero_hiddenhigh7mantissa(sgl_opnd)) {	\</span>
<span class="cp">		Sgl_leftshiftby8(sgl_opnd);			\</span>
<span class="cp">		exponent -= 8;					\</span>
<span class="cp">	}							\</span>
<span class="cp">	if(Sgl_iszero_hiddenhigh3mantissa(sgl_opnd)) {		\</span>
<span class="cp">		Sgl_leftshiftby4(sgl_opnd);			\</span>
<span class="cp">		exponent -= 4;					\</span>
<span class="cp">	}							\</span>
<span class="cp">	while(Sgl_iszero_hidden(sgl_opnd)) {			\</span>
<span class="cp">		Sgl_leftshiftby1(sgl_opnd);			\</span>
<span class="cp">		exponent -= 1;					\</span>
<span class="cp">	}</span>

<span class="cp">#define Sgl_setoverflow(sgl_opnd)				\</span>
<span class="cp">	</span><span class="cm">/* set result to infinity or largest number */</span><span class="cp">		\</span>
<span class="cp">	switch (Rounding_mode()) {				\</span>
<span class="cp">		case ROUNDPLUS:					\</span>
<span class="cp">			if (Sgl_isone_sign(sgl_opnd)) {		\</span>
<span class="cp">				Sgl_setlargestnegative(sgl_opnd); \</span>
<span class="cp">			}					\</span>
<span class="cp">			else {					\</span>
<span class="cp">				Sgl_setinfinitypositive(sgl_opnd); \</span>
<span class="cp">			}					\</span>
<span class="cp">			break;					\</span>
<span class="cp">		case ROUNDMINUS:				\</span>
<span class="cp">			if (Sgl_iszero_sign(sgl_opnd)) {	\</span>
<span class="cp">				Sgl_setlargestpositive(sgl_opnd); \</span>
<span class="cp">			}					\</span>
<span class="cp">			else {					\</span>
<span class="cp">				Sgl_setinfinitynegative(sgl_opnd); \</span>
<span class="cp">			}					\</span>
<span class="cp">			break;					\</span>
<span class="cp">		case ROUNDNEAREST:				\</span>
<span class="cp">			Sgl_setinfinity_exponentmantissa(sgl_opnd); \</span>
<span class="cp">			break;					\</span>
<span class="cp">		case ROUNDZERO:					\</span>
<span class="cp">			Sgl_setlargest_exponentmantissa(sgl_opnd); \</span>
<span class="cp">	}</span>

<span class="cp">#define Sgl_denormalize(opnd,exponent,guard,sticky,inexact)		\</span>
<span class="cp">	Sgl_clear_signexponent_set_hidden(opnd);			\</span>
<span class="cp">	if (exponent &gt;= (1 - SGL_P)) {					\</span>
<span class="cp">		guard = (Sall(opnd) &gt;&gt; -exponent) &amp; 1;			\</span>
<span class="cp">		if (exponent &lt; 0) sticky |= Sall(opnd) &lt;&lt; (32+exponent); \</span>
<span class="cp">		inexact = guard | sticky;				\</span>
<span class="cp">		Sall(opnd) &gt;&gt;= (1-exponent);				\</span>
<span class="cp">	}								\</span>
<span class="cp">	else {								\</span>
<span class="cp">		guard = 0;						\</span>
<span class="cp">		sticky |= Sall(opnd);					\</span>
<span class="cp">		inexact = sticky;					\</span>
<span class="cp">		Sgl_setzero(opnd);					\</span>
<span class="cp">	}</span>

<span class="cm">/* </span>
<span class="cm"> * The fused multiply add instructions requires a single extended format,</span>
<span class="cm"> * with 48 bits of mantissa.</span>
<span class="cm"> */</span>
<span class="cp">#define SGLEXT_THRESHOLD 48</span>

<span class="cp">#define Sglext_setzero(valA,valB)	\</span>
<span class="cp">    Sextallp1(valA) = 0; Sextallp2(valB) = 0</span>

<span class="cp">#define Sglext_isnotzero_mantissap2(valB) (Sextallp2(valB)!=0)</span>
<span class="cp">#define Sglext_isone_lowp1(val) (Sextlowp1(val)!=0)</span>
<span class="cp">#define Sglext_isone_highp2(val) (Sexthighp2(val)!=0)</span>
<span class="cp">#define Sglext_isnotzero_low31p2(val) (Sextlow31p2(val)!=0)</span>
<span class="cp">#define Sglext_iszero(valA,valB) (Sextallp1(valA)==0 &amp;&amp; Sextallp2(valB)==0)</span>

<span class="cp">#define Sgl_copytoptr(src,destptr) *destptr = src</span>
<span class="cp">#define Sgl_copyfromptr(srcptr,dest) dest = *srcptr</span>
<span class="cp">#define Sglext_copy(srca,srcb,desta,destb) \</span>
<span class="cp">    Sextallp1(desta) = Sextallp1(srca);	\</span>
<span class="cp">    Sextallp2(destb) = Sextallp2(srcb)</span>
<span class="cp">#define Sgl_copyto_sglext(src1,dest1,dest2) \</span>
<span class="cp">	Sextallp1(dest1) = Sall(src1); Sextallp2(dest2) = 0</span>

<span class="cp">#define Sglext_swap_lower(leftp2,rightp2)  \</span>
<span class="cp">    Sextallp2(leftp2)  = Sextallp2(leftp2) XOR Sextallp2(rightp2);  \</span>
<span class="cp">    Sextallp2(rightp2) = Sextallp2(leftp2) XOR Sextallp2(rightp2);  \</span>
<span class="cp">    Sextallp2(leftp2)  = Sextallp2(leftp2) XOR Sextallp2(rightp2)</span>

<span class="cp">#define Sglext_setone_lowmantissap2(value) Deposit_dlowp2(value,1)</span>

<span class="cm">/* The high bit is always zero so arithmetic or logical shifts will work. */</span>
<span class="cp">#define Sglext_right_align(srcdstA,srcdstB,shift) \</span>
<span class="cp">  {int shiftamt, sticky;						\</span>
<span class="cp">    shiftamt = shift % 32;						\</span>
<span class="cp">    sticky = 0;								\</span>
<span class="cp">    switch (shift/32) {							\</span>
<span class="cp">     case 0: if (shiftamt &gt; 0) {					\</span>
<span class="cp">	        sticky = Sextallp2(srcdstB) &lt;&lt; 32 - (shiftamt);		\</span>
<span class="cp">                Variable_shift_double(Sextallp1(srcdstA),		\</span>
<span class="cp">		 Sextallp2(srcdstB),shiftamt,Sextallp2(srcdstB));	\</span>
<span class="cp">	        Sextallp1(srcdstA) &gt;&gt;= shiftamt;			\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     break;							\</span>
<span class="cp">     case 1: if (shiftamt &gt; 0) {					\</span>
<span class="cp">	        sticky = (Sextallp1(srcdstA) &lt;&lt; 32 - (shiftamt)) |	\</span>
<span class="cp">			 Sextallp2(srcdstB);				\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     else {							\</span>
<span class="cp">		sticky = Sextallp2(srcdstB);				\</span>
<span class="cp">	     }								\</span>
<span class="cp">	     Sextallp2(srcdstB) = Sextallp1(srcdstA) &gt;&gt; shiftamt;	\</span>
<span class="cp">	     Sextallp1(srcdstA) = 0;					\</span>
<span class="cp">	     break;							\</span>
<span class="cp">    }									\</span>
<span class="cp">    if (sticky) Sglext_setone_lowmantissap2(srcdstB);			\</span>
<span class="cp">  }</span>

<span class="cm">/* The left argument is never smaller than the right argument */</span>
<span class="cp">#define Sglext_subtract(lefta,leftb,righta,rightb,resulta,resultb) \</span>
<span class="cp">    if( Sextallp2(rightb) &gt; Sextallp2(leftb) ) Sextallp1(lefta)--; \</span>
<span class="cp">    Sextallp2(resultb) = Sextallp2(leftb) - Sextallp2(rightb);	\</span>
<span class="cp">    Sextallp1(resulta) = Sextallp1(lefta) - Sextallp1(righta)</span>

<span class="cp">#define Sglext_addition(lefta,leftb,righta,rightb,resulta,resultb) \</span>
<span class="cp">    </span><span class="cm">/* If the sum of the low words is less than either source, then \</span>
<span class="cm">     * an overflow into the next word occurred. */</span><span class="cp"> \</span>
<span class="cp">    if ((Sextallp2(resultb) = Sextallp2(leftb)+Sextallp2(rightb)) &lt; \</span>
<span class="cp">        Sextallp2(rightb)) \</span>
<span class="cp">	    Sextallp1(resulta) = Sextallp1(lefta)+Sextallp1(righta)+1; \</span>
<span class="cp">    else Sextallp1(resulta) = Sextallp1(lefta)+Sextallp1(righta)</span>


<span class="cp">#define Sglext_arithrightshiftby1(srcdstA,srcdstB)	\</span>
<span class="cp">    Shiftdouble(Sextallp1(srcdstA),Sextallp2(srcdstB),1,Sextallp2(srcdstB)); \</span>
<span class="cp">    Sextallp1(srcdstA) = (int)Sextallp1(srcdstA) &gt;&gt; 1</span>
   
<span class="cp">#define Sglext_leftshiftby8(valA,valB) \</span>
<span class="cp">    Shiftdouble(Sextallp1(valA),Sextallp2(valB),24,Sextallp1(valA)); \</span>
<span class="cp">    Sextallp2(valB) &lt;&lt;= 8</span>
<span class="cp">#define Sglext_leftshiftby4(valA,valB) \</span>
<span class="cp">    Shiftdouble(Sextallp1(valA),Sextallp2(valB),28,Sextallp1(valA)); \</span>
<span class="cp">    Sextallp2(valB) &lt;&lt;= 4</span>
<span class="cp">#define Sglext_leftshiftby3(valA,valB) \</span>
<span class="cp">    Shiftdouble(Sextallp1(valA),Sextallp2(valB),29,Sextallp1(valA)); \</span>
<span class="cp">    Sextallp2(valB) &lt;&lt;= 3</span>
<span class="cp">#define Sglext_leftshiftby2(valA,valB) \</span>
<span class="cp">    Shiftdouble(Sextallp1(valA),Sextallp2(valB),30,Sextallp1(valA)); \</span>
<span class="cp">    Sextallp2(valB) &lt;&lt;= 2</span>
<span class="cp">#define Sglext_leftshiftby1(valA,valB) \</span>
<span class="cp">    Shiftdouble(Sextallp1(valA),Sextallp2(valB),31,Sextallp1(valA)); \</span>
<span class="cp">    Sextallp2(valB) &lt;&lt;= 1</span>

<span class="cp">#define Sglext_rightshiftby4(valueA,valueB) \</span>
<span class="cp">    Shiftdouble(Sextallp1(valueA),Sextallp2(valueB),4,Sextallp2(valueB)); \</span>
<span class="cp">    Sextallp1(valueA) &gt;&gt;= 4</span>
<span class="cp">#define Sglext_rightshiftby3(valueA,valueB) \</span>
<span class="cp">    Shiftdouble(Sextallp1(valueA),Sextallp2(valueB),3,Sextallp2(valueB)); \</span>
<span class="cp">    Sextallp1(valueA) &gt;&gt;= 3</span>
<span class="cp">#define Sglext_rightshiftby1(valueA,valueB) \</span>
<span class="cp">    Shiftdouble(Sextallp1(valueA),Sextallp2(valueB),1,Sextallp2(valueB)); \</span>
<span class="cp">    Sextallp1(valueA) &gt;&gt;= 1</span>

<span class="cp">#define Sglext_xortointp1(left,right,result) Sgl_xortointp1(left,right,result)</span>
<span class="cp">#define Sglext_xorfromintp1(left,right,result) \</span>
<span class="cp">	Sgl_xorfromintp1(left,right,result)</span>
<span class="cp">#define Sglext_copytoint_exponentmantissa(src,dest) \</span>
<span class="cp">	Sgl_copytoint_exponentmantissa(src,dest)</span>
<span class="cp">#define Sglext_ismagnitudeless(signlessleft,signlessright) \</span>
<span class="cp">	Sgl_ismagnitudeless(signlessleft,signlessright)</span>

<span class="cp">#define Sglext_set_sign(dbl_value,sign)  Sgl_set_sign(dbl_value,sign)  </span>
<span class="cp">#define Sglext_clear_signexponent_set_hidden(srcdst) \</span>
<span class="cp">	Sgl_clear_signexponent_set_hidden(srcdst) </span>
<span class="cp">#define Sglext_clear_signexponent(srcdst) Sgl_clear_signexponent(srcdst) </span>
<span class="cp">#define Sglext_clear_sign(srcdst) Sgl_clear_sign(srcdst) </span>
<span class="cp">#define Sglext_isone_hidden(dbl_value) Sgl_isone_hidden(dbl_value) </span>

<span class="cp">#define Sglext_denormalize(opndp1,opndp2,exponent,is_tiny)		\</span>
<span class="cp">  {int sticky;								\</span>
<span class="cp">    is_tiny = TRUE;							\</span>
<span class="cp">    if (exponent == 0 &amp;&amp; Sextallp2(opndp2)) {				\</span>
<span class="cp">	switch (Rounding_mode()) {					\</span>
<span class="cp">	case ROUNDPLUS:							\</span>
<span class="cp">		if (Sgl_iszero_sign(opndp1))				\</span>
<span class="cp">			if (Sgl_isone_hiddenoverflow(opndp1 + 1))	\</span>
<span class="cp">				is_tiny = FALSE;			\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case ROUNDMINUS:						\</span>
<span class="cp">		if (Sgl_isone_sign(opndp1)) {				\</span>
<span class="cp">			if (Sgl_isone_hiddenoverflow(opndp1 + 1))	\</span>
<span class="cp">				is_tiny = FALSE;			\</span>
<span class="cp">		}							\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case ROUNDNEAREST:						\</span>
<span class="cp">		if (Sglext_isone_highp2(opndp2) &amp;&amp;			\</span>
<span class="cp">		    (Sglext_isone_lowp1(opndp1) || 			\</span>
<span class="cp">		     Sglext_isnotzero_low31p2(opndp2)))			\</span>
<span class="cp">			if (Sgl_isone_hiddenoverflow(opndp1 + 1))	\</span>
<span class="cp">				is_tiny = FALSE;			\</span>
<span class="cp">		break;							\</span>
<span class="cp">	}								\</span>
<span class="cp">    }									\</span>
<span class="cp">    Sglext_clear_signexponent_set_hidden(opndp1);			\</span>
<span class="cp">    if (exponent &gt;= (1-DBL_P)) {					\</span>
<span class="cp">	if (exponent &gt;= -31) {						\</span>
<span class="cp">	    if (exponent &gt; -31) {					\</span>
<span class="cp">		sticky = Sextallp2(opndp2) &lt;&lt; 31+exponent;		\</span>
<span class="cp">		Variable_shift_double(opndp1,opndp2,1-exponent,opndp2);	\</span>
<span class="cp">		Sextallp1(opndp1) &gt;&gt;= 1-exponent;			\</span>
<span class="cp">	    }								\</span>
<span class="cp">	    else {							\</span>
<span class="cp">		sticky = Sextallp2(opndp2);				\</span>
<span class="cp">		Sextallp2(opndp2) = Sextallp1(opndp1);			\</span>
<span class="cp">		Sextallp1(opndp1) = 0;					\</span>
<span class="cp">	    }								\</span>
<span class="cp">	}								\</span>
<span class="cp">	else {								\</span>
<span class="cp">	    sticky = (Sextallp1(opndp1) &lt;&lt; 31+exponent) | 		\</span>
<span class="cp">		     Sextallp2(opndp2);					\</span>
<span class="cp">	    Sextallp2(opndp2) = Sextallp1(opndp1) &gt;&gt; -31-exponent;	\</span>
<span class="cp">	    Sextallp1(opndp1) = 0;					\</span>
<span class="cp">	}								\</span>
<span class="cp">    }									\</span>
<span class="cp">    else {								\</span>
<span class="cp">	sticky = Sextallp1(opndp1) | Sextallp2(opndp2);			\</span>
<span class="cp">	Sglext_setzero(opndp1,opndp2);					\</span>
<span class="cp">    }									\</span>
<span class="cp">    if (sticky) Sglext_setone_lowmantissap2(opndp2);			\</span>
<span class="cp">    exponent = 0;							\</span>
<span class="cp">  }</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
