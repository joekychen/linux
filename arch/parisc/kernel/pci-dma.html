<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › kernel › pci-dma.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pci-dma.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** PARISC 1.1 Dynamic DMA mapping support.</span>
<span class="cm">** This implementation is for PA-RISC platforms that do not support</span>
<span class="cm">** I/O TLBs (aka DMA address translation hardware).</span>
<span class="cm">** See Documentation/DMA-API-HOWTO.txt for interface definitions.</span>
<span class="cm">**</span>
<span class="cm">**      (c) Copyright 1999,2000 Hewlett-Packard Company</span>
<span class="cm">**      (c) Copyright 2000 Grant Grundler</span>
<span class="cm">**	(c) Copyright 2000 Philipp Rumpf &lt;prumpf@tux.org&gt;</span>
<span class="cm">**      (c) Copyright 2000 John Marvin</span>
<span class="cm">**</span>
<span class="cm">** &quot;leveraged&quot; from 2.3.47: arch/ia64/kernel/pci-dma.c.</span>
<span class="cm">** (I assume it&#39;s from David Mosberger-Tang but there was no Copyright)</span>
<span class="cm">**</span>
<span class="cm">** AFAIK, all PA7100LC and PA7300LC platforms can use this code.</span>
<span class="cm">**</span>
<span class="cm">** - ggg</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;    </span><span class="cm">/* for DMA_CHUNK_SIZE */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;	</span><span class="cm">/* get_order */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;	</span><span class="cm">/* for purge_tlb_*() macros */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span> <span class="n">proc_gsc_root</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pcxl_used_bytes</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pcxl_used_pages</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pcxl_dma_start</span><span class="p">;</span> <span class="cm">/* Start of pcxl dma mapping area */</span>
<span class="k">static</span> <span class="n">spinlock_t</span>   <span class="n">pcxl_res_lock</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span>    <span class="o">*</span><span class="n">pcxl_res_map</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>     <span class="n">pcxl_res_hint</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>     <span class="n">pcxl_res_size</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_PCXL_RESOURCE</span>
<span class="cp">#define DBG_RES(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RES(x...)</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm">** Dump a hex representation of the resource map.</span>
<span class="cm">*/</span>

<span class="cp">#ifdef DUMP_RESMAP</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">dump_resmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_long</span> <span class="o">*</span><span class="n">res_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">pcxl_res_map</span><span class="p">;</span>
	<span class="n">u_long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;res_map: &quot;</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">pcxl_res_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">res_ptr</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%08lx &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dump_resmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{;}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pa11_dma_supported</span><span class="p">(</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">map_pte_uncached</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span> <span class="n">pte</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">paddr_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_vaddr</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PMD_MASK</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">PMD_SIZE</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;map_pte_uncached: page already exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">set_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">__mk_pte</span><span class="p">(</span><span class="o">*</span><span class="n">paddr_ptr</span><span class="p">,</span> <span class="n">PAGE_KERNEL_UNC</span><span class="p">));</span>
		<span class="n">purge_tlb_start</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">pdtlb_kernel</span><span class="p">(</span><span class="n">orig_vaddr</span><span class="p">);</span>
		<span class="n">purge_tlb_end</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">orig_vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">paddr_ptr</span><span class="p">)</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">map_pmd_uncached</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span> <span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">paddr_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_vaddr</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PGDIR_MASK</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">PGDIR_SIZE</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">PGDIR_SIZE</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pte_alloc_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map_pte_uncached</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">orig_vaddr</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">paddr_ptr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PMD_MASK</span><span class="p">;</span>
		<span class="n">orig_vaddr</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
		<span class="n">pmd</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">map_uncached_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span> <span class="n">dir</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
		
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map_pmd_uncached</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">vaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">paddr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">PGDIR_SIZE</span><span class="p">;</span>
		<span class="n">dir</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unmap_uncached_pte</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span> <span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span> <span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_vaddr</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmd_ERROR</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">);</span>
		<span class="n">pmd_clear</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
	<span class="n">vaddr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PMD_MASK</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">PMD_SIZE</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">pte_t</span> <span class="n">page</span> <span class="o">=</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

		<span class="n">pte_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
		<span class="n">purge_tlb_start</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">pdtlb_kernel</span><span class="p">(</span><span class="n">orig_vaddr</span><span class="p">);</span>
		<span class="n">purge_tlb_end</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">orig_vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">pte_present</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;Whee.. Swapped out page in kernel page table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unmap_uncached_pmd</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span> <span class="n">pmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_vaddr</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">dir</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_bad</span><span class="p">(</span><span class="o">*</span><span class="n">dir</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgd_ERROR</span><span class="p">(</span><span class="o">*</span><span class="n">dir</span><span class="p">);</span>
		<span class="n">pgd_clear</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
	<span class="n">vaddr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PGDIR_MASK</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">PGDIR_SIZE</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">PGDIR_SIZE</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">unmap_uncached_pte</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">orig_vaddr</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">vaddr</span><span class="p">);</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PMD_MASK</span><span class="p">;</span>
		<span class="n">orig_vaddr</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
		<span class="n">pmd</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_uncached_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span> <span class="n">dir</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">unmap_uncached_pmd</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">vaddr</span><span class="p">);</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">PGDIR_SIZE</span><span class="p">;</span>
		<span class="n">dir</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define PCXL_SEARCH_LOOP(idx, mask, size)  \</span>
<span class="cp">       for(; res_ptr &lt; res_end; ++res_ptr) \</span>
<span class="cp">       { \</span>
<span class="cp">               if(0 == ((*res_ptr) &amp; mask)) { \</span>
<span class="cp">                       *res_ptr |= mask; \</span>
<span class="cp">		       idx = (int)((u_long)res_ptr - (u_long)pcxl_res_map); \</span>
<span class="cp">		       pcxl_res_hint = idx + (size &gt;&gt; 3); \</span>
<span class="cp">                       goto resource_found; \</span>
<span class="cp">               } \</span>
<span class="cp">       }</span>

<span class="cp">#define PCXL_FIND_FREE_MAPPING(idx, mask, size)  { \</span>
<span class="cp">       u##size *res_ptr = (u##size *)&amp;(pcxl_res_map[pcxl_res_hint &amp; ~((size &gt;&gt; 3) - 1)]); \</span>
<span class="cp">       u##size *res_end = (u##size *)&amp;pcxl_res_map[pcxl_res_size]; \</span>
<span class="cp">       PCXL_SEARCH_LOOP(idx, mask, size); \</span>
<span class="cp">       res_ptr = (u##size *)&amp;pcxl_res_map[0]; \</span>
<span class="cp">       PCXL_SEARCH_LOOP(idx, mask, size); \</span>
<span class="cp">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">pcxl_alloc_range</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res_idx</span><span class="p">;</span>
	<span class="n">u_long</span> <span class="n">mask</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_needed</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="o">-</span><span class="mi">1L</span><span class="p">;</span>
 	<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">pages_needed</span><span class="p">;</span>

	<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;pcxl_alloc_range() size: %d pages_needed %d pages_mask 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">size</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcxl_res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">pages_needed</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PCXL_FIND_FREE_MAPPING</span><span class="p">(</span><span class="n">res_idx</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pages_needed</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PCXL_FIND_FREE_MAPPING</span><span class="p">(</span><span class="n">res_idx</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pages_needed</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PCXL_FIND_FREE_MAPPING</span><span class="p">(</span><span class="n">res_idx</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: pcxl_alloc_range() Too many pages to map.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__FILE__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dump_resmap</span><span class="p">();</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: pcxl_alloc_range() out of dma mapping resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">__FILE__</span><span class="p">);</span>
	
<span class="nl">resource_found:</span>
	
	<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;pcxl_alloc_range() res_idx %d mask 0x%08lx res_hint: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">res_idx</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">pcxl_res_hint</span><span class="p">);</span>

	<span class="n">pcxl_used_pages</span> <span class="o">+=</span> <span class="n">pages_needed</span><span class="p">;</span>
	<span class="n">pcxl_used_bytes</span> <span class="o">+=</span> <span class="p">((</span><span class="n">pages_needed</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">pages_needed</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcxl_res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dump_resmap</span><span class="p">();</span>

	<span class="cm">/* </span>
<span class="cm">	** return the corresponding vaddr in the pcxl dma map</span>
<span class="cm">	*/</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pcxl_dma_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">res_idx</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cp">#define PCXL_FREE_MAPPINGS(idx, m, size) \</span>
<span class="cp">		u##size *res_ptr = (u##size *)&amp;(pcxl_res_map[(idx) + (((size &gt;&gt; 3) - 1) &amp; (~((size &gt;&gt; 3) - 1)))]); \</span>
<span class="cp">		</span><span class="cm">/* BUG_ON((*res_ptr &amp; m) != m); */</span><span class="cp"> \</span>
<span class="cp">		*res_ptr &amp;= ~m;</span>

<span class="cm">/*</span>
<span class="cm">** clear bits in the pcxl resource map</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pcxl_free_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_long</span> <span class="n">mask</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">-</span> <span class="n">pcxl_dma_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_mapped</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="o">-</span><span class="mi">1L</span><span class="p">;</span>
 	<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">pages_mapped</span><span class="p">;</span>

	<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;pcxl_free_range() res_idx: %d size: %d pages_mapped %d mask 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">res_idx</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pages_mapped</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcxl_res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">pages_mapped</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PCXL_FREE_MAPPINGS</span><span class="p">(</span><span class="n">res_idx</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pages_mapped</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PCXL_FREE_MAPPINGS</span><span class="p">(</span><span class="n">res_idx</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pages_mapped</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PCXL_FREE_MAPPINGS</span><span class="p">(</span><span class="n">res_idx</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: pcxl_free_range() Too many pages to unmap.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__FILE__</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">pcxl_used_pages</span> <span class="o">-=</span> <span class="p">(</span><span class="n">pages_mapped</span> <span class="o">?</span> <span class="n">pages_mapped</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">pcxl_used_bytes</span> <span class="o">-=</span> <span class="p">((</span><span class="n">pages_mapped</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">pages_mapped</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcxl_res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dump_resmap</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pcxl_dma_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	u_long i = 0;</span>
<span class="c">	unsigned long *res_ptr = (u_long *)pcxl_res_map;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_pages</span> <span class="o">=</span> <span class="n">pcxl_res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>   <span class="cm">/* 8 bits per byte */</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">DMA Mapping Area size    : %d bytes (%ld pages)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">PCXL_DMA_MAP_SIZE</span><span class="p">,</span> <span class="n">total_pages</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Resource bitmap : %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcxl_res_size</span><span class="p">);</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>  <span class="s">&quot;     	  total:    free:    used:   % used:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;blocks  %8d %8ld %8ld %8ld%%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcxl_res_size</span><span class="p">,</span>
		<span class="n">pcxl_res_size</span> <span class="o">-</span> <span class="n">pcxl_used_bytes</span><span class="p">,</span> <span class="n">pcxl_used_bytes</span><span class="p">,</span>
		<span class="p">(</span><span class="n">pcxl_used_bytes</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="n">pcxl_res_size</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pages   %8ld %8ld %8ld %8ld%%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total_pages</span><span class="p">,</span>
		<span class="n">total_pages</span> <span class="o">-</span> <span class="n">pcxl_used_pages</span><span class="p">,</span> <span class="n">pcxl_used_pages</span><span class="p">,</span>
		<span class="p">(</span><span class="n">pcxl_used_pages</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">total_pages</span><span class="p">));</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	seq_puts(m, &quot;\nResource bitmap:&quot;);</span>

<span class="c">	for(; i &lt; (pcxl_res_size / sizeof(u_long)); ++i, ++res_ptr) {</span>
<span class="c">		if ((i &amp; 7) == 0)</span>
<span class="c">		    seq_puts(m,&quot;\n   &quot;);</span>
<span class="c">		seq_printf(m, &quot;%s %08lx&quot;, buf, *res_ptr);</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pcxl_dma_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">proc_pcxl_dma_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_pcxl_dma_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">proc_pcxl_dma_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">pcxl_dma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcxl_dma_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcxl_res_lock</span><span class="p">);</span>
	<span class="n">pcxl_res_size</span> <span class="o">=</span> <span class="n">PCXL_DMA_MAP_SIZE</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">pcxl_res_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcxl_res_map</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span>
					    <span class="n">get_order</span><span class="p">(</span><span class="n">pcxl_res_size</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pcxl_res_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pcxl_res_size</span><span class="p">);</span>
	<span class="n">proc_gsc_root</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="s">&quot;gsc&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_gsc_root</span><span class="p">)</span>
    		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;pcxl_dma_init: Unable to create gsc /proc dir entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">proc_dir_entry</span><span class="o">*</span> <span class="n">ent</span><span class="p">;</span>
		<span class="n">ent</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;pcxl_dma&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">proc_gsc_root</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">proc_pcxl_dma_ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ent</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;pci-dma.c: Unable to create pcxl_dma /proc entry.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__initcall</span><span class="p">(</span><span class="n">pcxl_dma_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">pa11_dma_alloc_consistent</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">pcxl_alloc_range</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">paddr</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="n">flush_kernel_dcache_range</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">paddr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
	<span class="n">map_uncached_pages</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">paddr</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="n">paddr</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* This probably isn&#39;t needed to support EISA cards.</span>
<span class="c">** ISA cards will certainly only support 24-bit DMA addressing.</span>
<span class="c">** Not clear if we can, want, or need to support ISA.</span>
<span class="c">*/</span>
<span class="c">	if (!dev || *dev-&gt;coherent_dma_mask &lt; 0xffffffff)</span>
<span class="c">		gfp |= GFP_DMA;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pa11_dma_free_consistent</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">unmap_uncached_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">pcxl_free_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">dma_handle</span><span class="p">),</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">pa11_dma_map_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>

	<span class="n">flush_kernel_dcache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pa11_dma_unmap_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
	    <span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For PCI_DMA_FROMDEVICE this flush is not necessary for the</span>
<span class="cm">	 * simple map/unmap case. However, it IS necessary if if</span>
<span class="cm">	 * pci_dma_sync_single_* has been called and the buffer reused.</span>
<span class="cm">	 */</span>

	<span class="n">flush_kernel_dcache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">dma_handle</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pa11_dma_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sglist</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="n">sg_virt_addr</span><span class="p">(</span><span class="n">sglist</span><span class="p">);</span>
		<span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
		<span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">)</span> <span class="o">=</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">flush_kernel_dcache_range</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nents</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pa11_dma_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
	    <span class="k">return</span><span class="p">;</span>

	<span class="cm">/* once we do combining we&#39;ll need to use phys_to_virt(sg_dma_address(sglist)) */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sglist</span><span class="o">++</span> <span class="p">)</span>
		<span class="n">flush_kernel_dcache_range</span><span class="p">(</span><span class="n">sg_virt_addr</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pa11_dma_sync_single_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>

	<span class="n">flush_kernel_dcache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">dma_handle</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pa11_dma_sync_single_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>

	<span class="n">flush_kernel_dcache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">dma_handle</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pa11_dma_sync_sg_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* once we do combining we&#39;ll need to use phys_to_virt(sg_dma_address(sglist)) */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sglist</span><span class="o">++</span> <span class="p">)</span>
		<span class="n">flush_kernel_dcache_range</span><span class="p">(</span><span class="n">sg_virt_addr</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pa11_dma_sync_sg_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* once we do combining we&#39;ll need to use phys_to_virt(sg_dma_address(sglist)) */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sglist</span><span class="o">++</span> <span class="p">)</span>
		<span class="n">flush_kernel_dcache_range</span><span class="p">(</span><span class="n">sg_virt_addr</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">hppa_dma_ops</span> <span class="n">pcxl_dma_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">dma_supported</span> <span class="o">=</span>	<span class="n">pa11_dma_supported</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_consistent</span> <span class="o">=</span>	<span class="n">pa11_dma_alloc_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_noncoherent</span> <span class="o">=</span>	<span class="n">pa11_dma_alloc_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_consistent</span> <span class="o">=</span>	<span class="n">pa11_dma_free_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_single</span> <span class="o">=</span>		<span class="n">pa11_dma_map_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_single</span> <span class="o">=</span>		<span class="n">pa11_dma_unmap_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span> <span class="o">=</span>		<span class="n">pa11_dma_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span> <span class="o">=</span>		<span class="n">pa11_dma_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_single_for_cpu</span> <span class="o">=</span> <span class="n">pa11_dma_sync_single_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_single_for_device</span> <span class="o">=</span> <span class="n">pa11_dma_sync_single_for_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_sg_for_cpu</span> <span class="o">=</span> <span class="n">pa11_dma_sync_sg_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_sg_for_device</span> <span class="o">=</span> <span class="n">pa11_dma_sync_sg_for_device</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fail_alloc_consistent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				   <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">pa11_dma_alloc_noncoherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					  <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pa11_dma_free_noncoherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">hppa_dma_ops</span> <span class="n">pcx_dma_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">dma_supported</span> <span class="o">=</span>	<span class="n">pa11_dma_supported</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_consistent</span> <span class="o">=</span>	<span class="n">fail_alloc_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_noncoherent</span> <span class="o">=</span>	<span class="n">pa11_dma_alloc_noncoherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_consistent</span> <span class="o">=</span>	<span class="n">pa11_dma_free_noncoherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_single</span> <span class="o">=</span>		<span class="n">pa11_dma_map_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_single</span> <span class="o">=</span>		<span class="n">pa11_dma_unmap_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span> <span class="o">=</span>		<span class="n">pa11_dma_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span> <span class="o">=</span>		<span class="n">pa11_dma_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_single_for_cpu</span> <span class="o">=</span>	<span class="n">pa11_dma_sync_single_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_single_for_device</span> <span class="o">=</span>	<span class="n">pa11_dma_sync_single_for_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_sg_for_cpu</span> <span class="o">=</span>		<span class="n">pa11_dma_sync_sg_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_sync_sg_for_device</span> <span class="o">=</span>	<span class="n">pa11_dma_sync_sg_for_device</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
