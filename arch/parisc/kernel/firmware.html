<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › kernel › firmware.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>firmware.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * arch/parisc/kernel/firmware.c  - safe PDC access routines</span>
<span class="cm"> *</span>
<span class="cm"> *	PDC == Processor Dependent Code</span>
<span class="cm"> *</span>
<span class="cm"> * See http://www.parisc-linux.org/documentation/index.html</span>
<span class="cm"> * for documentation describing the entry points and calling</span>
<span class="cm"> * conventions defined below.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1999 SuSE GmbH Nuernberg (Philipp Rumpf, prumpf@tux.org)</span>
<span class="cm"> * Copyright 1999 The Puffin Group, (Alex deVries, David Kennedy)</span>
<span class="cm"> * Copyright 2003 Grant Grundler &lt;grundler parisc-linux org&gt;</span>
<span class="cm"> * Copyright 2003,2004 Ryan Bradetich &lt;rbrad@parisc-linux.org&gt;</span>
<span class="cm"> * Copyright 2004,2006 Thibaut VARENE &lt;varenet@parisc-linux.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *    (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*	I think it would be in everyone&#39;s best interest to follow this</span>
<span class="cm"> *	guidelines when writing PDC wrappers:</span>
<span class="cm"> *</span>
<span class="cm"> *	 - the name of the pdc wrapper should match one of the macros</span>
<span class="cm"> *	   used for the first two arguments</span>
<span class="cm"> *	 - don&#39;t use caps for random parts of the name</span>
<span class="cm"> *	 - use the static PDC result buffers and &quot;copyout&quot; to structs</span>
<span class="cm"> *	   supplied by the caller to encapsulate alignment restrictions</span>
<span class="cm"> *	 - hold pdc_lock while in PDC or using static result buffers</span>
<span class="cm"> *	 - use __pa() to convert virtual (kernel) pointers to physical</span>
<span class="cm"> *	   ones.</span>
<span class="cm"> *	 - the name of the struct used for pdc return values should equal</span>
<span class="cm"> *	   one of the macros used for the first two arguments to the</span>
<span class="cm"> *	   corresponding PDC call</span>
<span class="cm"> *	 - keep the order of arguments</span>
<span class="cm"> *	 - don&#39;t be smart (setting trailing NUL bytes for strings, return</span>
<span class="cm"> *	   something useful even if the call failed) unless you are sure</span>
<span class="cm"> *	   it&#39;s not going to affect functionality or performance</span>
<span class="cm"> *</span>
<span class="cm"> *	Example:</span>
<span class="cm"> *	int pdc_cache_info(struct pdc_cache_info *cache_info )</span>
<span class="cm"> *	{</span>
<span class="cm"> *		int retval;</span>
<span class="cm"> *</span>
<span class="cm"> *		spin_lock_irq(&amp;pdc_lock);</span>
<span class="cm"> *		retval = mem_pdc_call(PDC_CACHE,PDC_CACHE_INFO,__pa(cache_info),0);</span>
<span class="cm"> *		convert_to_wide(pdc_result);</span>
<span class="cm"> *		memcpy(cache_info, pdc_result, sizeof(*cache_info));</span>
<span class="cm"> *		spin_unlock_irq(&amp;pdc_lock);</span>
<span class="cm"> *</span>
<span class="cm"> *		return retval;</span>
<span class="cm"> *	}</span>
<span class="cm"> *					prumpf	991016	</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pdc.h&gt;</span>
<span class="cp">#include &lt;asm/pdcpat.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;	</span><span class="cm">/* for boot_cpu_data */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">pdc_lock</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pdc_result</span><span class="p">[</span><span class="n">NUM_PDC_RESULT</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pdc_result2</span><span class="p">[</span><span class="n">NUM_PDC_RESULT</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define WIDE_FIRMWARE 0x1</span>
<span class="cp">#define NARROW_FIRMWARE 0x2</span>

<span class="cm">/* Firmware needs to be initially set to narrow to determine the </span>
<span class="cm"> * actual firmware width. */</span>
<span class="kt">int</span> <span class="n">parisc_narrow_firmware</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* On most currently-supported platforms, IODC I/O calls are 32-bit calls</span>
<span class="cm"> * and MEM_PDC calls are always the same width as the OS.</span>
<span class="cm"> * Some PAT boxes may have 64-bit IODC I/O.</span>
<span class="cm"> *</span>
<span class="cm"> * Ryan Bradetich added the now obsolete CONFIG_PDC_NARROW to allow</span>
<span class="cm"> * 64-bit kernels to run on systems with 32-bit MEM_PDC calls.</span>
<span class="cm"> * This allowed wide kernels to run on Cxxx boxes.</span>
<span class="cm"> * We now detect 32-bit-only PDC and dynamically switch to 32-bit mode</span>
<span class="cm"> * when running a 64-bit kernel on such boxes (e.g. C200 or C360).</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="kt">long</span> <span class="n">real64_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">function</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#endif</span>
<span class="kt">long</span> <span class="n">real32_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">function</span><span class="p">,</span> <span class="p">...);</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#   define MEM_PDC (unsigned long)(PAGE0-&gt;mem_pdc_hi) &lt;&lt; 32 | PAGE0-&gt;mem_pdc</span>
<span class="cp">#   define mem_pdc_call(args...) unlikely(parisc_narrow_firmware) ? real32_call(MEM_PDC, args) : real64_call(MEM_PDC, args)</span>
<span class="cp">#else</span>
<span class="cp">#   define MEM_PDC (unsigned long)PAGE0-&gt;mem_pdc</span>
<span class="cp">#   define mem_pdc_call(args...) real32_call(MEM_PDC, args)</span>
<span class="cp">#endif</span>


<span class="cm">/**</span>
<span class="cm"> * f_extend - Convert PDC addresses to kernel addresses.</span>
<span class="cm"> * @address: Address returned from PDC.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to convert PDC addresses into kernel addresses</span>
<span class="cm"> * when the PDC address size and kernel address size are different.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">f_extend</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">parisc_narrow_firmware</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">((</span><span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xf0000000</span><span class="p">)</span>
			<span class="k">return</span> <span class="mh">0xf0f0f0f000000000UL</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>

		<span class="k">if</span><span class="p">((</span><span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0xf0000000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xf0000000</span><span class="p">)</span>
			<span class="k">return</span> <span class="mh">0xffffffff00000000UL</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">address</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * convert_to_wide - Convert the return buffer addresses into kernel addresses.</span>
<span class="cm"> * @address: The return buffer from PDC.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to convert the return buffer addresses retrieved from PDC</span>
<span class="cm"> * into kernel addresses when the PDC address size and kernel address size are</span>
<span class="cm"> * different.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">convert_to_wide</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">parisc_narrow_firmware</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
			<span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">set_firmware_width_unlocked</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_MODEL</span><span class="p">,</span> <span class="n">PDC_MODEL_CAPABILITIES</span><span class="p">,</span>
		<span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NARROW_FIRMWARE</span><span class="p">)</span>
		<span class="n">parisc_narrow_firmware</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
	
<span class="cm">/**</span>
<span class="cm"> * set_firmware_width - Determine if the firmware is wide or narrow.</span>
<span class="cm"> * </span>
<span class="cm"> * This function must be called before any pdc_* function that uses the</span>
<span class="cm"> * convert_to_wide function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">set_firmware_width</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">set_firmware_width_unlocked</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">set_firmware_width_unlocked</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">set_firmware_width</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/*CONFIG_64BIT*/</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * pdc_emergency_unlock - Unlock the linux pdc lock</span>
<span class="cm"> *</span>
<span class="cm"> * This call unlocks the linux pdc lock in case we need some PDC functions</span>
<span class="cm"> * (like pdc_add_valid) during kernel stack dump.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pdc_emergency_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="cm">/* Spinlock DEBUG code freaks out if we unconditionally unlock */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">spin_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">))</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pdc_add_valid - Verify address can be accessed without causing a HPMC.</span>
<span class="cm"> * @address: Address to be verified.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call attempts to read from the specified address and verifies</span>
<span class="cm"> * if the address is valid.</span>
<span class="cm"> * </span>
<span class="cm"> * The return value is PDC_OK (0) in case accessing this address is valid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_add_valid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_ADD_VALID</span><span class="p">,</span> <span class="n">PDC_ADD_VALID_VERIFY</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_add_valid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_chassis_info - Return chassis information.</span>
<span class="cm"> * @result: The return buffer.</span>
<span class="cm"> * @chassis_info: The memory buffer address.</span>
<span class="cm"> * @len: The size of the memory buffer address.</span>
<span class="cm"> *</span>
<span class="cm"> * An HVERSION dependent call for returning the chassis information.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">pdc_chassis_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_chassis_info</span> <span class="o">*</span><span class="n">chassis_info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">led_info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_result</span><span class="p">,</span> <span class="n">chassis_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chassis_info</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_result2</span><span class="p">,</span> <span class="n">led_info</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_CHASSIS</span><span class="p">,</span> <span class="n">PDC_RETURN_CHASSIS_INFO</span><span class="p">,</span>
                              <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result2</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">chassis_info</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chassis_info</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">led_info</span><span class="p">,</span> <span class="n">pdc_result2</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_pat_chassis_send_log - Sends a PDC PAT CHASSIS log message.</span>
<span class="cm"> * @retval: -1 on error, 0 on success. Other value are PDC errors</span>
<span class="cm"> * </span>
<span class="cm"> * Must be correctly formatted or expect system crash</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="kt">int</span> <span class="nf">pdc_pat_chassis_send_log</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
        
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_pdc_pat</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PAT_CHASSIS_LOG</span><span class="p">,</span> <span class="n">PDC_PAT_CHASSIS_WRITE_LOG</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_chassis_disp - Updates chassis code</span>
<span class="cm"> * @retval: -1 on error, 0 on success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_chassis_disp</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">disp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_CHASSIS</span><span class="p">,</span> <span class="n">PDC_CHASSIS_DISP</span><span class="p">,</span> <span class="n">disp</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_chassis_warn - Fetches chassis warnings</span>
<span class="cm"> * @retval: -1 on error, 0 on success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_chassis_warn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">warn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_CHASSIS</span><span class="p">,</span> <span class="n">PDC_CHASSIS_WARN</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">));</span>
	<span class="o">*</span><span class="n">warn</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">pdc_coproc_cfg_unlocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_coproc_cfg</span> <span class="o">*</span><span class="n">pdc_coproc_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_COPROC</span><span class="p">,</span> <span class="n">PDC_COPROC_CFG</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">));</span>
	<span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
	<span class="n">pdc_coproc_info</span><span class="o">-&gt;</span><span class="n">ccr_functional</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">pdc_coproc_info</span><span class="o">-&gt;</span><span class="n">ccr_present</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">pdc_coproc_info</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
	<span class="n">pdc_coproc_info</span><span class="o">-&gt;</span><span class="n">model</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">18</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_coproc_cfg - To identify coprocessors attached to the processor.</span>
<span class="cm"> * @pdc_coproc_info: Return buffer address.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call returns the presence and status of all the coprocessors</span>
<span class="cm"> * attached to the processor.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">pdc_coproc_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_coproc_cfg</span> <span class="o">*</span><span class="n">pdc_coproc_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pdc_coproc_cfg_unlocked</span><span class="p">(</span><span class="n">pdc_coproc_info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_iodc_read - Read data from the modules IODC.</span>
<span class="cm"> * @actcnt: The actual number of bytes.</span>
<span class="cm"> * @hpa: The HPA of the module for the iodc read.</span>
<span class="cm"> * @index: The iodc entry point.</span>
<span class="cm"> * @iodc_data: A buffer memory for the iodc options.</span>
<span class="cm"> * @iodc_data_size: Size of the memory buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call reads from the IODC of the module specified by the hpa</span>
<span class="cm"> * argument.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_iodc_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">actcnt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
		  <span class="kt">void</span> <span class="o">*</span><span class="n">iodc_data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iodc_data_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_IODC</span><span class="p">,</span> <span class="n">PDC_IODC_READ</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">hpa</span><span class="p">,</span> 
			      <span class="n">index</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result2</span><span class="p">),</span> <span class="n">iodc_data_size</span><span class="p">);</span>
	<span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
	<span class="o">*</span><span class="n">actcnt</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">iodc_data</span><span class="p">,</span> <span class="n">pdc_result2</span><span class="p">,</span> <span class="n">iodc_data_size</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_iodc_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_system_map_find_mods - Locate unarchitected modules.</span>
<span class="cm"> * @pdc_mod_info: Return buffer address.</span>
<span class="cm"> * @mod_path: pointer to dev path structure.</span>
<span class="cm"> * @mod_index: fixed address module index.</span>
<span class="cm"> *</span>
<span class="cm"> * To locate and identify modules which reside at fixed I/O addresses, which</span>
<span class="cm"> * do not self-identify via architected bus walks.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_system_map_find_mods</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_system_map_mod_info</span> <span class="o">*</span><span class="n">pdc_mod_info</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">pdc_module_path</span> <span class="o">*</span><span class="n">mod_path</span><span class="p">,</span> <span class="kt">long</span> <span class="n">mod_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_SYSTEM_MAP</span><span class="p">,</span> <span class="n">PDC_FIND_MODULE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> 
			      <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result2</span><span class="p">),</span> <span class="n">mod_index</span><span class="p">);</span>
	<span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pdc_mod_info</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pdc_mod_info</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mod_path</span><span class="p">,</span> <span class="n">pdc_result2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod_path</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pdc_mod_info</span><span class="o">-&gt;</span><span class="n">mod_addr</span> <span class="o">=</span> <span class="n">f_extend</span><span class="p">(</span><span class="n">pdc_mod_info</span><span class="o">-&gt;</span><span class="n">mod_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_system_map_find_addrs - Retrieve additional address ranges.</span>
<span class="cm"> * @pdc_addr_info: Return buffer address.</span>
<span class="cm"> * @mod_index: Fixed address module index.</span>
<span class="cm"> * @addr_index: Address range index.</span>
<span class="cm"> * </span>
<span class="cm"> * Retrieve additional information about subsequent address ranges for modules</span>
<span class="cm"> * with multiple address ranges.  </span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_system_map_find_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_system_map_addr_info</span> <span class="o">*</span><span class="n">pdc_addr_info</span><span class="p">,</span> 
			      <span class="kt">long</span> <span class="n">mod_index</span><span class="p">,</span> <span class="kt">long</span> <span class="n">addr_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_SYSTEM_MAP</span><span class="p">,</span> <span class="n">PDC_FIND_ADDRESS</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span>
			      <span class="n">mod_index</span><span class="p">,</span> <span class="n">addr_index</span><span class="p">);</span>
	<span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pdc_addr_info</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pdc_addr_info</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pdc_addr_info</span><span class="o">-&gt;</span><span class="n">mod_addr</span> <span class="o">=</span> <span class="n">f_extend</span><span class="p">(</span><span class="n">pdc_addr_info</span><span class="o">-&gt;</span><span class="n">mod_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_model_info - Return model information about the processor.</span>
<span class="cm"> * @model: The return buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the version numbers, identifiers, and capabilities from the processor module.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_model_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_model</span> <span class="o">*</span><span class="n">model</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_MODEL</span><span class="p">,</span> <span class="n">PDC_MODEL_INFO</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">model</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_model_sysmodel - Get the system model name.</span>
<span class="cm"> * @name: A char array of at least 81 characters.</span>
<span class="cm"> *</span>
<span class="cm"> * Get system model name from PDC ROM (e.g. 9000/715 or 9000/778/B160L).</span>
<span class="cm"> * Using OS_ID_HPUX will return the equivalent of the &#39;modelname&#39; command</span>
<span class="cm"> * on HP/UX.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_model_sysmodel</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_MODEL</span><span class="p">,</span> <span class="n">PDC_MODEL_SYSMODEL</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span>
                              <span class="n">OS_ID_HPUX</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
        <span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">[</span><span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* add trailing &#39;\0&#39; */</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_model_versions - Identify the version number of each processor.</span>
<span class="cm"> * @cpu_id: The return buffer.</span>
<span class="cm"> * @id: The id of the processor to check.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the version number for each processor component.</span>
<span class="cm"> *</span>
<span class="cm"> * This comment was here before, but I do not know what it means :( -RB</span>
<span class="cm"> * id: 0 = cpu revision, 1 = boot-rom-version</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_model_versions</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">versions</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_MODEL</span><span class="p">,</span> <span class="n">PDC_MODEL_VERSIONS</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">id</span><span class="p">);</span>
        <span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
        <span class="o">*</span><span class="n">versions</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_model_cpuid - Returns the CPU_ID.</span>
<span class="cm"> * @cpu_id: The return buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the CPU_ID value which uniquely identifies the cpu portion of</span>
<span class="cm"> * the processor module.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_model_cpuid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* preset zero (call may not be implemented!) */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_MODEL</span><span class="p">,</span> <span class="n">PDC_MODEL_CPU_ID</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
        <span class="o">*</span><span class="n">cpu_id</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_model_capabilities - Returns the platform capabilities.</span>
<span class="cm"> * @capabilities: The return buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns information about platform support for 32- and/or 64-bit</span>
<span class="cm"> * OSes, IO-PDIR coherency, and virtual aliasing.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_model_capabilities</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">capabilities</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* preset zero (call may not be implemented!) */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_MODEL</span><span class="p">,</span> <span class="n">PDC_MODEL_CAPABILITIES</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">PDC_MODEL_OS32</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_cache_info - Return cache and TLB information.</span>
<span class="cm"> * @cache_info: The return buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns information about the processor&#39;s cache and TLB.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_cache_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_cache_info</span> <span class="o">*</span><span class="n">cache_info</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_CACHE</span><span class="p">,</span> <span class="n">PDC_CACHE_INFO</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">cache_info</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache_info</span><span class="p">));</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_spaceid_bits - Return whether Space ID hashing is turned on.</span>
<span class="cm"> * @space_bits: Should be 0, if not, bad mojo!</span>
<span class="cm"> *</span>
<span class="cm"> * Returns information about Space ID hashing.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_spaceid_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">space_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_CACHE</span><span class="p">,</span> <span class="n">PDC_CACHE_RET_SPID</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
	<span class="o">*</span><span class="n">space_bits</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_PA20</span>
<span class="cm">/**</span>
<span class="cm"> * pdc_btlb_info - Return block TLB information.</span>
<span class="cm"> * @btlb: The return buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns information about the hardware Block TLB.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_btlb_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_btlb_info</span> <span class="o">*</span><span class="n">btlb</span><span class="p">)</span> 
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_BLOCK_TLB</span><span class="p">,</span> <span class="n">PDC_BTLB_INFO</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">btlb</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">btlb</span><span class="p">));</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">btlb</span><span class="o">-&gt;</span><span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_mem_map_hpa - Find fixed module information.  </span>
<span class="cm"> * @address: The return buffer</span>
<span class="cm"> * @mod_path: pointer to dev path structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This call was developed for S700 workstations to allow the kernel to find</span>
<span class="cm"> * the I/O devices (Core I/O). In the future (Kittyhawk and beyond) this</span>
<span class="cm"> * call will be replaced (on workstations) by the architected PDC_SYSTEM_MAP</span>
<span class="cm"> * call.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is supported by all existing S700 workstations (up to  Gecko).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_mem_map_hpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_memory_map</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pdc_module_path</span> <span class="o">*</span><span class="n">mod_path</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">pdc_result2</span><span class="p">,</span> <span class="n">mod_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod_path</span><span class="p">));</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_MEM_MAP</span><span class="p">,</span> <span class="n">PDC_MEM_MAP_HPA</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span>
				<span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result2</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">address</span><span class="p">));</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* !CONFIG_PA20 */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * pdc_lan_station_id - Get the LAN address.</span>
<span class="cm"> * @lan_addr: The return buffer.</span>
<span class="cm"> * @hpa: The network device HPA.</span>
<span class="cm"> *</span>
<span class="cm"> * Get the LAN station address when it is not directly available from the LAN hardware.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_lan_station_id</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">lan_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_LAN_STATION_ID</span><span class="p">,</span> <span class="n">PDC_LAN_STATION_ID_READ</span><span class="p">,</span>
			<span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">hpa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: else read MAC from NVRAM */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">lan_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PDC_LAN_STATION_ID_SIZE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">lan_addr</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="n">PDC_LAN_STATION_ID_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_lan_station_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_stable_read - Read data from Stable Storage.</span>
<span class="cm"> * @staddr: Stable Storage address to access.</span>
<span class="cm"> * @memaddr: The memory address where Stable Storage data shall be copied.</span>
<span class="cm"> * @count: number of bytes to transfer. count is multiple of 4.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call reads from the Stable Storage address supplied in staddr</span>
<span class="cm"> * and copies count bytes to the memory address memaddr.</span>
<span class="cm"> * The call will fail if staddr+count &gt; PDC_STABLE size.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_stable_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">staddr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">memaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
       <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

       <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
       <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_STABLE</span><span class="p">,</span> <span class="n">PDC_STABLE_READ</span><span class="p">,</span> <span class="n">staddr</span><span class="p">,</span>
               <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">count</span><span class="p">);</span>
       <span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
       <span class="n">memcpy</span><span class="p">(</span><span class="n">memaddr</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
       <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

       <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_stable_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_stable_write - Write data to Stable Storage.</span>
<span class="cm"> * @staddr: Stable Storage address to access.</span>
<span class="cm"> * @memaddr: The memory address where Stable Storage data shall be read from.</span>
<span class="cm"> * @count: number of bytes to transfer. count is multiple of 4.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call reads count bytes from the supplied memaddr address,</span>
<span class="cm"> * and copies count bytes to the Stable Storage address staddr.</span>
<span class="cm"> * The call will fail if staddr+count &gt; PDC_STABLE size.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_stable_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">staddr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">memaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
       <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

       <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
       <span class="n">memcpy</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">,</span> <span class="n">memaddr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
       <span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
       <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_STABLE</span><span class="p">,</span> <span class="n">PDC_STABLE_WRITE</span><span class="p">,</span> <span class="n">staddr</span><span class="p">,</span>
               <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">count</span><span class="p">);</span>
       <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

       <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_stable_write</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_stable_get_size - Get Stable Storage size in bytes.</span>
<span class="cm"> * @size: pointer where the size will be stored.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call returns the number of bytes in the processor&#39;s Stable</span>
<span class="cm"> * Storage, which is the number of contiguous bytes implemented in Stable</span>
<span class="cm"> * Storage starting from staddr=0. size in an unsigned 64-bit integer</span>
<span class="cm"> * which is a multiple of four.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_stable_get_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
       <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

       <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
       <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_STABLE</span><span class="p">,</span> <span class="n">PDC_STABLE_RETURN_SIZE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">));</span>
       <span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
       <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

       <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_stable_get_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_stable_verify_contents - Checks that Stable Storage contents are valid.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call is meant to be used to check the integrity of the current</span>
<span class="cm"> * contents of Stable Storage.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_stable_verify_contents</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
       <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

       <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
       <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_STABLE</span><span class="p">,</span> <span class="n">PDC_STABLE_VERIFY_CONTENTS</span><span class="p">);</span>
       <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

       <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_stable_verify_contents</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_stable_initialize - Sets Stable Storage contents to zero and initialize</span>
<span class="cm"> * the validity indicator.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call will erase all contents of Stable Storage. Use with care!</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_stable_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
       <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

       <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
       <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_STABLE</span><span class="p">,</span> <span class="n">PDC_STABLE_INITIALIZE</span><span class="p">);</span>
       <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

       <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_stable_initialize</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_get_initiator - Get the SCSI Interface Card params (SCSI ID, SDTR, SE or LVD)</span>
<span class="cm"> * @hwpath: fully bc.mod style path to the device.</span>
<span class="cm"> * @initiator: the array to return the result into</span>
<span class="cm"> *</span>
<span class="cm"> * Get the SCSI operational parameters from PDC.</span>
<span class="cm"> * Needed since HPUX never used BIOS or symbios card NVRAM.</span>
<span class="cm"> * Most ncr/sym cards won&#39;t have an entry and just use whatever</span>
<span class="cm"> * capabilities of the card are (eg Ultra, LVD). But there are</span>
<span class="cm"> * several cases where it&#39;s useful:</span>
<span class="cm"> *    o set SCSI id for Multi-initiator clusters,</span>
<span class="cm"> *    o cable too long (ie SE scsi 10Mhz won&#39;t support 6m length),</span>
<span class="cm"> *    o bus width exported is less than what the interface chip supports.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_get_initiator</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">hwpath</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pdc_initiator</span> <span class="o">*</span><span class="n">initiator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* BCJ-XXXX series boxes. E.G. &quot;9000/785/C3000&quot; */</span>
<span class="cp">#define IS_SPROCKETS() (strlen(boot_cpu_data.pdc.sys_model_name) == 14 &amp;&amp; \</span>
<span class="cp">	strncmp(boot_cpu_data.pdc.sys_model_name, &quot;9000/785&quot;, 8) == 0)</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_INITIATOR</span><span class="p">,</span> <span class="n">PDC_GET_INITIATOR</span><span class="p">,</span> 
			      <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">hwpath</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="n">PDC_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">initiator</span><span class="o">-&gt;</span><span class="n">host_id</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">initiator</span><span class="o">-&gt;</span><span class="n">host_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sprockets and Piranha return 20 or 40 (MT/s).  Prelude returns</span>
<span class="cm">	 * 1, 2, 5 or 10 for 5, 10, 20 or 40 MT/s, respectively</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pdc_result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span>  <span class="mi">1</span>: <span class="n">initiator</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span>  <span class="mi">2</span>: <span class="n">initiator</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span>  <span class="mi">5</span>: <span class="n">initiator</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">25</span>: <span class="n">initiator</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">20</span>: <span class="n">initiator</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">40</span>: <span class="n">initiator</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="n">initiator</span><span class="o">-&gt;</span><span class="n">factor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SPROCKETS</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">initiator</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">initiator</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">initiator</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">initiator</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="n">PDC_OK</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_get_initiator</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * pdc_pci_irt_size - Get the number of entries in the interrupt routing table.</span>
<span class="cm"> * @num_entries: The return value.</span>
<span class="cm"> * @hpa: The HPA for the device.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC function returns the number of entries in the specified cell&#39;s</span>
<span class="cm"> * interrupt table.</span>
<span class="cm"> * Similar to PDC_PAT stuff - but added for Forte/Allegro boxes</span>
<span class="cm"> */</span> 
<span class="kt">int</span> <span class="nf">pdc_pci_irt_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">num_entries</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PCI_INDEX</span><span class="p">,</span> <span class="n">PDC_PCI_GET_INT_TBL_SIZE</span><span class="p">,</span> 
			      <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">hpa</span><span class="p">);</span>
	<span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
	<span class="o">*</span><span class="n">num_entries</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** </span>
<span class="cm"> * pdc_pci_irt - Get the PCI interrupt routing table.</span>
<span class="cm"> * @num_entries: The number of entries in the table.</span>
<span class="cm"> * @hpa: The Hard Physical Address of the device.</span>
<span class="cm"> * @tbl: </span>
<span class="cm"> *</span>
<span class="cm"> * Get the PCI interrupt routing table for the device at the given HPA.</span>
<span class="cm"> * Similar to PDC_PAT stuff - but added for Forte/Allegro boxes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_pci_irt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_entries</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">tbl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tbl</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_entries</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PCI_INDEX</span><span class="p">,</span> <span class="n">PDC_PCI_GET_INT_TBL</span><span class="p">,</span> 
			      <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">hpa</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">tbl</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#if 0</span><span class="c">	/* UNTEST CODE - left here in case someone needs it */</span>

<span class="c">/** </span>
<span class="c"> * pdc_pci_config_read - read PCI config space.</span>
<span class="c"> * @hpa		token from PDC to indicate which PCI device</span>
<span class="c"> * @pci_addr	configuration space address to read from</span>
<span class="c"> *</span>
<span class="c"> * Read PCI Configuration space *before* linux PCI subsystem is running.</span>
<span class="c"> */</span>
<span class="c">unsigned int pdc_pci_config_read(void *hpa, unsigned long cfg_addr)</span>
<span class="c">{</span>
<span class="c">	int retval;</span>
<span class="c">	unsigned long flags;</span>

<span class="c">	spin_lock_irqsave(&amp;pdc_lock, flags);</span>
<span class="c">	pdc_result[0] = 0;</span>
<span class="c">	pdc_result[1] = 0;</span>
<span class="c">	retval = mem_pdc_call(PDC_PCI_INDEX, PDC_PCI_READ_CONFIG, </span>
<span class="c">			      __pa(pdc_result), hpa, cfg_addr&amp;~3UL, 4UL);</span>
<span class="c">	spin_unlock_irqrestore(&amp;pdc_lock, flags);</span>

<span class="c">	return retval ? ~0 : (unsigned int) pdc_result[0];</span>
<span class="c">}</span>


<span class="c">/** </span>
<span class="c"> * pdc_pci_config_write - read PCI config space.</span>
<span class="c"> * @hpa		token from PDC to indicate which PCI device</span>
<span class="c"> * @pci_addr	configuration space address to write</span>
<span class="c"> * @val		value we want in the 32-bit register</span>
<span class="c"> *</span>
<span class="c"> * Write PCI Configuration space *before* linux PCI subsystem is running.</span>
<span class="c"> */</span>
<span class="c">void pdc_pci_config_write(void *hpa, unsigned long cfg_addr, unsigned int val)</span>
<span class="c">{</span>
<span class="c">	int retval;</span>
<span class="c">	unsigned long flags;</span>

<span class="c">	spin_lock_irqsave(&amp;pdc_lock, flags);</span>
<span class="c">	pdc_result[0] = 0;</span>
<span class="c">	retval = mem_pdc_call(PDC_PCI_INDEX, PDC_PCI_WRITE_CONFIG, </span>
<span class="c">			      __pa(pdc_result), hpa,</span>
<span class="c">			      cfg_addr&amp;~3UL, 4UL, (unsigned long) val);</span>
<span class="c">	spin_unlock_irqrestore(&amp;pdc_lock, flags);</span>

<span class="c">	return retval;</span>
<span class="c">}</span>
<span class="cp">#endif /* UNTESTED CODE */</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_tod_read - Read the Time-Of-Day clock.</span>
<span class="cm"> * @tod: The return buffer:</span>
<span class="cm"> *</span>
<span class="cm"> * Read the Time-Of-Day clock</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_tod_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_tod</span> <span class="o">*</span><span class="n">tod</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_TOD</span><span class="p">,</span> <span class="n">PDC_TOD_READ</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">tod</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tod</span><span class="p">));</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_tod_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_tod_set - Set the Time-Of-Day clock.</span>
<span class="cm"> * @sec: The number of seconds since epoch.</span>
<span class="cm"> * @usec: The number of micro seconds.</span>
<span class="cm"> *</span>
<span class="cm"> * Set the Time-Of-Day clock.</span>
<span class="cm"> */</span> 
<span class="kt">int</span> <span class="nf">pdc_tod_set</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_TOD</span><span class="p">,</span> <span class="n">PDC_TOD_WRITE</span><span class="p">,</span> <span class="n">sec</span><span class="p">,</span> <span class="n">usec</span><span class="p">);</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_tod_set</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="kt">int</span> <span class="nf">pdc_mem_mem_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_memory_table_raddr</span> <span class="o">*</span><span class="n">r_addr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pdc_memory_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_MEM</span><span class="p">,</span> <span class="n">PDC_MEM_TABLE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result2</span><span class="p">),</span> <span class="n">entries</span><span class="p">);</span>
	<span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">r_addr</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">r_addr</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">pdc_result2</span><span class="p">,</span> <span class="n">entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tbl</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cm">/* FIXME: Is this pdc used?  I could not find type reference to ftc_bitmap</span>
<span class="cm"> * so I guessed at unsigned long.  Someone who knows what this does, can fix</span>
<span class="cm"> * it later. :)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_do_firm_test_reset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ftc_bitmap</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_BROADCAST_RESET</span><span class="p">,</span> <span class="n">PDC_DO_FIRM_TEST_RESET</span><span class="p">,</span>
                              <span class="n">PDC_FIRM_TEST_MAGIC</span><span class="p">,</span> <span class="n">ftc_bitmap</span><span class="p">);</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pdc_do_reset - Reset the system.</span>
<span class="cm"> *</span>
<span class="cm"> * Reset the system.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_do_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_BROADCAST_RESET</span><span class="p">,</span> <span class="n">PDC_DO_RESET</span><span class="p">);</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pdc_soft_power_info - Enable soft power switch.</span>
<span class="cm"> * @power_reg: address of soft power register</span>
<span class="cm"> *</span>
<span class="cm"> * Return the absolute address of the soft power switch register</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">pdc_soft_power_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">power_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="o">*</span><span class="n">power_reg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_SOFT_POWER</span><span class="p">,</span> <span class="n">PDC_SOFT_POWER_INFO</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">convert_to_wide</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">);</span>
                <span class="o">*</span><span class="n">power_reg</span> <span class="o">=</span> <span class="n">f_extend</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pdc_soft_power_button - Control the soft power button behaviour</span>
<span class="cm"> * @sw_control: 0 for hardware control, 1 for software control </span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC function places the soft power button under software or</span>
<span class="cm"> * hardware control.</span>
<span class="cm"> * Under software control the OS may control to when to allow to shut </span>
<span class="cm"> * down the system. Under hardware control pressing the power button </span>
<span class="cm"> * powers off the system immediately.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_soft_power_button</span><span class="p">(</span><span class="kt">int</span> <span class="n">sw_control</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_SOFT_POWER</span><span class="p">,</span> <span class="n">PDC_SOFT_POWER_ENABLE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">sw_control</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pdc_io_reset - Hack to avoid overlapping range registers of Bridges devices.</span>
<span class="cm"> * Primarily a problem on T600 (which parisc-linux doesn&#39;t support) but</span>
<span class="cm"> * who knows what other platform firmware might do with this OS &quot;hook&quot;.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pdc_io_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_IO</span><span class="p">,</span> <span class="n">PDC_IO_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pdc_io_reset_devices - Hack to Stop USB controller</span>
<span class="cm"> *</span>
<span class="cm"> * If PDC used the usb controller, the usb controller</span>
<span class="cm"> * is still running and will crash the machines during iommu </span>
<span class="cm"> * setup, because of still running DMA. This PDC call</span>
<span class="cm"> * stops the USB controller.</span>
<span class="cm"> * Normally called after calling pdc_io_reset().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pdc_io_reset_devices</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_IO</span><span class="p">,</span> <span class="n">PDC_IO_RESET_DEVICES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* locked by pdc_console_lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)))</span>   <span class="n">iodc_retbuf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span> <span class="n">iodc_dbuf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_iodc_print - Console print using IODC.</span>
<span class="cm"> * @str: the string to output.</span>
<span class="cm"> * @count: length of str</span>
<span class="cm"> *</span>
<span class="cm"> * Note that only these special chars are architected for console IODC io:</span>
<span class="cm"> * BEL, BS, CR, and LF. Others are passed through.</span>
<span class="cm"> * Since the HP console requires CR+LF to perform a &#39;newline&#39;, we translate</span>
<span class="cm"> * &quot;\n&quot; to &quot;\r\n&quot;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_iodc_print</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;)</span> <span class="p">{</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;\n&#39;</span>:
			<span class="n">iodc_dbuf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\r&#39;</span><span class="p">;</span>
			<span class="n">iodc_dbuf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">print</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">iodc_dbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">print:</span>
        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">real32_call</span><span class="p">(</span><span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_cons</span><span class="p">.</span><span class="n">iodc_io</span><span class="p">,</span>
                    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_cons</span><span class="p">.</span><span class="n">hpa</span><span class="p">,</span> <span class="n">ENTRY_IO_COUT</span><span class="p">,</span>
                    <span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_cons</span><span class="p">.</span><span class="n">spa</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_cons</span><span class="p">.</span><span class="n">dp</span><span class="p">.</span><span class="n">layers</span><span class="p">),</span>
                    <span class="n">__pa</span><span class="p">(</span><span class="n">iodc_retbuf</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">iodc_dbuf</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_iodc_getc - Read a character (non-blocking) from the PDC console.</span>
<span class="cm"> *</span>
<span class="cm"> * Read a character (non-blocking) from the PDC console, returns -1 if</span>
<span class="cm"> * key is not present.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_iodc_getc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Bail if no console input device. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_kbd</span><span class="p">.</span><span class="n">iodc_io</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="cm">/* wait for a keyboard (rs232)-input */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">real32_call</span><span class="p">(</span><span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_kbd</span><span class="p">.</span><span class="n">iodc_io</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_kbd</span><span class="p">.</span><span class="n">hpa</span><span class="p">,</span> <span class="n">ENTRY_IO_CIN</span><span class="p">,</span>
		    <span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_kbd</span><span class="p">.</span><span class="n">spa</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">mem_kbd</span><span class="p">.</span><span class="n">dp</span><span class="p">.</span><span class="n">layers</span><span class="p">),</span> 
		    <span class="n">__pa</span><span class="p">(</span><span class="n">iodc_retbuf</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">iodc_dbuf</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="n">iodc_dbuf</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="o">*</span><span class="n">iodc_retbuf</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pdc_sti_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">func</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
                 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">outputr</span><span class="p">,</span>
                 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">glob_cfg</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>  
        <span class="n">retval</span> <span class="o">=</span> <span class="n">real32_call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">inptr</span><span class="p">,</span> <span class="n">outputr</span><span class="p">,</span> <span class="n">glob_cfg</span><span class="p">);</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pdc_sti_call</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cm">/**</span>
<span class="cm"> * pdc_pat_cell_get_number - Returns the cell number.</span>
<span class="cm"> * @cell_info: The return buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call returns the cell number of the cell from which the call</span>
<span class="cm"> * is made.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_pat_cell_get_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_pat_cell_num</span> <span class="o">*</span><span class="n">cell_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PAT_CELL</span><span class="p">,</span> <span class="n">PDC_PAT_CELL_GET_NUMBER</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cell_info</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cell_info</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_pat_cell_module - Retrieve the cell&#39;s module information.</span>
<span class="cm"> * @actcnt: The number of bytes written to mem_addr.</span>
<span class="cm"> * @ploc: The physical location.</span>
<span class="cm"> * @mod: The module index.</span>
<span class="cm"> * @view_type: The view of the address type.</span>
<span class="cm"> * @mem_addr: The return buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC call returns information about each module attached to the cell</span>
<span class="cm"> * at the specified location.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_pat_cell_module</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">actcnt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ploc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mod</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">view_type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">pdc_pat_cell_mod_maddr_block</span> <span class="n">result</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PAT_CELL</span><span class="p">,</span> <span class="n">PDC_PAT_CELL_MODULE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> 
			      <span class="n">ploc</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">view_type</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">actcnt</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mem_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">actcnt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_pat_cpu_get_number - Retrieve the cpu number.</span>
<span class="cm"> * @cpu_info: The return buffer.</span>
<span class="cm"> * @hpa: The Hard Physical Address of the CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve the cpu number for the cpu at the specified HPA.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_pat_cpu_get_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_pat_cpu_num</span> <span class="o">*</span><span class="n">cpu_info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PAT_CPU</span><span class="p">,</span> <span class="n">PDC_PAT_CPU_GET_NUMBER</span><span class="p">,</span>
			      <span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">hpa</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cpu_info</span><span class="p">,</span> <span class="n">pdc_result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cpu_info</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_pat_get_irt_size - Retrieve the number of entries in the cell&#39;s interrupt table.</span>
<span class="cm"> * @num_entries: The return value.</span>
<span class="cm"> * @cell_num: The target cell.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC function returns the number of entries in the specified cell&#39;s</span>
<span class="cm"> * interrupt table.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_pat_get_irt_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">num_entries</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cell_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PAT_IO</span><span class="p">,</span> <span class="n">PDC_PAT_IO_GET_PCI_ROUTING_TABLE_SIZE</span><span class="p">,</span>
			      <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">cell_num</span><span class="p">);</span>
	<span class="o">*</span><span class="n">num_entries</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_pat_get_irt - Retrieve the cell&#39;s interrupt table.</span>
<span class="cm"> * @r_addr: The return buffer.</span>
<span class="cm"> * @cell_num: The target cell.</span>
<span class="cm"> *</span>
<span class="cm"> * This PDC function returns the actual interrupt table for the specified cell.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_pat_get_irt</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">r_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cell_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PAT_IO</span><span class="p">,</span> <span class="n">PDC_PAT_IO_GET_PCI_ROUTING_TABLE</span><span class="p">,</span>
			      <span class="n">__pa</span><span class="p">(</span><span class="n">r_addr</span><span class="p">),</span> <span class="n">cell_num</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_pat_pd_get_addr_map - Retrieve information about memory address ranges.</span>
<span class="cm"> * @actlen: The return buffer.</span>
<span class="cm"> * @mem_addr: Pointer to the memory buffer.</span>
<span class="cm"> * @count: The number of bytes to read from the buffer.</span>
<span class="cm"> * @offset: The offset with respect to the beginning of the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_pat_pd_get_addr_map</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">actual_len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_addr</span><span class="p">,</span> 
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PAT_PD</span><span class="p">,</span> <span class="n">PDC_PAT_PD_GET_ADDR_MAP</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> 
			      <span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result2</span><span class="p">),</span> <span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">actual_len</span> <span class="o">=</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mem_addr</span><span class="p">,</span> <span class="n">pdc_result2</span><span class="p">,</span> <span class="o">*</span><span class="n">actual_len</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_pat_io_pci_cfg_read - Read PCI configuration space.</span>
<span class="cm"> * @pci_addr: PCI configuration space address for which the read request is being made.</span>
<span class="cm"> * @pci_size: Size of read in bytes. Valid values are 1, 2, and 4. </span>
<span class="cm"> * @mem_addr: Pointer to return memory buffer.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_pat_io_pci_cfg_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pci_size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">mem_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PAT_IO</span><span class="p">,</span> <span class="n">PDC_PAT_IO_PCI_CONFIG_READ</span><span class="p">,</span>
					<span class="n">__pa</span><span class="p">(</span><span class="n">pdc_result</span><span class="p">),</span> <span class="n">pci_addr</span><span class="p">,</span> <span class="n">pci_size</span><span class="p">);</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">pci_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">mem_addr</span> <span class="o">=</span>  <span class="p">(</span><span class="n">u8</span><span class="p">)</span>  <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">case</span> <span class="mi">2</span>: <span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">mem_addr</span> <span class="o">=</span>  <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">case</span> <span class="mi">4</span>: <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">mem_addr</span> <span class="o">=</span>  <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">pdc_result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pdc_pat_io_pci_cfg_write - Retrieve information about memory address ranges.</span>
<span class="cm"> * @pci_addr: PCI configuration space address for which the write  request is being made.</span>
<span class="cm"> * @pci_size: Size of write in bytes. Valid values are 1, 2, and 4. </span>
<span class="cm"> * @value: Pointer to 1, 2, or 4 byte value in low order end of argument to be </span>
<span class="cm"> *         written to PCI Config space.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pdc_pat_io_pci_cfg_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pci_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mem_pdc_call</span><span class="p">(</span><span class="n">PDC_PAT_IO</span><span class="p">,</span> <span class="n">PDC_PAT_IO_PCI_CONFIG_WRITE</span><span class="p">,</span>
				<span class="n">pci_addr</span><span class="p">,</span> <span class="n">pci_size</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>


<span class="cm">/***************** 32-bit real-mode calls ***********/</span>
<span class="cm">/* The struct below is used</span>
<span class="cm"> * to overlay real_stack (real2.S), preparing a 32-bit call frame.</span>
<span class="cm"> * real32_call_asm() then uses this stack in narrow real mode</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">narrow_stack</span> <span class="p">{</span>
	<span class="cm">/* use int, not long which is 64 bits */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg13</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg12</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg11</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg10</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg9</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg8</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg7</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg6</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg5</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frame_marker</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sp</span><span class="p">;</span>
	<span class="cm">/* in reality, there&#39;s nearly 8k of stack after this */</span>
<span class="p">};</span>

<span class="kt">long</span> <span class="nf">real32_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fn</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">extern</span> <span class="k">struct</span> <span class="n">narrow_stack</span> <span class="n">real_stack</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">real32_call_asm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> 
					     <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg0</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg2</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg3</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg4</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg5</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg6</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg7</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg8</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg9</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg10</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg11</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg12</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">real_stack</span><span class="p">.</span><span class="n">arg13</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">real32_call_asm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">real_stack</span><span class="p">.</span><span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">real_stack</span><span class="p">.</span><span class="n">arg0</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cm">/***************** 64-bit real-mode calls ***********/</span>

<span class="k">struct</span> <span class="n">wide_stack</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg5</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg6</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg7</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg8</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg9</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg10</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg11</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg12</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg13</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">frame_marker</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* rp, previous sp */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">;</span>
	<span class="cm">/* in reality, there&#39;s nearly 8k of stack after this */</span>
<span class="p">};</span>

<span class="kt">long</span> <span class="nf">real64_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fn</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">extern</span> <span class="k">struct</span> <span class="n">wide_stack</span> <span class="n">real64_stack</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">real64_call_asm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> 
					     <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg0</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg2</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg3</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg4</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg5</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg6</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg7</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg8</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg9</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg10</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg11</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg12</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">real64_stack</span><span class="p">.</span><span class="n">arg13</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">real64_call_asm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">real64_stack</span><span class="p">.</span><span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">real64_stack</span><span class="p">.</span><span class="n">arg0</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
