<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › kernel › smp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** SMP Support</span>
<span class="cm">**</span>
<span class="cm">** Copyright (C) 1999 Walt Drummond &lt;drummond@valinux.com&gt;</span>
<span class="cm">** Copyright (C) 1999 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm">** Copyright (C) 2001,2004 Grant Grundler &lt;grundler@parisc-linux.org&gt;</span>
<span class="cm">** </span>
<span class="cm">** Lots of stuff stolen from arch/alpha/kernel/smp.c</span>
<span class="cm">** ...and then parisc stole from arch/ia64/kernel/smp.c. Thanks David! :^)</span>
<span class="cm">**</span>
<span class="cm">** Thanks to John Curry and Ullas Ponnadi. I learned a lot from their work.</span>
<span class="cm">** -grant (1/12/2001)</span>
<span class="cm">**</span>
<span class="cm">**	This program is free software; you can redistribute it and/or modify</span>
<span class="cm">**	it under the terms of the GNU General Public License as published by</span>
<span class="cm">**      the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">**      (at your option) any later version.</span>
<span class="cm">*/</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/current.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;		</span><span class="cm">/* for CPU_IRQ_REGION and friends */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>

<span class="cp">#undef DEBUG_SMP</span>
<span class="cp">#ifdef DEBUG_SMP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smp_debug_lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#define smp_debug(lvl, printargs...)		\</span>
<span class="cp">		if (lvl &gt;= smp_debug_lvl)	\</span>
<span class="cp">			printk(printargs);</span>
<span class="cp">#else</span>
<span class="cp">#define smp_debug(lvl, ...)	do { } while(0)</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG_SMP */</span><span class="cp"></span>

<span class="k">volatile</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">smp_init_current_idle_task</span><span class="p">;</span>

<span class="cm">/* track which CPU is booting */</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">cpu_now_booting</span> <span class="n">__cpuinitdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">parisc_max_cpus</span> <span class="n">__cpuinitdata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">spinlock_t</span><span class="p">,</span> <span class="n">ipi_lock</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">ipi_message_type</span> <span class="p">{</span>
	<span class="n">IPI_NOP</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">IPI_RESCHEDULE</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">IPI_CALL_FUNC</span><span class="p">,</span>
	<span class="n">IPI_CALL_FUNC_SINGLE</span><span class="p">,</span>
	<span class="n">IPI_CPU_START</span><span class="p">,</span>
	<span class="n">IPI_CPU_STOP</span><span class="p">,</span>
	<span class="n">IPI_CPU_TEST</span>
<span class="p">};</span>


<span class="cm">/********** SMP inter processor interrupt and communication routines */</span>

<span class="cp">#undef PER_CPU_IRQ_REGION</span>
<span class="cp">#ifdef PER_CPU_IRQ_REGION</span>
<span class="cm">/* XXX REVISIT Ignore for now.</span>
<span class="cm">**    *May* need this &quot;hook&quot; to register IPI handler</span>
<span class="cm">**    once we have perCPU ExtIntr switch tables.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ipi_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpuid</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#error verify IRQ_OFFSET(IPI_IRQ) is ipi_interrupt() in new IRQ region</span>

	<span class="k">if</span><span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpuid</span><span class="p">)</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">switch_to_idle_task</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm">** Yoink this CPU from the runnable list... </span>
<span class="cm">**</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">halt_processor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="cm">/* REVISIT : redirect I/O Interrupts to another CPU? */</span>
	<span class="cm">/* REVISIT : does PM *know* this CPU isn&#39;t available? */</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;;)</span>
		<span class="p">;</span>
<span class="p">}</span>


<span class="n">irqreturn_t</span> <span class="n">__irq_entry</span>
<span class="nf">ipi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">cpuinfo_parisc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Count this now; we may make a call that never returns. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">ipi_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>	<span class="cm">/* Order interrupt and bit testing. */</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_lock</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ops</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pending_ipi</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">pending_ipi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">mb</span><span class="p">();</span> <span class="cm">/* Order bit clearing and data access. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="p">)</span>
		    <span class="k">break</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">which</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">ops</span><span class="p">);</span>

			<span class="n">ops</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">which</span><span class="p">);</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">which</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">IPI_NOP</span>:
				<span class="n">smp_debug</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d IPI_NOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
				
			<span class="k">case</span> <span class="n">IPI_RESCHEDULE</span>:
				<span class="n">smp_debug</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d IPI_RESCHEDULE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
				<span class="n">scheduler_ipi</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">IPI_CALL_FUNC</span>:
				<span class="n">smp_debug</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d IPI_CALL_FUNC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
				<span class="n">generic_smp_call_function_interrupt</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">IPI_CALL_FUNC_SINGLE</span>:
				<span class="n">smp_debug</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d IPI_CALL_FUNC_SINGLE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
				<span class="n">generic_smp_call_function_single_interrupt</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">IPI_CPU_START</span>:
				<span class="n">smp_debug</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d IPI_CPU_START</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">IPI_CPU_STOP</span>:
				<span class="n">smp_debug</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d IPI_CPU_STOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
				<span class="n">halt_processor</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">IPI_CPU_TEST</span>:
				<span class="n">smp_debug</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d is alive!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;Unknown IPI num on CPU%d: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">this_cpu</span><span class="p">,</span> <span class="n">which</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
			<span class="p">}</span> <span class="cm">/* Switch */</span>
		<span class="cm">/* let in any pending interrupts */</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="p">}</span> <span class="cm">/* while (ops) */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ipi_send</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ipi_message_type</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuinfo_parisc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_lock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">pending_ipi</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">gsc_writel</span><span class="p">(</span><span class="n">IPI_IRQ</span> <span class="o">-</span> <span class="n">CPU_IRQ_BASE</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">send_IPI_mask</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ipi_message_type</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
		<span class="n">ipi_send</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">send_IPI_single</span><span class="p">(</span><span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ipi_message_type</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dest_cpu</span> <span class="o">==</span> <span class="n">NO_PROC_ID</span><span class="p">);</span>

	<span class="n">ipi_send</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">send_IPI_allbutself</span><span class="p">(</span><span class="k">enum</span> <span class="n">ipi_message_type</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span>
			<span class="n">send_IPI_single</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kr">inline</span> <span class="kt">void</span> 
<span class="nf">smp_send_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>	<span class="p">{</span> <span class="n">send_IPI_allbutself</span><span class="p">(</span><span class="n">IPI_CPU_STOP</span><span class="p">);</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">smp_send_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>	<span class="p">{</span> <span class="n">send_IPI_allbutself</span><span class="p">(</span><span class="n">IPI_CPU_START</span><span class="p">);</span> <span class="p">}</span>

<span class="kt">void</span> 
<span class="nf">smp_send_reschedule</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span> <span class="n">send_IPI_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">IPI_RESCHEDULE</span><span class="p">);</span> <span class="p">}</span>

<span class="kt">void</span>
<span class="nf">smp_send_all_nop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">send_IPI_allbutself</span><span class="p">(</span><span class="n">IPI_NOP</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_send_call_function_ipi_mask</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">IPI_CALL_FUNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_send_call_function_single_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">send_IPI_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">IPI_CALL_FUNC_SINGLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush all other CPU&#39;s tlb and then mine.  Do this with on_each_cpu()</span>
<span class="cm"> * as we want to ensure all TLB&#39;s flushed before proceeding.</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">smp_flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">flush_tlb_all_local</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called by secondaries to update state and initialize CPU registers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">smp_cpu_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpunum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">int</span> <span class="n">init_per_cpu</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  <span class="cm">/* arch/parisc/kernel/processor.c */</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_IRQ</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>    <span class="cm">/* arch/parisc/kernel/irq.c */</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">start_cpu_itimer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="cm">/* arch/parisc/kernel/time.c */</span>

	<span class="cm">/* Set modes and Enable floating point coprocessor */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">init_per_cpu</span><span class="p">(</span><span class="n">cpunum</span><span class="p">);</span>

	<span class="n">disable_sr_hashing</span><span class="p">();</span>

	<span class="n">mb</span><span class="p">();</span>

	<span class="cm">/* Well, support 2.4 linux scheme as well. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpunum</span><span class="p">))</span>	<span class="p">{</span>
		<span class="k">extern</span> <span class="kt">void</span> <span class="n">machine_halt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="cm">/* arch/parisc.../process.c */</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;CPU#%d already initialized!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpunum</span><span class="p">);</span>
		<span class="n">machine_halt</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">notify_cpu_starting</span><span class="p">(</span><span class="n">cpunum</span><span class="p">);</span>

	<span class="n">ipi_call_lock</span><span class="p">();</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpunum</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">ipi_call_unlock</span><span class="p">();</span>

	<span class="cm">/* Initialise the idle task for this CPU */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">init_IRQ</span><span class="p">();</span>   <span class="cm">/* make sure no IRQs are enabled or pending */</span>
	<span class="n">start_cpu_itimer</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Slaves start using C here. Indirectly called from smp_slave_stext.</span>
<span class="cm"> * Do what start_kernel() and main() do for boot strap processor (aka monarch)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_callin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slave_id</span> <span class="o">=</span> <span class="n">cpu_now_booting</span><span class="p">;</span>

	<span class="n">smp_cpu_init</span><span class="p">(</span><span class="n">slave_id</span><span class="p">);</span>
	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">flush_cache_all_local</span><span class="p">();</span> <span class="cm">/* start with known state */</span>
	<span class="n">flush_tlb_all_local</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>  <span class="cm">/* Interrupts have been off until now */</span>

	<span class="n">cpu_idle</span><span class="p">();</span>      <span class="cm">/* Wait for timer to schedule some work */</span>

	<span class="cm">/* NOTREACHED */</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;smp_callin() AAAAaaaaahhhh....</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Bring one cpu online.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">smp_boot_one_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpuid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpuinfo_parisc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">task_thread_info</span><span class="p">(</span><span class="n">idle</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">;</span>

	<span class="cm">/* Let _start know what logical CPU we&#39;re booting</span>
<span class="cm">	** (offset into init_tasks[],cpu_data[])</span>
<span class="cm">	*/</span>
	<span class="n">cpu_now_booting</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	** boot strap code needs to know the task address since</span>
<span class="cm">	** it also contains the process stack.</span>
<span class="cm">	*/</span>
	<span class="n">smp_init_current_idle_task</span> <span class="o">=</span> <span class="n">idle</span> <span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Releasing cpu %d now, hpa=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** This gets PDC to release the CPU from a very tight loop.</span>
<span class="cm">	**</span>
<span class="cm">	** From the PA-RISC 2.0 Firmware Architecture Reference Specification:</span>
<span class="cm">	** &quot;The MEM_RENDEZ vector specifies the location of OS_RENDEZ which </span>
<span class="cm">	** is executed after receiving the rendezvous signal (an interrupt to </span>
<span class="cm">	** EIR{0}). MEM_RENDEZ is valid only when it is nonzero and the </span>
<span class="cm">	** contents of memory are valid.&quot;</span>
<span class="cm">	*/</span>
	<span class="n">gsc_writel</span><span class="p">(</span><span class="n">TIMER_IRQ</span> <span class="o">-</span> <span class="n">CPU_IRQ_BASE</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="cm">/* </span>
<span class="cm">	 * OK, wait a bit for that CPU to finish staggering about. </span>
<span class="cm">	 * Slave will set a bit when it reaches smp_cpu_init().</span>
<span class="cm">	 * Once the &quot;monarch CPU&quot; sees the bit change, it can move on.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">timeout</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpuid</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Which implies Slave has started up */</span>
			<span class="n">cpu_now_booting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">smp_init_current_idle_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">alive</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;SMP: CPU:%d is stuck.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="nl">alive:</span>
	<span class="cm">/* Remember the Slave data */</span>
	<span class="n">smp_debug</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;SMP: CPU:%d came alive after %ld _us</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cpuid</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_prepare_boot_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bootstrap_processor</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="n">cpuid</span><span class="p">;</span>

	<span class="cm">/* Setup BSP mappings */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMP: bootstrap CPU ID is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bootstrap_processor</span><span class="p">);</span>

	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">bootstrap_processor</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">bootstrap_processor</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm">** inventory.c:do_inventory() hasn&#39;t yet been run and thus we</span>
<span class="cm">** don&#39;t &#39;discover&#39; the additional CPUs until later.</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_prepare_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_lock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>

	<span class="n">init_cpu_present</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="n">parisc_max_cpus</span> <span class="o">=</span> <span class="n">max_cpus</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_cpus</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMP mode deactivated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">smp_cpus_done</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">__cpu_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tidle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">parisc_max_cpus</span><span class="p">)</span>
		<span class="n">smp_boot_one_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tidle</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">setup_profiling_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">multiplier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
