<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › kernel › module.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>module.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*    Kernel dynamically loadable module help for PARISC.</span>
<span class="cm"> *</span>
<span class="cm"> *    The best reference for this stuff is probably the Processor-</span>
<span class="cm"> *    Specific ELF Supplement for PA-RISC:</span>
<span class="cm"> *        http://ftp.parisc-linux.org/docs/arch/elf-pa-hp.pdf</span>
<span class="cm"> *</span>
<span class="cm"> *    Linux/PA-RISC Project (http://www.parisc-linux.org/)</span>
<span class="cm"> *    Copyright (C) 2003 Randolph Chung &lt;tausq at debian . org&gt;</span>
<span class="cm"> *    Copyright (C) 2008 Helge Deller &lt;deller@gmx.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *    it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *    (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *    This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *    GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *    You should have received a copy of the GNU General Public License</span>
<span class="cm"> *    along with this program; if not, write to the Free Software</span>
<span class="cm"> *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *    Notes:</span>
<span class="cm"> *    - PLT stub handling</span>
<span class="cm"> *      On 32bit (and sometimes 64bit) and with big kernel modules like xfs or</span>
<span class="cm"> *      ipv6 the relocation types R_PARISC_PCREL17F and R_PARISC_PCREL22F may</span>
<span class="cm"> *      fail to reach their PLT stub if we only create one big stub array for</span>
<span class="cm"> *      all sections at the beginning of the core or init section.</span>
<span class="cm"> *      Instead we now insert individual PLT stub entries directly in front of</span>
<span class="cm"> *      of the code sections where the stubs are actually called.</span>
<span class="cm"> *      This reduces the distance between the PCREL location and the stub entry</span>
<span class="cm"> *      so that the relocations can be fulfilled.</span>
<span class="cm"> *      While calculating the final layout of the kernel module in memory, the</span>
<span class="cm"> *      kernel module loader calls arch_mod_section_prepend() to request the</span>
<span class="cm"> *      to be reserved amount of memory in front of each individual section.</span>
<span class="cm"> *</span>
<span class="cm"> *    - SEGREL32 handling</span>
<span class="cm"> *      We are not doing SEGREL32 handling correctly. According to the ABI, we</span>
<span class="cm"> *      should do a value offset, like this:</span>
<span class="cm"> *			if (in_init(me, (void *)val))</span>
<span class="cm"> *				val -= (uint32_t)me-&gt;module_init;</span>
<span class="cm"> *			else</span>
<span class="cm"> *				val -= (uint32_t)me-&gt;module_core;</span>
<span class="cm"> *	However, SEGREL32 is used only for PARISC unwind entries, and we want</span>
<span class="cm"> *	those entries to have an absolute address, and not just an offset.</span>
<span class="cm"> *</span>
<span class="cm"> *	The unwind table mechanism has the ability to specify an offset for </span>
<span class="cm"> *	the unwind table; however, because we split off the init functions into</span>
<span class="cm"> *	a different piece of memory, it is not possible to do this using a </span>
<span class="cm"> *	single offset. Instead, we use the above hack for now.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/moduleloader.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/unwind.h&gt;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define DEBUGP printk</span>
<span class="cp">#else</span>
<span class="cp">#define DEBUGP(fmt...)</span>
<span class="cp">#endif</span>

<span class="cp">#define RELOC_REACHABLE(val, bits) \</span>
<span class="cp">	(( ( !((val) &amp; (1&lt;&lt;((bits)-1))) &amp;&amp; ((val)&gt;&gt;(bits)) != 0 )  ||	\</span>
<span class="cp">	     ( ((val) &amp; (1&lt;&lt;((bits)-1))) &amp;&amp; ((val)&gt;&gt;(bits)) != (((__typeof__(val))(~0))&gt;&gt;((bits)+2)))) ? \</span>
<span class="cp">	0 : 1)</span>

<span class="cp">#define CHECK_RELOC(val, bits) \</span>
<span class="cp">	if (!RELOC_REACHABLE(val, bits)) { \</span>
<span class="cp">		printk(KERN_ERR &quot;module %s relocation of symbol %s is out of range (0x%lx in %d bits)\n&quot;, \</span>
<span class="cp">		me-&gt;name, strtab + sym-&gt;st_name, (unsigned long)val, bits); \</span>
<span class="cp">		return -ENOEXEC;			\</span>
<span class="cp">	}</span>

<span class="cm">/* Maximum number of GOT entries. We use a long displacement ldd from</span>
<span class="cm"> * the bottom of the table, which has a maximum signed displacement of</span>
<span class="cm"> * 0x3fff; however, since we&#39;re only going forward, this becomes</span>
<span class="cm"> * 0x1fff, and thus, since each GOT entry is 8 bytes long we can have</span>
<span class="cm"> * at most 1023 entries.</span>
<span class="cm"> * To overcome this 14bit displacement with some kernel modules, we&#39;ll</span>
<span class="cm"> * use instead the unusal 16bit displacement method (see reassemble_16a)</span>
<span class="cm"> * which gives us a maximum positive displacement of 0x7fff, and as such</span>
<span class="cm"> * allows us to allocate up to 4095 GOT entries. */</span>
<span class="cp">#define MAX_GOTS	4095</span>

<span class="cm">/* three functions to determine where in the module core</span>
<span class="cm"> * or init pieces the location is */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">in_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">loc</span> <span class="o">&gt;=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">&amp;&amp;</span>
		<span class="n">loc</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">+</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">in_core</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">loc</span> <span class="o">&gt;=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">&amp;&amp;</span>
		<span class="n">loc</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">in_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_init</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span> <span class="o">||</span> <span class="n">in_core</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">loc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="k">struct</span> <span class="n">got_entry</span> <span class="p">{</span>
	<span class="n">Elf32_Addr</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">stub_entry</span> <span class="p">{</span>
	<span class="n">Elf32_Word</span> <span class="n">insns</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* each stub entry has two insns */</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="k">struct</span> <span class="n">got_entry</span> <span class="p">{</span>
	<span class="n">Elf64_Addr</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">stub_entry</span> <span class="p">{</span>
	<span class="n">Elf64_Word</span> <span class="n">insns</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* each stub entry has four insns */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* Field selection types defined by hppa */</span>
<span class="cp">#define rnd(x)			(((x)+0x1000)&amp;~0x1fff)</span>
<span class="cm">/* fsel: full 32 bits */</span>
<span class="cp">#define fsel(v,a)		((v)+(a))</span>
<span class="cm">/* lsel: select left 21 bits */</span>
<span class="cp">#define lsel(v,a)		(((v)+(a))&gt;&gt;11)</span>
<span class="cm">/* rsel: select right 11 bits */</span>
<span class="cp">#define rsel(v,a)		(((v)+(a))&amp;0x7ff)</span>
<span class="cm">/* lrsel with rounding of addend to nearest 8k */</span>
<span class="cp">#define lrsel(v,a)		(((v)+rnd(a))&gt;&gt;11)</span>
<span class="cm">/* rrsel with rounding of addend to nearest 8k */</span>
<span class="cp">#define rrsel(v,a)		((((v)+rnd(a))&amp;0x7ff)+((a)-rnd(a)))</span>

<span class="cp">#define mask(x,sz)		((x) &amp; ~((1&lt;&lt;(sz))-1))</span>


<span class="cm">/* The reassemble_* functions prepare an immediate value for</span>
<span class="cm">   insertion into an opcode. pa-risc uses all sorts of weird bitfields</span>
<span class="cm">   in the instruction to hold the value.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sign_unext</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len_ones</span><span class="p">;</span>

	<span class="n">len_ones</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">len_ones</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">low_sign_unext</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sign</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">sign_unext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">sign</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reassemble_14</span><span class="p">(</span><span class="kt">int</span> <span class="n">as14</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">as14</span> <span class="o">&amp;</span> <span class="mh">0x1fff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as14</span> <span class="o">&amp;</span> <span class="mh">0x2000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reassemble_16a</span><span class="p">(</span><span class="kt">int</span> <span class="n">as16</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/* Unusual 16-bit encoding, for wide mode only.  */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">as16</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">as16</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">t</span> <span class="o">^</span> <span class="n">s</span> <span class="o">^</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reassemble_17</span><span class="p">(</span><span class="kt">int</span> <span class="n">as17</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">as17</span> <span class="o">&amp;</span> <span class="mh">0x10000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as17</span> <span class="o">&amp;</span> <span class="mh">0x0f800</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as17</span> <span class="o">&amp;</span> <span class="mh">0x00400</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as17</span> <span class="o">&amp;</span> <span class="mh">0x003ff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reassemble_21</span><span class="p">(</span><span class="kt">int</span> <span class="n">as21</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">as21</span> <span class="o">&amp;</span> <span class="mh">0x100000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as21</span> <span class="o">&amp;</span> <span class="mh">0x0ffe00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as21</span> <span class="o">&amp;</span> <span class="mh">0x000180</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as21</span> <span class="o">&amp;</span> <span class="mh">0x00007c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as21</span> <span class="o">&amp;</span> <span class="mh">0x000003</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reassemble_22</span><span class="p">(</span><span class="kt">int</span> <span class="n">as22</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">as22</span> <span class="o">&amp;</span> <span class="mh">0x200000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as22</span> <span class="o">&amp;</span> <span class="mh">0x1f0000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as22</span> <span class="o">&amp;</span> <span class="mh">0x00f800</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as22</span> <span class="o">&amp;</span> <span class="mh">0x000400</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">as22</span> <span class="o">&amp;</span> <span class="mh">0x0003ff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">module_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* using RWX means less protection for modules, but it&#39;s</span>
<span class="cm">	 * easier than trying to map the text, data, init_text and</span>
<span class="cm">	 * init_data correctly */</span>
	<span class="k">return</span> <span class="n">__vmalloc_node_range</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">VMALLOC_START</span><span class="p">,</span> <span class="n">VMALLOC_END</span><span class="p">,</span>
				    <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span><span class="p">,</span>
				    <span class="n">PAGE_KERNEL_RWX</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				    <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">count_gots</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">count_fdescs</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">count_stubs</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">,</span> <span class="n">rela</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF32_R_TYPE</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">R_PARISC_PCREL17F</span>:
			<span class="k">case</span> <span class="n">R_PARISC_PCREL22F</span>:
				<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">count_gots</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">,</span> <span class="n">rela</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">R_PARISC_LTOFF21L</span>:
			<span class="k">case</span> <span class="n">R_PARISC_LTOFF14R</span>:
			<span class="k">case</span> <span class="n">R_PARISC_PCREL22F</span>:
				<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">count_fdescs</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">,</span> <span class="n">rela</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">R_PARISC_FPTR64</span>:
				<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">count_stubs</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">,</span> <span class="n">rela</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">R_PARISC_PCREL22F</span>:
				<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/* Free memory returned from module_alloc */</span>
<span class="kt">void</span> <span class="nf">module_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">module_region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">module_region</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Additional bytes needed in front of individual sections */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">arch_mod_section_prepend</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">section</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* size needed for all stubs of this section (including</span>
<span class="cm">	 * one additional for correct alignment of the stubs) */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="n">section</span><span class="p">].</span><span class="n">stub_entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stub_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define CONST </span>
<span class="kt">int</span> <span class="nf">module_frob_arch_sections</span><span class="p">(</span><span class="n">CONST</span> <span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
			      <span class="n">CONST</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
			      <span class="n">CONST</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secstrings</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gots</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fdescs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">rels</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nrels</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rels</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_name</span><span class="p">,</span>
			    <span class="s">&quot;.PARISC.unwind&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind_section</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">!=</span> <span class="n">SHT_RELA</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* some of these are not relevant for 32-bit/64-bit</span>
<span class="cm">		 * we leave them here to make the code common. the</span>
<span class="cm">		 * compiler will do its thing and optimize out the</span>
<span class="cm">		 * stuff we don&#39;t need</span>
<span class="cm">		 */</span>
		<span class="n">gots</span> <span class="o">+=</span> <span class="n">count_gots</span><span class="p">(</span><span class="n">rels</span><span class="p">,</span> <span class="n">nrels</span><span class="p">);</span>
		<span class="n">fdescs</span> <span class="o">+=</span> <span class="n">count_fdescs</span><span class="p">(</span><span class="n">rels</span><span class="p">,</span> <span class="n">nrels</span><span class="p">);</span>

		<span class="cm">/* XXX: By sorting the relocs and finding duplicate entries</span>
<span class="cm">		 *  we could reduce the number of necessary stubs and save</span>
<span class="cm">		 *  some memory. */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">count_stubs</span><span class="p">(</span><span class="n">rels</span><span class="p">,</span> <span class="n">nrels</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* so we need relocation stubs. reserve necessary memory. */</span>
		<span class="cm">/* sh_info gives the section for which we need to add stubs. */</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_info</span><span class="p">;</span>

		<span class="cm">/* each code section should only have one relocation section */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">stub_entries</span><span class="p">);</span>

		<span class="cm">/* store number of stubs we need for this section */</span>
		<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">stub_entries</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* align things a bit */</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_offset</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">;</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">+=</span> <span class="n">gots</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">got_entry</span><span class="p">);</span>

	<span class="n">me</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fdesc_offset</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">;</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">+=</span> <span class="n">fdescs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Fdesc</span><span class="p">);</span>

	<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_max</span> <span class="o">=</span> <span class="n">gots</span><span class="p">;</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fdesc_max</span> <span class="o">=</span> <span class="n">fdescs</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="k">static</span> <span class="n">Elf64_Word</span> <span class="nf">get_got</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span> <span class="kt">long</span> <span class="n">addend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">got_entry</span> <span class="o">*</span><span class="n">got</span><span class="p">;</span>

	<span class="n">value</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">got</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_offset</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">got</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">got</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_count</span> <span class="o">&gt;</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_max</span><span class="p">);</span>

	<span class="n">got</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;GOT ENTRY %d[%x] val %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">got_entry</span><span class="p">),</span>
	       <span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">got_entry</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="k">static</span> <span class="n">Elf_Addr</span> <span class="nf">get_fdesc</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Fdesc</span> <span class="o">*</span><span class="n">fdesc</span> <span class="o">=</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fdesc_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: zero OPD requested!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Look for existing fdesc entry. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">fdesc</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fdesc</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">Elf_Addr</span><span class="p">)</span><span class="n">fdesc</span><span class="p">;</span>
		<span class="n">fdesc</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">++</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fdesc_count</span> <span class="o">&gt;</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fdesc_max</span><span class="p">);</span>

	<span class="cm">/* Create new one */</span>
	<span class="n">fdesc</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">fdesc</span><span class="o">-&gt;</span><span class="n">gp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf_Addr</span><span class="p">)</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">Elf_Addr</span><span class="p">)</span><span class="n">fdesc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">elf_stub_type</span> <span class="p">{</span>
	<span class="n">ELF_STUB_GOT</span><span class="p">,</span>
	<span class="n">ELF_STUB_MILLI</span><span class="p">,</span>
	<span class="n">ELF_STUB_DIRECT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">Elf_Addr</span> <span class="nf">get_stub</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span> <span class="kt">long</span> <span class="n">addend</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">elf_stub_type</span> <span class="n">stub_type</span><span class="p">,</span> <span class="n">Elf_Addr</span> <span class="n">loc0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">targetsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stub_entry</span> <span class="o">*</span><span class="n">stub</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__maybe_unused</span> <span class="n">d</span><span class="p">;</span>

	<span class="cm">/* initialize stub_offset to point in front of the section */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">stub_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loc0</span> <span class="o">-=</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">stub_entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stub_entry</span><span class="p">);</span>
		<span class="cm">/* get correct alignment for the stubs */</span>
		<span class="n">loc0</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">loc0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stub_entry</span><span class="p">));</span>
		<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">stub_offset</span> <span class="o">=</span> <span class="n">loc0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get address of stub entry */</span>
	<span class="n">stub</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">stub_offset</span><span class="p">;</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">stub_offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stub_entry</span><span class="p">);</span>

	<span class="cm">/* do not write outside available stub area */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">stub_entries</span><span class="o">--</span><span class="p">);</span>


<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="cm">/* for 32-bit the stub looks like this:</span>
<span class="cm"> * 	ldil L&#39;XXX,%r1</span>
<span class="cm"> * 	be,n R&#39;XXX(%sr4,%r1)</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>value = <em>(unsigned long *)((value + addend) &amp; ~3); /</em> why? */</p></td><td class="code"><div class="highlight"><pre>	<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20200000</span><span class="p">;</span>	<span class="cm">/* ldil L&#39;XXX,%r1	*/</span>
	<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe0202002</span><span class="p">;</span>	<span class="cm">/* be,n R&#39;XXX(%sr4,%r1)	*/</span>

	<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">reassemble_21</span><span class="p">(</span><span class="n">lrsel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">addend</span><span class="p">));</span>
	<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">reassemble_17</span><span class="p">(</span><span class="n">rrsel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">addend</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="cm">/* for 64-bit we have three kinds of stubs:</span>
<span class="cm"> * for normal function calls:</span>
<span class="cm"> * 	ldd 0(%dp),%dp</span>
<span class="cm"> * 	ldd 10(%dp), %r1</span>
<span class="cm"> * 	bve (%r1)</span>
<span class="cm"> * 	ldd 18(%dp), %dp</span>
<span class="cm"> *</span>
<span class="cm"> * for millicode:</span>
<span class="cm"> * 	ldil 0, %r1</span>
<span class="cm"> * 	ldo 0(%r1), %r1</span>
<span class="cm"> * 	ldd 10(%r1), %r1</span>
<span class="cm"> * 	bve,n (%r1)</span>
<span class="cm"> *</span>
<span class="cm"> * for direct branches (jumps between different section of the</span>
<span class="cm"> * same module):</span>
<span class="cm"> *	ldil 0, %r1</span>
<span class="cm"> *	ldo 0(%r1), %r1</span>
<span class="cm"> *	bve,n (%r1)</span>
<span class="cm"> */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">stub_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELF_STUB_GOT</span>:
		<span class="n">d</span> <span class="o">=</span> <span class="n">get_got</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Format 5 */</span>
			<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0f6010db</span><span class="p">;</span> <span class="cm">/* ldd 0(%dp),%dp	*/</span>
			<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">low_sign_unext</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Format 3 */</span>
			<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x537b0000</span><span class="p">;</span> <span class="cm">/* ldd 0(%dp),%dp	*/</span>
			<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">reassemble_16a</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x53610020</span><span class="p">;</span>	<span class="cm">/* ldd 10(%dp),%r1	*/</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe820d000</span><span class="p">;</span>	<span class="cm">/* bve (%r1)		*/</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x537b0030</span><span class="p">;</span>	<span class="cm">/* ldd 18(%dp),%dp	*/</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELF_STUB_MILLI</span>:
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20200000</span><span class="p">;</span>	<span class="cm">/* ldil 0,%r1		*/</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x34210000</span><span class="p">;</span>	<span class="cm">/* ldo 0(%r1), %r1	*/</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x50210020</span><span class="p">;</span>	<span class="cm">/* ldd 10(%r1),%r1	*/</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe820d002</span><span class="p">;</span>	<span class="cm">/* bve,n (%r1)		*/</span>

		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">reassemble_21</span><span class="p">(</span><span class="n">lrsel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">addend</span><span class="p">));</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">reassemble_14</span><span class="p">(</span><span class="n">rrsel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">addend</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELF_STUB_DIRECT</span>:
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20200000</span><span class="p">;</span>    <span class="cm">/* ldil 0,%r1           */</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x34210000</span><span class="p">;</span>    <span class="cm">/* ldo 0(%r1), %r1      */</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe820d002</span><span class="p">;</span>    <span class="cm">/* bve,n (%r1)          */</span>

		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">reassemble_21</span><span class="p">(</span><span class="n">lrsel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">addend</span><span class="p">));</span>
		<span class="n">stub</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">reassemble_14</span><span class="p">(</span><span class="n">rrsel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">addend</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#endif</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">Elf_Addr</span><span class="p">)</span><span class="n">stub</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="kt">int</span> <span class="nf">apply_relocate_add</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">relsec</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">Elf32_Rela</span> <span class="o">*</span><span class="n">rel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">Elf32_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="n">Elf32_Word</span> <span class="o">*</span><span class="n">loc</span><span class="p">;</span>
	<span class="n">Elf32_Addr</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">Elf32_Sword</span> <span class="n">addend</span><span class="p">;</span>
	<span class="n">Elf32_Addr</span> <span class="n">dot</span><span class="p">;</span>
	<span class="n">Elf_Addr</span> <span class="n">loc0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">targetsec</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_info</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>unsigned long dp = (unsigned long)$global$;</p></td><td class="code"><div class="highlight"><pre>	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dp</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r27&quot;</span><span class="p">);</span>

	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;Applying relocate section %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">relsec</span><span class="p">,</span>
	       <span class="n">targetsec</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rel</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is where to make the change */</span>
		<span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">sh_addr</span>
		      <span class="o">+</span> <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_offset</span><span class="p">;</span>
		<span class="cm">/* This is the start of the target section */</span>
		<span class="n">loc0</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
		<span class="cm">/* This is the symbol it is referring to */</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf32_Sym</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_addr</span>
			<span class="o">+</span> <span class="n">ELF32_R_SYM</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Unknown symbol %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>dot = (sechdrs[relsec].sh<em>addr + rel->r</em>offset) &amp; ~0x03;</p></td><td class="code"><div class="highlight"><pre>		<span class="n">dot</span> <span class="o">=</span>  <span class="p">(</span><span class="n">Elf32_Addr</span><span class="p">)</span><span class="n">loc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x03</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">;</span>
		<span class="n">addend</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_addend</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define r(t) ELF32_R_TYPE(rel[i].r_info)==t ? #t :</span>
<span class="c">		DEBUGP(&quot;Symbol %s loc 0x%x val 0x%x addend 0x%x: %s\n&quot;,</span>
<span class="c">			strtab + sym-&gt;st_name,</span>
<span class="c">			(uint32_t)loc, val, addend,</span>
<span class="c">			r(R_PARISC_PLABEL32)</span>
<span class="c">			r(R_PARISC_DIR32)</span>
<span class="c">			r(R_PARISC_DIR21L)</span>
<span class="c">			r(R_PARISC_DIR14R)</span>
<span class="c">			r(R_PARISC_SEGREL32)</span>
<span class="c">			r(R_PARISC_DPREL21L)</span>
<span class="c">			r(R_PARISC_DPREL14R)</span>
<span class="c">			r(R_PARISC_PCREL17F)</span>
<span class="c">			r(R_PARISC_PCREL22F)</span>
<span class="c">			&quot;UNKNOWN&quot;);</span>
<span class="c">#undef r</span>
<span class="cp">#endif</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF32_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">R_PARISC_PLABEL32</span>:
			<span class="cm">/* 32-bit function address */</span>
			<span class="cm">/* no function descriptors... */</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">fsel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_DIR32</span>:
			<span class="cm">/* direct 32-bit ref */</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">fsel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_DIR21L</span>:
			<span class="cm">/* left 21 bits of effective address */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">lrsel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="o">*</span><span class="n">loc</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span> <span class="o">|</span> <span class="n">reassemble_21</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_DIR14R</span>:
			<span class="cm">/* right 14 bits of effective address */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">rrsel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="o">*</span><span class="n">loc</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span> <span class="o">|</span> <span class="n">reassemble_14</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_SEGREL32</span>:
			<span class="cm">/* 32-bit segment relative address */</span>
			<span class="cm">/* See note about special handling of SEGREL32 at</span>
<span class="cm">			 * the beginning of this file.</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">fsel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span> 
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_DPREL21L</span>:
			<span class="cm">/* left 21 bit of relative address */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">lrsel</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">dp</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="o">*</span><span class="n">loc</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span> <span class="o">|</span> <span class="n">reassemble_21</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_DPREL14R</span>:
			<span class="cm">/* right 14 bit of relative address */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">rrsel</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">dp</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="o">*</span><span class="n">loc</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span> <span class="o">|</span> <span class="n">reassemble_14</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_PCREL17F</span>:
			<span class="cm">/* 17-bit PC relative address */</span>
			<span class="cm">/* calculate direct call offset */</span>
			<span class="n">val</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RELOC_REACHABLE</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* direct distance too far, create</span>
<span class="cm">				 * stub entry instead */</span>
				<span class="n">val</span> <span class="o">=</span> <span class="n">get_stub</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">,</span> <span class="n">addend</span><span class="p">,</span>
					<span class="n">ELF_STUB_DIRECT</span><span class="p">,</span> <span class="n">loc0</span><span class="p">,</span> <span class="n">targetsec</span><span class="p">);</span>
				<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
				<span class="n">CHECK_RELOC</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">17</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">loc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1f1ffd</span><span class="p">)</span> <span class="o">|</span> <span class="n">reassemble_17</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_PCREL22F</span>:
			<span class="cm">/* 22-bit PC relative address; only defined for pa20 */</span>
			<span class="cm">/* calculate direct call offset */</span>
			<span class="n">val</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RELOC_REACHABLE</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">22</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* direct distance too far, create</span>
<span class="cm">				 * stub entry instead */</span>
				<span class="n">val</span> <span class="o">=</span> <span class="n">get_stub</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">,</span> <span class="n">addend</span><span class="p">,</span>
					<span class="n">ELF_STUB_DIRECT</span><span class="p">,</span> <span class="n">loc0</span><span class="p">,</span> <span class="n">targetsec</span><span class="p">);</span>
				<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
				<span class="n">CHECK_RELOC</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">loc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3ff1ffd</span><span class="p">)</span> <span class="o">|</span> <span class="n">reassemble_22</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;module %s: Unknown relocation: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ELF32_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="kt">int</span> <span class="nf">apply_relocate_add</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">relsec</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">Elf64_Rela</span> <span class="o">*</span><span class="n">rel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">Elf64_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="n">Elf64_Word</span> <span class="o">*</span><span class="n">loc</span><span class="p">;</span>
	<span class="n">Elf64_Xword</span> <span class="o">*</span><span class="n">loc64</span><span class="p">;</span>
	<span class="n">Elf64_Addr</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">Elf64_Sxword</span> <span class="n">addend</span><span class="p">;</span>
	<span class="n">Elf64_Addr</span> <span class="n">dot</span><span class="p">;</span>
	<span class="n">Elf_Addr</span> <span class="n">loc0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">targetsec</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_info</span><span class="p">;</span>

	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;Applying relocate section %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">relsec</span><span class="p">,</span>
	       <span class="n">targetsec</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rel</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is where to make the change */</span>
		<span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">sh_addr</span>
		      <span class="o">+</span> <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_offset</span><span class="p">;</span>
		<span class="cm">/* This is the start of the target section */</span>
		<span class="n">loc0</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">targetsec</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
		<span class="cm">/* This is the symbol it is referring to */</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf64_Sym</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_addr</span>
			<span class="o">+</span> <span class="n">ELF64_R_SYM</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Unknown symbol %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>dot = (sechdrs[relsec].sh<em>addr + rel->r</em>offset) &amp; ~0x03;</p></td><td class="code"><div class="highlight"><pre>		<span class="n">dot</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf64_Addr</span><span class="p">)</span><span class="n">loc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x03</span><span class="p">;</span>
		<span class="n">loc64</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf64_Xword</span> <span class="o">*</span><span class="p">)</span><span class="n">loc</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">;</span>
		<span class="n">addend</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_addend</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define r(t) ELF64_R_TYPE(rel[i].r_info)==t ? #t :</span>
<span class="c">		printk(&quot;Symbol %s loc %p val 0x%Lx addend 0x%Lx: %s\n&quot;,</span>
<span class="c">			strtab + sym-&gt;st_name,</span>
<span class="c">			loc, val, addend,</span>
<span class="c">			r(R_PARISC_LTOFF14R)</span>
<span class="c">			r(R_PARISC_LTOFF21L)</span>
<span class="c">			r(R_PARISC_PCREL22F)</span>
<span class="c">			r(R_PARISC_DIR64)</span>
<span class="c">			r(R_PARISC_SEGREL32)</span>
<span class="c">			r(R_PARISC_FPTR64)</span>
<span class="c">			&quot;UNKNOWN&quot;);</span>
<span class="c">#undef r</span>
<span class="cp">#endif</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">R_PARISC_LTOFF21L</span>:
			<span class="cm">/* LT-relative; left 21 bits */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">get_got</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
			<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;LTOFF21L Symbol %s loc %p val %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">,</span>
			       <span class="n">loc</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">lrsel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="o">*</span><span class="n">loc</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span> <span class="o">|</span> <span class="n">reassemble_21</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_LTOFF14R</span>:
			<span class="cm">/* L(ltoff(val+addend)) */</span>
			<span class="cm">/* LT-relative; right 14 bits */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">get_got</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">rrsel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;LTOFF14R Symbol %s loc %p val %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">,</span>
			       <span class="n">loc</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="o">*</span><span class="n">loc</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span> <span class="o">|</span> <span class="n">reassemble_14</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_PCREL22F</span>:
			<span class="cm">/* PC-relative; 22 bits */</span>
			<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;PCREL22F Symbol %s loc %p val %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">,</span>
			       <span class="n">loc</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>
			<span class="cm">/* can we reach it locally? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">in_local</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* this is the case where the symbol is local</span>
<span class="cm">				 * to the module, but in a different section,</span>
<span class="cm">				 * so stub the jump in case it&#39;s more than 22</span>
<span class="cm">				 * bits away */</span>
				<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RELOC_REACHABLE</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">22</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* direct distance too far, create</span>
<span class="cm">					 * stub entry instead */</span>
					<span class="n">val</span> <span class="o">=</span> <span class="n">get_stub</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">,</span>
						<span class="n">addend</span><span class="p">,</span> <span class="n">ELF_STUB_DIRECT</span><span class="p">,</span>
						<span class="n">loc0</span><span class="p">,</span> <span class="n">targetsec</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Ok, we can reach it directly. */</span>
					<span class="n">val</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">;</span>
					<span class="n">val</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">val</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">,</span> <span class="s">&quot;$$&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
				    <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">val</span> <span class="o">=</span> <span class="n">get_stub</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">,</span> <span class="n">ELF_STUB_MILLI</span><span class="p">,</span>
						       <span class="n">loc0</span><span class="p">,</span> <span class="n">targetsec</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">val</span> <span class="o">=</span> <span class="n">get_stub</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">,</span> <span class="n">ELF_STUB_GOT</span><span class="p">,</span>
						       <span class="n">loc0</span><span class="p">,</span> <span class="n">targetsec</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;STUB FOR %s loc %lx, val %lx+%lx at %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			       <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">,</span>
			       <span class="n">addend</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">dot</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
			<span class="n">CHECK_RELOC</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">loc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3ff1ffd</span><span class="p">)</span> <span class="o">|</span> <span class="n">reassemble_22</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_DIR64</span>:
			<span class="cm">/* 64-bit effective address */</span>
			<span class="o">*</span><span class="n">loc64</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">addend</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_SEGREL32</span>:
			<span class="cm">/* 32-bit segment relative address */</span>
			<span class="cm">/* See note about special handling of SEGREL32 at</span>
<span class="cm">			 * the beginning of this file.</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">fsel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span> 
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_PARISC_FPTR64</span>:
			<span class="cm">/* 64-bit function address */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">in_local</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">val</span> <span class="o">+</span> <span class="n">addend</span><span class="p">)))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">loc64</span> <span class="o">=</span> <span class="n">get_fdesc</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">val</span><span class="o">+</span><span class="n">addend</span><span class="p">);</span>
				<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;FDESC for %s at %p points to %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">,</span> <span class="o">*</span><span class="n">loc64</span><span class="p">,</span>
				       <span class="p">((</span><span class="n">Elf_Fdesc</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">loc64</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* if the symbol is not local to this</span>
<span class="cm">				 * module then val+addend is a pointer</span>
<span class="cm">				 * to the function descriptor */</span>
				<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;Non local FPTR64 Symbol %s loc %p val %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">,</span>
				       <span class="n">loc</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
				<span class="o">*</span><span class="n">loc64</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">addend</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;module %s: Unknown relocation: %Lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">register_unwind_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span>
		      <span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind_section</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">table</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind_section</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">table</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind_section</span><span class="p">].</span><span class="n">sh_size</span><span class="p">;</span>
	<span class="n">gp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf_Addr</span><span class="p">)</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_offset</span><span class="p">;</span>

	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;register_unwind_table(), sect = %d at 0x%p - 0x%p (gp=0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind_section</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">gp</span><span class="p">);</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind</span> <span class="o">=</span> <span class="n">unwind_table_add</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">deregister_unwind_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind</span><span class="p">)</span>
		<span class="n">unwind_table_remove</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">module_finalize</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
		    <span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nsyms</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">newptr</span><span class="p">,</span> <span class="o">*</span><span class="n">oldptr</span><span class="p">;</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">symhdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">Elf_Fdesc</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf_Fdesc</span> <span class="o">*</span><span class="p">)</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;FINALIZE, -&gt;init FPTR is %p, GP %lx ADDR %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
	       <span class="n">entry</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INSNS: %x %x %x %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;got entries used %ld, gots max %ld</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;fdescs used %ld, fdescs max %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_count</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_max</span><span class="p">,</span>
	       <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fdesc_count</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fdesc_max</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">register_unwind_table</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">sechdrs</span><span class="p">);</span>

	<span class="cm">/* haven&#39;t filled in me-&gt;symtab yet, so have to find it</span>
<span class="cm">	 * ourselves */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_SYMTAB</span>
		   <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">strindex</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_link</span><span class="p">;</span>
			<span class="cm">/* FIXME: AWFUL HACK</span>
<span class="cm">			 * The cast is to drop the const from</span>
<span class="cm">			 * the sechdrs pointer */</span>
			<span class="n">symhdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">strtab</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">strindex</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;module %s: strtab %p, symhdr %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">strtab</span><span class="p">,</span> <span class="n">symhdr</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_count</span> <span class="o">&gt;</span> <span class="n">MAX_GOTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Global Offset Table overflow (used %ld, allowed %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got_count</span><span class="p">,</span> <span class="n">MAX_GOTS</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span><span class="p">);</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">section</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* no symbol table */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">symhdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">oldptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">symhdr</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">newptr</span> <span class="o">=</span> <span class="n">oldptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* we start counting at 1 */</span>
	<span class="n">nsyms</span> <span class="o">=</span> <span class="n">symhdr</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Sym</span><span class="p">);</span>
	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;OLD num_symtab %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nsyms</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsyms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oldptr</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* note, count starts at 1 so preincrement */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">oldptr</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">,</span>
			      <span class="s">&quot;.L&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">newptr</span> <span class="o">!=</span> <span class="n">oldptr</span><span class="p">)</span>
			<span class="o">*</span><span class="n">newptr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">oldptr</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">newptr</span><span class="o">++</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">nsyms</span> <span class="o">=</span> <span class="n">newptr</span> <span class="o">-</span> <span class="p">(</span><span class="n">Elf_Sym</span> <span class="o">*</span><span class="p">)</span><span class="n">symhdr</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;NEW num_symtab %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nsyms</span><span class="p">);</span>
	<span class="n">symhdr</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">=</span> <span class="n">nsyms</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Sym</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">module_arch_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">deregister_unwind_table</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
