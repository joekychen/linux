<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › kernel › drivers.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>drivers.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers.c</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1999 The Puffin Group</span>
<span class="cm"> * Copyright (c) 2001 Matthew Wilcox for Hewlett Packard</span>
<span class="cm"> * Copyright (c) 2001 Helge Deller &lt;deller@gmx.de&gt;</span>
<span class="cm"> * Copyright (c) 2001,2002 Ryan Bradetich </span>
<span class="cm"> * Copyright (c) 2004-2005 Thibaut VARENE &lt;varenet@parisc-linux.org&gt;</span>
<span class="cm"> * </span>
<span class="cm"> * The file handles registering devices and drivers, then matching them.</span>
<span class="cm"> * It&#39;s the closest we get to a dating agency.</span>
<span class="cm"> *</span>
<span class="cm"> * If you&#39;re thinking about modifying this file, here are some gotchas to</span>
<span class="cm"> * bear in mind:</span>
<span class="cm"> *  - 715/Mirage device paths have a dummy device between Lasi and its children</span>
<span class="cm"> *  - The EISA adapter may show up as a sibling or child of Wax</span>
<span class="cm"> *  - Dino has an optionally functional serial port.  If firmware enables it,</span>
<span class="cm"> *    it shows up as a child of Dino.  If firmware disables it, the buswalk</span>
<span class="cm"> *    finds it and it shows up as a child of Cujo</span>
<span class="cm"> *  - Dino has both parisc and pci devices as children</span>
<span class="cm"> *  - parisc devices are discovered in a random order, including children</span>
<span class="cm"> *    before parents in some cases.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;asm/hardware.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/pdc.h&gt;</span>
<span class="cp">#include &lt;asm/parisc-device.h&gt;</span>

<span class="cm">/* See comments in include/asm-parisc/pci.h */</span>
<span class="k">struct</span> <span class="n">hppa_dma_ops</span> <span class="o">*</span><span class="n">hppa_dma_ops</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hppa_dma_ops</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="n">root</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init_name</span> <span class="o">=</span> <span class="s">&quot;parisc&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">parisc_bus_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span> <span class="o">!=</span> <span class="n">HPHW_FAULTY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span>
<span class="n">parse_tree_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">modpath</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">recurse_struct</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span> <span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">descend_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">recurse_struct</span> <span class="o">*</span> <span class="n">recurse_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">recurse_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">recurse_data</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">recurse_data</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">recurse_data</span><span class="p">,</span> <span class="n">descend_children</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	for_each_padev - Iterate over all devices in the tree</span>
<span class="cm"> *	@fn:	Function to call for each device.</span>
<span class="cm"> *	@data:	Data to pass to the called function.</span>
<span class="cm"> *</span>
<span class="cm"> *	This performs a depth-first traversal of the tree, calling the</span>
<span class="cm"> *	function passed for each node.  It calls the function for parents</span>
<span class="cm"> *	before children.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">for_each_padev</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">recurse_struct</span> <span class="n">recurse_data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">obj</span>	<span class="o">=</span> <span class="n">data</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fn</span>	<span class="o">=</span> <span class="n">fn</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recurse_data</span><span class="p">,</span> <span class="n">descend_children</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * match_device - Report whether this driver can handle this device</span>
<span class="cm"> * @driver: the PA-RISC driver to try</span>
<span class="cm"> * @dev: the PA-RISC device to try</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device_id</span> <span class="o">*</span><span class="n">ids</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ids</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">;</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">sversion</span><span class="p">;</span> <span class="n">ids</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">sversion</span> <span class="o">!=</span> <span class="n">SVERSION_ANY_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">sversion</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">sversion</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">hw_type</span> <span class="o">!=</span> <span class="n">HWTYPE_ANY_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">hw_type</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">hversion</span> <span class="o">!=</span> <span class="n">HVERSION_ANY_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">hversion</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hversion</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parisc_driver_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">pa_dev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">parisc_driver</span> <span class="o">*</span><span class="n">pa_drv</span> <span class="o">=</span> <span class="n">to_parisc_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pa_drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">pa_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">pa_dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">pa_drv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parisc_driver_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">pa_dev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">parisc_driver</span> <span class="o">*</span><span class="n">pa_drv</span> <span class="o">=</span> <span class="n">to_parisc_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pa_drv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span>
		<span class="n">pa_drv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">pa_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
	

<span class="cm">/**</span>
<span class="cm"> * register_parisc_driver - Register this driver if it can handle a device</span>
<span class="cm"> * @driver: the PA-RISC driver to try</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_parisc_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: we need this because apparently the sti</span>
<span class="cm">	 * driver can be registered twice */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> 
		       <span class="s">&quot;BUG: skipping previously registered driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> 
		       <span class="s">&quot;BUG: driver %s has no probe routine</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parisc_bus_type</span><span class="p">;</span>

	<span class="cm">/* We install our own probe and remove routines */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">.</span><span class="n">probe</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">.</span><span class="n">remove</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_parisc_driver</span><span class="p">);</span>


<span class="k">struct</span> <span class="n">match_count</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_driver</span> <span class="o">*</span> <span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_and_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">match_count</span> <span class="o">*</span> <span class="n">m</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span> <span class="n">pdev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_device</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">pdev</span><span class="p">))</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * count_parisc_driver - count # of devices this driver would match</span>
<span class="cm"> * @driver: the PA-RISC driver to try</span>
<span class="cm"> *</span>
<span class="cm"> * Use by IOMMU support to &quot;guess&quot; the right size IOPdir.</span>
<span class="cm"> * Formula is something like memsize/(num_iommu * entry_size).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">count_parisc_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">match_count</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">driver</span>	<span class="o">=</span> <span class="n">driver</span><span class="p">,</span>
		<span class="p">.</span><span class="n">count</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">for_each_padev</span><span class="p">(</span><span class="n">match_and_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/**</span>
<span class="cm"> * unregister_parisc_driver - Unregister this driver from the list of drivers</span>
<span class="cm"> * @driver: the PA-RISC driver to unregister</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">unregister_parisc_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">drv</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_parisc_driver</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">find_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span> <span class="n">pdev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">find_data</span> <span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">find_data</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="nf">find_device_by_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">find_data</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">hpa</span>	<span class="o">=</span> <span class="n">hpa</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">for_each_padev</span><span class="p">(</span><span class="n">find_device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">d</span><span class="p">.</span><span class="n">dev</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_pa_parent_type - Find a parent of a specific type</span>
<span class="cm"> * @dev: The device to start searching from</span>
<span class="cm"> * @type: The device type to search for.</span>
<span class="cm"> *</span>
<span class="cm"> * Walks up the device tree looking for a device of the specified type.</span>
<span class="cm"> * If it finds it, it returns it.  If not, it returns NULL.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span>
<span class="nf">find_pa_parent_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">padev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">padev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">candidate</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_pci_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_pci_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * get_node_path fills in @path with the firmware path to the device.</span>
<span class="cm"> * Note that if @node is a parisc device, we don&#39;t fill in the &#39;mod&#39; field.</span>
<span class="cm"> * This is because both callers pass the parent and fill in the mod</span>
<span class="cm"> * themselves.  If @node is a PCI device, we do fill it in, even though this</span>
<span class="cm"> * is inconsistent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_node_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">=</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">devfn</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">devfn</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">devfn</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">devfn</span><span class="p">)</span><span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">parisc_bus_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hw_path</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">print_hwpath</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&quot;%u/&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">output</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&quot;%u&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * print_pa_hwpath - Returns hardware path for PA devices</span>
<span class="cm"> * dev: The device to return the path for</span>
<span class="cm"> * output: Pointer to a previously-allocated array to place the path in.</span>
<span class="cm"> *</span>
<span class="cm"> * This function fills in the output array with a human-readable path</span>
<span class="cm"> * to a PA device.  This string is compatible with that used by PDC, and</span>
<span class="cm"> * may be printed on the outside of the box.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">print_pa_hwpath</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardware_path</span> <span class="n">path</span><span class="p">;</span>

	<span class="n">get_node_path</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">path</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_path</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">print_hwpath</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">print_pa_hwpath</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_PCI) || defined(CONFIG_ISA)</span>
<span class="cm">/**</span>
<span class="cm"> * get_pci_node_path - Determines the hardware path for a PCI device</span>
<span class="cm"> * @pdev: The device to return the path for</span>
<span class="cm"> * @path: Pointer to a previously-allocated array to place the path in.</span>
<span class="cm"> *</span>
<span class="cm"> * This function fills in the hardware_path structure with the route to</span>
<span class="cm"> * the specified PCI device.  This structure is suitable for passing to</span>
<span class="cm"> * PDC calls.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">get_pci_node_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_node_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_pci_node_path</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * print_pci_hwpath - Returns hardware path for PCI devices</span>
<span class="cm"> * dev: The device to return the path for</span>
<span class="cm"> * output: Pointer to a previously-allocated array to place the path in.</span>
<span class="cm"> *</span>
<span class="cm"> * This function fills in the output array with a human-readable path</span>
<span class="cm"> * to a PCI device.  This string is compatible with that used by PDC, and</span>
<span class="cm"> * may be printed on the outside of the box.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">print_pci_hwpath</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardware_path</span> <span class="n">path</span><span class="p">;</span>

	<span class="n">get_pci_node_path</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">print_hwpath</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">print_pci_hwpath</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_PCI) || defined(CONFIG_ISA) */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_bus_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">padev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardware_path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">output</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">get_node_path</span><span class="p">(</span><span class="n">padev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&quot;%u:&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">path</span><span class="p">.</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&quot;%u&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">padev</span><span class="o">-&gt;</span><span class="n">hw_path</span><span class="p">);</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">padev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span> <span class="nf">create_tree_node</span><span class="p">(</span><span class="kt">char</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_path</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span> <span class="o">=</span> <span class="n">HPHW_FAULTY</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">setup_bus_id</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parisc_bus_type</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="mh">0xffffffffUL</span><span class="p">;</span>	<span class="cm">/* PARISC devices are 32-bit */</span>

	<span class="cm">/* make the generic dma mask a pointer to the parisc one */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">match_id_data</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_by_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span> <span class="n">pdev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">match_id_data</span> <span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">hw_path</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_tree_node - returns a device entry in the iotree</span>
<span class="cm"> * @parent: the parent node in the tree</span>
<span class="cm"> * @id: the element of the module path for this entry</span>
<span class="cm"> *</span>
<span class="cm"> * Checks all the children of @parent for a matching @id.  If none</span>
<span class="cm"> * found, it allocates a new device and returns it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span> <span class="nf">alloc_tree_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">char</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">match_id_data</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_for_each_child</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">match_by_id</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">create_tree_node</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="nf">create_parisc_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">modpath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">modpath</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">alloc_tree_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">modpath</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">alloc_tree_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">modpath</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span>
<span class="nf">alloc_pa_dev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">mod_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytecnt</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">iodc_data</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* Check to make sure this device has not already been added - Ryan */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_device_by_addr</span><span class="p">(</span><span class="n">hpa</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_iodc_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytecnt</span><span class="p">,</span> <span class="n">hpa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iodc_data</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">create_parisc_device</span><span class="p">(</span><span class="n">mod_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span> <span class="o">!=</span> <span class="n">HPHW_FAULTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Two devices have hardware path [%s].  &quot;</span>
				<span class="s">&quot;IODC data for second device: &quot;</span>
				<span class="s">&quot;%02x%02x%02x%02x%02x%02x</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;Rearranging GSC cards sometimes helps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">parisc_pathname</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">iodc_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">iodc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">iodc_data</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">iodc_data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">iodc_data</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">iodc_data</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span> <span class="o">=</span> <span class="n">iodc_data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hversion</span> <span class="o">=</span> <span class="p">(</span><span class="n">iodc_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">iodc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hversion_rev</span> <span class="o">=</span> <span class="n">iodc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">sversion</span> <span class="o">=</span> <span class="p">((</span><span class="n">iodc_data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">iodc_data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">iodc_data</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">parisc_pathname</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">hpa</span><span class="p">;</span>
	<span class="cm">/* This is awkward.  The STI spec says that gfx devices may occupy</span>
<span class="cm">	 * 32MB or 64MB.  Unfortunately, we don&#39;t know how to tell whether</span>
<span class="cm">	 * it&#39;s the former or the latter.  Assumptions either way can hurt us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpa</span> <span class="o">==</span> <span class="mh">0xf4000000</span> <span class="o">||</span> <span class="n">hpa</span> <span class="o">==</span> <span class="mh">0xf8000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">hpa</span> <span class="o">+</span> <span class="mh">0x03ffffff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hpa</span> <span class="o">==</span> <span class="mh">0xf6000000</span> <span class="o">||</span> <span class="n">hpa</span> <span class="o">==</span> <span class="mh">0xfa000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">hpa</span> <span class="o">+</span> <span class="mh">0x01ffffff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">hpa</span> <span class="o">+</span> <span class="mh">0xfff</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">parisc_hardware_description</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Silently fail things like mouse ports which are subsumed within</span>
<span class="cm">	 * the keyboard controller</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hpa</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unable to claim HPA %lx for device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">hpa</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parisc_generic_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">match_device</span><span class="p">(</span><span class="n">to_parisc_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">),</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">make_modalias</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">padev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">padev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;parisc:t%02Xhv%04Xrev%02Xsv%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">hw_type</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">hversion</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">hversion_rev</span><span class="p">,</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">sversion</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parisc_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">padev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">modalias</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">padev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">padev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;PARISC_NAME=%s&quot;</span><span class="p">,</span> <span class="n">padev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">make_modalias</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">modalias</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;MODALIAS=%s&quot;</span><span class="p">,</span> <span class="n">modalias</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define pa_dev_attr(name, field, format_string)				\</span>
<span class="cp">static ssize_t name##_show(struct device *dev, struct device_attribute *attr, char *buf)		\</span>
<span class="cp">{									\</span>
<span class="cp">	struct parisc_device *padev = to_parisc_device(dev);		\</span>
<span class="cp">	return sprintf(buf, format_string, padev-&gt;field);		\</span>
<span class="cp">}</span>

<span class="cp">#define pa_dev_attr_id(field, format) pa_dev_attr(field, id.field, format)</span>

<span class="n">pa_dev_attr</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">pa_dev_attr_id</span><span class="p">(</span><span class="n">hw_type</span><span class="p">,</span> <span class="s">&quot;0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">pa_dev_attr</span><span class="p">(</span><span class="n">rev</span><span class="p">,</span> <span class="n">id</span><span class="p">.</span><span class="n">hversion_rev</span><span class="p">,</span> <span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">pa_dev_attr_id</span><span class="p">(</span><span class="n">hversion</span><span class="p">,</span> <span class="s">&quot;0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">pa_dev_attr_id</span><span class="p">(</span><span class="n">sversion</span><span class="p">,</span> <span class="s">&quot;0x%05x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">modalias_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">make_modalias</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">parisc_device_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">irq</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">hw_type</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">rev</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">hversion</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">sversion</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">modalias</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">parisc_bus_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;parisc&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">parisc_generic_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span> <span class="o">=</span> <span class="n">parisc_uevent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_attrs</span> <span class="o">=</span> <span class="n">parisc_device_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">parisc_driver_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">parisc_driver_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * register_parisc_device - Locate a driver to manage this device.</span>
<span class="cm"> * @dev: The parisc device.</span>
<span class="cm"> *</span>
<span class="cm"> * Search the driver list for a driver that is willing to manage</span>
<span class="cm"> * this device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_parisc_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * match_pci_device - Matches a pci device against a given hardware path</span>
<span class="cm"> * entry.</span>
<span class="cm"> * @dev: the generic device (known to be contained by a pci_dev).</span>
<span class="cm"> * @index: the current BC index</span>
<span class="cm"> * @modpath: the hardware path.</span>
<span class="cm"> * @return: true if the device matches the hardware path.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_pci_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">modpath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we are at the end of the path, and on the actual device */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">modpath</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">devfn</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">modpath</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">==</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">devfn</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">modpath</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * match_parisc_device - Matches a parisc device against a given hardware</span>
<span class="cm"> * path entry.</span>
<span class="cm"> * @dev: the generic device (known to be contained by a parisc_device).</span>
<span class="cm"> * @index: the current BC index</span>
<span class="cm"> * @modpath: the hardware path.</span>
<span class="cm"> * @return: true if the device matches the hardware path.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_parisc_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">modpath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="o">?</span> <span class="n">modpath</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">:</span> <span class="n">modpath</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">hw_path</span> <span class="o">==</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">parse_tree_data</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span> <span class="n">modpath</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parse_tree_data</span> <span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">parisc_bus_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">match_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">modpath</span><span class="p">))</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">match_pci_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">modpath</span><span class="p">))</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we are on a bus bridge */</span>
			<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">parse_tree_node</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">modpath</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parse_tree_node - returns a device entry in the iotree</span>
<span class="cm"> * @parent: the parent node in the tree</span>
<span class="cm"> * @index: the current BC index</span>
<span class="cm"> * @modpath: the hardware_path struct to match a device against</span>
<span class="cm"> * @return: The corresponding device if found, NULL otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Checks all the children of @parent for a matching @id.  If none</span>
<span class="cm"> * found, it returns NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span>
<span class="nf">parse_tree_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">modpath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parse_tree_data</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">index</span>          <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
		<span class="p">.</span><span class="n">modpath</span>        <span class="o">=</span> <span class="n">modpath</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">recurse_struct</span> <span class="n">recurse_data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">obj</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fn</span>	<span class="o">=</span> <span class="n">check_parent</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device_for_each_child</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recurse_data</span><span class="p">,</span> <span class="n">descend_children</span><span class="p">))</span>
		<span class="cm">/* nothing */</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hwpath_to_device - Finds the generic device corresponding to a given hardware path.</span>
<span class="cm"> * @modpath: the hardware path.</span>
<span class="cm"> * @return: The target device, NULL if not found.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">hwpath_to_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">modpath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">modpath</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">parse_tree_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">modpath</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_pci_dev</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span> <span class="cm">/* pci devices already parse MOD */</span>
		<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">parse_tree_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">modpath</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hwpath_to_device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * device_to_hwpath - Populates the hwpath corresponding to the given device.</span>
<span class="cm"> * @param dev the target device</span>
<span class="cm"> * @param path pointer to a previously allocated hwpath struct to be filled in</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">device_to_hwpath</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hardware_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">padev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">parisc_bus_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">padev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">get_node_path</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">=</span> <span class="n">padev</span><span class="o">-&gt;</span><span class="n">hw_path</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">get_node_path</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">device_to_hwpath</span><span class="p">);</span>

<span class="cp">#define BC_PORT_MASK 0x8</span>
<span class="cp">#define BC_LOWER_PORT 0x8</span>

<span class="cp">#define BUS_CONVERTER(dev) \</span>
<span class="cp">        ((dev-&gt;id.hw_type == HPHW_IOA) || (dev-&gt;id.hw_type == HPHW_BCPORT))</span>

<span class="cp">#define IS_LOWER_PORT(dev) \</span>
<span class="cp">        ((gsc_readl(dev-&gt;hpa.start + offsetof(struct bc_module, io_status)) \</span>
<span class="cp">                &amp; BC_PORT_MASK) == BC_LOWER_PORT)</span>

<span class="cp">#define MAX_NATIVE_DEVICES 64</span>
<span class="cp">#define NATIVE_DEVICE_OFFSET 0x1000</span>

<span class="cp">#define FLEX_MASK 	F_EXTEND(0xfffc0000)</span>
<span class="cp">#define IO_IO_LOW	offsetof(struct bc_module, io_io_low)</span>
<span class="cp">#define IO_IO_HIGH	offsetof(struct bc_module, io_io_high)</span>
<span class="cp">#define READ_IO_IO_LOW(dev)  (unsigned long)(signed int)gsc_readl(dev-&gt;hpa.start + IO_IO_LOW)</span>
<span class="cp">#define READ_IO_IO_HIGH(dev) (unsigned long)(signed int)gsc_readl(dev-&gt;hpa.start + IO_IO_HIGH)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">walk_native_bus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_io_low</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_io_high</span><span class="p">,</span>
                            <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">walk_lower_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_io_low</span><span class="p">,</span> <span class="n">io_io_high</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BUS_CONVERTER</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_LOWER_PORT</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span> <span class="o">==</span> <span class="n">HPHW_IOA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_io_low</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="kt">signed</span> <span class="kt">int</span><span class="p">)(</span><span class="n">READ_IO_IO_LOW</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">io_io_high</span> <span class="o">=</span> <span class="n">io_io_low</span> <span class="o">+</span> <span class="n">MAX_NATIVE_DEVICES</span> <span class="o">*</span> <span class="n">NATIVE_DEVICE_OFFSET</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">io_io_low</span> <span class="o">=</span> <span class="p">(</span><span class="n">READ_IO_IO_LOW</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="o">~</span><span class="n">FLEX_MASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FLEX_MASK</span><span class="p">;</span>
		<span class="n">io_io_high</span> <span class="o">=</span> <span class="p">(</span><span class="n">READ_IO_IO_HIGH</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">+</span> <span class="o">~</span><span class="n">FLEX_MASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FLEX_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">walk_native_bus</span><span class="p">(</span><span class="n">io_io_low</span><span class="p">,</span> <span class="n">io_io_high</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * walk_native_bus -- Probe a bus for devices</span>
<span class="cm"> * @io_io_low: Base address of this bus.</span>
<span class="cm"> * @io_io_high: Last address of this bus.</span>
<span class="cm"> * @parent: The parent bus device.</span>
<span class="cm"> * </span>
<span class="cm"> * A native bus (eg Runway or GSC) may have up to 64 devices on it,</span>
<span class="cm"> * spaced at intervals of 0x1000 bytes.  PDC may not inform us of these</span>
<span class="cm"> * devices, so we have to probe for them.  Unfortunately, we may find</span>
<span class="cm"> * devices which are not physically connected (such as extra serial &amp;</span>
<span class="cm"> * keyboard ports).  This problem is not yet solved.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">walk_native_bus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_io_low</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_io_high</span><span class="p">,</span>
                            <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">devices_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span> <span class="o">=</span> <span class="n">io_io_low</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hardware_path</span> <span class="n">path</span><span class="p">;</span>

	<span class="n">get_node_path</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NATIVE_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">hpa</span> <span class="o">+=</span> <span class="n">NATIVE_DEVICE_OFFSET</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

			<span class="cm">/* Was the device already added by Firmware? */</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">find_device_by_addr</span><span class="p">(</span><span class="n">hpa</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">path</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_pa_dev</span><span class="p">(</span><span class="n">hpa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">register_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">devices_found</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">walk_lower_bus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">devices_found</span> <span class="o">&amp;&amp;</span> <span class="n">hpa</span> <span class="o">&lt;</span> <span class="n">io_io_high</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define CENTRAL_BUS_ADDR F_EXTEND(0xfff80000)</span>

<span class="cm">/**</span>
<span class="cm"> * walk_central_bus - Find devices attached to the central bus</span>
<span class="cm"> *</span>
<span class="cm"> * PDC doesn&#39;t tell us about all devices in the system.  This routine</span>
<span class="cm"> * finds devices connected to the central bus.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">walk_central_bus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">walk_native_bus</span><span class="p">(</span><span class="n">CENTRAL_BUS_ADDR</span><span class="p">,</span>
			<span class="n">CENTRAL_BUS_ADDR</span> <span class="o">+</span> <span class="p">(</span><span class="n">MAX_NATIVE_DEVICES</span> <span class="o">*</span> <span class="n">NATIVE_DEVICE_OFFSET</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_parisc_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">hw_path</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">print_pa_hwpath</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hw_path</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%d. %s at 0x%p [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }&quot;</span><span class="p">,</span>
		<span class="o">++</span><span class="n">count</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">hw_path</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hversion_rev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hversion</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">sversion</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_addrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, additional addresses: &quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_addrs</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;0x%lx &quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_parisc_bus - Some preparation to be done before inventory</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">init_parisc_bus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parisc_bus_type</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Could not register PA-RISC bus type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Could not register PA-RISC root device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">print_one_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span> <span class="n">pdev</span> <span class="o">=</span> <span class="n">to_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">print_parisc_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * print_parisc_devices - Print out a list of devices found in this system</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">print_parisc_devices</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">for_each_padev</span><span class="p">(</span><span class="n">print_one_device</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
