<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › kernel › inventory.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>inventory.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * inventory.c</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1999 The Puffin Group (David Kennedy and Alex deVries)</span>
<span class="cm"> * Copyright (c) 2001 Matthew Wilcox for Hewlett-Packard</span>
<span class="cm"> *</span>
<span class="cm"> * These are the routines to discover what hardware exists in this box.</span>
<span class="cm"> * This task is complicated by there being 3 different ways of</span>
<span class="cm"> * performing an inventory, depending largely on the age of the box.</span>
<span class="cm"> * The recommended way to do this is to check to see whether the machine</span>
<span class="cm"> * is a `Snake&#39; first, then try System Map, then try PAT.  We try System</span>
<span class="cm"> * Map before checking for a Snake -- this probably doesn&#39;t cause any</span>
<span class="cm"> * problems, but...</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;asm/hardware.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/mmzone.h&gt;</span>
<span class="cp">#include &lt;asm/pdc.h&gt;</span>
<span class="cp">#include &lt;asm/pdcpat.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/parisc-device.h&gt;</span>

<span class="cm">/*</span>
<span class="cm">** Debug options</span>
<span class="cm">** DEBUG_PAT Dump details which PDC PAT provides about ranges/devices.</span>
<span class="cm">*/</span>
<span class="cp">#undef DEBUG_PAT</span>

<span class="kt">int</span> <span class="n">pdc_type</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">PDC_TYPE_ILLEGAL</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_pdc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdc_system_map_mod_info</span> <span class="n">module_result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdc_module_path</span> <span class="n">module_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdc_model</span> <span class="n">model</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="k">struct</span> <span class="n">pdc_pat_cell_num</span> <span class="n">cell_info</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Determine the pdc &quot;type&quot; used on this machine */</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Determining PDC firmware type: &quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_system_map_find_mods</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdc_type</span> <span class="o">=</span> <span class="n">PDC_TYPE_SYSTEM_MAP</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;System Map.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the machine doesn&#39;t support PDC_SYSTEM_MAP then either it</span>
<span class="cm">	 * is a pdc pat box, or it is an older box. All 64 bit capable</span>
<span class="cm">	 * machines are either pdc pat boxes or they support PDC_SYSTEM_MAP.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: We should test for 64 bit capability and give a</span>
<span class="cm">	 * clearer message.</span>
<span class="cm">	 */</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pat_cell_get_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdc_type</span> <span class="o">=</span> <span class="n">PDC_TYPE_PAT</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;64 bit PAT.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Check the CPU&#39;s bus ID.  There&#39;s probably a better test.  */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_model_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">model</span><span class="p">);</span>

	<span class="n">bus_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">hversion</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bus_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x4</span>:		<span class="cm">/* 720, 730, 750, 735, 755 */</span>
	<span class="k">case</span> <span class="mh">0x6</span>:		<span class="cm">/* 705, 710 */</span>
	<span class="k">case</span> <span class="mh">0x7</span>:		<span class="cm">/* 715, 725 */</span>
	<span class="k">case</span> <span class="mh">0x8</span>:		<span class="cm">/* 745, 747, 742 */</span>
	<span class="k">case</span> <span class="mh">0xA</span>:		<span class="cm">/* 712 and similar */</span>
	<span class="k">case</span> <span class="mh">0xC</span>:		<span class="cm">/* 715/64, at least */</span>

		<span class="n">pdc_type</span> <span class="o">=</span> <span class="n">PDC_TYPE_SNAKE</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Snake.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="nl">default:</span>		<span class="cm">/* Everything else */</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unsupported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;If this is a 64-bit machine, please try a 64-bit kernel.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define PDC_PAGE_ADJ_SHIFT (PAGE_SHIFT - 12) </span><span class="cm">/* pdc pages are always 4k */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">set_pmem_entry</span><span class="p">(</span><span class="n">physmem_range_t</span> <span class="o">*</span><span class="n">pmem_ptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages4k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Rather than aligning and potentially throwing away</span>
<span class="cm">	 * memory, we&#39;ll assume that any ranges are already</span>
<span class="cm">	 * nicely aligned with any reasonable page size, and</span>
<span class="cm">	 * panic if they are not (it&#39;s more likely that the</span>
<span class="cm">	 * pdc info is bad in this case).</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span> <span class="p">((</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">pages4k</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">PDC_PAGE_ADJ_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">))</span> <span class="p">{</span>

		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Memory range doesn&#39;t align with page size!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pmem_ptr</span><span class="o">-&gt;</span><span class="n">start_pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">pmem_ptr</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">pages4k</span> <span class="o">&gt;&gt;</span> <span class="n">PDC_PAGE_ADJ_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">pagezero_memconfig</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">;</span>

	<span class="cm">/* Use the 32 bit information from page zero to create a single</span>
<span class="cm">	 * entry in the pmem_ranges[] table.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We currently don&#39;t support machines with contiguous memory</span>
<span class="cm">	 * &gt;= 4 Gb, who report that memory using 64 bit only fields</span>
<span class="cm">	 * on page zero. It&#39;s not worth doing until it can be tested,</span>
<span class="cm">	 * and it is not clear we can support those machines for other</span>
<span class="cm">	 * reasons.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If that support is done in the future, this is where it</span>
<span class="cm">	 * should be done.</span>
<span class="cm">	 */</span>

	<span class="n">npages</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">PAGE0</span><span class="o">-&gt;</span><span class="n">imm_max_mem</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">set_pmem_entry</span><span class="p">(</span><span class="n">pmem_ranges</span><span class="p">,</span><span class="mi">0UL</span><span class="p">,</span><span class="n">npages</span><span class="p">);</span>
	<span class="n">npmem_ranges</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_64BIT</span>

<span class="cm">/* All of the PDC PAT specific code is 64-bit only */</span>

<span class="cm">/*</span>
<span class="cm">**  The module object is filled via PDC_PAT_CELL[Return Cell Module].</span>
<span class="cm">**  If a module is found, register module will get the IODC bytes via</span>
<span class="cm">**  pdc_iodc_read() using the PA view of conf_base_addr for the hpa parameter.</span>
<span class="cm">**</span>
<span class="cm">**  The IO view can be used by PDC_PAT_CELL[Return Cell Module]</span>
<span class="cm">**  only for SBAs and LBAs.  This view will cause an invalid</span>
<span class="cm">**  argument error for all other cell module types.</span>
<span class="cm">**</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> 
<span class="nf">pat_query_module</span><span class="p">(</span><span class="n">ulong</span> <span class="n">pcell_loc</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">mod_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pdc_pat_cell_mod_maddr_block_t</span> <span class="o">*</span><span class="n">pa_pdc_cell</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytecnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">temp</span><span class="p">;</span>	<span class="cm">/* 64-bit scratch value */</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>		<span class="cm">/* PDC return value status */</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">pa_pdc_cell</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">pa_pdc_cell</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pa_pdc_cell</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;couldn&#39;t allocate memory for PDC_PAT_CELL!&quot;</span><span class="p">);</span>

	<span class="cm">/* return cell module (PA or Processor view) */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pat_cell_module</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytecnt</span><span class="p">,</span> <span class="n">pcell_loc</span><span class="p">,</span> <span class="n">mod_index</span><span class="p">,</span>
				     <span class="n">PA_VIEW</span><span class="p">,</span> <span class="n">pa_pdc_cell</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no more cell modules or error */</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">cba</span><span class="p">;</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_pa_dev</span><span class="p">(</span><span class="n">PAT_GET_CBA</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod_path</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">PDC_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* alloc_pa_dev sets dev-&gt;hpa */</span>

	<span class="cm">/*</span>
<span class="cm">	** save parameters in the parisc_device</span>
<span class="cm">	** (The idea being the device driver will call pdc_pat_cell_module()</span>
<span class="cm">	** and store the results in its own data structure.)</span>
<span class="cm">	*/</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcell_loc</span> <span class="o">=</span> <span class="n">pcell_loc</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mod_index</span> <span class="o">=</span> <span class="n">mod_index</span><span class="p">;</span>

	<span class="cm">/* save generic info returned from the call */</span>
	<span class="cm">/* REVISIT: who is the consumer of this? not sure yet... */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mod_info</span> <span class="o">=</span> <span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod_info</span><span class="p">;</span>	<span class="cm">/* pass to PAT_GET_ENTITY() */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pmod_loc</span> <span class="o">=</span> <span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod_location</span><span class="p">;</span>

	<span class="n">register_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* advertise device */</span>

<span class="cp">#ifdef DEBUG_PAT</span>
	<span class="n">pdc_pat_cell_mod_maddr_block_t</span> <span class="n">io_pdc_cell</span><span class="p">;</span>
	<span class="cm">/* dump what we see so far... */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">PAT_GET_ENTITY</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mod_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PAT_ENTITY_PROC</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;PAT_ENTITY_PROC: id_eid 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PAT_ENTITY_MEM</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> 
			<span class="s">&quot;PAT_ENTITY_MEM: amount 0x%lx min_gni_base 0x%lx min_gni_len 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PAT_ENTITY_CA</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;PAT_ENTITY_CA: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcell_loc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PAT_ENTITY_PBC</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;PAT_ENTITY_PBC: &quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">print_ranges</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PAT_ENTITY_SBA</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;PAT_ENTITY_SBA: &quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">print_ranges</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PAT_ENTITY_LBA</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;PAT_ENTITY_LBA: &quot;</span><span class="p">);</span>

 <span class="nl">print_ranges:</span>
		<span class="n">pdc_pat_cell_module</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytecnt</span><span class="p">,</span> <span class="n">pcell_loc</span><span class="p">,</span> <span class="n">mod_index</span><span class="p">,</span>
				    <span class="n">IO_VIEW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_pdc_cell</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;ranges %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> 
				<span class="s">&quot;  PA_VIEW %ld: 0x%016lx 0x%016lx 0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
				<span class="n">i</span><span class="p">,</span> <span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span>	<span class="cm">/* type */</span>
				<span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span>	<span class="cm">/* start */</span>
				<span class="n">pa_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">4</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]);</span>	<span class="cm">/* finish (ie end) */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> 
				<span class="s">&quot;  IO_VIEW %ld: 0x%016lx 0x%016lx 0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
				<span class="n">i</span><span class="p">,</span> <span class="n">io_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span>	<span class="cm">/* type */</span>
				<span class="n">io_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span>	<span class="cm">/* start */</span>
				<span class="n">io_pdc_cell</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">[</span><span class="mi">4</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]);</span>	<span class="cm">/* finish (ie end) */</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG_PAT */</span><span class="cp"></span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pa_pdc_cell</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PDC_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* pat pdc can return information about a variety of different</span>
<span class="cm"> * types of memory (e.g. firmware,i/o, etc) but we only care about</span>
<span class="cm"> * the usable physical ram right now. Since the firmware specific</span>
<span class="cm"> * information is allocated on the stack, we&#39;ll be generous, in</span>
<span class="cm"> * case there is a lot of other information we don&#39;t care about.</span>
<span class="cm"> */</span>

<span class="cp">#define PAT_MAX_RANGES (4 * MAX_PHYSMEM_RANGES)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">pat_memconfig</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">actual_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdc_pat_pd_addr_map_entry</span> <span class="n">mem_table</span><span class="p">[</span><span class="n">PAT_MAX_RANGES</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pdc_pat_pd_addr_map_entry</span> <span class="o">*</span><span class="n">mtbl_ptr</span><span class="p">;</span>
	<span class="n">physmem_range_t</span> <span class="o">*</span><span class="n">pmem_ptr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAT_MAX_RANGES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_pat_pd_addr_map_entry</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pat_pd_get_addr_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actual_len</span><span class="p">,</span> <span class="n">mem_table</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">0L</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">actual_len</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_pat_pd_addr_map_entry</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* The above pdc call shouldn&#39;t fail, but, just in</span>
<span class="cm">		 * case, just use the PAGE0 info.</span>
<span class="cm">		 */</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;WARNING! Could not get full memory configuration. &quot;</span>
			<span class="s">&quot;All memory may not be used!</span><span class="se">\n\n\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pagezero_memconfig</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="n">actual_len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_pat_pd_addr_map_entry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entries</span> <span class="o">&gt;</span> <span class="n">PAT_MAX_RANGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;This Machine has more memory ranges than we support!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Some memory may not be used!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Copy information into the firmware independent pmem_ranges</span>
<span class="cm">	 * array, skipping types we don&#39;t care about. Notice we said</span>
<span class="cm">	 * &quot;may&quot; above. We&#39;ll use all the entries that were returned.</span>
<span class="cm">	 */</span>

	<span class="n">npmem_ranges</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mtbl_ptr</span> <span class="o">=</span> <span class="n">mem_table</span><span class="p">;</span>
	<span class="n">pmem_ptr</span> <span class="o">=</span> <span class="n">pmem_ranges</span><span class="p">;</span> <span class="cm">/* Global firmware independent table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">mtbl_ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span>   <span class="p">(</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">entry_type</span> <span class="o">!=</span> <span class="n">PAT_MEMORY_DESCRIPTOR</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">memory_type</span> <span class="o">!=</span> <span class="n">PAT_MEMTYPE_MEMORY</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span>   <span class="p">(</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">memory_usage</span> <span class="o">!=</span> <span class="n">PAT_MEMUSE_GENERAL</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">memory_usage</span> <span class="o">!=</span> <span class="n">PAT_MEMUSE_GI</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">memory_usage</span> <span class="o">!=</span> <span class="n">PAT_MEMUSE_GNI</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">npmem_ranges</span> <span class="o">==</span> <span class="n">MAX_PHYSMEM_RANGES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;This Machine has more memory ranges than we support!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Some memory will not be used!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">set_pmem_entry</span><span class="p">(</span><span class="n">pmem_ptr</span><span class="o">++</span><span class="p">,</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">,</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">npmem_ranges</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pat_inventory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">ulong</span> <span class="n">mod_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdc_pat_cell_num</span> <span class="n">cell_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	** Note:  Prelude (and it&#39;s successors: Lclass, A400/500) only</span>
<span class="cm">	**        implement PDC_PAT_CELL sub-options 0 and 2.</span>
<span class="cm">	*/</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_pat_cell_get_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cell_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG_PAT</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;CELL_GET_NUMBER: 0x%lx 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cell_info</span><span class="p">.</span><span class="n">cell_num</span><span class="p">,</span> 
	       <span class="n">cell_info</span><span class="p">.</span><span class="n">cell_loc</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">PDC_OK</span> <span class="o">==</span> <span class="n">pat_query_module</span><span class="p">(</span><span class="n">cell_info</span><span class="p">.</span><span class="n">cell_loc</span><span class="p">,</span> <span class="n">mod_index</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mod_index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mod_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We only look for extended memory ranges on a 64 bit capable box */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sprockets_memconfig</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pdc_memory_table_raddr</span> <span class="n">r_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdc_memory_table</span> <span class="n">mem_table</span><span class="p">[</span><span class="n">MAX_PHYSMEM_RANGES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pdc_memory_table</span> <span class="o">*</span><span class="n">mtbl_ptr</span><span class="p">;</span>
	<span class="n">physmem_range_t</span> <span class="o">*</span><span class="n">pmem_ptr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_mem_mem_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r_addr</span><span class="p">,</span><span class="n">mem_table</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">MAX_PHYSMEM_RANGES</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* The above pdc call only works on boxes with sprockets</span>
<span class="cm">		 * firmware (newer B,C,J class). Other non PAT PDC machines</span>
<span class="cm">		 * do support more than 3.75 Gb of memory, but we don&#39;t</span>
<span class="cm">		 * support them yet.</span>
<span class="cm">		 */</span>

		<span class="n">pagezero_memconfig</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r_addr</span><span class="p">.</span><span class="n">entries_total</span> <span class="o">&gt;</span> <span class="n">MAX_PHYSMEM_RANGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;This Machine has more memory ranges than we support!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Some memory will not be used!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">r_addr</span><span class="p">.</span><span class="n">entries_returned</span><span class="p">;</span>

	<span class="n">npmem_ranges</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mtbl_ptr</span> <span class="o">=</span> <span class="n">mem_table</span><span class="p">;</span>
	<span class="n">pmem_ptr</span> <span class="o">=</span> <span class="n">pmem_ranges</span><span class="p">;</span> <span class="cm">/* Global firmware independent table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">mtbl_ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_pmem_entry</span><span class="p">(</span><span class="n">pmem_ptr</span><span class="o">++</span><span class="p">,</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">,</span><span class="n">mtbl_ptr</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">npmem_ranges</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else   </span><span class="cm">/* !CONFIG_64BIT */</span><span class="cp"></span>

<span class="cp">#define pat_inventory() do { } while (0)</span>
<span class="cp">#define pat_memconfig() do { } while (0)</span>
<span class="cp">#define sprockets_memconfig() pagezero_memconfig()</span>

<span class="cp">#endif	</span><span class="cm">/* !CONFIG_64BIT */</span><span class="cp"></span>


<span class="cp">#ifndef CONFIG_PA20</span>

<span class="cm">/* Code to support Snake machines (7[2350], 7[235]5, 715/Scorpio) */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span> <span class="n">__init</span>
<span class="nf">legacy_create_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pdc_memory_map</span> <span class="o">*</span><span class="n">r_addr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pdc_module_path</span> <span class="o">*</span><span class="n">module_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">pdc_mem_map_hpa</span><span class="p">(</span><span class="n">r_addr</span><span class="p">,</span> <span class="n">module_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_pa_dev</span><span class="p">(</span><span class="n">r_addr</span><span class="o">-&gt;</span><span class="n">hpa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module_path</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">register_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snake_inventory</span>
<span class="cm"> *</span>
<span class="cm"> * Before PDC_SYSTEM_MAP was invented, the PDC_MEM_MAP call was used.</span>
<span class="cm"> * To use it, we initialise the mod_path.bc to 0xff and try all values of</span>
<span class="cm"> * mod to get the HPA for the top-level devices.  Bus adapters may have</span>
<span class="cm"> * sub-devices which are discovered by setting bc[5] to 0 and bc[4] to the</span>
<span class="cm"> * module, then trying all possible functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">snake_inventory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mod</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">mod</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mod</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">mod</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pdc_module_path</span> <span class="n">module_path</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pdc_memory_map</span> <span class="n">r_addr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">func</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">module_path</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">bc</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">module_path</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">legacy_create_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module_path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">hw_type</span> <span class="o">!=</span> <span class="n">HPHW_BA</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">module_path</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">bc</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">module_path</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">bc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">func</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">func</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">func</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">module_path</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">bc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">module_path</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
			<span class="n">legacy_create_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module_path</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_PA20 */</span><span class="cp"></span>
<span class="cp">#define snake_inventory() do { } while (0)</span>
<span class="cp">#endif  </span><span class="cm">/* CONFIG_PA20 */</span><span class="cp"></span>

<span class="cm">/* Common 32/64 bit based code goes here */</span>

<span class="cm">/**</span>
<span class="cm"> * add_system_map_addresses - Add additional addresses to the parisc device.</span>
<span class="cm"> * @dev: The parisc device.</span>
<span class="cm"> * @num_addrs: Then number of addresses to add;</span>
<span class="cm"> * @module_instance: The system_map module instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds any additional addresses reported by the system_map</span>
<span class="cm"> * firmware to the parisc device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">add_system_map_addresses</span><span class="p">(</span><span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_addrs</span><span class="p">,</span> 
			 <span class="kt">int</span> <span class="n">module_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pdc_system_map_addr_info</span> <span class="n">addr_result</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">num_addrs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s %s(): memory allocation failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">num_addrs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_system_map_find_addrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr_result</span><span class="p">,</span> 
						   <span class="n">module_instance</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">PDC_OK</span> <span class="o">==</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_addrs</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr_result</span><span class="p">.</span><span class="n">mod_addr</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_addrs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> 
			       <span class="s">&quot;Bad PDC_FIND_ADDRESS status return (%ld) for index %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">status</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * system_map_inventory - Retrieve firmware devices via SYSTEM_MAP.</span>
<span class="cm"> *</span>
<span class="cm"> * This function attempts to retrieve and register all the devices firmware</span>
<span class="cm"> * knows about via the SYSTEM_MAP PDC call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">system_map_inventory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">status</span> <span class="o">=</span> <span class="n">PDC_OK</span><span class="p">;</span>
    
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pdc_system_map_mod_info</span> <span class="n">module_result</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pdc_module_path</span> <span class="n">module_path</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">pdc_system_map_find_mods</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_result</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">module_path</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="n">PDC_BAD_PROC</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PDC_NE_MOD</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PDC_OK</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_pa_dev</span><span class="p">(</span><span class="n">module_result</span><span class="p">.</span><span class="n">mod_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module_path</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		
		<span class="n">register_parisc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* if available, get the additional addresses for a module */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">module_result</span><span class="p">.</span><span class="n">add_addrs</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">add_system_map_addresses</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">module_result</span><span class="p">.</span><span class="n">add_addrs</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">walk_central_bus</span><span class="p">();</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_memory_inventory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pdc_type</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">PDC_TYPE_PAT</span>:
		<span class="n">pat_memconfig</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PDC_TYPE_SYSTEM_MAP</span>:
		<span class="n">sprockets_memconfig</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PDC_TYPE_SNAKE</span>:
		<span class="n">pagezero_memconfig</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unknown PDC type!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">npmem_ranges</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pmem_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">start_pfn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Bad memory configuration returned!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Some memory may not be used!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pagezero_memconfig</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_device_inventory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Searching for devices...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">init_parisc_bus</span><span class="p">();</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pdc_type</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">PDC_TYPE_PAT</span>:
		<span class="n">pat_inventory</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PDC_TYPE_SYSTEM_MAP</span>:
		<span class="n">system_map_inventory</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PDC_TYPE_SNAKE</span>:
		<span class="n">snake_inventory</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unknown PDC type!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Found devices:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_parisc_devices</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
