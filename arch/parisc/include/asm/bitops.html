<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › include › asm › bitops.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>bitops.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _PARISC_BITOPS_H</span>
<span class="cp">#define _PARISC_BITOPS_H</span>

<span class="cp">#ifndef _LINUX_BITOPS_H</span>
<span class="cp">#error only &lt;linux/bitops.h&gt; can be included directly</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;		</span><span class="cm">/* for BITS_PER_LONG/SHIFT_PER_LONG */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * HP-PARISC specific bit operations</span>
<span class="cm"> * for a detailed description of the functions please refer</span>
<span class="cm"> * to include/asm-i386/bitops.h or kerneldoc</span>
<span class="cm"> */</span>

<span class="cp">#define CHOP_SHIFTCOUNT(x) (((unsigned long) (x)) &amp; (BITS_PER_LONG - 1))</span>


<span class="cp">#define smp_mb__before_clear_bit()      smp_mb()</span>
<span class="cp">#define smp_mb__after_clear_bit()       smp_mb()</span>

<span class="cm">/* See http://marc.theaimsgroup.com/?t=108826637900003 for discussion</span>
<span class="cm"> * on use of volatile and __*_bit() (set/clear/change):</span>
<span class="cm"> *	*_bit() want use of volatile.</span>
<span class="cm"> *	__*_bit() are &quot;relaxed&quot; and don&#39;t use spinlock or volatile.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">set_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CHOP_SHIFTCOUNT</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_PER_LONG</span><span class="p">);</span>
	<span class="n">_atomic_spin_lock_irqsave</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="o">*</span><span class="n">addr</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">_atomic_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">clear_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CHOP_SHIFTCOUNT</span><span class="p">(</span><span class="n">nr</span><span class="p">));</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_PER_LONG</span><span class="p">);</span>
	<span class="n">_atomic_spin_lock_irqsave</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="o">*</span><span class="n">addr</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">_atomic_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">change_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CHOP_SHIFTCOUNT</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_PER_LONG</span><span class="p">);</span>
	<span class="n">_atomic_spin_lock_irqsave</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="o">*</span><span class="n">addr</span> <span class="o">^=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">_atomic_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">test_and_set_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CHOP_SHIFTCOUNT</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">set</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_PER_LONG</span><span class="p">);</span>
	<span class="n">_atomic_spin_lock_irqsave</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">set</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set</span><span class="p">)</span>
		<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">old</span> <span class="o">|</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">_atomic_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">set</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">test_and_clear_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CHOP_SHIFTCOUNT</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">set</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_PER_LONG</span><span class="p">);</span>
	<span class="n">_atomic_spin_lock_irqsave</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">set</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span>
		<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">_atomic_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">set</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">test_and_change_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CHOP_SHIFTCOUNT</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">oldbit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_PER_LONG</span><span class="p">);</span>
	<span class="n">_atomic_spin_lock_irqsave</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">oldbit</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">oldbit</span> <span class="o">^</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">_atomic_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">oldbit</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &lt;asm-generic/bitops/non-atomic.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/**</span>
<span class="cm"> * __ffs - find first bit in word. returns 0 to &quot;BITS_PER_LONG-1&quot;.</span>
<span class="cm"> * @word: The word to search</span>
<span class="cm"> *</span>
<span class="cm"> * __ffs() return is undefined if no bit is set.</span>
<span class="cm"> *</span>
<span class="cm"> * 32-bit fast __ffs by LaMont Jones &quot;lamont At hp com&quot;.</span>
<span class="cm"> * 64-bit enhancement by Grant Grundler &quot;grundler At parisc-linux org&quot;.</span>
<span class="cm"> * (with help from willy/jejb to get the semantics right)</span>
<span class="cm"> *</span>
<span class="cm"> * This algorithm avoids branches by making use of nullification.</span>
<span class="cm"> * One side effect of &quot;extr&quot; instructions is it sets PSW[N] bit.</span>
<span class="cm"> * How PSW[N] (nullify next insn) gets set is determined by the </span>
<span class="cm"> * &quot;condition&quot; field (eg &quot;&lt;&gt;&quot; or &quot;TR&quot; below) in the extr* insn.</span>
<span class="cm"> * Only the 1st and one of either the 2cd or 3rd insn will get executed.</span>
<span class="cm"> * Each set of 3 insn will get executed in 2 cycles on PA8x00 vs 16 or so</span>
<span class="cm"> * cycles for each mispredicted branch.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__ffs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">__asm__</span><span class="p">(</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
		<span class="s">&quot; ldi       63,%1</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extrd,u,*&lt;&gt;  %0,63,32,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extrd,u,*TR  %0,31,32,%0</span><span class="se">\n</span><span class="s">&quot;</span>	<span class="cm">/* move top 32-bits down */</span>
		<span class="s">&quot; addi    -32,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#else</span>
		<span class="s">&quot; ldi       31,%1</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
		<span class="s">&quot; extru,&lt;&gt;  %0,31,16,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extru,TR  %0,15,16,%0</span><span class="se">\n</span><span class="s">&quot;</span>	<span class="cm">/* xxxx0000 -&gt; 0000xxxx */</span>
		<span class="s">&quot; addi    -16,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extru,&lt;&gt;  %0,31,8,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extru,TR  %0,23,8,%0</span><span class="se">\n</span><span class="s">&quot;</span>	<span class="cm">/* 0000xx00 -&gt; 000000xx */</span>
		<span class="s">&quot; addi    -8,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extru,&lt;&gt;  %0,31,4,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extru,TR  %0,27,4,%0</span><span class="se">\n</span><span class="s">&quot;</span>	<span class="cm">/* 000000x0 -&gt; 0000000x */</span>
		<span class="s">&quot; addi    -4,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extru,&lt;&gt;  %0,31,2,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extru,TR  %0,29,2,%0</span><span class="se">\n</span><span class="s">&quot;</span>	<span class="cm">/* 0000000y, 1100b -&gt; 0011b */</span>
		<span class="s">&quot; addi    -2,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot; extru,=  %0,31,1,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>	<span class="cm">/* check last bit */</span>
		<span class="s">&quot; addi    -1,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &lt;asm-generic/bitops/ffz.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * ffs: find first bit set. returns 1 to BITS_PER_LONG or 0 (if none set)</span>
<span class="cm"> * This is defined the same way as the libc and compiler builtin</span>
<span class="cm"> * ffs routines, therefore differs in spirit from the above ffz (man ffs).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">ffs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">?</span> <span class="p">(</span><span class="n">__ffs</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fls: find last (most significant) bit set.</span>
<span class="cm"> * fls(0) = 0, fls(1) = 1, fls(0x80000000) = 32.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">fls</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">__asm__</span><span class="p">(</span>
	<span class="s">&quot;	ldi		1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	extru,&lt;&gt;	%0,15,16,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	zdep,TR		%0,15,16,%0</span><span class="se">\n</span><span class="s">&quot;</span>		<span class="cm">/* xxxx0000 */</span>
	<span class="s">&quot;	addi		16,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	extru,&lt;&gt;	%0,7,8,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	zdep,TR		%0,23,24,%0</span><span class="se">\n</span><span class="s">&quot;</span>		<span class="cm">/* xx000000 */</span>
	<span class="s">&quot;	addi		8,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	extru,&lt;&gt;	%0,3,4,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	zdep,TR		%0,27,28,%0</span><span class="se">\n</span><span class="s">&quot;</span>		<span class="cm">/* x0000000 */</span>
	<span class="s">&quot;	addi		4,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	extru,&lt;&gt;	%0,1,2,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	zdep,TR		%0,29,30,%0</span><span class="se">\n</span><span class="s">&quot;</span>		<span class="cm">/* y0000000 (y&amp;3 = 0) */</span>
	<span class="s">&quot;	addi		2,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	extru,=		%0,0,1,%%r0</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	addi		1,%1,%1</span><span class="se">\n</span><span class="s">&quot;</span>		<span class="cm">/* if y &amp; 8, add 1 */</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &lt;asm-generic/bitops/__fls.h&gt;</span>
<span class="cp">#include &lt;asm-generic/bitops/fls64.h&gt;</span>
<span class="cp">#include &lt;asm-generic/bitops/hweight.h&gt;</span>
<span class="cp">#include &lt;asm-generic/bitops/lock.h&gt;</span>
<span class="cp">#include &lt;asm-generic/bitops/sched.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#include &lt;asm-generic/bitops/find.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;asm-generic/bitops/le.h&gt;</span>
<span class="cp">#include &lt;asm-generic/bitops/ext2-atomic-setbit.h&gt;</span>

<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _PARISC_BITOPS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
