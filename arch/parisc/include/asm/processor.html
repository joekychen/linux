<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › parisc › include › asm › processor.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>processor.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * include/asm-parisc/processor.h</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1994 Linus Torvalds</span>
<span class="cm"> * Copyright (C) 2001 Grant Grundler</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __ASM_PARISC_PROCESSOR_H</span>
<span class="cp">#define __ASM_PARISC_PROCESSOR_H</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>

<span class="cp">#include &lt;asm/prefetch.h&gt;</span>
<span class="cp">#include &lt;asm/hardware.h&gt;</span>
<span class="cp">#include &lt;asm/pdc.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/percpu.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define KERNEL_STACK_SIZE 	(4*PAGE_SIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * Default implementation of macro that returns current</span>
<span class="cm"> * instruction pointer (&quot;program counter&quot;).</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PA20</span>
<span class="cp">#define current_ia(x)	__asm__(&quot;mfia %0&quot; : &quot;=r&quot;(x))</span>
<span class="cp">#else </span><span class="cm">/* mfia added in pa2.0 */</span><span class="cp"></span>
<span class="cp">#define current_ia(x)	__asm__(&quot;blr 0,%0\n\tnop&quot; : &quot;=r&quot;(x))</span>
<span class="cp">#endif</span>
<span class="cp">#define current_text_addr() ({ void *pc; current_ia(pc); pc; })</span>

<span class="cp">#define TASK_SIZE_OF(tsk)       ((tsk)-&gt;thread.task_size)</span>
<span class="cp">#define TASK_SIZE	        TASK_SIZE_OF(current)</span>
<span class="cp">#define TASK_UNMAPPED_BASE      (current-&gt;thread.map_base)</span>

<span class="cp">#define DEFAULT_TASK_SIZE32	(0xFFF00000UL)</span>
<span class="cp">#define DEFAULT_MAP_BASE32	(0x40000000UL)</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define DEFAULT_TASK_SIZE       (MAX_ADDRESS-0xf000000)</span>
<span class="cp">#define DEFAULT_MAP_BASE        (0x200000000UL)</span>
<span class="cp">#else</span>
<span class="cp">#define DEFAULT_TASK_SIZE	DEFAULT_TASK_SIZE32</span>
<span class="cp">#define DEFAULT_MAP_BASE	DEFAULT_MAP_BASE32</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/* XXX: STACK_TOP actually should be STACK_BOTTOM for parisc.</span>
<span class="cm"> * prumpf */</span>

<span class="cp">#define STACK_TOP	TASK_SIZE</span>
<span class="cp">#define STACK_TOP_MAX	DEFAULT_TASK_SIZE</span>

<span class="cp">#endif</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/*</span>
<span class="cm"> * Data detected about CPUs at boot time which is the same for all CPU&#39;s.</span>
<span class="cm"> * HP boxes are SMP - ie identical processors.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: some CPU rev info may be processor specific...</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">system_cpuinfo_parisc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cpu_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cpu_hz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">hversion</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">sversion</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">cpu_type</span>	<span class="n">cpu_type</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pdc_model</span> <span class="n">model</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">versions</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpuid</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capabilities</span><span class="p">;</span>
		<span class="kt">char</span>   <span class="n">sys_model_name</span><span class="p">[</span><span class="mi">81</span><span class="p">];</span> <span class="cm">/* PDC-ROM returnes this model name */</span>
	<span class="p">}</span> <span class="n">pdc</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">cpu_name</span><span class="p">;</span>	<span class="cm">/* e.g. &quot;PA7300LC (PCX-L2)&quot; */</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">family_name</span><span class="p">;</span>	<span class="cm">/* e.g. &quot;1.1e&quot; */</span>
<span class="p">};</span>


<span class="cm">/* Per CPU data structure - ie varies per CPU.  */</span>
<span class="k">struct</span> <span class="n">cpuinfo_parisc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">it_value</span><span class="p">;</span>     <span class="cm">/* Interval Timer at last timer Intr */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">it_delta</span><span class="p">;</span>     <span class="cm">/* Interval delta (tic_10ms / HZ * 100) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_count</span><span class="p">;</span>    <span class="cm">/* number of IRQ&#39;s since boot */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_max_cr16</span><span class="p">;</span> <span class="cm">/* longest time to handle a single IRQ */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpuid</span><span class="p">;</span>        <span class="cm">/* aka slot_number or set to NO_PROC_ID */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">;</span>          <span class="cm">/* Host Physical address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">txn_addr</span><span class="p">;</span>     <span class="cm">/* MMIO addr of EIR or id_eid */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_ipi</span><span class="p">;</span>  <span class="cm">/* bitmap of type ipi_message_type */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipi_count</span><span class="p">;</span>    <span class="cm">/* number ipi Interrupts */</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bh_count</span><span class="p">;</span>     <span class="cm">/* number of times bh was invoked */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prof_counter</span><span class="p">;</span> <span class="cm">/* per CPU profiling support */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prof_multiplier</span><span class="p">;</span>	<span class="cm">/* per CPU profiling support */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp_rev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp_model</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parisc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">loops_per_jiffy</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">system_cpuinfo_parisc</span> <span class="n">boot_cpu_data</span><span class="p">;</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_parisc</span><span class="p">,</span> <span class="n">cpu_data</span><span class="p">);</span>

<span class="cp">#define CPU_HVERSION ((boot_cpu_data.hversion &gt;&gt; 4) &amp; 0x0FFF)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">seg</span><span class="p">;</span>  
<span class="p">}</span> <span class="n">mm_segment_t</span><span class="p">;</span>

<span class="cp">#define ARCH_MIN_TASKALIGN	8</span>

<span class="k">struct</span> <span class="n">thread_struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">task_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">map_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span> 

<span class="cp">#define task_pt_regs(tsk) ((struct pt_regs *)&amp;((tsk)-&gt;thread.regs))</span>

<span class="cm">/* Thread struct flags. */</span>
<span class="cp">#define PARISC_UAC_NOPRINT	(1UL &lt;&lt; 0)	</span><span class="cm">/* see prctl and unaligned.c */</span><span class="cp"></span>
<span class="cp">#define PARISC_UAC_SIGBUS	(1UL &lt;&lt; 1)</span>
<span class="cp">#define PARISC_KERNEL_DEATH	(1UL &lt;&lt; 31)	</span><span class="cm">/* see die_if_kernel()... */</span><span class="cp"></span>

<span class="cp">#define PARISC_UAC_SHIFT	0</span>
<span class="cp">#define PARISC_UAC_MASK		(PARISC_UAC_NOPRINT|PARISC_UAC_SIGBUS)</span>

<span class="cp">#define SET_UNALIGN_CTL(task,value)                                       \</span>
<span class="cp">        ({                                                                \</span>
<span class="cp">        (task)-&gt;thread.flags = (((task)-&gt;thread.flags &amp; ~PARISC_UAC_MASK) \</span>
<span class="cp">                                | (((value) &lt;&lt; PARISC_UAC_SHIFT) &amp;        \</span>
<span class="cp">                                   PARISC_UAC_MASK));                     \</span>
<span class="cp">        0;                                                                \</span>
<span class="cp">        })</span>

<span class="cp">#define GET_UNALIGN_CTL(task,addr)                                        \</span>
<span class="cp">        ({                                                                \</span>
<span class="cp">        put_user(((task)-&gt;thread.flags &amp; PARISC_UAC_MASK)                 \</span>
<span class="cp">                 &gt;&gt; PARISC_UAC_SHIFT, (int __user *) (addr));             \</span>
<span class="cp">        })</span>

<span class="cp">#define INIT_THREAD { \</span>
<span class="cp">	.regs = {	.gr	= { 0, }, \</span>
<span class="cp">			.fr	= { 0, }, \</span>
<span class="cp">			.sr	= { 0, }, \</span>
<span class="cp">			.iasq	= { 0, }, \</span>
<span class="cp">			.iaoq	= { 0, }, \</span>
<span class="cp">			.cr27	= 0, \</span>
<span class="cp">		}, \</span>
<span class="cp">	.task_size	= DEFAULT_TASK_SIZE, \</span>
<span class="cp">	.map_base	= DEFAULT_MAP_BASE, \</span>
<span class="cp">	.flags		= 0 \</span>
<span class="cp">	}</span>

<span class="cm">/*</span>
<span class="cm"> * Return saved PC of a blocked thread.  This is used by ps mostly.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thread_saved_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">show_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">stack</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Start user thread in another space.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we set both the iaoq and r31 to the new pc. When</span>
<span class="cm"> * the kernel initially calls execve it will return through an</span>
<span class="cm"> * rfi path that will use the values in the iaoq. The execve</span>
<span class="cm"> * syscall path will return through the gateway page, and</span>
<span class="cm"> * that uses r31 to branch to.</span>
<span class="cm"> *</span>
<span class="cm"> * For ELF we clear r23, because the dynamic linker uses it to pass</span>
<span class="cm"> * the address of the finalizer function.</span>
<span class="cm"> *</span>
<span class="cm"> * We also initialize sr3 to an illegal value (illegal for our</span>
<span class="cm"> * implementation, not for the architecture).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">elf_caddr_t</span><span class="p">;</span>

<span class="cp">#define start_thread_som(regs, new_pc, new_sp) do {	\</span>
<span class="cp">	unsigned long *sp = (unsigned long *)new_sp;	\</span>
<span class="cp">	__u32 spaceid = (__u32)current-&gt;mm-&gt;context;	\</span>
<span class="cp">	unsigned long pc = (unsigned long)new_pc;	\</span>
<span class="cp">	</span><span class="cm">/* offset pc for priv. level */</span><span class="cp">			\</span>
<span class="cp">	pc |= 3;					\</span>
<span class="cp">							\</span>
<span class="cp">	regs-&gt;iasq[0] = spaceid;			\</span>
<span class="cp">	regs-&gt;iasq[1] = spaceid;			\</span>
<span class="cp">	regs-&gt;iaoq[0] = pc;				\</span>
<span class="cp">	regs-&gt;iaoq[1] = pc + 4;                         \</span>
<span class="cp">	regs-&gt;sr[2] = LINUX_GATEWAY_SPACE;              \</span>
<span class="cp">	regs-&gt;sr[3] = 0xffff;				\</span>
<span class="cp">	regs-&gt;sr[4] = spaceid;				\</span>
<span class="cp">	regs-&gt;sr[5] = spaceid;				\</span>
<span class="cp">	regs-&gt;sr[6] = spaceid;				\</span>
<span class="cp">	regs-&gt;sr[7] = spaceid;				\</span>
<span class="cp">	regs-&gt;gr[ 0] = USER_PSW;                        \</span>
<span class="cp">	regs-&gt;gr[30] = ((new_sp)+63)&amp;~63;		\</span>
<span class="cp">	regs-&gt;gr[31] = pc;				\</span>
<span class="cp">							\</span>
<span class="cp">	get_user(regs-&gt;gr[26],&amp;sp[0]);			\</span>
<span class="cp">	get_user(regs-&gt;gr[25],&amp;sp[-1]); 		\</span>
<span class="cp">	get_user(regs-&gt;gr[24],&amp;sp[-2]); 		\</span>
<span class="cp">	get_user(regs-&gt;gr[23],&amp;sp[-3]); 		\</span>
<span class="cp">} while(0)</span>

<span class="cm">/* The ELF abi wants things done a &quot;wee bit&quot; differently than</span>
<span class="cm"> * som does.  Supporting this behavior here avoids</span>
<span class="cm"> * having our own version of create_elf_tables.</span>
<span class="cm"> *</span>
<span class="cm"> * Oh, and yes, that is not a typo, we are really passing argc in r25</span>
<span class="cm"> * and argv in r24 (rather than r26 and r25).  This is because that&#39;s</span>
<span class="cm"> * where __libc_start_main wants them.</span>
<span class="cm"> *</span>
<span class="cm"> * Duplicated from dl-machine.h for the benefit of readers:</span>
<span class="cm"> *</span>
<span class="cm"> *  Our initial stack layout is rather different from everyone else&#39;s</span>
<span class="cm"> *  due to the unique PA-RISC ABI.  As far as I know it looks like</span>
<span class="cm"> *  this:</span>

<span class="cm">   -----------------------------------  (user startup code creates this frame)</span>
<span class="cm">   |         32 bytes of magic       |</span>
<span class="cm">   |---------------------------------|</span>
<span class="cm">   | 32 bytes argument/sp save area  |</span>
<span class="cm">   |---------------------------------| (bprm-&gt;p)</span>
<span class="cm">   |	    ELF auxiliary info	     |</span>
<span class="cm">   |         (up to 28 words)        |</span>
<span class="cm">   |---------------------------------|</span>
<span class="cm">   |		   NULL		     |</span>
<span class="cm">   |---------------------------------|</span>
<span class="cm">   |	   Environment pointers	     |</span>
<span class="cm">   |---------------------------------|</span>
<span class="cm">   |		   NULL		     |</span>
<span class="cm">   |---------------------------------|</span>
<span class="cm">   |        Argument pointers        |</span>
<span class="cm">   |---------------------------------| &lt;- argv</span>
<span class="cm">   |          argc (1 word)          |</span>
<span class="cm">   |---------------------------------| &lt;- bprm-&gt;exec (HACK!)</span>
<span class="cm">   |         N bytes of slack        |</span>
<span class="cm">   |---------------------------------|</span>
<span class="cm">   |	filename passed to execve    |</span>
<span class="cm">   |---------------------------------| (mm-&gt;env_end)</span>
<span class="cm">   |           env strings           |</span>
<span class="cm">   |---------------------------------| (mm-&gt;env_start, mm-&gt;arg_end)</span>
<span class="cm">   |           arg strings           |</span>
<span class="cm">   |---------------------------------|</span>
<span class="cm">   | additional faked arg strings if |</span>
<span class="cm">   | we&#39;re invoked via binfmt_script |</span>
<span class="cm">   |---------------------------------| (mm-&gt;arg_start)</span>
<span class="cm">   stack base is at TASK_SIZE - rlim_max.</span>

<span class="cm">on downward growing arches, it looks like this:</span>
<span class="cm">   stack base at TASK_SIZE</span>
<span class="cm">   | filename passed to execve</span>
<span class="cm">   | env strings</span>
<span class="cm">   | arg strings</span>
<span class="cm">   | faked arg strings</span>
<span class="cm">   | slack</span>
<span class="cm">   | ELF</span>
<span class="cm">   | envps</span>
<span class="cm">   | argvs</span>
<span class="cm">   | argc</span>

<span class="cm"> *  The pleasant part of this is that if we need to skip arguments we</span>
<span class="cm"> *  can just decrement argc and move argv, because the stack pointer</span>
<span class="cm"> *  is utterly unrelated to the location of the environment and</span>
<span class="cm"> *  argument vectors.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the S/390 people took the easy way out and hacked their</span>
<span class="cm"> * GCC to make the stack grow downwards.</span>
<span class="cm"> *</span>
<span class="cm"> * Final Note: For entry from syscall, the W (wide) bit of the PSW</span>
<span class="cm"> * is stuffed into the lowest bit of the user sp (%r30), so we fill</span>
<span class="cm"> * it in here from the current-&gt;personality</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define USER_WIDE_MODE	(!test_thread_flag(TIF_32BIT))</span>
<span class="cp">#else</span>
<span class="cp">#define USER_WIDE_MODE	0</span>
<span class="cp">#endif</span>

<span class="cp">#define start_thread(regs, new_pc, new_sp) do {		\</span>
<span class="cp">	elf_addr_t *sp = (elf_addr_t *)new_sp;		\</span>
<span class="cp">	__u32 spaceid = (__u32)current-&gt;mm-&gt;context;	\</span>
<span class="cp">	elf_addr_t pc = (elf_addr_t)new_pc | 3;		\</span>
<span class="cp">	elf_caddr_t *argv = (elf_caddr_t *)bprm-&gt;exec + 1;	\</span>
<span class="cp">							\</span>
<span class="cp">	regs-&gt;iasq[0] = spaceid;			\</span>
<span class="cp">	regs-&gt;iasq[1] = spaceid;			\</span>
<span class="cp">	regs-&gt;iaoq[0] = pc;				\</span>
<span class="cp">	regs-&gt;iaoq[1] = pc + 4;                         \</span>
<span class="cp">	regs-&gt;sr[2] = LINUX_GATEWAY_SPACE;              \</span>
<span class="cp">	regs-&gt;sr[3] = 0xffff;				\</span>
<span class="cp">	regs-&gt;sr[4] = spaceid;				\</span>
<span class="cp">	regs-&gt;sr[5] = spaceid;				\</span>
<span class="cp">	regs-&gt;sr[6] = spaceid;				\</span>
<span class="cp">	regs-&gt;sr[7] = spaceid;				\</span>
<span class="cp">	regs-&gt;gr[ 0] = USER_PSW | (USER_WIDE_MODE ? PSW_W : 0); \</span>
<span class="cp">	regs-&gt;fr[ 0] = 0LL;                            	\</span>
<span class="cp">	regs-&gt;fr[ 1] = 0LL;                            	\</span>
<span class="cp">	regs-&gt;fr[ 2] = 0LL;                            	\</span>
<span class="cp">	regs-&gt;fr[ 3] = 0LL;                            	\</span>
<span class="cp">	regs-&gt;gr[30] = (((unsigned long)sp + 63) &amp;~ 63) | (USER_WIDE_MODE ? 1 : 0); \</span>
<span class="cp">	regs-&gt;gr[31] = pc;				\</span>
<span class="cp">							\</span>
<span class="cp">	get_user(regs-&gt;gr[25], (argv - 1));		\</span>
<span class="cp">	regs-&gt;gr[24] = (long) argv;			\</span>
<span class="cp">	regs-&gt;gr[23] = 0;				\</span>
<span class="cp">} while(0)</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>

<span class="cm">/* Free all resources held by a thread. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">release_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">map_hpux_gateway_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_wchan</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cp">#define KSTK_EIP(tsk)	((tsk)-&gt;thread.regs.iaoq[0])</span>
<span class="cp">#define KSTK_ESP(tsk)	((tsk)-&gt;thread.regs.gr[30])</span>

<span class="cp">#define cpu_relax()	barrier()</span>

<span class="cm">/* Used as a macro to identify the combined VIPT/PIPT cached</span>
<span class="cm"> * CPUs which require a guarantee of coherency (no inequivalent</span>
<span class="cm"> * aliases with different data, whether clean or not) to operate */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">parisc_requires_coherency</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PA8X00</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">cpu_type</span> <span class="o">==</span> <span class="n">mako</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">cpu_type</span> <span class="o">==</span> <span class="n">mako2</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __ASM_PARISC_PROCESSOR_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
