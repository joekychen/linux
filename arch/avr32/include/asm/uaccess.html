<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › avr32 › include › asm › uaccess.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>uaccess.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2004-2006 Atmel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASM_AVR32_UACCESS_H</span>
<span class="cp">#define __ASM_AVR32_UACCESS_H</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#define VERIFY_READ	0</span>
<span class="cp">#define VERIFY_WRITE	1</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_user_space</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mm_segment_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The fs value determines whether argument validity checking should be</span>
<span class="cm"> * performed or not.  If get_fs() == USER_DS, checking is performed, with</span>
<span class="cm"> * get_fs() == KERNEL_DS, checking is bypassed.</span>
<span class="cm"> *</span>
<span class="cm"> * For historical reasons (Data Segment Register?), these macros are misnamed.</span>
<span class="cm"> */</span>
<span class="cp">#define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })</span>
<span class="cp">#define segment_eq(a,b)	((a).is_user_space == (b).is_user_space)</span>

<span class="cp">#define USER_ADDR_LIMIT 0x80000000</span>

<span class="cp">#define KERNEL_DS	MAKE_MM_SEG(0)</span>
<span class="cp">#define USER_DS		MAKE_MM_SEG(1)</span>

<span class="cp">#define get_ds()	(KERNEL_DS)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">mm_segment_t</span> <span class="nf">get_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">MAKE_MM_SEG</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_USERSPACE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_fs</span><span class="p">(</span><span class="n">mm_segment_t</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">is_user_space</span><span class="p">)</span>
		<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_USERSPACE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_USERSPACE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test whether a block of memory is a valid user space address.</span>
<span class="cm"> * Returns 0 if the range is valid, nonzero otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * We do the following checks:</span>
<span class="cm"> *   1. Is the access from kernel space?</span>
<span class="cm"> *   2. Does (addr + size) set the carry bit?</span>
<span class="cm"> *   3. Is (addr + size) a negative number (i.e. &gt;= 0x80000000)?</span>
<span class="cm"> *</span>
<span class="cm"> * If yes on the first check, access is granted.</span>
<span class="cm"> * If no on any of the others, access is denied.</span>
<span class="cm"> */</span>
<span class="cp">#define __range_ok(addr, size)						\</span>
<span class="cp">	(test_thread_flag(TIF_USERSPACE)				\</span>
<span class="cp">	 &amp;&amp; (((unsigned long)(addr) &gt;= 0x80000000)			\</span>
<span class="cp">	     || ((unsigned long)(size) &gt; 0x80000000)			\</span>
<span class="cp">	     || (((unsigned long)(addr) + (unsigned long)(size)) &gt; 0x80000000)))</span>

<span class="cp">#define access_ok(type, addr, size) (likely(__range_ok(addr, size) == 0))</span>

<span class="cm">/* Generic arbitrary sized copy. Return the number of bytes NOT copied */</span>
<span class="k">extern</span> <span class="n">__kernel_size_t</span> <span class="n">__copy_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
				   <span class="n">__kernel_size_t</span> <span class="n">n</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">__kernel_size_t</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
				    <span class="n">__kernel_size_t</span> <span class="n">n</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__kernel_size_t</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
				      <span class="n">__kernel_size_t</span> <span class="n">n</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__kernel_size_t</span> <span class="nf">__copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
					     <span class="n">__kernel_size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__kernel_size_t</span> <span class="nf">__copy_from_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
					       <span class="n">__kernel_size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define __copy_to_user_inatomic __copy_to_user</span>
<span class="cp">#define __copy_from_user_inatomic __copy_from_user</span>

<span class="cm">/*</span>
<span class="cm"> * put_user: - Write a simple value into user space.</span>
<span class="cm"> * @x:   Value to copy to user space.</span>
<span class="cm"> * @ptr: Destination address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple value from kernel space to user</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and @x must be assignable</span>
<span class="cm"> * to the result of dereferencing @ptr.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> */</span>
<span class="cp">#define put_user(x,ptr)	\</span>
<span class="cp">	__put_user_check((x),(ptr),sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * get_user: - Get a simple variable from user space.</span>
<span class="cm"> * @x:   Variable to store result.</span>
<span class="cm"> * @ptr: Source address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple variable from user space to kernel</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and the result of</span>
<span class="cm"> * dereferencing @ptr must be assignable to @x without a cast.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> * On error, the variable @x is set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define get_user(x,ptr) \</span>
<span class="cp">	__get_user_check((x),(ptr),sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * __put_user: - Write a simple value into user space, with less checking.</span>
<span class="cm"> * @x:   Value to copy to user space.</span>
<span class="cm"> * @ptr: Destination address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple value from kernel space to user</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and @x must be assignable</span>
<span class="cm"> * to the result of dereferencing @ptr.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must check the pointer with access_ok() before calling this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> */</span>
<span class="cp">#define __put_user(x,ptr) \</span>
<span class="cp">	__put_user_nocheck((x),(ptr),sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * __get_user: - Get a simple variable from user space, with less checking.</span>
<span class="cm"> * @x:   Variable to store result.</span>
<span class="cm"> * @ptr: Source address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple variable from user space to kernel</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and the result of</span>
<span class="cm"> * dereferencing @ptr must be assignable to @x without a cast.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must check the pointer with access_ok() before calling this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> * On error, the variable @x is set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define __get_user(x,ptr) \</span>
<span class="cp">	__get_user_nocheck((x),(ptr),sizeof(*(ptr)))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__get_user_bad</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__put_user_bad</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define __get_user_nocheck(x, ptr, size)				\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __gu_val = 0;					\</span>
<span class="cp">	int __gu_err = 0;						\</span>
<span class="cp">									\</span>
<span class="cp">	switch (size) {							\</span>
<span class="cp">	case 1: __get_user_asm(&quot;ub&quot;, __gu_val, ptr, __gu_err); break;	\</span>
<span class="cp">	case 2: __get_user_asm(&quot;uh&quot;, __gu_val, ptr, __gu_err); break;	\</span>
<span class="cp">	case 4: __get_user_asm(&quot;w&quot;, __gu_val, ptr, __gu_err); break;	\</span>
<span class="cp">	default: __gu_err = __get_user_bad(); break;			\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	x = (typeof(*(ptr)))__gu_val;					\</span>
<span class="cp">	__gu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_check(x, ptr, size)					\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __gu_val = 0;					\</span>
<span class="cp">	const typeof(*(ptr)) __user * __gu_addr = (ptr);		\</span>
<span class="cp">	int __gu_err = 0;						\</span>
<span class="cp">									\</span>
<span class="cp">	if (access_ok(VERIFY_READ, __gu_addr, size)) {			\</span>
<span class="cp">		switch (size) {						\</span>
<span class="cp">		case 1:							\</span>
<span class="cp">			__get_user_asm(&quot;ub&quot;, __gu_val, __gu_addr,	\</span>
<span class="cp">				       __gu_err);			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case 2:							\</span>
<span class="cp">			__get_user_asm(&quot;uh&quot;, __gu_val, __gu_addr,	\</span>
<span class="cp">				       __gu_err);			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case 4:							\</span>
<span class="cp">			__get_user_asm(&quot;w&quot;, __gu_val, __gu_addr,	\</span>
<span class="cp">				       __gu_err);			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		default:						\</span>
<span class="cp">			__gu_err = __get_user_bad();			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		}							\</span>
<span class="cp">	} else {							\</span>
<span class="cp">		__gu_err = -EFAULT;					\</span>
<span class="cp">	}								\</span>
<span class="cp">	x = (typeof(*(ptr)))__gu_val;					\</span>
<span class="cp">	__gu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_asm(suffix, __gu_val, ptr, __gu_err)			\</span>
<span class="cp">	asm volatile(							\</span>
<span class="cp">		&quot;1:	ld.&quot; suffix &quot;	%1, %3			\n&quot;	\</span>
<span class="cp">		&quot;2:						\n&quot;	\</span>
<span class="cp">		&quot;	.subsection 1				\n&quot;	\</span>
<span class="cp">		&quot;3:	mov	%0, %4				\n&quot;	\</span>
<span class="cp">		&quot;	rjmp	2b				\n&quot;	\</span>
<span class="cp">		&quot;	.subsection 0				\n&quot;	\</span>
<span class="cp">		&quot;	.section __ex_table, \&quot;a\&quot;		\n&quot;	\</span>
<span class="cp">		&quot;	.long	1b, 3b				\n&quot;	\</span>
<span class="cp">		&quot;	.previous				\n&quot;	\</span>
<span class="cp">		: &quot;=r&quot;(__gu_err), &quot;=r&quot;(__gu_val)			\</span>
<span class="cp">		: &quot;0&quot;(__gu_err), &quot;m&quot;(*(ptr)), &quot;i&quot;(-EFAULT))</span>

<span class="cp">#define __put_user_nocheck(x, ptr, size)				\</span>
<span class="cp">({									\</span>
<span class="cp">	typeof(*(ptr)) __pu_val;					\</span>
<span class="cp">	int __pu_err = 0;						\</span>
<span class="cp">									\</span>
<span class="cp">	__pu_val = (x);							\</span>
<span class="cp">	switch (size) {							\</span>
<span class="cp">	case 1: __put_user_asm(&quot;b&quot;, ptr, __pu_val, __pu_err); break;	\</span>
<span class="cp">	case 2: __put_user_asm(&quot;h&quot;, ptr, __pu_val, __pu_err); break;	\</span>
<span class="cp">	case 4: __put_user_asm(&quot;w&quot;, ptr, __pu_val, __pu_err); break;	\</span>
<span class="cp">	case 8: __put_user_asm(&quot;d&quot;, ptr, __pu_val, __pu_err); break;	\</span>
<span class="cp">	default: __pu_err = __put_user_bad(); break;			\</span>
<span class="cp">	}								\</span>
<span class="cp">	__pu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __put_user_check(x, ptr, size)					\</span>
<span class="cp">({									\</span>
<span class="cp">	typeof(*(ptr)) __pu_val;					\</span>
<span class="cp">	typeof(*(ptr)) __user *__pu_addr = (ptr);			\</span>
<span class="cp">	int __pu_err = 0;						\</span>
<span class="cp">									\</span>
<span class="cp">	__pu_val = (x);							\</span>
<span class="cp">	if (access_ok(VERIFY_WRITE, __pu_addr, size)) {			\</span>
<span class="cp">		switch (size) {						\</span>
<span class="cp">		case 1:							\</span>
<span class="cp">			__put_user_asm(&quot;b&quot;, __pu_addr, __pu_val,	\</span>
<span class="cp">				       __pu_err);			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case 2:							\</span>
<span class="cp">			__put_user_asm(&quot;h&quot;, __pu_addr, __pu_val,	\</span>
<span class="cp">				       __pu_err);			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case 4:							\</span>
<span class="cp">			__put_user_asm(&quot;w&quot;, __pu_addr, __pu_val,	\</span>
<span class="cp">				       __pu_err);			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case 8:							\</span>
<span class="cp">			__put_user_asm(&quot;d&quot;, __pu_addr, __pu_val,		\</span>
<span class="cp">				       __pu_err);			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		default:						\</span>
<span class="cp">			__pu_err = __put_user_bad();			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		}							\</span>
<span class="cp">	} else {							\</span>
<span class="cp">		__pu_err = -EFAULT;					\</span>
<span class="cp">	}								\</span>
<span class="cp">	__pu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __put_user_asm(suffix, ptr, __pu_val, __gu_err)			\</span>
<span class="cp">	asm volatile(							\</span>
<span class="cp">		&quot;1:	st.&quot; suffix &quot;	%1, %3			\n&quot;	\</span>
<span class="cp">		&quot;2:						\n&quot;	\</span>
<span class="cp">		&quot;	.subsection 1				\n&quot;	\</span>
<span class="cp">		&quot;3:	mov	%0, %4				\n&quot;	\</span>
<span class="cp">		&quot;	rjmp	2b				\n&quot;	\</span>
<span class="cp">		&quot;	.subsection 0				\n&quot;	\</span>
<span class="cp">		&quot;	.section __ex_table, \&quot;a\&quot;		\n&quot;	\</span>
<span class="cp">		&quot;	.long	1b, 3b				\n&quot;	\</span>
<span class="cp">		&quot;	.previous				\n&quot;	\</span>
<span class="cp">		: &quot;=r&quot;(__gu_err), &quot;=m&quot;(*(ptr))				\</span>
<span class="cp">		: &quot;0&quot;(__gu_err), &quot;r&quot;(__pu_val), &quot;i&quot;(-EFAULT))</span>

<span class="k">extern</span> <span class="n">__kernel_size_t</span> <span class="n">clear_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">__kernel_size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__kernel_size_t</span> <span class="n">__clear_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">__kernel_size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">strncpy_from_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">__strncpy_from_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">strnlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__s</span><span class="p">,</span> <span class="kt">long</span> <span class="n">__n</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">__strnlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__s</span><span class="p">,</span> <span class="kt">long</span> <span class="n">__n</span><span class="p">);</span>

<span class="cp">#define strlen_user(s) strnlen_user(s, ~0UL &gt;&gt; 1)</span>

<span class="k">struct</span> <span class="n">exception_table_entry</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insn</span><span class="p">,</span> <span class="n">fixup</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* __ASM_AVR32_UACCESS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
