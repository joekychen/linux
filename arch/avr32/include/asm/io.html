<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › avr32 › include › asm › io.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>io.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __ASM_AVR32_IO_H</span>
<span class="cp">#define __ASM_AVR32_IO_H</span>

<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;asm/addrspace.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &lt;mach/io.h&gt;</span>

<span class="cm">/* virt_to_phys will only work when address is in P1 or P2 */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">virt_to_phys</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">PHYSADDR</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">phys_to_virt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">P1SEGADDR</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cached_to_phys(addr)	((unsigned long)PHYSADDR(addr))</span>
<span class="cp">#define uncached_to_phys(addr)	((unsigned long)PHYSADDR(addr))</span>
<span class="cp">#define phys_to_cached(addr)	((void *)P1SEGADDR(addr))</span>
<span class="cp">#define phys_to_uncached(addr)	((void *)P2SEGADDR(addr))</span>

<span class="cm">/*</span>
<span class="cm"> * Generic IO read/write.  These perform native-endian accesses.  Note</span>
<span class="cm"> * that some architectures will want to re-define __raw_{read,write}w.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_writesb</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytelen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_writesw</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wordlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_writesl</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">longlen</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_readsb</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytelen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_readsw</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wordlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_readsl</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">longlen</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_writeb</span><span class="p">(</span><span class="n">u8</span> <span class="n">v</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u8</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_writew</span><span class="p">(</span><span class="n">u16</span> <span class="n">v</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u16</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_writel</span><span class="p">(</span><span class="n">u32</span> <span class="n">v</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">__raw_readb</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">u8</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">__raw_readw</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">u16</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">__raw_readl</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">u32</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert I/O port address to virtual address */</span>
<span class="cp">#ifndef __io</span>
<span class="cp"># define __io(p)	((void *)phys_to_uncached(p))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Not really sure about the best way to slow down I/O on</span>
<span class="cm"> * AVR32. Defining it as a no-op until we have an actual test case.</span>
<span class="cm"> */</span>
<span class="cp">#define SLOW_DOWN_IO	do { } while (0)</span>

<span class="cp">#define __BUILD_MEMORY_SINGLE(pfx, bwl, type)				\</span>
<span class="cp">static inline void							\</span>
<span class="cp">pfx##write##bwl(type val, volatile void __iomem *addr)			\</span>
<span class="cp">{									\</span>
<span class="cp">	volatile type *__addr;						\</span>
<span class="cp">	type __val;							\</span>
<span class="cp">									\</span>
<span class="cp">	__addr = (void *)__swizzle_addr_##bwl((unsigned long)(addr));	\</span>
<span class="cp">	__val = pfx##ioswab##bwl(__addr, val);				\</span>
<span class="cp">									\</span>
<span class="cp">	BUILD_BUG_ON(sizeof(type) &gt; sizeof(unsigned long));		\</span>
<span class="cp">									\</span>
<span class="cp">	*__addr = __val;						\</span>
<span class="cp">}									\</span>
<span class="cp">									\</span>
<span class="cp">static inline type pfx##read##bwl(const volatile void __iomem *addr)	\</span>
<span class="cp">{									\</span>
<span class="cp">	volatile type *__addr;						\</span>
<span class="cp">	type __val;							\</span>
<span class="cp">									\</span>
<span class="cp">	__addr = (void *)__swizzle_addr_##bwl((unsigned long)(addr));	\</span>
<span class="cp">									\</span>
<span class="cp">	BUILD_BUG_ON(sizeof(type) &gt; sizeof(unsigned long));		\</span>
<span class="cp">									\</span>
<span class="cp">	__val = *__addr;						\</span>
<span class="cp">	return pfx##ioswab##bwl(__addr, __val);				\</span>
<span class="cp">}</span>

<span class="cp">#define __BUILD_IOPORT_SINGLE(pfx, bwl, type, p, slow)			\</span>
<span class="cp">static inline void pfx##out##bwl##p(type val, unsigned long port)	\</span>
<span class="cp">{									\</span>
<span class="cp">	volatile type *__addr;						\</span>
<span class="cp">	type __val;							\</span>
<span class="cp">									\</span>
<span class="cp">	__addr = __io(__swizzle_addr_##bwl(port));			\</span>
<span class="cp">	__val = pfx##ioswab##bwl(__addr, val);				\</span>
<span class="cp">									\</span>
<span class="cp">	BUILD_BUG_ON(sizeof(type) &gt; sizeof(unsigned long));		\</span>
<span class="cp">									\</span>
<span class="cp">	*__addr = __val;						\</span>
<span class="cp">	slow;								\</span>
<span class="cp">}									\</span>
<span class="cp">									\</span>
<span class="cp">static inline type pfx##in##bwl##p(unsigned long port)			\</span>
<span class="cp">{									\</span>
<span class="cp">	volatile type *__addr;						\</span>
<span class="cp">	type __val;							\</span>
<span class="cp">									\</span>
<span class="cp">	__addr = __io(__swizzle_addr_##bwl(port));			\</span>
<span class="cp">									\</span>
<span class="cp">	BUILD_BUG_ON(sizeof(type) &gt; sizeof(unsigned long));		\</span>
<span class="cp">									\</span>
<span class="cp">	__val = *__addr;						\</span>
<span class="cp">	slow;								\</span>
<span class="cp">									\</span>
<span class="cp">	return pfx##ioswab##bwl(__addr, __val);				\</span>
<span class="cp">}</span>

<span class="cp">#define __BUILD_MEMORY_PFX(bus, bwl, type)				\</span>
<span class="cp">	__BUILD_MEMORY_SINGLE(bus, bwl, type)</span>

<span class="cp">#define BUILDIO_MEM(bwl, type)						\</span>
<span class="cp">	__BUILD_MEMORY_PFX(, bwl, type)					\</span>
<span class="cp">	__BUILD_MEMORY_PFX(__mem_, bwl, type)</span>

<span class="cp">#define __BUILD_IOPORT_PFX(bus, bwl, type)				\</span>
<span class="cp">	__BUILD_IOPORT_SINGLE(bus, bwl, type, ,)			\</span>
<span class="cp">	__BUILD_IOPORT_SINGLE(bus, bwl, type, _p, SLOW_DOWN_IO)</span>

<span class="cp">#define BUILDIO_IOPORT(bwl, type)					\</span>
<span class="cp">	__BUILD_IOPORT_PFX(, bwl, type)					\</span>
<span class="cp">	__BUILD_IOPORT_PFX(__mem_, bwl, type)</span>

<span class="n">BUILDIO_MEM</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">u8</span><span class="p">)</span>
<span class="n">BUILDIO_MEM</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">u16</span><span class="p">)</span>
<span class="n">BUILDIO_MEM</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">u32</span><span class="p">)</span>

<span class="n">BUILDIO_IOPORT</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">u8</span><span class="p">)</span>
<span class="n">BUILDIO_IOPORT</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">u16</span><span class="p">)</span>
<span class="n">BUILDIO_IOPORT</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">u32</span><span class="p">)</span>

<span class="cp">#define readb_relaxed			readb</span>
<span class="cp">#define readw_relaxed			readw</span>
<span class="cp">#define readl_relaxed			readl</span>

<span class="cp">#define readb_be			__raw_readb</span>
<span class="cp">#define readw_be			__raw_readw</span>
<span class="cp">#define readl_be			__raw_readl</span>

<span class="cp">#define writeb_be			__raw_writeb</span>
<span class="cp">#define writew_be			__raw_writew</span>
<span class="cp">#define writel_be			__raw_writel</span>

<span class="cp">#define __BUILD_MEMORY_STRING(bwl, type)				\</span>
<span class="cp">static inline void writes##bwl(volatile void __iomem *addr,		\</span>
<span class="cp">			       const void *data, unsigned int count)	\</span>
<span class="cp">{									\</span>
<span class="cp">	const type *__data = data;					\</span>
<span class="cp">									\</span>
<span class="cp">	while (count--)							\</span>
<span class="cp">		__mem_write##bwl(*__data++, addr);			\</span>
<span class="cp">}									\</span>
<span class="cp">									\</span>
<span class="cp">static inline void reads##bwl(const volatile void __iomem *addr,	\</span>
<span class="cp">			      void *data, unsigned int count)		\</span>
<span class="cp">{									\</span>
<span class="cp">	type *__data = data;						\</span>
<span class="cp">									\</span>
<span class="cp">	while (count--)							\</span>
<span class="cp">		*__data++ = __mem_read##bwl(addr);			\</span>
<span class="cp">}</span>

<span class="cp">#define __BUILD_IOPORT_STRING(bwl, type)				\</span>
<span class="cp">static inline void outs##bwl(unsigned long port, const void *data,	\</span>
<span class="cp">			     unsigned int count)			\</span>
<span class="cp">{									\</span>
<span class="cp">	const type *__data = data;					\</span>
<span class="cp">									\</span>
<span class="cp">	while (count--)							\</span>
<span class="cp">		__mem_out##bwl(*__data++, port);			\</span>
<span class="cp">}									\</span>
<span class="cp">									\</span>
<span class="cp">static inline void ins##bwl(unsigned long port, void *data,		\</span>
<span class="cp">			   unsigned int count)				\</span>
<span class="cp">{									\</span>
<span class="cp">	type *__data = data;						\</span>
<span class="cp">									\</span>
<span class="cp">	while (count--)							\</span>
<span class="cp">		*__data++ = __mem_in##bwl(port);			\</span>
<span class="cp">}</span>

<span class="cp">#define BUILDSTRING(bwl, type)						\</span>
<span class="cp">	__BUILD_MEMORY_STRING(bwl, type)				\</span>
<span class="cp">	__BUILD_IOPORT_STRING(bwl, type)</span>

<span class="n">BUILDSTRING</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">u8</span><span class="p">)</span>
<span class="n">BUILDSTRING</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">u16</span><span class="p">)</span>
<span class="n">BUILDSTRING</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">u32</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * io{read,write}{8,16,32} macros in both le (for PCI style consumers) and native be</span>
<span class="cm"> */</span>
<span class="cp">#ifndef ioread8</span>

<span class="cp">#define ioread8(p)		((unsigned int)readb(p))</span>

<span class="cp">#define ioread16(p)		((unsigned int)readw(p))</span>
<span class="cp">#define ioread16be(p)		((unsigned int)__raw_readw(p))</span>

<span class="cp">#define ioread32(p)		((unsigned int)readl(p))</span>
<span class="cp">#define ioread32be(p)		((unsigned int)__raw_readl(p))</span>

<span class="cp">#define iowrite8(v,p)		writeb(v, p)</span>

<span class="cp">#define iowrite16(v,p)		writew(v, p)</span>
<span class="cp">#define iowrite16be(v,p)	__raw_writew(v, p)</span>

<span class="cp">#define iowrite32(v,p)		writel(v, p)</span>
<span class="cp">#define iowrite32be(v,p)	__raw_writel(v, p)</span>

<span class="cp">#define ioread8_rep(p,d,c)	readsb(p,d,c)</span>
<span class="cp">#define ioread16_rep(p,d,c)	readsw(p,d,c)</span>
<span class="cp">#define ioread32_rep(p,d,c)	readsl(p,d,c)</span>

<span class="cp">#define iowrite8_rep(p,s,c)	writesb(p,s,c)</span>
<span class="cp">#define iowrite16_rep(p,s,c)	writesw(p,s,c)</span>
<span class="cp">#define iowrite32_rep(p,s,c)	writesl(p,s,c)</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">memcpy_fromio</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>  <span class="n">memcpy_toio</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">from</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">memset_io</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define mmiowb()</span>

<span class="cp">#define IO_SPACE_LIMIT	0xffffffff</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">__ioremap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iounmap</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ioremap	-   map bus memory into CPU space</span>
<span class="cm"> * @offset	bus address of the memory</span>
<span class="cm"> * @size	size of the resource to map</span>
<span class="cm"> *</span>
<span class="cm"> * ioremap performs a platform specific sequence of operations to make</span>
<span class="cm"> * bus memory CPU accessible via the readb/.../writel functions and</span>
<span class="cm"> * the other mmio helpers. The returned address is not guaranteed to</span>
<span class="cm"> * be usable directly as a virtual address.</span>
<span class="cm"> */</span>
<span class="cp">#define ioremap(offset, size)			\</span>
<span class="cp">	__ioremap((offset), (size), 0)</span>

<span class="cp">#define ioremap_nocache(offset, size)		\</span>
<span class="cp">	__ioremap((offset), (size), 0)</span>

<span class="cp">#define iounmap(addr)				\</span>
<span class="cp">	__iounmap(addr)</span>

<span class="cp">#define cached(addr) P1SEGADDR(addr)</span>
<span class="cp">#define uncached(addr) P2SEGADDR(addr)</span>

<span class="cp">#define virt_to_bus virt_to_phys</span>
<span class="cp">#define bus_to_virt phys_to_virt</span>
<span class="cp">#define page_to_bus page_to_phys</span>
<span class="cp">#define bus_to_page phys_to_page</span>

<span class="cm">/*</span>
<span class="cm"> * Create a virtual mapping cookie for an IO port range.  There exists</span>
<span class="cm"> * no such thing as port-based I/O on AVR32, so a regular ioremap()</span>
<span class="cm"> * should do what we need.</span>
<span class="cm"> */</span>
<span class="cp">#define ioport_map(port, nr)	ioremap(port, nr)</span>
<span class="cp">#define ioport_unmap(port)	iounmap(port)</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a physical pointer to a virtual kernel pointer for /dev/mem</span>
<span class="cm"> * access</span>
<span class="cm"> */</span>
<span class="cp">#define xlate_dev_mem_ptr(p)    __va(p)</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a virtual cached pointer to an uncached pointer</span>
<span class="cm"> */</span>
<span class="cp">#define xlate_dev_kmem_ptr(p)   p</span>

<span class="cp">#endif </span><span class="cm">/* __ASM_AVR32_IO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
