<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › avr32 › include › asm › pgtable.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2004-2006 Atmel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASM_AVR32_PGTABLE_H</span>
<span class="cp">#define __ASM_AVR32_PGTABLE_H</span>

<span class="cp">#include &lt;asm/addrspace.h&gt;</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Use two-level page tables just as the i386 (without PAE)</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;asm/pgtable-2level.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The following code might need some cleanup when the values are</span>
<span class="cm"> * final...</span>
<span class="cm"> */</span>
<span class="cp">#define PMD_SIZE	(1UL &lt;&lt; PMD_SHIFT)</span>
<span class="cp">#define PMD_MASK	(~(PMD_SIZE-1))</span>
<span class="cp">#define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)</span>
<span class="cp">#define PGDIR_MASK	(~(PGDIR_SIZE-1))</span>

<span class="cp">#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)</span>
<span class="cp">#define FIRST_USER_ADDRESS	0</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="n">pgd_t</span> <span class="n">swapper_pg_dir</span><span class="p">[</span><span class="n">PTRS_PER_PGD</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ZERO_PAGE is a global shared page that is always zero: used for</span>
<span class="cm"> * zero-mapped memory areas etc.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">empty_zero_page</span><span class="p">;</span>
<span class="cp">#define ZERO_PAGE(vaddr) (empty_zero_page)</span>

<span class="cm">/*</span>
<span class="cm"> * Just any arbitrary offset to the start of the vmalloc VM area: the</span>
<span class="cm"> * current 8 MiB value just means that there will be a 8 MiB &quot;hole&quot;</span>
<span class="cm"> * after the uncached physical memory (P2 segment) until the vmalloc</span>
<span class="cm"> * area starts. That means that any out-of-bounds memory accesses will</span>
<span class="cm"> * hopefully be caught; we don&#39;t know if the end of the P1/P2 segments</span>
<span class="cm"> * are actually used for anything, but it is anyway safer to let the</span>
<span class="cm"> * MMU catch these kinds of errors than to rely on the memory bus.</span>
<span class="cm"> *</span>
<span class="cm"> * A &quot;hole&quot; of the same size is added to the end of the P3 segment as</span>
<span class="cm"> * well. It might seem wasteful to use 16 MiB of virtual address space</span>
<span class="cm"> * on this, but we do have 512 MiB of it...</span>
<span class="cm"> *</span>
<span class="cm"> * The vmalloc() routines leave a hole of 4 KiB between each vmalloced</span>
<span class="cm"> * area for the same reason.</span>
<span class="cm"> */</span>
<span class="cp">#define VMALLOC_OFFSET	(8 * 1024 * 1024)</span>
<span class="cp">#define VMALLOC_START	(P3SEG + VMALLOC_OFFSET)</span>
<span class="cp">#define VMALLOC_END	(P4SEG - VMALLOC_OFFSET)</span>
<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Page flags. Some of these flags are not directly supported by</span>
<span class="cm"> * hardware, so we have to emulate them.</span>
<span class="cm"> */</span>
<span class="cp">#define _TLBEHI_BIT_VALID	9</span>
<span class="cp">#define _TLBEHI_VALID		(1 &lt;&lt; _TLBEHI_BIT_VALID)</span>

<span class="cp">#define _PAGE_BIT_WT		0  </span><span class="cm">/* W-bit   : write-through */</span><span class="cp"></span>
<span class="cp">#define _PAGE_BIT_DIRTY		1  </span><span class="cm">/* D-bit   : page changed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_BIT_SZ0		2  </span><span class="cm">/* SZ0-bit : Size of page */</span><span class="cp"></span>
<span class="cp">#define _PAGE_BIT_SZ1		3  </span><span class="cm">/* SZ1-bit : Size of page */</span><span class="cp"></span>
<span class="cp">#define _PAGE_BIT_EXECUTE	4  </span><span class="cm">/* X-bit   : execute access allowed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_BIT_RW		5  </span><span class="cm">/* AP0-bit : write access allowed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_BIT_USER		6  </span><span class="cm">/* AP1-bit : user space access allowed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_BIT_BUFFER	7  </span><span class="cm">/* B-bit   : bufferable */</span><span class="cp"></span>
<span class="cp">#define _PAGE_BIT_GLOBAL	8  </span><span class="cm">/* G-bit   : global (ignore ASID) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_BIT_CACHABLE	9  </span><span class="cm">/* C-bit   : cachable */</span><span class="cp"></span>

<span class="cm">/* If we drop support for 1K pages, we get two extra bits */</span>
<span class="cp">#define _PAGE_BIT_PRESENT	10</span>
<span class="cp">#define _PAGE_BIT_ACCESSED	11 </span><span class="cm">/* software: page was accessed */</span><span class="cp"></span>

<span class="cm">/* The following flags are only valid when !PRESENT */</span>
<span class="cp">#define _PAGE_BIT_FILE		0 </span><span class="cm">/* software: pagecache or swap? */</span><span class="cp"></span>

<span class="cp">#define _PAGE_WT		(1 &lt;&lt; _PAGE_BIT_WT)</span>
<span class="cp">#define _PAGE_DIRTY		(1 &lt;&lt; _PAGE_BIT_DIRTY)</span>
<span class="cp">#define _PAGE_EXECUTE		(1 &lt;&lt; _PAGE_BIT_EXECUTE)</span>
<span class="cp">#define _PAGE_RW		(1 &lt;&lt; _PAGE_BIT_RW)</span>
<span class="cp">#define _PAGE_USER		(1 &lt;&lt; _PAGE_BIT_USER)</span>
<span class="cp">#define _PAGE_BUFFER		(1 &lt;&lt; _PAGE_BIT_BUFFER)</span>
<span class="cp">#define _PAGE_GLOBAL		(1 &lt;&lt; _PAGE_BIT_GLOBAL)</span>
<span class="cp">#define _PAGE_CACHABLE		(1 &lt;&lt; _PAGE_BIT_CACHABLE)</span>

<span class="cm">/* Software flags */</span>
<span class="cp">#define _PAGE_ACCESSED		(1 &lt;&lt; _PAGE_BIT_ACCESSED)</span>
<span class="cp">#define _PAGE_PRESENT		(1 &lt;&lt; _PAGE_BIT_PRESENT)</span>
<span class="cp">#define _PAGE_FILE		(1 &lt;&lt; _PAGE_BIT_FILE)</span>

<span class="cm">/*</span>
<span class="cm"> * Page types, i.e. sizes. _PAGE_TYPE_NONE corresponds to what is</span>
<span class="cm"> * usually called _PAGE_PROTNONE on other architectures.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX: Find out if _PAGE_PROTNONE is equivalent with !_PAGE_USER. If</span>
<span class="cm"> * so, we can encode all possible page sizes (although we can&#39;t really</span>
<span class="cm"> * support 1K pages anyway due to the _PAGE_PRESENT and _PAGE_ACCESSED</span>
<span class="cm"> * bits)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_TYPE_MASK		((1 &lt;&lt; _PAGE_BIT_SZ0) | (1 &lt;&lt; _PAGE_BIT_SZ1))</span>
<span class="cp">#define _PAGE_TYPE_NONE		(0 &lt;&lt; _PAGE_BIT_SZ0)</span>
<span class="cp">#define _PAGE_TYPE_SMALL	(1 &lt;&lt; _PAGE_BIT_SZ0)</span>
<span class="cp">#define _PAGE_TYPE_MEDIUM	(2 &lt;&lt; _PAGE_BIT_SZ0)</span>
<span class="cp">#define _PAGE_TYPE_LARGE	(3 &lt;&lt; _PAGE_BIT_SZ0)</span>

<span class="cm">/*</span>
<span class="cm"> * Mask which drop software flags. We currently can&#39;t handle more than</span>
<span class="cm"> * 512 MiB of physical memory, so we can use bits 29-31 for other</span>
<span class="cm"> * stuff.  With a fixed 4K page size, we can use bits 10-11 as well as</span>
<span class="cm"> * bits 2-3 (SZ)</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_FLAGS_HARDWARE_MASK	0xfffff3ff</span>

<span class="cp">#define _PAGE_FLAGS_CACHE_MASK	(_PAGE_CACHABLE | _PAGE_BUFFER | _PAGE_WT)</span>

<span class="cm">/* Flags that may be modified by software */</span>
<span class="cp">#define _PAGE_CHG_MASK		(PTE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY \</span>
<span class="cp">				 | _PAGE_FLAGS_CACHE_MASK)</span>

<span class="cp">#define _PAGE_FLAGS_READ	(_PAGE_CACHABLE	| _PAGE_BUFFER)</span>
<span class="cp">#define _PAGE_FLAGS_WRITE	(_PAGE_FLAGS_READ | _PAGE_RW | _PAGE_DIRTY)</span>

<span class="cp">#define _PAGE_NORMAL(x)	__pgprot((x) | _PAGE_PRESENT | _PAGE_TYPE_SMALL	\</span>
<span class="cp">				 | _PAGE_ACCESSED)</span>

<span class="cp">#define PAGE_NONE	(_PAGE_ACCESSED | _PAGE_TYPE_NONE)</span>
<span class="cp">#define PAGE_READ	(_PAGE_FLAGS_READ | _PAGE_USER)</span>
<span class="cp">#define PAGE_EXEC	(_PAGE_FLAGS_READ | _PAGE_EXECUTE | _PAGE_USER)</span>
<span class="cp">#define PAGE_WRITE	(_PAGE_FLAGS_WRITE | _PAGE_USER)</span>
<span class="cp">#define PAGE_KERNEL	_PAGE_NORMAL(_PAGE_FLAGS_WRITE | _PAGE_EXECUTE | _PAGE_GLOBAL)</span>
<span class="cp">#define PAGE_KERNEL_RO	_PAGE_NORMAL(_PAGE_FLAGS_READ | _PAGE_EXECUTE | _PAGE_GLOBAL)</span>

<span class="cp">#define _PAGE_P(x)	_PAGE_NORMAL((x) &amp; ~(_PAGE_RW | _PAGE_DIRTY))</span>
<span class="cp">#define _PAGE_S(x)	_PAGE_NORMAL(x)</span>

<span class="cp">#define PAGE_COPY	_PAGE_P(PAGE_WRITE | PAGE_READ)</span>
<span class="cp">#define PAGE_SHARED	_PAGE_S(PAGE_WRITE | PAGE_READ)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cm">/*</span>
<span class="cm"> * The hardware supports flags for write- and execute access. Read is</span>
<span class="cm"> * always allowed if the page is loaded into the TLB, so the &quot;-w-&quot;,</span>
<span class="cm"> * &quot;--x&quot; and &quot;-wx&quot; mappings are implemented as &quot;rw-&quot;, &quot;r-x&quot; and &quot;rwx&quot;,</span>
<span class="cm"> * respectively.</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;---&quot; case is handled by software; the page will simply not be</span>
<span class="cm"> * loaded into the TLB if the page type is _PAGE_TYPE_NONE.</span>
<span class="cm"> */</span>

<span class="cp">#define __P000	__pgprot(PAGE_NONE)</span>
<span class="cp">#define __P001	_PAGE_P(PAGE_READ)</span>
<span class="cp">#define __P010	_PAGE_P(PAGE_WRITE)</span>
<span class="cp">#define __P011	_PAGE_P(PAGE_WRITE | PAGE_READ)</span>
<span class="cp">#define __P100	_PAGE_P(PAGE_EXEC)</span>
<span class="cp">#define __P101	_PAGE_P(PAGE_EXEC | PAGE_READ)</span>
<span class="cp">#define __P110	_PAGE_P(PAGE_EXEC | PAGE_WRITE)</span>
<span class="cp">#define __P111	_PAGE_P(PAGE_EXEC | PAGE_WRITE | PAGE_READ)</span>

<span class="cp">#define __S000	__pgprot(PAGE_NONE)</span>
<span class="cp">#define __S001	_PAGE_S(PAGE_READ)</span>
<span class="cp">#define __S010	_PAGE_S(PAGE_WRITE)</span>
<span class="cp">#define __S011	_PAGE_S(PAGE_WRITE | PAGE_READ)</span>
<span class="cp">#define __S100	_PAGE_S(PAGE_EXEC)</span>
<span class="cp">#define __S101	_PAGE_S(PAGE_EXEC | PAGE_READ)</span>
<span class="cp">#define __S110	_PAGE_S(PAGE_EXEC | PAGE_WRITE)</span>
<span class="cp">#define __S111	_PAGE_S(PAGE_EXEC | PAGE_WRITE | PAGE_READ)</span>

<span class="cp">#define pte_none(x)	(!pte_val(x))</span>
<span class="cp">#define pte_present(x)	(pte_val(x) &amp; _PAGE_PRESENT)</span>

<span class="cp">#define pte_clear(mm,addr,xp)					\</span>
<span class="cp">	do {							\</span>
<span class="cp">		set_pte_at(mm, addr, xp, __pte(0));		\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * The following only work if pte_present() is true.</span>
<span class="cm"> * Undefined behaviour if not..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_write</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_RW</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_dirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_DIRTY</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_young</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_special</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following only work if pte_present() is not true.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_file</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_FILE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Mutator functions for PTE bits */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_wrprotect</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_RW</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkclean</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_DIRTY</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkold</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_ACCESSED</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkwrite</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_RW</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkdirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_DIRTY</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkyoung</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_ACCESSED</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkspecial</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define pmd_none(x)	(!pmd_val(x))</span>
<span class="cp">#define pmd_present(x)	(pmd_val(x))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmd_clear</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pmd</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define	pmd_bad(x)	(pmd_val(x) &amp; ~PAGE_MASK)</span>

<span class="cm">/*</span>
<span class="cm"> * Permanent address of a page. We don&#39;t support highmem, so this is</span>
<span class="cm"> * trivial.</span>
<span class="cm"> */</span>
<span class="cp">#define pages_to_mb(x)	((x) &gt;&gt; (20-PAGE_SHIFT))</span>
<span class="cp">#define pte_page(x)	(pfn_to_page(pte_pfn(x)))</span>

<span class="cm">/*</span>
<span class="cm"> * Mark the prot value as uncacheable and unbufferable</span>
<span class="cm"> */</span>
<span class="cp">#define pgprot_noncached(prot)						\</span>
<span class="cp">	__pgprot(pgprot_val(prot) &amp; ~(_PAGE_BUFFER | _PAGE_CACHABLE))</span>

<span class="cm">/*</span>
<span class="cm"> * Mark the prot value as uncacheable but bufferable</span>
<span class="cm"> */</span>
<span class="cp">#define pgprot_writecombine(prot)					\</span>
<span class="cp">	__pgprot((pgprot_val(prot) &amp; ~_PAGE_CACHABLE) | _PAGE_BUFFER)</span>

<span class="cm">/*</span>
<span class="cm"> * Conversion functions: convert a page and protection to a page entry,</span>
<span class="cm"> * and a page entry and page directory to the page they refer to.</span>
<span class="cm"> *</span>
<span class="cm"> * extern pte_t mk_pte(struct page *page, pgprot_t pgprot)</span>
<span class="cm"> */</span>
<span class="cp">#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_CHG_MASK</span><span class="p">)</span>
			    <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">newprot</span><span class="p">)));</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define page_pte(page)	page_pte_prot(page, __pgprot(0))</span>

<span class="cp">#define pmd_page_vaddr(pmd)	pmd_val(pmd)</span>
<span class="cp">#define pmd_page(pmd)		(virt_to_page(pmd_val(pmd)))</span>

<span class="cm">/* to find an entry in a page-table-directory. */</span>
<span class="cp">#define pgd_index(address)	(((address) &gt;&gt; PGDIR_SHIFT)	\</span>
<span class="cp">				 &amp; (PTRS_PER_PGD - 1))</span>
<span class="cp">#define pgd_offset(mm, address)	((mm)-&gt;pgd + pgd_index(address))</span>

<span class="cm">/* to find an entry in a kernel page-table-directory */</span>
<span class="cp">#define pgd_offset_k(address)	pgd_offset(&amp;init_mm, address)</span>

<span class="cm">/* Find an entry in the third-level page table.. */</span>
<span class="cp">#define pte_index(address)				\</span>
<span class="cp">	((address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))</span>
<span class="cp">#define pte_offset(dir, address)					\</span>
<span class="cp">	((pte_t *) pmd_page_vaddr(*(dir)) + pte_index(address))</span>
<span class="cp">#define pte_offset_kernel(dir, address)					\</span>
<span class="cp">	((pte_t *) pmd_page_vaddr(*(dir)) + pte_index(address))</span>
<span class="cp">#define pte_offset_map(dir, address) pte_offset_kernel(dir, address)</span>
<span class="cp">#define pte_unmap(pte)		do { } while (0)</span>

<span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">update_mmu_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Encode and decode a swap entry</span>
<span class="cm"> *</span>
<span class="cm"> * Constraints:</span>
<span class="cm"> *   _PAGE_FILE at bit 0</span>
<span class="cm"> *   _PAGE_TYPE_* at bits 2-3 (for emulating _PAGE_PROTNONE)</span>
<span class="cm"> *   _PAGE_PRESENT at bit 10</span>
<span class="cm"> *</span>
<span class="cm"> * We encode the type into bits 4-9 and offset into bits 11-31. This</span>
<span class="cm"> * gives us a 21 bits offset, or 2**21 * 4K = 8G usable swap space per</span>
<span class="cm"> * device, and 64 possible types.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: We should set ZEROs at the position of _PAGE_PRESENT</span>
<span class="cm"> *       and _PAGE_PROTNONE bits</span>
<span class="cm"> */</span>
<span class="cp">#define __swp_type(x)		(((x).val &gt;&gt; 4) &amp; 0x3f)</span>
<span class="cp">#define __swp_offset(x)		((x).val &gt;&gt; 11)</span>
<span class="cp">#define __swp_entry(type, offset) ((swp_entry_t) { ((type) &lt;&lt; 4) | ((offset) &lt;&lt; 11) })</span>
<span class="cp">#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })</span>
<span class="cp">#define __swp_entry_to_pte(x)	((pte_t) { (x).val })</span>

<span class="cm">/*</span>
<span class="cm"> * Encode and decode a nonlinear file mapping entry. We have to</span>
<span class="cm"> * preserve _PAGE_FILE and _PAGE_PRESENT here. _PAGE_TYPE_* isn&#39;t</span>
<span class="cm"> * necessary, since _PAGE_FILE implies !_PAGE_PROTNONE (?)</span>
<span class="cm"> */</span>
<span class="cp">#define PTE_FILE_MAX_BITS	30</span>
<span class="cp">#define pte_to_pgoff(pte)	(((pte_val(pte) &gt;&gt; 1) &amp; 0x1ff)		\</span>
<span class="cp">				 | ((pte_val(pte) &gt;&gt; 11) &lt;&lt; 9))</span>
<span class="cp">#define pgoff_to_pte(off)	((pte_t) { ((((off) &amp; 0x1ff) &lt;&lt; 1)	\</span>
<span class="cp">					    | (((off) &gt;&gt; 9) &lt;&lt; 11)	\</span>
<span class="cp">					    | _PAGE_FILE) })</span>

<span class="k">typedef</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte_addr_t</span><span class="p">;</span>

<span class="cp">#define kern_addr_valid(addr)	(1)</span>

<span class="cp">#define io_remap_pfn_range(vma, vaddr, pfn, size, prot)	\</span>
<span class="cp">	remap_pfn_range(vma, vaddr, pfn, size, prot)</span>

<span class="cm">/* No page table caches to initialize (?) */</span>
<span class="cp">#define pgtable_cache_init()	do { } while(0)</span>

<span class="cp">#include &lt;asm-generic/pgtable.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __ASM_AVR32_PGTABLE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
