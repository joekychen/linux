<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › avr32 › kernel › kprobes.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>kprobes.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Kernel Probes (KProbes)</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Atmel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Based on arch/ppc64/kernel/kprobes.c</span>
<span class="cm"> *  Copyright (C) IBM Corporation, 2002, 2004</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>

<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;asm/ocd.h&gt;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="p">,</span> <span class="n">current_kprobe</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kprobe_status</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">jprobe_saved_regs</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">kretprobe_blackpoint</span> <span class="n">kretprobe_blacklist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}};</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">arch_prepare_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Attempt to register kprobe at an unaligned address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* XXX: Might be a good idea to check if p-&gt;addr is a valid</span>
<span class="cm">	 * kernel address as well... */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;copy kprobe at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">MAX_INSN_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">arch_arm_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;arming kprobe at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">ocd_enable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">BREAKPOINT_INSTRUCTION</span><span class="p">;</span>
	<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">arch_disarm_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;disarming kprobe at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">ocd_disable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">;</span>
	<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">prepare_singlestep</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dc</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;preparing to singlestep over %p (PC=%08lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sysreg_read</span><span class="p">(</span><span class="n">SR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SYSREG_BIT</span><span class="p">(</span><span class="n">SR_D</span><span class="p">)));</span>

	<span class="n">dc</span> <span class="o">=</span> <span class="n">ocd_read</span><span class="p">(</span><span class="n">DC</span><span class="p">);</span>
	<span class="n">dc</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">OCD_DC_SS_BIT</span><span class="p">;</span>
	<span class="n">ocd_write</span><span class="p">(</span><span class="n">DC</span><span class="p">,</span> <span class="n">dc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must run the instruction from its original location</span>
<span class="cm">	 * since it may actually reference PC.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: Do the instruction replacement directly in icache.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">;</span>
	<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">resume_execution</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dc</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;resuming execution at PC=%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">);</span>

	<span class="n">dc</span> <span class="o">=</span> <span class="n">ocd_read</span><span class="p">(</span><span class="n">DC</span><span class="p">);</span>
	<span class="n">dc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">OCD_DC_SS_BIT</span><span class="p">);</span>
	<span class="n">ocd_write</span><span class="p">(</span><span class="n">DC</span><span class="p">,</span> <span class="n">dc</span><span class="p">);</span>

	<span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">BREAKPOINT_INSTRUCTION</span><span class="p">;</span>
	<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">set_current_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">current_kprobe</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">kprobe_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kprobe_handler: kprobe_running=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">kprobe_running</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to be preempted for the entire</span>
<span class="cm">	 * duration of kprobe processing</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="cm">/* Check that we&#39;re not recursing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_running</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">get_kprobe</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_status</span> <span class="o">==</span> <span class="n">KPROBE_HIT_SS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;FIXME: kprobe hit while single-stepping!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">no_kprobe</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;FIXME: kprobe hit while handling another kprobe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_kprobe</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">kprobe_running</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">ss_probe</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* If it&#39;s not ours, can&#39;t be delete race, (we hold lock). */</span>
		<span class="k">goto</span> <span class="n">no_kprobe</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">get_kprobe</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_kprobe</span><span class="p">;</span>

	<span class="n">kprobe_status</span> <span class="o">=</span> <span class="n">KPROBE_HIT_ACTIVE</span><span class="p">;</span>
	<span class="n">set_current_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pre_handler</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pre_handler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
		<span class="cm">/* handler has already set things up, so skip ss setup */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">ss_probe:</span>
	<span class="n">prepare_singlestep</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">kprobe_status</span> <span class="o">=</span> <span class="n">KPROBE_HIT_SS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">no_kprobe:</span>
	<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">post_kprobe_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">kprobe_running</span><span class="p">();</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;post_kprobe_handler, cur=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kprobe_status</span> <span class="o">=</span> <span class="n">KPROBE_HIT_SSDONE</span><span class="p">;</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">resume_execution</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">reset_current_kprobe</span><span class="p">();</span>
	<span class="n">preempt_enable_no_resched</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">kprobe_fault_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trapnr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">kprobe_running</span><span class="p">();</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kprobe_fault_handler: trapnr=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">trapnr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">fault_handler</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">fault_handler</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">trapnr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_status</span> <span class="o">&amp;</span> <span class="n">KPROBE_HIT_SS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resume_execution</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper routine to for handling exceptions.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">kprobe_exceptions_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">die_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">die_args</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kprobe_exceptions_notify: val=%lu, data=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">val</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DIE_BREAKPOINT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_handler</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_STOP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DIE_SSTEP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">post_kprobe_handler</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_STOP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">setjmp_pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jprobe</span> <span class="o">*</span><span class="n">jp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jprobe_saved_regs</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: We should probably save some of the stack here as</span>
<span class="cm">	 * well, since gcc may pass arguments on the stack for certain</span>
<span class="cm">	 * functions (lots of arguments, large aggregates, varargs)</span>
<span class="cm">	 */</span>

	<span class="cm">/* setup return addr to the jprobe handler routine */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">jp</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">jprobe_return</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;breakpoint&quot;</span> <span class="o">:::</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">longjmp_break_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME - we should ideally be validating that we got here &#39;cos</span>
<span class="cm">	 * of the &quot;trap&quot; in jprobe_return() above, before restoring the</span>
<span class="cm">	 * saved regs...</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jprobe_saved_regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">arch_init_kprobes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* TODO: Register kretprobe trampoline */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
