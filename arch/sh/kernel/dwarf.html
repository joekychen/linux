<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sh › kernel › dwarf.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dwarf.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2009 Matt Fleming &lt;matt@console-pimps.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * This is an implementation of a DWARF unwinder. Its main purpose is</span>
<span class="cm"> * for generating stacktrace information. Based on the DWARF 3</span>
<span class="cm"> * specification from http://www.dwarfstd.org.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO:</span>
<span class="cm"> *	- DWARF64 doesn&#39;t work.</span>
<span class="cm"> *	- Registers with DWARF_VAL_OFFSET rules aren&#39;t handled properly.</span>
<span class="cm"> */</span>

<span class="cm">/* #define DEBUG */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/dwarf.h&gt;</span>
<span class="cp">#include &lt;asm/unwinder.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;asm/stacktrace.h&gt;</span>

<span class="cm">/* Reserve enough memory for two stack frames */</span>
<span class="cp">#define DWARF_FRAME_MIN_REQ	2</span>
<span class="cm">/* ... with 4 registers per frame. */</span>
<span class="cp">#define DWARF_REG_MIN_REQ	(DWARF_FRAME_MIN_REQ * 4)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">dwarf_frame_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">dwarf_frame_pool</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">dwarf_reg_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">dwarf_reg_pool</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">cie_root</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dwarf_cie_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">fde_root</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dwarf_fde_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cached_cie</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dwarf_unwinder_ready</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_frame_alloc_reg - allocate memory for a DWARF register</span>
<span class="cm"> *	@frame: the DWARF frame whose list of registers we insert on</span>
<span class="cm"> *	@reg_num: the register number</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate space for, and initialise, a dwarf reg from</span>
<span class="cm"> *	dwarf_reg_pool and insert it onto the (unsorted) linked-list of</span>
<span class="cm"> *	dwarf registers for @frame.</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the initialised DWARF reg.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dwarf_reg</span> <span class="o">*</span><span class="nf">dwarf_frame_alloc_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dwarf_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_reg</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">dwarf_reg_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Unable to allocate a DWARF register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Let&#39;s just bomb hard here, we have no way to</span>
<span class="cm">		 * gracefully recover.</span>
<span class="cm">		 */</span>
		<span class="n">UNWINDER_BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">reg_num</span><span class="p">;</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">reg_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dwarf_frame_free_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dwarf_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_reg</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">reg_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">dwarf_reg_pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_frame_reg - return a DWARF register</span>
<span class="cm"> *	@frame: the DWARF frame to search in for @reg_num</span>
<span class="cm"> *	@reg_num: the register number to search for</span>
<span class="cm"> *</span>
<span class="cm"> *	Lookup and return the dwarf reg @reg_num for this frame. Return</span>
<span class="cm"> *	NULL if @reg_num is an register invalid number.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dwarf_reg</span> <span class="o">*</span><span class="nf">dwarf_frame_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dwarf_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_reg</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">reg_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">==</span> <span class="n">reg_num</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_read_addr - read dwarf data</span>
<span class="cm"> *	@src: source address of data</span>
<span class="cm"> *	@dst: destination address to store the data to</span>
<span class="cm"> *</span>
<span class="cm"> *	Read &#39;n&#39; bytes from @src, where &#39;n&#39; is the size of an address on</span>
<span class="cm"> *	the native machine. We return the number of bytes read, which</span>
<span class="cm"> *	should always be &#39;n&#39;. We also have to be careful when reading</span>
<span class="cm"> *	from @src and writing to @dst, because they can be arbitrarily</span>
<span class="cm"> *	aligned. Return &#39;n&#39; - the number of bytes read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dwarf_read_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">put_unaligned</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_read_uleb128 - read unsigned LEB128 data</span>
<span class="cm"> *	@addr: the address where the ULEB128 data is stored</span>
<span class="cm"> *	@ret: address to store the result</span>
<span class="cm"> *</span>
<span class="cm"> *	Decode an unsigned LEB128 encoded datum. The algorithm is taken</span>
<span class="cm"> *	from Appendix C of the DWARF 3 spec. For information on the</span>
<span class="cm"> *	encodings refer to section &quot;7.6 - Variable Length Data&quot;. Return</span>
<span class="cm"> *	the number of bytes read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">dwarf_read_uleb128</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">byte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">__raw_readb</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">addr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="n">shift</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_read_leb128 - read signed LEB128 data</span>
<span class="cm"> *	@addr: the address of the LEB128 encoded data</span>
<span class="cm"> *	@ret: address to store the result</span>
<span class="cm"> *</span>
<span class="cm"> *	Decode signed LEB128 data. The algorithm is taken from Appendix</span>
<span class="cm"> *	C of the DWARF 3 spec. Return the number of bytes read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">dwarf_read_leb128</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">byte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">__raw_readb</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">addr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="n">shift</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The number of bits in a signed integer. */</span>
	<span class="n">num_bits</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="n">num_bits</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">))</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_read_encoded_value - return the decoded value at @addr</span>
<span class="cm"> *	@addr: the address of the encoded value</span>
<span class="cm"> *	@val: where to write the decoded value</span>
<span class="cm"> *	@encoding: the encoding with which we can decode @addr</span>
<span class="cm"> *</span>
<span class="cm"> *	GCC emits encoded address in the .eh_frame FDE entries. Decode</span>
<span class="cm"> *	the value at @addr using @encoding. The decoded value is written</span>
<span class="cm"> *	to @val and the number of bytes read is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dwarf_read_encoded_value</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">encoding</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">decoded_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="mh">0x70</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DW_EH_PE_absptr</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DW_EH_PE_pcrel</span>:
		<span class="n">decoded_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;encoding=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="mh">0x70</span><span class="p">));</span>
		<span class="n">UNWINDER_BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span>
		<span class="n">encoding</span> <span class="o">|=</span> <span class="n">DW_EH_PE_udata4</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DW_EH_PE_sdata4</span>:
	<span class="k">case</span> <span class="n">DW_EH_PE_udata4</span>:
		<span class="n">count</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">decoded_addr</span> <span class="o">+=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">decoded_addr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;encoding=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="p">);</span>
		<span class="n">UNWINDER_BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_entry_len - return the length of an FDE or CIE</span>
<span class="cm"> *	@addr: the address of the entry</span>
<span class="cm"> *	@len: the length of the entry</span>
<span class="cm"> *</span>
<span class="cm"> *	Read the initial_length field of the entry and store the size of</span>
<span class="cm"> *	the entry in @len. We return the number of bytes read. Return a</span>
<span class="cm"> *	count of 0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dwarf_entry_len</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">initial_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">initial_len</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * An initial length field value in the range DW_LEN_EXT_LO -</span>
<span class="cm">	 * DW_LEN_EXT_HI indicates an extension, and should not be</span>
<span class="cm">	 * interpreted as a length. The only extension that we currently</span>
<span class="cm">	 * understand is the use of DWARF64 addresses.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">initial_len</span> <span class="o">&gt;=</span> <span class="n">DW_EXT_LO</span> <span class="o">&amp;&amp;</span> <span class="n">initial_len</span> <span class="o">&lt;=</span> <span class="n">DW_EXT_HI</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The 64-bit length field immediately follows the</span>
<span class="cm">		 * compulsory 32-bit length field.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">initial_len</span> <span class="o">==</span> <span class="n">DW_EXT_DWARF64</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Unknown DWARF extension</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">initial_len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_lookup_cie - locate the cie</span>
<span class="cm"> *	@cie_ptr: pointer to help with lookup</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="nf">dwarf_lookup_cie</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cie_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cie_root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cie</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_cie_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve cached the last CIE we looked up because chances are</span>
<span class="cm">	 * that the FDE wants this CIE.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cached_cie</span> <span class="o">&amp;&amp;</span> <span class="n">cached_cie</span><span class="o">-&gt;</span><span class="n">cie_pointer</span> <span class="o">==</span> <span class="n">cie_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cie</span> <span class="o">=</span> <span class="n">cached_cie</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cie_tmp</span><span class="p">;</span>

		<span class="n">cie_tmp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dwarf_cie</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cie_tmp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cie_ptr</span> <span class="o">==</span> <span class="n">cie_tmp</span><span class="o">-&gt;</span><span class="n">cie_pointer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cie</span> <span class="o">=</span> <span class="n">cie_tmp</span><span class="p">;</span>
			<span class="n">cached_cie</span> <span class="o">=</span> <span class="n">cie_tmp</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cie_ptr</span> <span class="o">&lt;</span> <span class="n">cie_tmp</span><span class="o">-&gt;</span><span class="n">cie_pointer</span><span class="p">)</span>
				<span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_cie_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cie</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_lookup_fde - locate the FDE that covers pc</span>
<span class="cm"> *	@pc: the program counter</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dwarf_fde</span> <span class="o">*</span><span class="nf">dwarf_lookup_fde</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fde_root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_fde</span> <span class="o">*</span><span class="n">fde</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_fde_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dwarf_fde</span> <span class="o">*</span><span class="n">fde_tmp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp_start</span><span class="p">,</span> <span class="n">tmp_end</span><span class="p">;</span>

		<span class="n">fde_tmp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dwarf_fde</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">fde_tmp</span><span class="p">);</span>

		<span class="n">tmp_start</span> <span class="o">=</span> <span class="n">fde_tmp</span><span class="o">-&gt;</span><span class="n">initial_location</span><span class="p">;</span>
		<span class="n">tmp_end</span> <span class="o">=</span> <span class="n">fde_tmp</span><span class="o">-&gt;</span><span class="n">initial_location</span> <span class="o">+</span> <span class="n">fde_tmp</span><span class="o">-&gt;</span><span class="n">address_range</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">&lt;</span> <span class="n">tmp_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">&lt;</span> <span class="n">tmp_end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fde</span> <span class="o">=</span> <span class="n">fde_tmp</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_fde_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fde</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_cfa_execute_insns - execute instructions to calculate a CFA</span>
<span class="cm"> *	@insn_start: address of the first instruction</span>
<span class="cm"> *	@insn_end: address of the last instruction</span>
<span class="cm"> *	@cie: the CIE for this function</span>
<span class="cm"> *	@fde: the FDE for this function</span>
<span class="cm"> *	@frame: the instructions calculate the CFA for this frame</span>
<span class="cm"> *	@pc: the program counter of the address we&#39;re interested in</span>
<span class="cm"> *</span>
<span class="cm"> *	Execute the Call Frame instruction sequence starting at</span>
<span class="cm"> *	@insn_start and ending at @insn_end. The instructions describe</span>
<span class="cm"> *	how to calculate the Canonical Frame Address of a stackframe.</span>
<span class="cm"> *	Store the results in @frame.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dwarf_cfa_execute_insns</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">insn_start</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">insn_end</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cie</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dwarf_fde</span> <span class="o">*</span><span class="n">fde</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dwarf_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">insn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">current_insn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">expr_len</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_reg</span> <span class="o">*</span><span class="n">regp</span><span class="p">;</span>

	<span class="n">current_insn</span> <span class="o">=</span> <span class="n">insn_start</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">current_insn</span> <span class="o">&lt;</span> <span class="n">insn_end</span> <span class="o">&amp;&amp;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">&lt;=</span> <span class="n">pc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">insn</span> <span class="o">=</span> <span class="n">__raw_readb</span><span class="p">(</span><span class="n">current_insn</span><span class="o">++</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Firstly, handle the opcodes that embed their operands</span>
<span class="cm">		 * in the instructions.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">DW_CFA_opcode</span><span class="p">(</span><span class="n">insn</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DW_CFA_advance_loc</span>:
			<span class="n">delta</span> <span class="o">=</span> <span class="n">DW_CFA_operand</span><span class="p">(</span><span class="n">insn</span><span class="p">);</span>
			<span class="n">delta</span> <span class="o">*=</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">code_alignment_factor</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/* NOTREACHED */</span>
		<span class="k">case</span> <span class="n">DW_CFA_offset</span>:
			<span class="n">reg</span> <span class="o">=</span> <span class="n">DW_CFA_operand</span><span class="p">(</span><span class="n">insn</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">*=</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">data_alignment_factor</span><span class="p">;</span>
			<span class="n">regp</span> <span class="o">=</span> <span class="n">dwarf_frame_alloc_reg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
			<span class="n">regp</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">regp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DWARF_REG_OFFSET</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/* NOTREACHED */</span>
		<span class="k">case</span> <span class="n">DW_CFA_restore</span>:
			<span class="n">reg</span> <span class="o">=</span> <span class="n">DW_CFA_operand</span><span class="p">(</span><span class="n">insn</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/* NOTREACHED */</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Secondly, handle the opcodes that don&#39;t embed their</span>
<span class="cm">		 * operands in the instruction.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">insn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DW_CFA_nop</span>:
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_advance_loc1</span>:
			<span class="n">delta</span> <span class="o">=</span> <span class="o">*</span><span class="n">current_insn</span><span class="o">++</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">+=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">code_alignment_factor</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_advance_loc2</span>:
			<span class="n">delta</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">current_insn</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">+=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">code_alignment_factor</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_advance_loc4</span>:
			<span class="n">delta</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">current_insn</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">+=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">code_alignment_factor</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_offset_extended</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">*=</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">data_alignment_factor</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_restore_extended</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_undefined</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">regp</span> <span class="o">=</span> <span class="n">dwarf_frame_alloc_reg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
			<span class="n">regp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DWARF_UNDEFINED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_def_cfa</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa_register</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa_offset</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DWARF_FRAME_CFA_REG_OFFSET</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_def_cfa_register</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa_register</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DWARF_FRAME_CFA_REG_OFFSET</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_def_cfa_offset</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_def_cfa_expression</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expr_len</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa_expr</span> <span class="o">=</span> <span class="n">current_insn</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa_expr_len</span> <span class="o">=</span> <span class="n">expr_len</span><span class="p">;</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">expr_len</span><span class="p">;</span>

			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DWARF_FRAME_CFA_REG_EXP</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_offset_extended_sf</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_leb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">*=</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">data_alignment_factor</span><span class="p">;</span>
			<span class="n">regp</span> <span class="o">=</span> <span class="n">dwarf_frame_alloc_reg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
			<span class="n">regp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DWARF_REG_OFFSET</span><span class="p">;</span>
			<span class="n">regp</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_val_offset</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_leb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">*=</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">data_alignment_factor</span><span class="p">;</span>
			<span class="n">regp</span> <span class="o">=</span> <span class="n">dwarf_frame_alloc_reg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
			<span class="n">regp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DWARF_VAL_OFFSET</span><span class="p">;</span>
			<span class="n">regp</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_GNU_args_size</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DW_CFA_GNU_negative_offset_extended</span>:
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">current_insn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">current_insn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">*=</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">data_alignment_factor</span><span class="p">;</span>

			<span class="n">regp</span> <span class="o">=</span> <span class="n">dwarf_frame_alloc_reg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
			<span class="n">regp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DWARF_REG_OFFSET</span><span class="p">;</span>
			<span class="n">regp</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;unhandled DWARF instruction 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
			<span class="n">UNWINDER_BUG</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_free_frame - free the memory allocated for @frame</span>
<span class="cm"> *	@frame: the frame to free</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dwarf_free_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">dwarf_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dwarf_frame_free_regs</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">dwarf_frame_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ret_from_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_unwind_stack - unwind the stack</span>
<span class="cm"> *</span>
<span class="cm"> *	@pc: address of the function to unwind</span>
<span class="cm"> *	@prev: struct dwarf_frame of the previous stackframe on the callstack</span>
<span class="cm"> *</span>
<span class="cm"> *	Return a struct dwarf_frame representing the most recent frame</span>
<span class="cm"> *	on the callstack. Each of the lower (older) stack frames are</span>
<span class="cm"> *	linked via the &quot;prev&quot; member.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dwarf_frame</span> <span class="o">*</span><span class="nf">dwarf_unwind_stack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dwarf_frame</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_fde</span> <span class="o">*</span><span class="n">fde</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_reg</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;ve been called in to before initialization has</span>
<span class="cm">	 * completed, bail out immediately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dwarf_unwinder_ready</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re starting at the top of the stack we need get the</span>
<span class="cm">	 * contents of a physical register to get the CFA in order to</span>
<span class="cm">	 * begin the virtual unwinding of the stack.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: the return address is guaranteed to be setup by the</span>
<span class="cm">	 * time this function makes its first function call.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pc</span> <span class="o">||</span> <span class="o">!</span><span class="n">prev</span><span class="p">)</span>
		<span class="n">pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">current_text_addr</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="cm">/*</span>
<span class="cm">	 * If our stack has been patched by the function graph tracer</span>
<span class="cm">	 * then we might see the address of return_to_handler() where we</span>
<span class="cm">	 * expected to find the real return address.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">return_to_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">curr_ret_stack</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We currently have no way of tracking how many</span>
<span class="cm">		 * return_to_handler()&#39;s we&#39;ve seen. If there is more</span>
<span class="cm">		 * than one patched return address on our stack,</span>
<span class="cm">		 * complain loudly.</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">pc</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">ret_stack</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">dwarf_frame_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to allocate a dwarf frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">UNWINDER_BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">reg_list</span><span class="p">);</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">return_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fde</span> <span class="o">=</span> <span class="n">dwarf_lookup_fde</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fde</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is our normal exit path. There are two reasons</span>
<span class="cm">		 * why we might exit here,</span>
<span class="cm">		 *</span>
<span class="cm">		 *	a) pc has no asscociated DWARF frame info and so</span>
<span class="cm">		 *	we don&#39;t know how to unwind this frame. This is</span>
<span class="cm">		 *	usually the case when we&#39;re trying to unwind a</span>
<span class="cm">		 *	frame that was called from some assembly code</span>
<span class="cm">		 *	that has no DWARF info, e.g. syscalls.</span>
<span class="cm">		 *</span>
<span class="cm">		 *	b) the DEBUG info for pc is bogus. There&#39;s</span>
<span class="cm">		 *	really no way to distinguish this case from the</span>
<span class="cm">		 *	case above, which sucks because we could print a</span>
<span class="cm">		 *	warning here.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cie</span> <span class="o">=</span> <span class="n">dwarf_lookup_cie</span><span class="p">(</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">cie_pointer</span><span class="p">);</span>

	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">fde</span><span class="o">-&gt;</span><span class="n">initial_location</span><span class="p">;</span>

	<span class="cm">/* CIE initial instructions */</span>
	<span class="n">dwarf_cfa_execute_insns</span><span class="p">(</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">initial_instructions</span><span class="p">,</span>
				<span class="n">cie</span><span class="o">-&gt;</span><span class="n">instructions_end</span><span class="p">,</span> <span class="n">cie</span><span class="p">,</span> <span class="n">fde</span><span class="p">,</span>
				<span class="n">frame</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>

	<span class="cm">/* FDE instructions */</span>
	<span class="n">dwarf_cfa_execute_insns</span><span class="p">(</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">instructions</span><span class="p">,</span> <span class="n">fde</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span> <span class="n">cie</span><span class="p">,</span>
				<span class="n">fde</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>

	<span class="cm">/* Calculate the CFA */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DWARF_FRAME_CFA_REG_OFFSET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">dwarf_frame_reg</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa_register</span><span class="p">);</span>
			<span class="n">UNWINDER_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">reg</span><span class="p">);</span>
			<span class="n">UNWINDER_BUG_ON</span><span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">DWARF_REG_OFFSET</span><span class="p">);</span>

			<span class="n">addr</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">cfa</span> <span class="o">+</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Again, we&#39;re starting from the top of the</span>
<span class="cm">			 * stack. We need to physically read</span>
<span class="cm">			 * the contents of a register in order to get</span>
<span class="cm">			 * the Canonical Frame Address for this</span>
<span class="cm">			 * function.</span>
<span class="cm">			 */</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa</span> <span class="o">=</span> <span class="n">dwarf_read_arch_reg</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa_register</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa</span> <span class="o">+=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa_offset</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">UNWINDER_BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">dwarf_frame_reg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">DWARF_ARCH_RA_REG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we haven&#39;t seen the return address register or the return</span>
<span class="cm">	 * address column is undefined then we must assume that this is</span>
<span class="cm">	 * the end of the callstack.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg</span> <span class="o">||</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">==</span> <span class="n">DWARF_UNDEFINED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">UNWINDER_BUG_ON</span><span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">DWARF_REG_OFFSET</span><span class="p">);</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">cfa</span> <span class="o">+</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">return_addr</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ah, the joys of unwinding through interrupts.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Interrupts are tricky - the DWARF info needs to be _really_</span>
<span class="cm">	 * accurate and unfortunately I&#39;m seeing a lot of bogus DWARF</span>
<span class="cm">	 * info. For example, I&#39;ve seen interrupts occur in epilogues</span>
<span class="cm">	 * just after the frame pointer (r14) had been restored. The</span>
<span class="cm">	 * problem was that the DWARF info claimed that the CFA could be</span>
<span class="cm">	 * reached by using the value of the frame pointer before it was</span>
<span class="cm">	 * restored.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So until the compiler can be trusted to produce reliable</span>
<span class="cm">	 * DWARF info when it really matters, let&#39;s stop unwinding once</span>
<span class="cm">	 * we&#39;ve calculated the function that was interrupted.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ret_from_irq</span><span class="p">)</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">return_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">frame</span><span class="p">;</span>

<span class="nl">bail:</span>
	<span class="n">dwarf_free_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dwarf_parse_cie</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cie_root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cie</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">cie</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cie</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cie</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">cie</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Record the offset into the .eh_frame section</span>
<span class="cm">	 * for this CIE. It allows this CIE to be</span>
<span class="cm">	 * quickly and easily looked up from the</span>
<span class="cm">	 * corresponding FDE.</span>
<span class="cm">	 */</span>
	<span class="n">cie</span><span class="o">-&gt;</span><span class="n">cie_pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">cie</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="n">UNWINDER_BUG_ON</span><span class="p">(</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">code_alignment_factor</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_leb128</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">data_alignment_factor</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Which column in the rule table contains the</span>
<span class="cm">	 * return address?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cie</span><span class="o">-&gt;</span><span class="n">return_address_reg</span> <span class="o">=</span> <span class="n">__raw_readb</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">return_address_reg</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">cie</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DWARF_CIE_Z_AUGMENTATION</span><span class="p">;</span>

		<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

		<span class="n">UNWINDER_BUG_ON</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">);</span>

		<span class="n">cie</span><span class="o">-&gt;</span><span class="n">initial_instructions</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * &quot;L&quot; indicates a byte showing how the</span>
<span class="cm">		 * LSDA pointer is encoded. Skip it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span> <span class="o">==</span> <span class="sc">&#39;L&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span> <span class="o">==</span> <span class="sc">&#39;R&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * &quot;R&quot; indicates a byte showing</span>
<span class="cm">			 * how FDE addresses are</span>
<span class="cm">			 * encoded.</span>
<span class="cm">			 */</span>
			<span class="n">cie</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span> <span class="o">==</span> <span class="sc">&#39;P&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * &quot;R&quot; indicates a personality</span>
<span class="cm">			 * routine in the CIE</span>
<span class="cm">			 * augmentation.</span>
<span class="cm">			 */</span>
			<span class="n">UNWINDER_BUG</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">augmentation</span> <span class="o">==</span> <span class="sc">&#39;S&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">UNWINDER_BUG</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Unknown augmentation. Assume</span>
<span class="cm">			 * &#39;z&#39; augmentation.</span>
<span class="cm">			 */</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">cie</span><span class="o">-&gt;</span><span class="n">initial_instructions</span><span class="p">;</span>
			<span class="n">UNWINDER_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cie</span><span class="o">-&gt;</span><span class="n">initial_instructions</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">cie</span><span class="o">-&gt;</span><span class="n">instructions_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

	<span class="cm">/* Add to list */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_cie_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cie_tmp</span><span class="p">;</span>

		<span class="n">cie_tmp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dwarf_cie</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">rb_node</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">cie_pointer</span> <span class="o">&lt;</span> <span class="n">cie_tmp</span><span class="o">-&gt;</span><span class="n">cie_pointer</span><span class="p">)</span>
			<span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">cie_pointer</span> <span class="o">&gt;=</span> <span class="n">cie_tmp</span><span class="o">-&gt;</span><span class="n">cie_pointer</span><span class="p">)</span>
			<span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cie_root</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MODULES</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cie_list</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_cie_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dwarf_parse_fde</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">u32</span> <span class="n">entry_type</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fde_root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_fde</span> <span class="o">*</span><span class="n">fde</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cie</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">fde</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fde</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fde</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fde</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In a .eh_frame section the CIE pointer is the</span>
<span class="cm">	 * delta between the address within the FDE</span>
<span class="cm">	 */</span>
	<span class="n">fde</span><span class="o">-&gt;</span><span class="n">cie_pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">entry_type</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">cie</span> <span class="o">=</span> <span class="n">dwarf_lookup_cie</span><span class="p">(</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">cie_pointer</span><span class="p">);</span>
	<span class="n">fde</span><span class="o">-&gt;</span><span class="n">cie</span> <span class="o">=</span> <span class="n">cie</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_encoded_value</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">initial_location</span><span class="p">,</span>
						 <span class="n">cie</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_addr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">initial_location</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_encoded_value</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">address_range</span><span class="p">,</span>
						 <span class="n">cie</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_addr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">address_range</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DWARF_CIE_Z_AUGMENTATION</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_read_uleb128</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Call frame instructions. */</span>
	<span class="n">fde</span><span class="o">-&gt;</span><span class="n">instructions</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">fde</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

	<span class="cm">/* Add to list. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_fde_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dwarf_fde</span> <span class="o">*</span><span class="n">fde_tmp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp_start</span><span class="p">,</span> <span class="n">tmp_end</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">fde_tmp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dwarf_fde</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">fde</span><span class="o">-&gt;</span><span class="n">initial_location</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">fde</span><span class="o">-&gt;</span><span class="n">initial_location</span> <span class="o">+</span> <span class="n">fde</span><span class="o">-&gt;</span><span class="n">address_range</span><span class="p">;</span>

		<span class="n">tmp_start</span> <span class="o">=</span> <span class="n">fde_tmp</span><span class="o">-&gt;</span><span class="n">initial_location</span><span class="p">;</span>
		<span class="n">tmp_end</span> <span class="o">=</span> <span class="n">fde_tmp</span><span class="o">-&gt;</span><span class="n">initial_location</span> <span class="o">+</span> <span class="n">fde_tmp</span><span class="o">-&gt;</span><span class="n">address_range</span><span class="p">;</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">rb_node</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">tmp_start</span><span class="p">)</span>
			<span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">tmp_end</span><span class="p">)</span>
			<span class="n">rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fde_root</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MODULES</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fde_list</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_fde_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dwarf_unwinder_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">stacktrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="o">*</span><span class="n">_frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">return_addr</span><span class="p">;</span>

	<span class="n">_frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">return_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="n">dwarf_unwind_stack</span><span class="p">(</span><span class="n">return_addr</span><span class="p">,</span> <span class="n">_frame</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">_frame</span><span class="p">)</span>
			<span class="n">dwarf_free_frame</span><span class="p">(</span><span class="n">_frame</span><span class="p">);</span>

		<span class="n">_frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame</span> <span class="o">||</span> <span class="o">!</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">return_addr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">return_addr</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">return_addr</span><span class="p">;</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">return_addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">)</span>
		<span class="n">dwarf_free_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">unwinder</span> <span class="n">dwarf_unwinder</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;dwarf-unwinder&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dump</span> <span class="o">=</span> <span class="n">dwarf_unwinder_dump</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span> <span class="o">=</span> <span class="mi">150</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dwarf_unwinder_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">fde_rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fde_root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">cie_rb_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cie_root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Deallocate all the memory allocated for the DWARF unwinder.</span>
<span class="cm">	 * Traverse all the FDE/CIE lists and remove and free all the</span>
<span class="cm">	 * memory associated with those data structures.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">fde_rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dwarf_fde</span> <span class="o">*</span><span class="n">fde</span><span class="p">;</span>

		<span class="n">fde</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">fde_rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dwarf_fde</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">*</span><span class="n">fde_rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fde_root</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">fde</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">cie_rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cie</span><span class="p">;</span>

		<span class="n">cie</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">cie_rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dwarf_cie</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">*</span><span class="n">cie_rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cie_root</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cie</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">dwarf_reg_cachep</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">dwarf_frame_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_parse_section - parse DWARF section</span>
<span class="cm"> *	@eh_frame_start: start address of the .eh_frame section</span>
<span class="cm"> *	@eh_frame_end: end address of the .eh_frame section</span>
<span class="cm"> *	@mod: the kernel module containing the .eh_frame section</span>
<span class="cm"> *</span>
<span class="cm"> *	Parse the information in a .eh_frame section.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dwarf_parse_section</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">eh_frame_start</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">eh_frame_end</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">entry_type</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c_entries</span><span class="p">,</span> <span class="n">f_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="n">c_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">f_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">eh_frame_start</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="n">eh_frame_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

		<span class="n">count</span> <span class="o">=</span> <span class="n">dwarf_entry_len</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We read a bogus length field value. There is</span>
<span class="cm">			 * nothing we can do here apart from disabling</span>
<span class="cm">			 * the DWARF unwinder. We can&#39;t even skip this</span>
<span class="cm">			 * entry and move to the next one because &#39;len&#39;</span>
<span class="cm">			 * tells us where our next entry is.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

		<span class="cm">/* initial length does not include itself */</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">entry_type</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry_type</span> <span class="o">==</span> <span class="n">DW_EH_FRAME_CIE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dwarf_parse_cie</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">c_entries</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dwarf_parse_fde</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">entry_type</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					      <span class="n">end</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">f_entries</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DWARF unwinder initialised: read %u CIEs, %u FDEs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">c_entries</span><span class="p">,</span> <span class="n">f_entries</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MODULES</span>
<span class="kt">int</span> <span class="nf">module_dwarf_finalize</span><span class="p">(</span><span class="k">const</span> <span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secstrings</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Alloc bit cleared means &quot;ignore it.&quot; */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">secstrings</span><span class="o">+</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_name</span><span class="p">,</span> <span class="s">&quot;.eh_frame&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Did we find the .eh_frame section? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cie_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fde_list</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dwarf_parse_section</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">end</span><span class="p">,</span> <span class="n">me</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: failed to parse DWARF info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	module_dwarf_cleanup - remove FDE/CIEs associated with @mod</span>
<span class="cm"> *	@mod: the module that is being unloaded</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove any FDEs and CIEs from the global lists that came from</span>
<span class="cm"> *	@mod&#39;s .eh_frame section because @mod is being unloaded.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">module_dwarf_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dwarf_fde</span> <span class="o">*</span><span class="n">fde</span><span class="p">,</span> <span class="o">*</span><span class="n">ftmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dwarf_cie</span> <span class="o">*</span><span class="n">cie</span><span class="p">,</span> <span class="o">*</span><span class="n">ctmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_cie_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cie</span><span class="p">,</span> <span class="n">ctmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cie_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cie</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cie_root</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cie</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_cie_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_fde_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fde</span><span class="p">,</span> <span class="n">ftmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fde_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fde_root</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">fde</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_fde_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MODULES */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> *	dwarf_unwinder_init - initialise the dwarf unwinder</span>
<span class="cm"> *</span>
<span class="cm"> *	Build the data structures describing the .dwarf_frame section to</span>
<span class="cm"> *	make it easier to lookup CIE and FDE entries. Because the</span>
<span class="cm"> *	.eh_frame section is packed as tightly as possible it is not</span>
<span class="cm"> *	easy to lookup the FDE for a given PC, so we build a list of FDE</span>
<span class="cm"> *	and CIE entries that make it easier.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dwarf_unwinder_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dwarf_frame_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;dwarf_frames&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dwarf_frame</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_PANIC</span> <span class="o">|</span> <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_NOTRACK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">dwarf_reg_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;dwarf_regs&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dwarf_reg</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_PANIC</span> <span class="o">|</span> <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_NOTRACK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">dwarf_frame_pool</span> <span class="o">=</span> <span class="n">mempool_create</span><span class="p">(</span><span class="n">DWARF_FRAME_MIN_REQ</span><span class="p">,</span>
					  <span class="n">mempool_alloc_slab</span><span class="p">,</span>
					  <span class="n">mempool_free_slab</span><span class="p">,</span>
					  <span class="n">dwarf_frame_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dwarf_frame_pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dwarf_reg_pool</span> <span class="o">=</span> <span class="n">mempool_create</span><span class="p">(</span><span class="n">DWARF_REG_MIN_REQ</span><span class="p">,</span>
					 <span class="n">mempool_alloc_slab</span><span class="p">,</span>
					 <span class="n">mempool_free_slab</span><span class="p">,</span>
					 <span class="n">dwarf_reg_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dwarf_reg_pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dwarf_parse_section</span><span class="p">(</span><span class="n">__start_eh_frame</span><span class="p">,</span> <span class="n">__stop_eh_frame</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">unwinder_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwarf_unwinder</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dwarf_unwinder_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to initialise DWARF unwinder: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">dwarf_unwinder_cleanup</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">dwarf_unwinder_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
