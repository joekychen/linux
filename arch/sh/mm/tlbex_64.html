<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sh › mm › tlbex_64.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>tlbex_64.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * The SH64 TLB miss.</span>
<span class="cm"> *</span>
<span class="cm"> * Original code from fault.c</span>
<span class="cm"> * Copyright (C) 2000, 2001  Paolo Alberelli</span>
<span class="cm"> *</span>
<span class="cm"> * Fast PTE-&gt;TLB refill path</span>
<span class="cm"> * Copyright (C) 2003 Richard.Curnow@superh.com</span>
<span class="cm"> *</span>
<span class="cm"> * IMPORTANT NOTES :</span>
<span class="cm"> * The do_fast_page_fault function is called from a context in entry.S</span>
<span class="cm"> * where very few registers have been saved.  In particular, the code in</span>
<span class="cm"> * this file must be compiled not to use ANY caller-save registers that</span>
<span class="cm"> * are not part of the restricted save set.  Also, it means that code in</span>
<span class="cm"> * this file must not make calls to functions elsewhere in the kernel, or</span>
<span class="cm"> * else the excepting context will see corruption in its caller-save</span>
<span class="cm"> * registers.  Plus, the entry.S save area is non-reentrant, so this code</span>
<span class="cm"> * has to run with SR.BL==1, i.e. no interrupts taken inside it and panic</span>
<span class="cm"> * on any exception.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_tlbmiss</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">protection_flags</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_vmalloc_addr</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">TASK_SIZE</span> <span class="o">||</span> <span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the page doesn&#39;t have sufficient protection bits set to</span>
<span class="cm">	 * service the kind of fault being handled, there&#39;s not much</span>
<span class="cm">	 * point doing the TLB refill.  Punt the fault to the general</span>
<span class="cm">	 * handler.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">protection_flags</span><span class="p">)</span> <span class="o">!=</span> <span class="n">protection_flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">update_mmu_cache</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Put all this information into one structure so that everything is just</span>
<span class="cm"> * arithmetic relative to a single base address.  This reduces the number</span>
<span class="cm"> * of movi/shori pairs needed just to load addresses of static data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">expevt_lookup</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">protection_flags</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">is_text_access</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">is_write_access</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define PRU (1&lt;&lt;9)</span>
<span class="cp">#define PRW (1&lt;&lt;8)</span>
<span class="cp">#define PRX (1&lt;&lt;7)</span>
<span class="cp">#define PRR (1&lt;&lt;6)</span>

<span class="cm">/* Sized as 8 rather than 4 to allow checking the PTE&#39;s PRU bit against whether</span>
<span class="cm">   the fault happened in user mode or privileged mode. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">expevt_lookup</span> <span class="n">expevt_lookup_table</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">protection_flags</span> <span class="o">=</span> <span class="p">{</span><span class="n">PRX</span><span class="p">,</span> <span class="n">PRX</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PRR</span><span class="p">,</span> <span class="n">PRR</span><span class="p">,</span> <span class="n">PRW</span><span class="p">,</span> <span class="n">PRW</span><span class="p">},</span>
	<span class="p">.</span><span class="n">is_text_access</span>   <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">expevt_to_fault_code</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expevt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expevt</span> <span class="o">==</span> <span class="mh">0xa40</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FAULT_CODE_ITLB</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">expevt</span> <span class="o">==</span> <span class="mh">0x060</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FAULT_CODE_WRITE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">   This routine handles page faults that can be serviced just by refilling a</span>
<span class="cm">   TLB entry from an existing page table entry.  (This case represents a very</span>
<span class="cm">   large majority of page faults.) Return 1 if the fault was successfully</span>
<span class="cm">   handled.  Return 0 if the fault could not be handled.  (This leads into the</span>
<span class="cm">   general fault handling in fault.c which deals with mapping file-backed</span>
<span class="cm">   pages, stack growth, segmentation faults, swapping etc etc)</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">do_fast_page_fault</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ssr_md</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">expevt</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">protection_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">expevt4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fault_code</span><span class="p">;</span>

	<span class="cm">/* The next few lines implement a way of hashing EXPEVT into a</span>
<span class="cm">	 * small array index which can be used to lookup parameters</span>
<span class="cm">	 * specific to the type of TLBMISS being handled.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note:</span>
<span class="cm">	 *	ITLBMISS has EXPEVT==0xa40</span>
<span class="cm">	 *	RTLBMISS has EXPEVT==0x040</span>
<span class="cm">	 *	WTLBMISS has EXPEVT==0x060</span>
<span class="cm">	 */</span>
	<span class="n">expevt4</span> <span class="o">=</span> <span class="p">(</span><span class="n">expevt</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* TODO : xor ssr_md into this expression too. Then we can check</span>
<span class="cm">	 * that PRU is set when it needs to be. */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">expevt4</span> <span class="o">^</span> <span class="p">(</span><span class="n">expevt4</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">&amp;=</span> <span class="mi">7</span><span class="p">;</span>

	<span class="n">fault_code</span> <span class="o">=</span> <span class="n">expevt_to_fault_code</span><span class="p">(</span><span class="n">expevt</span><span class="p">);</span>

	<span class="n">protection_flags</span> <span class="o">=</span> <span class="n">expevt_lookup_table</span><span class="p">.</span><span class="n">protection_flags</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">expevt_lookup_table</span><span class="p">.</span><span class="n">is_text_access</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
		<span class="n">fault_code</span> <span class="o">|=</span> <span class="n">FAULT_CODE_ITLB</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ssr_md</span><span class="p">)</span>
		<span class="n">fault_code</span> <span class="o">|=</span> <span class="n">FAULT_CODE_USER</span><span class="p">;</span>

	<span class="n">set_thread_fault_code</span><span class="p">(</span><span class="n">fault_code</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">handle_tlbmiss</span><span class="p">(</span><span class="n">protection_flags</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
