<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sh › include › asm › elf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>elf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __ASM_SH_ELF_H</span>
<span class="cp">#define __ASM_SH_ELF_H</span>

<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;asm/auxvec.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/user.h&gt;</span>

<span class="cm">/* ELF header e_flags defines */</span>
<span class="cp">#define EF_SH_PIC		0x100	</span><span class="cm">/* -fpic */</span><span class="cp"></span>
<span class="cp">#define EF_SH_FDPIC		0x8000	</span><span class="cm">/* -mfdpic */</span><span class="cp"></span>

<span class="cm">/* SH (particularly SHcompact) relocation types  */</span>
<span class="cp">#define	R_SH_NONE		0</span>
<span class="cp">#define	R_SH_DIR32		1</span>
<span class="cp">#define	R_SH_REL32		2</span>
<span class="cp">#define	R_SH_DIR8WPN		3</span>
<span class="cp">#define	R_SH_IND12W		4</span>
<span class="cp">#define	R_SH_DIR8WPL		5</span>
<span class="cp">#define	R_SH_DIR8WPZ		6</span>
<span class="cp">#define	R_SH_DIR8BP		7</span>
<span class="cp">#define	R_SH_DIR8W		8</span>
<span class="cp">#define	R_SH_DIR8L		9</span>
<span class="cp">#define	R_SH_SWITCH16		25</span>
<span class="cp">#define	R_SH_SWITCH32		26</span>
<span class="cp">#define	R_SH_USES		27</span>
<span class="cp">#define	R_SH_COUNT		28</span>
<span class="cp">#define	R_SH_ALIGN		29</span>
<span class="cp">#define	R_SH_CODE		30</span>
<span class="cp">#define	R_SH_DATA		31</span>
<span class="cp">#define	R_SH_LABEL		32</span>
<span class="cp">#define	R_SH_SWITCH8		33</span>
<span class="cp">#define	R_SH_GNU_VTINHERIT	34</span>
<span class="cp">#define	R_SH_GNU_VTENTRY	35</span>
<span class="cp">#define	R_SH_TLS_GD_32		144</span>
<span class="cp">#define	R_SH_TLS_LD_32		145</span>
<span class="cp">#define	R_SH_TLS_LDO_32		146</span>
<span class="cp">#define	R_SH_TLS_IE_32		147</span>
<span class="cp">#define	R_SH_TLS_LE_32		148</span>
<span class="cp">#define	R_SH_TLS_DTPMOD32	149</span>
<span class="cp">#define	R_SH_TLS_DTPOFF32	150</span>
<span class="cp">#define	R_SH_TLS_TPOFF32	151</span>
<span class="cp">#define	R_SH_GOT32		160</span>
<span class="cp">#define	R_SH_PLT32		161</span>
<span class="cp">#define	R_SH_COPY		162</span>
<span class="cp">#define	R_SH_GLOB_DAT		163</span>
<span class="cp">#define	R_SH_JMP_SLOT		164</span>
<span class="cp">#define	R_SH_RELATIVE		165</span>
<span class="cp">#define	R_SH_GOTOFF		166</span>
<span class="cp">#define	R_SH_GOTPC		167</span>

<span class="cm">/* FDPIC relocs */</span>
<span class="cp">#define R_SH_GOT20		201</span>
<span class="cp">#define R_SH_GOTOFF20		202</span>
<span class="cp">#define R_SH_GOTFUNCDESC	203</span>
<span class="cp">#define R_SH_GOTFUNCDESC20	204</span>
<span class="cp">#define R_SH_GOTOFFFUNCDESC	205</span>
<span class="cp">#define R_SH_GOTOFFFUNCDESC20	206</span>
<span class="cp">#define R_SH_FUNCDESC		207</span>
<span class="cp">#define R_SH_FUNCDESC_VALUE	208</span>

<span class="cm">/* SHmedia relocs */</span>
<span class="cp">#define R_SH_IMM_LOW16		246</span>
<span class="cp">#define R_SH_IMM_LOW16_PCREL	247</span>
<span class="cp">#define R_SH_IMM_MEDLOW16	248</span>
<span class="cp">#define R_SH_IMM_MEDLOW16_PCREL	249</span>
<span class="cm">/* Keep this the last entry.  */</span>
<span class="cp">#define	R_SH_NUM		256</span>

<span class="cm">/*</span>
<span class="cm"> * ELF register definitions..</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_greg_t</span><span class="p">;</span>

<span class="cp">#define ELF_NGREG (sizeof (struct pt_regs) / sizeof(elf_greg_t))</span>
<span class="k">typedef</span> <span class="n">elf_greg_t</span> <span class="n">elf_gregset_t</span><span class="p">[</span><span class="n">ELF_NGREG</span><span class="p">];</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">user_fpu_struct</span> <span class="n">elf_fpregset_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * These are used to set parameters in the core dumps.</span>
<span class="cm"> */</span>
<span class="cp">#define ELF_CLASS	ELFCLASS32</span>
<span class="cp">#ifdef __LITTLE_ENDIAN__</span>
<span class="cp">#define ELF_DATA	ELFDATA2LSB</span>
<span class="cp">#else</span>
<span class="cp">#define ELF_DATA	ELFDATA2MSB</span>
<span class="cp">#endif</span>
<span class="cp">#define ELF_ARCH	EM_SH</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/*</span>
<span class="cm"> * This is used to ensure we don&#39;t load something for the wrong architecture.</span>
<span class="cm"> */</span>
<span class="cp">#define elf_check_arch(x)		((x)-&gt;e_machine == EM_SH)</span>
<span class="cp">#define elf_check_fdpic(x)		((x)-&gt;e_flags &amp; EF_SH_FDPIC)</span>
<span class="cp">#define elf_check_const_displacement(x)	((x)-&gt;e_flags &amp; EF_SH_PIC)</span>

<span class="cm">/*</span>
<span class="cm"> * Enable dump using regset.</span>
<span class="cm"> * This covers all of general/DSP/FPU regs.</span>
<span class="cm"> */</span>
<span class="cp">#define CORE_DUMP_USE_REGSET</span>

<span class="cp">#define ELF_FDPIC_CORE_EFLAGS	EF_SH_FDPIC</span>
<span class="cp">#define ELF_EXEC_PAGESIZE	PAGE_SIZE</span>

<span class="cm">/* This is the location that an ET_DYN program is loaded if exec&#39;ed.  Typical</span>
<span class="cm">   use of this is to invoke &quot;./ld.so someprog&quot; to test out a new version of</span>
<span class="cm">   the loader.  We need to make sure that it is out of the way of the program</span>
<span class="cm">   that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */</span>

<span class="cp">#define ELF_ET_DYN_BASE         (2 * TASK_SIZE / 3)</span>

<span class="cp">#define ELF_CORE_COPY_REGS(_dest,_regs)				\</span>
<span class="cp">	memcpy((char *) &amp;_dest, (char *) _regs,			\</span>
<span class="cp">	       sizeof(struct pt_regs));</span>

<span class="cm">/* This yields a mask that user programs can use to figure out what</span>
<span class="cm">   instruction set this CPU supports.  This could be done in user space,</span>
<span class="cm">   but it&#39;s not easy, and we&#39;ve already done it here.  */</span>

<span class="cp">#define ELF_HWCAP	(boot_cpu_data.flags)</span>

<span class="cm">/* This yields a string that ld.so will use to load implementation</span>
<span class="cm">   specific libraries for optimization.  This is more specific in</span>
<span class="cm">   intent than poking at uname or /proc/cpuinfo.</span>

<span class="cm">   For the moment, we have only optimizations for the Intel generations,</span>
<span class="cm">   but that could change... */</span>

<span class="cp">#define ELF_PLATFORM	(utsname()-&gt;machine)</span>

<span class="cp">#ifdef __SH5__</span>
<span class="cp">#define ELF_PLAT_INIT(_r, load_addr) \</span>
<span class="cp">  do { _r-&gt;regs[0]=0; _r-&gt;regs[1]=0; _r-&gt;regs[2]=0; _r-&gt;regs[3]=0; \</span>
<span class="cp">       _r-&gt;regs[4]=0; _r-&gt;regs[5]=0; _r-&gt;regs[6]=0; _r-&gt;regs[7]=0; \</span>
<span class="cp">       _r-&gt;regs[8]=0; _r-&gt;regs[9]=0; _r-&gt;regs[10]=0; _r-&gt;regs[11]=0; \</span>
<span class="cp">       _r-&gt;regs[12]=0; _r-&gt;regs[13]=0; _r-&gt;regs[14]=0; _r-&gt;regs[15]=0; \</span>
<span class="cp">       _r-&gt;regs[16]=0; _r-&gt;regs[17]=0; _r-&gt;regs[18]=0; _r-&gt;regs[19]=0; \</span>
<span class="cp">       _r-&gt;regs[20]=0; _r-&gt;regs[21]=0; _r-&gt;regs[22]=0; _r-&gt;regs[23]=0; \</span>
<span class="cp">       _r-&gt;regs[24]=0; _r-&gt;regs[25]=0; _r-&gt;regs[26]=0; _r-&gt;regs[27]=0; \</span>
<span class="cp">       _r-&gt;regs[28]=0; _r-&gt;regs[29]=0; _r-&gt;regs[30]=0; _r-&gt;regs[31]=0; \</span>
<span class="cp">       _r-&gt;regs[32]=0; _r-&gt;regs[33]=0; _r-&gt;regs[34]=0; _r-&gt;regs[35]=0; \</span>
<span class="cp">       _r-&gt;regs[36]=0; _r-&gt;regs[37]=0; _r-&gt;regs[38]=0; _r-&gt;regs[39]=0; \</span>
<span class="cp">       _r-&gt;regs[40]=0; _r-&gt;regs[41]=0; _r-&gt;regs[42]=0; _r-&gt;regs[43]=0; \</span>
<span class="cp">       _r-&gt;regs[44]=0; _r-&gt;regs[45]=0; _r-&gt;regs[46]=0; _r-&gt;regs[47]=0; \</span>
<span class="cp">       _r-&gt;regs[48]=0; _r-&gt;regs[49]=0; _r-&gt;regs[50]=0; _r-&gt;regs[51]=0; \</span>
<span class="cp">       _r-&gt;regs[52]=0; _r-&gt;regs[53]=0; _r-&gt;regs[54]=0; _r-&gt;regs[55]=0; \</span>
<span class="cp">       _r-&gt;regs[56]=0; _r-&gt;regs[57]=0; _r-&gt;regs[58]=0; _r-&gt;regs[59]=0; \</span>
<span class="cp">       _r-&gt;regs[60]=0; _r-&gt;regs[61]=0; _r-&gt;regs[62]=0; \</span>
<span class="cp">       _r-&gt;tregs[0]=0; _r-&gt;tregs[1]=0; _r-&gt;tregs[2]=0; _r-&gt;tregs[3]=0; \</span>
<span class="cp">       _r-&gt;tregs[4]=0; _r-&gt;tregs[5]=0; _r-&gt;tregs[6]=0; _r-&gt;tregs[7]=0; \</span>
<span class="cp">       _r-&gt;sr = SR_FD | SR_MMU; } while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define ELF_PLAT_INIT(_r, load_addr) \</span>
<span class="cp">  do { _r-&gt;regs[0]=0; _r-&gt;regs[1]=0; _r-&gt;regs[2]=0; _r-&gt;regs[3]=0; \</span>
<span class="cp">       _r-&gt;regs[4]=0; _r-&gt;regs[5]=0; _r-&gt;regs[6]=0; _r-&gt;regs[7]=0; \</span>
<span class="cp">       _r-&gt;regs[8]=0; _r-&gt;regs[9]=0; _r-&gt;regs[10]=0; _r-&gt;regs[11]=0; \</span>
<span class="cp">       _r-&gt;regs[12]=0; _r-&gt;regs[13]=0; _r-&gt;regs[14]=0; \</span>
<span class="cp">       _r-&gt;sr = SR_FD; } while (0)</span>

<span class="cp">#define ELF_FDPIC_PLAT_INIT(_r, _exec_map_addr, _interp_map_addr,	\</span>
<span class="cp">			    _dynamic_addr)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	_r-&gt;regs[0]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[1]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[2]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[3]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[4]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[5]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[6]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[7]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[8]	= _exec_map_addr;				\</span>
<span class="cp">	_r-&gt;regs[9]	= _interp_map_addr;				\</span>
<span class="cp">	_r-&gt;regs[10]	= _dynamic_addr;				\</span>
<span class="cp">	_r-&gt;regs[11]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[12]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[13]	= 0;						\</span>
<span class="cp">	_r-&gt;regs[14]	= 0;						\</span>
<span class="cp">	_r-&gt;sr		= SR_FD;					\</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define SET_PERSONALITY(ex) set_personality(PER_LINUX_32BIT)</span>

<span class="cp">#ifdef CONFIG_VSYSCALL</span>
<span class="cm">/* vDSO has arch_setup_additional_pages */</span>
<span class="cp">#define ARCH_HAS_SETUP_ADDITIONAL_PAGES</span>
<span class="k">struct</span> <span class="n">linux_binprm</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">arch_setup_additional_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">uses_interp</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vdso_enabled</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__kernel_vsyscall</span><span class="p">;</span>

<span class="cp">#define VDSO_BASE		((unsigned long)current-&gt;mm-&gt;context.vdso)</span>
<span class="cp">#define VDSO_SYM(x)		(VDSO_BASE + (unsigned long)(x))</span>

<span class="cp">#define VSYSCALL_AUX_ENT					\</span>
<span class="cp">	if (vdso_enabled)					\</span>
<span class="cp">		NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_BASE);	\</span>
<span class="cp">	else							\</span>
<span class="cp">		NEW_AUX_ENT(AT_IGNORE, 0);</span>
<span class="cp">#else</span>
<span class="cp">#define VSYSCALL_AUX_ENT</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSYSCALL */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SH_FPU</span>
<span class="cp">#define FPU_AUX_ENT	NEW_AUX_ENT(AT_FPUCW, FPSCR_INIT)</span>
<span class="cp">#else</span>
<span class="cp">#define FPU_AUX_ENT	NEW_AUX_ENT(AT_IGNORE, 0)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">l1i_cache_shape</span><span class="p">,</span> <span class="n">l1d_cache_shape</span><span class="p">,</span> <span class="n">l2_cache_shape</span><span class="p">;</span>

<span class="cm">/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
<span class="cp">#define ARCH_DLINFO						\</span>
<span class="cp">do {								\</span>
<span class="cp">	</span><span class="cm">/* Optional FPU initialization */</span><span class="cp">			\</span>
<span class="cp">	FPU_AUX_ENT;						\</span>
<span class="cp">								\</span>
<span class="cp">	</span><span class="cm">/* Optional vsyscall entry */</span><span class="cp">				\</span>
<span class="cp">	VSYSCALL_AUX_ENT;					\</span>
<span class="cp">								\</span>
<span class="cp">	</span><span class="cm">/* Cache desc */</span><span class="cp">					\</span>
<span class="cp">	NEW_AUX_ENT(AT_L1I_CACHESHAPE, l1i_cache_shape);	\</span>
<span class="cp">	NEW_AUX_ENT(AT_L1D_CACHESHAPE, l1d_cache_shape);	\</span>
<span class="cp">	NEW_AUX_ENT(AT_L2_CACHESHAPE, l2_cache_shape);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __ASM_SH_ELF_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
