<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sh › include › asm › pgtable_64.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable_64.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __ASM_SH_PGTABLE_64_H</span>
<span class="cp">#define __ASM_SH_PGTABLE_64_H</span>

<span class="cm">/*</span>
<span class="cm"> * include/asm-sh/pgtable_64.h</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains the functions and defines necessary to modify and use</span>
<span class="cm"> * the SuperH page table tree.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000, 2001  Paolo Alberelli</span>
<span class="cm"> * Copyright (C) 2003, 2004  Paul Mundt</span>
<span class="cm"> * Copyright (C) 2003, 2004  Richard Curnow</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Error outputs.</span>
<span class="cm"> */</span>
<span class="cp">#define pte_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pte %016Lx.\n&quot;, __FILE__, __LINE__, pte_val(e))</span>
<span class="cp">#define pgd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))</span>

<span class="cm">/*</span>
<span class="cm"> * Table setting routines. Used within arch/mm only.</span>
<span class="cm"> */</span>
<span class="cp">#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">pteptr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pteval</span><span class="p">.</span><span class="n">pte_low</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">xp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">pteptr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sign-extend based on NPHYS.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">NPHYS_SIGN</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="n">NPHYS_MASK</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)</span>

<span class="cm">/*</span>
<span class="cm"> * PGD defines. Top level.</span>
<span class="cm"> */</span>

<span class="cm">/* To find an entry in a generic PGD. */</span>
<span class="cp">#define pgd_index(address) (((address) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))</span>
<span class="cp">#define __pgd_offset(address) pgd_index(address)</span>
<span class="cp">#define pgd_offset(mm, address) ((mm)-&gt;pgd+pgd_index(address))</span>

<span class="cm">/* To find an entry in a kernel PGD. */</span>
<span class="cp">#define pgd_offset_k(address) pgd_offset(&amp;init_mm, address)</span>

<span class="cp">#define __pud_offset(address)	(((address) &gt;&gt; PUD_SHIFT) &amp; (PTRS_PER_PUD-1))</span>
<span class="cp">#define __pmd_offset(address)	(((address) &gt;&gt; PMD_SHIFT) &amp; (PTRS_PER_PMD-1))</span>

<span class="cm">/*</span>
<span class="cm"> * PMD level access routines. Same notes as above.</span>
<span class="cm"> */</span>
<span class="cp">#define _PMD_EMPTY		0x0</span>
<span class="cm">/* Either the PMD is empty or present, it&#39;s not paged out */</span>
<span class="cp">#define pmd_present(pmd_entry)	(pmd_val(pmd_entry) &amp; _PAGE_PRESENT)</span>
<span class="cp">#define pmd_clear(pmd_entry_p)	(set_pmd((pmd_entry_p), __pmd(_PMD_EMPTY)))</span>
<span class="cp">#define pmd_none(pmd_entry)	(pmd_val((pmd_entry)) == _PMD_EMPTY)</span>
<span class="cp">#define pmd_bad(pmd_entry)	((pmd_val(pmd_entry) &amp; (~PAGE_MASK &amp; ~_PAGE_USER)) != _KERNPG_TABLE)</span>

<span class="cp">#define pmd_page_vaddr(pmd_entry) \</span>
<span class="cp">	((unsigned long) __va(pmd_val(pmd_entry) &amp; PAGE_MASK))</span>

<span class="cp">#define pmd_page(pmd) \</span>
<span class="cp">	(virt_to_page(pmd_val(pmd)))</span>

<span class="cm">/* PMD to PTE dereferencing */</span>
<span class="cp">#define pte_index(address) \</span>
<span class="cp">		((address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))</span>

<span class="cp">#define __pte_offset(address)	pte_index(address)</span>

<span class="cp">#define pte_offset_kernel(dir, addr) \</span>
<span class="cp">		((pte_t *) ((pmd_val(*(dir))) &amp; PAGE_MASK) + pte_index((addr)))</span>

<span class="cp">#define pte_offset_map(dir,addr)	pte_offset_kernel(dir, addr)</span>
<span class="cp">#define pte_unmap(pte)		do { } while (0)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cm">/*</span>
<span class="cm"> * PTEL coherent flags.</span>
<span class="cm"> * See Chapter 17 ST50 CPU Core Volume 1, Architecture.</span>
<span class="cm"> */</span>
<span class="cm">/* The bits that are required in the SH-5 TLB are placed in the h/w-defined</span>
<span class="cm">   positions, to avoid expensive bit shuffling on every refill.  The remaining</span>
<span class="cm">   bits are used for s/w purposes and masked out on each refill.</span>

<span class="cm">   Note, the PTE slots are used to hold data of type swp_entry_t when a page is</span>
<span class="cm">   swapped out.  Only the _PAGE_PRESENT flag is significant when the page is</span>
<span class="cm">   swapped out, and it must be placed so that it doesn&#39;t overlap either the</span>
<span class="cm">   type or offset fields of swp_entry_t.  For x86, offset is at [31:8] and type</span>
<span class="cm">   at [6:1], with _PAGE_PRESENT at bit 0 for both pte_t and swp_entry_t.  This</span>
<span class="cm">   scheme doesn&#39;t map to SH-5 because bit [0] controls cacheability.  So bit</span>
<span class="cm">   [2] is used for _PAGE_PRESENT and the type field of swp_entry_t is split</span>
<span class="cm">   into 2 pieces.  That is handled by SWP_ENTRY and SWP_TYPE below. */</span>
<span class="cp">#define _PAGE_WT	0x001  </span><span class="cm">/* CB0: if cacheable, 1-&gt;write-thru, 0-&gt;write-back */</span><span class="cp"></span>
<span class="cp">#define _PAGE_DEVICE	0x001  </span><span class="cm">/* CB0: if uncacheable, 1-&gt;device (i.e. no write-combining or reordering at bus level) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_CACHABLE	0x002  </span><span class="cm">/* CB1: uncachable/cachable */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PRESENT	0x004  </span><span class="cm">/* software: page referenced */</span><span class="cp"></span>
<span class="cp">#define _PAGE_FILE	0x004  </span><span class="cm">/* software: only when !present */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SIZE0	0x008  </span><span class="cm">/* SZ0-bit : size of page */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SIZE1	0x010  </span><span class="cm">/* SZ1-bit : size of page */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SHARED	0x020  </span><span class="cm">/* software: reflects PTEH&#39;s SH */</span><span class="cp"></span>
<span class="cp">#define _PAGE_READ	0x040  </span><span class="cm">/* PR0-bit : read access allowed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_EXECUTE	0x080  </span><span class="cm">/* PR1-bit : execute access allowed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_WRITE	0x100  </span><span class="cm">/* PR2-bit : write access allowed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_USER	0x200  </span><span class="cm">/* PR3-bit : user space access allowed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_DIRTY	0x400  </span><span class="cm">/* software: page accessed in write */</span><span class="cp"></span>
<span class="cp">#define _PAGE_ACCESSED	0x800  </span><span class="cm">/* software: page referenced */</span><span class="cp"></span>

<span class="cm">/* Wrapper for extended mode pgprot twiddling */</span>
<span class="cp">#define _PAGE_EXT(x)		((unsigned long long)(x) &lt;&lt; 32)</span>

<span class="cm">/*</span>
<span class="cm"> * We can use the sign-extended bits in the PTEL to get 32 bits of</span>
<span class="cm"> * software flags. This works for now because no implementations uses</span>
<span class="cm"> * anything above the PPN field.</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_WIRED	_PAGE_EXT(0x001) </span><span class="cm">/* software: wire the tlb entry */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SPECIAL	_PAGE_EXT(0x002)</span>

<span class="cp">#define _PAGE_CLEAR_FLAGS	(_PAGE_PRESENT | _PAGE_FILE | _PAGE_SHARED | \</span>
<span class="cp">				 _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_WIRED)</span>

<span class="cm">/* Mask which drops software flags */</span>
<span class="cp">#define _PAGE_FLAGS_HARDWARE_MASK	(NEFF_MASK &amp; ~(_PAGE_CLEAR_FLAGS))</span>

<span class="cm">/*</span>
<span class="cm"> * HugeTLB support</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_HUGETLB_PAGE_SIZE_64K)</span>
<span class="cp">#define _PAGE_SZHUGE	(_PAGE_SIZE0)</span>
<span class="cp">#elif defined(CONFIG_HUGETLB_PAGE_SIZE_1MB)</span>
<span class="cp">#define _PAGE_SZHUGE	(_PAGE_SIZE1)</span>
<span class="cp">#elif defined(CONFIG_HUGETLB_PAGE_SIZE_512MB)</span>
<span class="cp">#define _PAGE_SZHUGE	(_PAGE_SIZE0 | _PAGE_SIZE1)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Stub out _PAGE_SZHUGE if we don&#39;t have a good definition for it,</span>
<span class="cm"> * to make pte_mkhuge() happy.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _PAGE_SZHUGE</span>
<span class="cp"># define _PAGE_SZHUGE	(0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Default flags for a Kernel page.</span>
<span class="cm"> * This is fundametally also SHARED because the main use of this define</span>
<span class="cm"> * (other than for PGD/PMD entries) is for the VMALLOC pool which is</span>
<span class="cm"> * contextless.</span>
<span class="cm"> *</span>
<span class="cm"> * _PAGE_EXECUTE is required for modules</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define _KERNPG_TABLE	(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | \</span>
<span class="cp">			 _PAGE_EXECUTE | \</span>
<span class="cp">			 _PAGE_CACHABLE | _PAGE_ACCESSED | _PAGE_DIRTY | \</span>
<span class="cp">			 _PAGE_SHARED)</span>

<span class="cm">/* Default flags for a User page */</span>
<span class="cp">#define _PAGE_TABLE	(_KERNPG_TABLE | _PAGE_USER)</span>

<span class="cp">#define _PAGE_CHG_MASK	(PTE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY | \</span>
<span class="cp">			 _PAGE_SPECIAL)</span>

<span class="cm">/*</span>
<span class="cm"> * We have full permissions (Read/Write/Execute/Shared).</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_COMMON	(_PAGE_PRESENT | _PAGE_USER | \</span>
<span class="cp">			 _PAGE_CACHABLE | _PAGE_ACCESSED)</span>

<span class="cp">#define PAGE_NONE	__pgprot(_PAGE_CACHABLE | _PAGE_ACCESSED)</span>
<span class="cp">#define PAGE_SHARED	__pgprot(_PAGE_COMMON | _PAGE_READ | _PAGE_WRITE | \</span>
<span class="cp">				 _PAGE_SHARED)</span>
<span class="cp">#define PAGE_EXECREAD	__pgprot(_PAGE_COMMON | _PAGE_READ | _PAGE_EXECUTE)</span>

<span class="cm">/*</span>
<span class="cm"> * We need to include PAGE_EXECUTE in PAGE_COPY because it is the default</span>
<span class="cm"> * protection mode for the stack.</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_COPY	PAGE_EXECREAD</span>

<span class="cp">#define PAGE_READONLY	__pgprot(_PAGE_COMMON | _PAGE_READ)</span>
<span class="cp">#define PAGE_WRITEONLY	__pgprot(_PAGE_COMMON | _PAGE_WRITE)</span>
<span class="cp">#define PAGE_RWX	__pgprot(_PAGE_COMMON | _PAGE_READ | \</span>
<span class="cp">				 _PAGE_WRITE | _PAGE_EXECUTE)</span>
<span class="cp">#define PAGE_KERNEL	__pgprot(_KERNPG_TABLE)</span>

<span class="cp">#define PAGE_KERNEL_NOCACHE \</span>
<span class="cp">			__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | \</span>
<span class="cp">				 _PAGE_EXECUTE | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_DIRTY | _PAGE_SHARED)</span>

<span class="cm">/* Make it a device mapping for maximum safety (e.g. for mapping device</span>
<span class="cm">   registers into user-space via /dev/map).  */</span>
<span class="cp">#define pgprot_noncached(x) __pgprot(((x).pgprot &amp; ~(_PAGE_CACHABLE)) | _PAGE_DEVICE)</span>
<span class="cp">#define pgprot_writecombine(prot) __pgprot(pgprot_val(prot) &amp; ~_PAGE_CACHABLE)</span>

<span class="cm">/*</span>
<span class="cm"> * PTE level access routines.</span>
<span class="cm"> *</span>
<span class="cm"> * Note1:</span>
<span class="cm"> * It&#39;s the tree walk leaf. This is physical address to be stored.</span>
<span class="cm"> *</span>
<span class="cm"> * Note 2:</span>
<span class="cm"> * Regarding the choice of _PTE_EMPTY:</span>

<span class="cm">   We must choose a bit pattern that cannot be valid, whether or not the page</span>
<span class="cm">   is present.  bit[2]==1 =&gt; present, bit[2]==0 =&gt; swapped out.  If swapped</span>
<span class="cm">   out, bits [31:8], [6:3], [1:0] are under swapper control, so only bit[7] is</span>
<span class="cm">   left for us to select.  If we force bit[7]==0 when swapped out, we could use</span>
<span class="cm">   the combination bit[7,2]=2&#39;b10 to indicate an empty PTE.  Alternatively, if</span>
<span class="cm">   we force bit[7]==1 when swapped out, we can use all zeroes to indicate</span>
<span class="cm">   empty.  This is convenient, because the page tables get cleared to zero</span>
<span class="cm">   when they are allocated.</span>

<span class="cm"> */</span>
<span class="cp">#define _PTE_EMPTY	0x0</span>
<span class="cp">#define pte_present(x)	(pte_val(x) &amp; _PAGE_PRESENT)</span>
<span class="cp">#define pte_clear(mm,addr,xp)	(set_pte_at(mm, addr, xp, __pte(_PTE_EMPTY)))</span>
<span class="cp">#define pte_none(x)	(pte_val(x) == _PTE_EMPTY)</span>

<span class="cm">/*</span>
<span class="cm"> * Some definitions to translate between mem_map, PTEs, and page</span>
<span class="cm"> * addresses:</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Given a PTE, return the index of the mem_map[] entry corresponding</span>
<span class="cm"> * to the page frame the PTE. Get the absolute physical address, make</span>
<span class="cm"> * a relative physical address and translate it to an index.</span>
<span class="cm"> */</span>
<span class="cp">#define pte_pagenr(x)		(((unsigned long) (pte_val(x)) - \</span>
<span class="cp">				 __MEMORY_START) &gt;&gt; PAGE_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * Given a PTE, return the &quot;struct page *&quot;.</span>
<span class="cm"> */</span>
<span class="cp">#define pte_page(x)		(mem_map + pte_pagenr(x))</span>

<span class="cm">/*</span>
<span class="cm"> * Return number of (down rounded) MB corresponding to x pages.</span>
<span class="cm"> */</span>
<span class="cp">#define pages_to_mb(x) ((x) &gt;&gt; (20-PAGE_SHIFT))</span>


<span class="cm">/*</span>
<span class="cm"> * The following have defined behavior only work if pte_present() is true.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_dirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_DIRTY</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_young</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_file</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_FILE</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_write</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_WRITE</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pte_special</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">){</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SPECIAL</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_WRITE</span><span class="p">));</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="n">pte_mkclean</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_DIRTY</span><span class="p">));</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="n">pte_mkold</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_ACCESSED</span><span class="p">));</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="n">pte_mkwrite</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_WRITE</span><span class="p">));</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_DIRTY</span><span class="p">));</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="n">pte_mkyoung</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_ACCESSED</span><span class="p">));</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="n">pte_mkhuge</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_SZHUGE</span><span class="p">));</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="n">pte_mkspecial</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_SPECIAL</span><span class="p">));</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Conversion functions: convert a page and protection to a page entry.</span>
<span class="cm"> *</span>
<span class="cm"> * extern pte_t mk_pte(struct page *page, pgprot_t pgprot)</span>
<span class="cm"> */</span>
<span class="cp">#define mk_pte(page,pgprot)							\</span>
<span class="cp">({										\</span>
<span class="cp">	pte_t __pte;								\</span>
<span class="cp">										\</span>
<span class="cp">	set_pte(&amp;__pte, __pte((((page)-mem_map) &lt;&lt; PAGE_SHIFT) | 		\</span>
<span class="cp">		__MEMORY_START | pgprot_val((pgprot))));			\</span>
<span class="cp">	__pte;									\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * This takes a (absolute) physical page address that is used</span>
<span class="cm"> * by the remapping functions</span>
<span class="cm"> */</span>
<span class="cp">#define mk_pte_phys(physpage, pgprot) \</span>
<span class="cp">({ pte_t __pte; set_pte(&amp;__pte, __pte(physpage | pgprot_val(pgprot))); __pte; })</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="n">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span> <span class="n">set_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">__pte</span><span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_CHG_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">newprot</span><span class="p">)));</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Encode and decode a swap entry */</span>
<span class="cp">#define __swp_type(x)			(((x).val &amp; 3) + (((x).val &gt;&gt; 1) &amp; 0x3c))</span>
<span class="cp">#define __swp_offset(x)			((x).val &gt;&gt; 8)</span>
<span class="cp">#define __swp_entry(type, offset)	((swp_entry_t) { ((offset &lt;&lt; 8) + ((type &amp; 0x3c) &lt;&lt; 1) + (type &amp; 3)) })</span>
<span class="cp">#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })</span>
<span class="cp">#define __swp_entry_to_pte(x)		((pte_t) { (x).val })</span>

<span class="cm">/* Encode and decode a nonlinear file mapping entry */</span>
<span class="cp">#define PTE_FILE_MAX_BITS		29</span>
<span class="cp">#define pte_to_pgoff(pte)		(pte_val(pte))</span>
<span class="cp">#define pgoff_to_pte(off)		((pte_t) { (off) | _PAGE_FILE })</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define pfn_pte(pfn, prot)	__pte(((pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot))</span>
<span class="cp">#define pfn_pmd(pfn, prot)	__pmd(((pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot))</span>

<span class="cp">#endif </span><span class="cm">/* __ASM_SH_PGTABLE_64_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
