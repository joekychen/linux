<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sh › include › asm › pgtable_32.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable_32.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __ASM_SH_PGTABLE_32_H</span>
<span class="cp">#define __ASM_SH_PGTABLE_32_H</span>

<span class="cm">/*</span>
<span class="cm"> * Linux PTEL encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware and software bit definitions for the PTEL value (see below for</span>
<span class="cm"> * notes on SH-X2 MMUs and 64-bit PTEs):</span>
<span class="cm"> *</span>
<span class="cm"> * - Bits 0 and 7 are reserved on SH-3 (_PAGE_WT and _PAGE_SZ1 on SH-4).</span>
<span class="cm"> *</span>
<span class="cm"> * - Bit 1 is the SH-bit, but is unused on SH-3 due to an MMU bug (the</span>
<span class="cm"> *   hardware PTEL value can&#39;t have the SH-bit set when MMUCR.IX is set,</span>
<span class="cm"> *   which is the default in cpu-sh3/mmu_context.h:MMU_CONTROL_INIT).</span>
<span class="cm"> *</span>
<span class="cm"> *   In order to keep this relatively clean, do not use these for defining</span>
<span class="cm"> *   SH-3 specific flags until all of the other unused bits have been</span>
<span class="cm"> *   exhausted.</span>
<span class="cm"> *</span>
<span class="cm"> * - Bit 9 is reserved by everyone and used by _PAGE_PROTNONE.</span>
<span class="cm"> *</span>
<span class="cm"> * - Bits 10 and 11 are low bits of the PPN that are reserved on &gt;= 4K pages.</span>
<span class="cm"> *   Bit 10 is used for _PAGE_ACCESSED, and bit 11 is used for _PAGE_SPECIAL.</span>
<span class="cm"> *</span>
<span class="cm"> * - On 29 bit platforms, bits 31 to 29 are used for the space attributes</span>
<span class="cm"> *   and timing control which (together with bit 0) are moved into the</span>
<span class="cm"> *   old-style PTEA on the parts that support it.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX: Leave the _PAGE_FILE and _PAGE_WT overhaul for a rainy day.</span>
<span class="cm"> *</span>
<span class="cm"> * SH-X2 MMUs and extended PTEs</span>
<span class="cm"> *</span>
<span class="cm"> * SH-X2 supports an extended mode TLB with split data arrays due to the</span>
<span class="cm"> * number of bits needed for PR and SZ (now EPR and ESZ) encodings. The PR and</span>
<span class="cm"> * SZ bit placeholders still exist in data array 1, but are implemented as</span>
<span class="cm"> * reserved bits, with the real logic existing in data array 2.</span>
<span class="cm"> *</span>
<span class="cm"> * The downside to this is that we can no longer fit everything in to a 32-bit</span>
<span class="cm"> * PTE encoding, so a 64-bit pte_t is necessary for these parts. On the plus</span>
<span class="cm"> * side, this gives us quite a few spare bits to play with for future usage.</span>
<span class="cm"> */</span>
<span class="cm">/* Legacy and compat mode bits */</span>
<span class="cp">#define	_PAGE_WT	0x001		</span><span class="cm">/* WT-bit on SH-4, 0 on SH-3 */</span><span class="cp"></span>
<span class="cp">#define _PAGE_HW_SHARED	0x002		</span><span class="cm">/* SH-bit  : shared among processes */</span><span class="cp"></span>
<span class="cp">#define _PAGE_DIRTY	0x004		</span><span class="cm">/* D-bit   : page changed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_CACHABLE	0x008		</span><span class="cm">/* C-bit   : cachable */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SZ0	0x010		</span><span class="cm">/* SZ0-bit : Size of page */</span><span class="cp"></span>
<span class="cp">#define _PAGE_RW	0x020		</span><span class="cm">/* PR0-bit : write access allowed */</span><span class="cp"></span>
<span class="cp">#define _PAGE_USER	0x040		</span><span class="cm">/* PR1-bit : user space access allowed*/</span><span class="cp"></span>
<span class="cp">#define _PAGE_SZ1	0x080		</span><span class="cm">/* SZ1-bit : Size of page (on SH-4) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PRESENT	0x100		</span><span class="cm">/* V-bit   : page is valid */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PROTNONE	0x200		</span><span class="cm">/* software: if not present  */</span><span class="cp"></span>
<span class="cp">#define _PAGE_ACCESSED	0x400		</span><span class="cm">/* software: page referenced */</span><span class="cp"></span>
<span class="cp">#define _PAGE_FILE	_PAGE_WT	</span><span class="cm">/* software: pagecache or swap? */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SPECIAL	0x800		</span><span class="cm">/* software: special page */</span><span class="cp"></span>

<span class="cp">#define _PAGE_SZ_MASK	(_PAGE_SZ0 | _PAGE_SZ1)</span>
<span class="cp">#define _PAGE_PR_MASK	(_PAGE_RW | _PAGE_USER)</span>

<span class="cm">/* Extended mode bits */</span>
<span class="cp">#define _PAGE_EXT_ESZ0		0x0010	</span><span class="cm">/* ESZ0-bit: Size of page */</span><span class="cp"></span>
<span class="cp">#define _PAGE_EXT_ESZ1		0x0020	</span><span class="cm">/* ESZ1-bit: Size of page */</span><span class="cp"></span>
<span class="cp">#define _PAGE_EXT_ESZ2		0x0040	</span><span class="cm">/* ESZ2-bit: Size of page */</span><span class="cp"></span>
<span class="cp">#define _PAGE_EXT_ESZ3		0x0080	</span><span class="cm">/* ESZ3-bit: Size of page */</span><span class="cp"></span>

<span class="cp">#define _PAGE_EXT_USER_EXEC	0x0100	</span><span class="cm">/* EPR0-bit: User space executable */</span><span class="cp"></span>
<span class="cp">#define _PAGE_EXT_USER_WRITE	0x0200	</span><span class="cm">/* EPR1-bit: User space writable */</span><span class="cp"></span>
<span class="cp">#define _PAGE_EXT_USER_READ	0x0400	</span><span class="cm">/* EPR2-bit: User space readable */</span><span class="cp"></span>

<span class="cp">#define _PAGE_EXT_KERN_EXEC	0x0800	</span><span class="cm">/* EPR3-bit: Kernel space executable */</span><span class="cp"></span>
<span class="cp">#define _PAGE_EXT_KERN_WRITE	0x1000	</span><span class="cm">/* EPR4-bit: Kernel space writable */</span><span class="cp"></span>
<span class="cp">#define _PAGE_EXT_KERN_READ	0x2000	</span><span class="cm">/* EPR5-bit: Kernel space readable */</span><span class="cp"></span>

<span class="cp">#define _PAGE_EXT_WIRED		0x4000	</span><span class="cm">/* software: Wire TLB entry */</span><span class="cp"></span>

<span class="cm">/* Wrapper for extended mode pgprot twiddling */</span>
<span class="cp">#define _PAGE_EXT(x)		((unsigned long long)(x) &lt;&lt; 32)</span>

<span class="cp">#ifdef CONFIG_X2TLB</span>
<span class="cp">#define _PAGE_PCC_MASK	0x00000000	</span><span class="cm">/* No legacy PTEA support */</span><span class="cp"></span>
<span class="cp">#else</span>

<span class="cm">/* software: moves to PTEA.TC (Timing Control) */</span>
<span class="cp">#define _PAGE_PCC_AREA5	0x00000000	</span><span class="cm">/* use BSC registers for area5 */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PCC_AREA6	0x80000000	</span><span class="cm">/* use BSC registers for area6 */</span><span class="cp"></span>

<span class="cm">/* software: moves to PTEA.SA[2:0] (Space Attributes) */</span>
<span class="cp">#define _PAGE_PCC_IODYN 0x00000001	</span><span class="cm">/* IO space, dynamically sized bus */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PCC_IO8	0x20000000	</span><span class="cm">/* IO space, 8 bit bus */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PCC_IO16	0x20000001	</span><span class="cm">/* IO space, 16 bit bus */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PCC_COM8	0x40000000	</span><span class="cm">/* Common Memory space, 8 bit bus */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PCC_COM16	0x40000001	</span><span class="cm">/* Common Memory space, 16 bit bus */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PCC_ATR8	0x60000000	</span><span class="cm">/* Attribute Memory space, 8 bit bus */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PCC_ATR16	0x60000001	</span><span class="cm">/* Attribute Memory space, 6 bit bus */</span><span class="cp"></span>

<span class="cp">#define _PAGE_PCC_MASK	0xe0000001</span>

<span class="cm">/* copy the ptea attributes */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_ptea_attributes</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xe</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Mask which drops unused bits from the PTEL value */</span>
<span class="cp">#if defined(CONFIG_CPU_SH3)</span>
<span class="cp">#define _PAGE_CLEAR_FLAGS	(_PAGE_PROTNONE | _PAGE_ACCESSED| \</span>
<span class="cp">				 _PAGE_FILE	| _PAGE_SZ1	| \</span>
<span class="cp">				 _PAGE_HW_SHARED)</span>
<span class="cp">#elif defined(CONFIG_X2TLB)</span>
<span class="cm">/* Get rid of the legacy PR/SZ bits when using extended mode */</span>
<span class="cp">#define _PAGE_CLEAR_FLAGS	(_PAGE_PROTNONE | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_FILE | _PAGE_PR_MASK | _PAGE_SZ_MASK)</span>
<span class="cp">#else</span>
<span class="cp">#define _PAGE_CLEAR_FLAGS	(_PAGE_PROTNONE | _PAGE_ACCESSED | _PAGE_FILE)</span>
<span class="cp">#endif</span>

<span class="cp">#define _PAGE_FLAGS_HARDWARE_MASK	(phys_addr_mask() &amp; ~(_PAGE_CLEAR_FLAGS))</span>

<span class="cm">/* Hardware flags, page size encoding */</span>
<span class="cp">#if !defined(CONFIG_MMU)</span>
<span class="cp"># define _PAGE_FLAGS_HARD	0ULL</span>
<span class="cp">#elif defined(CONFIG_X2TLB)</span>
<span class="cp"># if defined(CONFIG_PAGE_SIZE_4KB)</span>
<span class="cp">#  define _PAGE_FLAGS_HARD	_PAGE_EXT(_PAGE_EXT_ESZ0)</span>
<span class="cp"># elif defined(CONFIG_PAGE_SIZE_8KB)</span>
<span class="cp">#  define _PAGE_FLAGS_HARD	_PAGE_EXT(_PAGE_EXT_ESZ1)</span>
<span class="cp"># elif defined(CONFIG_PAGE_SIZE_64KB)</span>
<span class="cp">#  define _PAGE_FLAGS_HARD	_PAGE_EXT(_PAGE_EXT_ESZ2)</span>
<span class="cp"># endif</span>
<span class="cp">#else</span>
<span class="cp"># if defined(CONFIG_PAGE_SIZE_4KB)</span>
<span class="cp">#  define _PAGE_FLAGS_HARD	_PAGE_SZ0</span>
<span class="cp"># elif defined(CONFIG_PAGE_SIZE_64KB)</span>
<span class="cp">#  define _PAGE_FLAGS_HARD	_PAGE_SZ1</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_X2TLB)</span>
<span class="cp"># if defined(CONFIG_HUGETLB_PAGE_SIZE_64K)</span>
<span class="cp">#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ2)</span>
<span class="cp"># elif defined(CONFIG_HUGETLB_PAGE_SIZE_256K)</span>
<span class="cp">#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ0 | _PAGE_EXT_ESZ2)</span>
<span class="cp"># elif defined(CONFIG_HUGETLB_PAGE_SIZE_1MB)</span>
<span class="cp">#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ0 | _PAGE_EXT_ESZ1 | _PAGE_EXT_ESZ2)</span>
<span class="cp"># elif defined(CONFIG_HUGETLB_PAGE_SIZE_4MB)</span>
<span class="cp">#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ3)</span>
<span class="cp"># elif defined(CONFIG_HUGETLB_PAGE_SIZE_64MB)</span>
<span class="cp">#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ2 | _PAGE_EXT_ESZ3)</span>
<span class="cp"># endif</span>
<span class="cp"># define _PAGE_WIRED	(_PAGE_EXT(_PAGE_EXT_WIRED))</span>
<span class="cp">#else</span>
<span class="cp"># if defined(CONFIG_HUGETLB_PAGE_SIZE_64K)</span>
<span class="cp">#  define _PAGE_SZHUGE	(_PAGE_SZ1)</span>
<span class="cp"># elif defined(CONFIG_HUGETLB_PAGE_SIZE_1MB)</span>
<span class="cp">#  define _PAGE_SZHUGE	(_PAGE_SZ0 | _PAGE_SZ1)</span>
<span class="cp"># endif</span>
<span class="cp"># define _PAGE_WIRED	(0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Stub out _PAGE_SZHUGE if we don&#39;t have a good definition for it,</span>
<span class="cm"> * to make pte_mkhuge() happy.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _PAGE_SZHUGE</span>
<span class="cp"># define _PAGE_SZHUGE	(_PAGE_FLAGS_HARD)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Mask of bits that are to be preserved across pgprot changes.</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_CHG_MASK \</span>
<span class="cp">	(PTE_MASK | _PAGE_ACCESSED | _PAGE_CACHABLE | \</span>
<span class="cp">	 _PAGE_DIRTY | _PAGE_SPECIAL)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#if defined(CONFIG_X2TLB) </span><span class="cm">/* SH-X2 TLB */</span><span class="cp"></span>
<span class="cp">#define PAGE_NONE	__pgprot(_PAGE_PROTNONE | _PAGE_CACHABLE | \</span>
<span class="cp">				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD)</span>

<span class="cp">#define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \</span>
<span class="cp">				 _PAGE_EXT(_PAGE_EXT_KERN_READ  | \</span>
<span class="cp">					   _PAGE_EXT_KERN_WRITE | \</span>
<span class="cp">					   _PAGE_EXT_USER_READ  | \</span>
<span class="cp">					   _PAGE_EXT_USER_WRITE))</span>

<span class="cp">#define PAGE_EXECREAD	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \</span>
<span class="cp">				 _PAGE_EXT(_PAGE_EXT_KERN_EXEC | \</span>
<span class="cp">					   _PAGE_EXT_KERN_READ | \</span>
<span class="cp">					   _PAGE_EXT_USER_EXEC | \</span>
<span class="cp">					   _PAGE_EXT_USER_READ))</span>

<span class="cp">#define PAGE_COPY	PAGE_EXECREAD</span>

<span class="cp">#define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \</span>
<span class="cp">				 _PAGE_EXT(_PAGE_EXT_KERN_READ | \</span>
<span class="cp">					   _PAGE_EXT_USER_READ))</span>

<span class="cp">#define PAGE_WRITEONLY	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \</span>
<span class="cp">				 _PAGE_EXT(_PAGE_EXT_KERN_WRITE | \</span>
<span class="cp">					   _PAGE_EXT_USER_WRITE))</span>

<span class="cp">#define PAGE_RWX	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \</span>
<span class="cp">				 _PAGE_EXT(_PAGE_EXT_KERN_WRITE | \</span>
<span class="cp">					   _PAGE_EXT_KERN_READ  | \</span>
<span class="cp">					   _PAGE_EXT_KERN_EXEC  | \</span>
<span class="cp">					   _PAGE_EXT_USER_WRITE | \</span>
<span class="cp">					   _PAGE_EXT_USER_READ  | \</span>
<span class="cp">					   _PAGE_EXT_USER_EXEC))</span>

<span class="cp">#define PAGE_KERNEL	__pgprot(_PAGE_PRESENT | _PAGE_CACHABLE | \</span>
<span class="cp">				 _PAGE_DIRTY | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_HW_SHARED | _PAGE_FLAGS_HARD | \</span>
<span class="cp">				 _PAGE_EXT(_PAGE_EXT_KERN_READ | \</span>
<span class="cp">					   _PAGE_EXT_KERN_WRITE | \</span>
<span class="cp">					   _PAGE_EXT_KERN_EXEC))</span>

<span class="cp">#define PAGE_KERNEL_NOCACHE \</span>
<span class="cp">			__pgprot(_PAGE_PRESENT | _PAGE_DIRTY | \</span>
<span class="cp">				 _PAGE_ACCESSED | _PAGE_HW_SHARED | \</span>
<span class="cp">				 _PAGE_FLAGS_HARD | \</span>
<span class="cp">				 _PAGE_EXT(_PAGE_EXT_KERN_READ | \</span>
<span class="cp">					   _PAGE_EXT_KERN_WRITE | \</span>
<span class="cp">					   _PAGE_EXT_KERN_EXEC))</span>

<span class="cp">#define PAGE_KERNEL_RO	__pgprot(_PAGE_PRESENT | _PAGE_CACHABLE | \</span>
<span class="cp">				 _PAGE_DIRTY | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_HW_SHARED | _PAGE_FLAGS_HARD | \</span>
<span class="cp">				 _PAGE_EXT(_PAGE_EXT_KERN_READ | \</span>
<span class="cp">					   _PAGE_EXT_KERN_EXEC))</span>

<span class="cp">#define PAGE_KERNEL_PCC(slot, type) \</span>
<span class="cp">			__pgprot(0)</span>

<span class="cp">#elif defined(CONFIG_MMU) </span><span class="cm">/* SH-X TLB */</span><span class="cp"></span>
<span class="cp">#define PAGE_NONE	__pgprot(_PAGE_PROTNONE | _PAGE_CACHABLE | \</span>
<span class="cp">				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD)</span>

<span class="cp">#define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | \</span>
<span class="cp">				 _PAGE_CACHABLE | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_FLAGS_HARD)</span>

<span class="cp">#define PAGE_COPY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_CACHABLE | \</span>
<span class="cp">				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD)</span>

<span class="cp">#define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_CACHABLE | \</span>
<span class="cp">				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD)</span>

<span class="cp">#define PAGE_EXECREAD	PAGE_READONLY</span>
<span class="cp">#define PAGE_RWX	PAGE_SHARED</span>
<span class="cp">#define PAGE_WRITEONLY	PAGE_SHARED</span>

<span class="cp">#define PAGE_KERNEL	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_CACHABLE | \</span>
<span class="cp">				 _PAGE_DIRTY | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_HW_SHARED | _PAGE_FLAGS_HARD)</span>

<span class="cp">#define PAGE_KERNEL_NOCACHE \</span>
<span class="cp">			__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | \</span>
<span class="cp">				 _PAGE_ACCESSED | _PAGE_HW_SHARED | \</span>
<span class="cp">				 _PAGE_FLAGS_HARD)</span>

<span class="cp">#define PAGE_KERNEL_RO	__pgprot(_PAGE_PRESENT | _PAGE_CACHABLE | \</span>
<span class="cp">				 _PAGE_DIRTY | _PAGE_ACCESSED | \</span>
<span class="cp">				 _PAGE_HW_SHARED | _PAGE_FLAGS_HARD)</span>

<span class="cp">#define PAGE_KERNEL_PCC(slot, type) \</span>
<span class="cp">			__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | \</span>
<span class="cp">				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD | \</span>
<span class="cp">				 (slot ? _PAGE_PCC_AREA5 : _PAGE_PCC_AREA6) | \</span>
<span class="cp">				 (type))</span>
<span class="cp">#else </span><span class="cm">/* no mmu */</span><span class="cp"></span>
<span class="cp">#define PAGE_NONE		__pgprot(0)</span>
<span class="cp">#define PAGE_SHARED		__pgprot(0)</span>
<span class="cp">#define PAGE_COPY		__pgprot(0)</span>
<span class="cp">#define PAGE_EXECREAD		__pgprot(0)</span>
<span class="cp">#define PAGE_RWX		__pgprot(0)</span>
<span class="cp">#define PAGE_READONLY		__pgprot(0)</span>
<span class="cp">#define PAGE_WRITEONLY		__pgprot(0)</span>
<span class="cp">#define PAGE_KERNEL		__pgprot(0)</span>
<span class="cp">#define PAGE_KERNEL_NOCACHE	__pgprot(0)</span>
<span class="cp">#define PAGE_KERNEL_RO		__pgprot(0)</span>

<span class="cp">#define PAGE_KERNEL_PCC(slot, type) \</span>
<span class="cp">				__pgprot(0)</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/*</span>
<span class="cm"> * Certain architectures need to do special things when PTEs</span>
<span class="cm"> * within a page table are directly modified.  Thus, the following</span>
<span class="cm"> * hook is made available.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X2TLB</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ptep</span><span class="o">-&gt;</span><span class="n">pte_high</span> <span class="o">=</span> <span class="n">pte</span><span class="p">.</span><span class="n">pte_high</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">ptep</span><span class="o">-&gt;</span><span class="n">pte_low</span> <span class="o">=</span> <span class="n">pte</span><span class="p">.</span><span class="n">pte_low</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define set_pte(pteptr, pteval) (*(pteptr) = pteval)</span>
<span class="cp">#endif</span>

<span class="cp">#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)</span>

<span class="cm">/*</span>
<span class="cm"> * (pmds are folded into pgds so this doesn&#39;t get actually called,</span>
<span class="cm"> * but the define is needed for a generic inline function.)</span>
<span class="cm"> */</span>
<span class="cp">#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)</span>

<span class="cp">#define pfn_pte(pfn, prot) \</span>
<span class="cp">	__pte(((unsigned long long)(pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot))</span>
<span class="cp">#define pfn_pmd(pfn, prot) \</span>
<span class="cp">	__pmd(((unsigned long long)(pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot))</span>

<span class="cp">#define pte_none(x)		(!pte_val(x))</span>
<span class="cp">#define pte_present(x)		((x).pte_low &amp; (_PAGE_PRESENT | _PAGE_PROTNONE))</span>

<span class="cp">#define pte_clear(mm,addr,xp) do { set_pte_at(mm, addr, xp, __pte(0)); } while (0)</span>

<span class="cp">#define pmd_none(x)	(!pmd_val(x))</span>
<span class="cp">#define pmd_present(x)	(pmd_val(x))</span>
<span class="cp">#define pmd_clear(xp)	do { set_pmd(xp, __pmd(0)); } while (0)</span>
<span class="cp">#define	pmd_bad(x)	(pmd_val(x) &amp; ~PAGE_MASK)</span>

<span class="cp">#define pages_to_mb(x)	((x) &gt;&gt; (20-PAGE_SHIFT))</span>
<span class="cp">#define pte_page(x)	pfn_to_page(pte_pfn(x))</span>

<span class="cm">/*</span>
<span class="cm"> * The following only work if pte_present() is true.</span>
<span class="cm"> * Undefined behaviour if not..</span>
<span class="cm"> */</span>
<span class="cp">#define pte_not_present(pte)	(!((pte).pte_low &amp; _PAGE_PRESENT))</span>
<span class="cp">#define pte_dirty(pte)		((pte).pte_low &amp; _PAGE_DIRTY)</span>
<span class="cp">#define pte_young(pte)		((pte).pte_low &amp; _PAGE_ACCESSED)</span>
<span class="cp">#define pte_file(pte)		((pte).pte_low &amp; _PAGE_FILE)</span>
<span class="cp">#define pte_special(pte)	((pte).pte_low &amp; _PAGE_SPECIAL)</span>

<span class="cp">#ifdef CONFIG_X2TLB</span>
<span class="cp">#define pte_write(pte) \</span>
<span class="cp">	((pte).pte_high &amp; (_PAGE_EXT_USER_WRITE | _PAGE_EXT_KERN_WRITE))</span>
<span class="cp">#else</span>
<span class="cp">#define pte_write(pte)		((pte).pte_low &amp; _PAGE_RW)</span>
<span class="cp">#endif</span>

<span class="cp">#define PTE_BIT_FUNC(h,fn,op) \</span>
<span class="cp">static inline pte_t pte_##fn(pte_t pte) { pte.pte_##h op; return pte; }</span>

<span class="cp">#ifdef CONFIG_X2TLB</span>
<span class="cm">/*</span>
<span class="cm"> * We cheat a bit in the SH-X2 TLB case. As the permission bits are</span>
<span class="cm"> * individually toggled (and user permissions are entirely decoupled from</span>
<span class="cm"> * kernel permissions), we attempt to couple them a bit more sanely here.</span>
<span class="cm"> */</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">wrprotect</span><span class="p">,</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">_PAGE_EXT_USER_WRITE</span> <span class="o">|</span> <span class="n">_PAGE_EXT_KERN_WRITE</span><span class="p">));</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">mkwrite</span><span class="p">,</span> <span class="o">|=</span> <span class="n">_PAGE_EXT_USER_WRITE</span> <span class="o">|</span> <span class="n">_PAGE_EXT_KERN_WRITE</span><span class="p">);</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">mkhuge</span><span class="p">,</span> <span class="o">|=</span> <span class="n">_PAGE_SZHUGE</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">wrprotect</span><span class="p">,</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_RW</span><span class="p">);</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">mkwrite</span><span class="p">,</span> <span class="o">|=</span> <span class="n">_PAGE_RW</span><span class="p">);</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">mkhuge</span><span class="p">,</span> <span class="o">|=</span> <span class="n">_PAGE_SZHUGE</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">mkclean</span><span class="p">,</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_DIRTY</span><span class="p">);</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">mkdirty</span><span class="p">,</span> <span class="o">|=</span> <span class="n">_PAGE_DIRTY</span><span class="p">);</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">mkold</span><span class="p">,</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_ACCESSED</span><span class="p">);</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">mkyoung</span><span class="p">,</span> <span class="o">|=</span> <span class="n">_PAGE_ACCESSED</span><span class="p">);</span>
<span class="n">PTE_BIT_FUNC</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">mkspecial</span><span class="p">,</span> <span class="o">|=</span> <span class="n">_PAGE_SPECIAL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Macro and implementation to make a page protection as uncachable.</span>
<span class="cm"> */</span>
<span class="cp">#define pgprot_writecombine(prot) \</span>
<span class="cp">	__pgprot(pgprot_val(prot) &amp; ~_PAGE_CACHABLE)</span>

<span class="cp">#define pgprot_noncached	 pgprot_writecombine</span>

<span class="cm">/*</span>
<span class="cm"> * Conversion functions: convert a page and protection to a page entry,</span>
<span class="cm"> * and a page entry and page directory to the page they refer to.</span>
<span class="cm"> *</span>
<span class="cm"> * extern pte_t mk_pte(struct page *page, pgprot_t pgprot)</span>
<span class="cm"> */</span>
<span class="cp">#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte</span><span class="p">.</span><span class="n">pte_low</span> <span class="o">&amp;=</span> <span class="n">_PAGE_CHG_MASK</span><span class="p">;</span>
	<span class="n">pte</span><span class="p">.</span><span class="n">pte_low</span> <span class="o">|=</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">newprot</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X2TLB</span>
	<span class="n">pte</span><span class="p">.</span><span class="n">pte_high</span> <span class="o">|=</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">newprot</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define pmd_page_vaddr(pmd)	((unsigned long)pmd_val(pmd))</span>
<span class="cp">#define pmd_page(pmd)		(virt_to_page(pmd_val(pmd)))</span>

<span class="cm">/* to find an entry in a page-table-directory. */</span>
<span class="cp">#define pgd_index(address)	(((address) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))</span>
<span class="cp">#define pgd_offset(mm, address)	((mm)-&gt;pgd + pgd_index(address))</span>
<span class="cp">#define __pgd_offset(address)	pgd_index(address)</span>

<span class="cm">/* to find an entry in a kernel page-table-directory */</span>
<span class="cp">#define pgd_offset_k(address)	pgd_offset(&amp;init_mm, address)</span>

<span class="cp">#define __pud_offset(address)	(((address) &gt;&gt; PUD_SHIFT) &amp; (PTRS_PER_PUD-1))</span>
<span class="cp">#define __pmd_offset(address)	(((address) &gt;&gt; PMD_SHIFT) &amp; (PTRS_PER_PMD-1))</span>

<span class="cm">/* Find an entry in the third-level page table.. */</span>
<span class="cp">#define pte_index(address)	((address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))</span>
<span class="cp">#define __pte_offset(address)	pte_index(address)</span>

<span class="cp">#define pte_offset_kernel(dir, address) \</span>
<span class="cp">	((pte_t *) pmd_page_vaddr(*(dir)) + pte_index(address))</span>
<span class="cp">#define pte_offset_map(dir, address)		pte_offset_kernel(dir, address)</span>
<span class="cp">#define pte_unmap(pte)		do { } while (0)</span>

<span class="cp">#ifdef CONFIG_X2TLB</span>
<span class="cp">#define pte_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pte %p(%08lx%08lx).\n&quot;, __FILE__, __LINE__, \</span>
<span class="cp">	       &amp;(e), (e).pte_high, (e).pte_low)</span>
<span class="cp">#define pgd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pgd %016llx.\n&quot;, __FILE__, __LINE__, pgd_val(e))</span>
<span class="cp">#else</span>
<span class="cp">#define pte_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pte %08lx.\n&quot;, __FILE__, __LINE__, pte_val(e))</span>
<span class="cp">#define pgd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Encode and de-code a swap entry</span>
<span class="cm"> *</span>
<span class="cm"> * Constraints:</span>
<span class="cm"> *	_PAGE_FILE at bit 0</span>
<span class="cm"> *	_PAGE_PRESENT at bit 8</span>
<span class="cm"> *	_PAGE_PROTNONE at bit 9</span>
<span class="cm"> *</span>
<span class="cm"> * For the normal case, we encode the swap type into bits 0:7 and the</span>
<span class="cm"> * swap offset into bits 10:30. For the 64-bit PTE case, we keep the</span>
<span class="cm"> * preserved bits in the low 32-bits and use the upper 32 as the swap</span>
<span class="cm"> * offset (along with a 5-bit type), following the same approach as x86</span>
<span class="cm"> * PAE. This keeps the logic quite simple, and allows for a full 32</span>
<span class="cm"> * PTE_FILE_MAX_BITS, as opposed to the 29-bits we&#39;re constrained with</span>
<span class="cm"> * in the pte_low case.</span>
<span class="cm"> *</span>
<span class="cm"> * As is evident by the Alpha code, if we ever get a 64-bit unsigned</span>
<span class="cm"> * long (swp_entry_t) to match up with the 64-bit PTEs, this all becomes</span>
<span class="cm"> * much cleaner..</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: We should set ZEROs at the position of _PAGE_PRESENT</span>
<span class="cm"> *       and _PAGE_PROTNONE bits</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X2TLB</span>
<span class="cp">#define __swp_type(x)			((x).val &amp; 0x1f)</span>
<span class="cp">#define __swp_offset(x)			((x).val &gt;&gt; 5)</span>
<span class="cp">#define __swp_entry(type, offset)	((swp_entry_t){ (type) | (offset) &lt;&lt; 5})</span>
<span class="cp">#define __pte_to_swp_entry(pte)		((swp_entry_t){ (pte).pte_high })</span>
<span class="cp">#define __swp_entry_to_pte(x)		((pte_t){ 0, (x).val })</span>

<span class="cm">/*</span>
<span class="cm"> * Encode and decode a nonlinear file mapping entry</span>
<span class="cm"> */</span>
<span class="cp">#define pte_to_pgoff(pte)		((pte).pte_high)</span>
<span class="cp">#define pgoff_to_pte(off)		((pte_t) { _PAGE_FILE, (off) })</span>

<span class="cp">#define PTE_FILE_MAX_BITS		32</span>
<span class="cp">#else</span>
<span class="cp">#define __swp_type(x)			((x).val &amp; 0xff)</span>
<span class="cp">#define __swp_offset(x)			((x).val &gt;&gt; 10)</span>
<span class="cp">#define __swp_entry(type, offset)	((swp_entry_t){(type) | (offset) &lt;&lt;10})</span>

<span class="cp">#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) &gt;&gt; 1 })</span>
<span class="cp">#define __swp_entry_to_pte(x)		((pte_t) { (x).val &lt;&lt; 1 })</span>

<span class="cm">/*</span>
<span class="cm"> * Encode and decode a nonlinear file mapping entry</span>
<span class="cm"> */</span>
<span class="cp">#define PTE_FILE_MAX_BITS	29</span>
<span class="cp">#define pte_to_pgoff(pte)	(pte_val(pte) &gt;&gt; 1)</span>
<span class="cp">#define pgoff_to_pte(off)	((pte_t) { ((off) &lt;&lt; 1) | _PAGE_FILE })</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __ASM_SH_PGTABLE_32_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
