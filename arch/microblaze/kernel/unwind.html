<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › microblaze › kernel › unwind.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>unwind.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Backtrace support for Microblaze</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010  Digital Design Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Based on arch/sh/kernel/cpu/sh5/unwind.c code which is:</span>
<span class="cm"> * Copyright (C) 2004  Paul Mundt</span>
<span class="cm"> * Copyright (C) 2004  Richard Curnow</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> */</span>

<span class="cm">/* #define DEBUG 1 */</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/stacktrace.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/exceptions.h&gt;</span>
<span class="cp">#include &lt;asm/unwind.h&gt;</span>
<span class="cp">#include &lt;asm/switch_to.h&gt;</span>

<span class="k">struct</span> <span class="n">stack_trace</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * On Microblaze, finding the previous stack frame is a little tricky.</span>
<span class="cm"> * At this writing (3/2010), Microblaze does not support CONFIG_FRAME_POINTERS,</span>
<span class="cm"> * and even if it did, gcc (4.1.2) does not store the frame pointer at</span>
<span class="cm"> * a consistent offset within each frame. To determine frame size, it is</span>
<span class="cm"> * necessary to search for the assembly instruction that creates or reclaims</span>
<span class="cm"> * the frame and extract the size from it.</span>
<span class="cm"> *</span>
<span class="cm"> * Microblaze stores the stack pointer in r1, and creates a frame via</span>
<span class="cm"> *</span>
<span class="cm"> *     addik r1, r1, -FRAME_SIZE</span>
<span class="cm"> *</span>
<span class="cm"> * The frame is reclaimed via</span>
<span class="cm"> *</span>
<span class="cm"> *     addik r1, r1, FRAME_SIZE</span>
<span class="cm"> *</span>
<span class="cm"> * Frame creation occurs at or near the top of a function.</span>
<span class="cm"> * Depending on the compiler, reclaim may occur at the end, or before</span>
<span class="cm"> * a mid-function return.</span>
<span class="cm"> *</span>
<span class="cm"> * A stack frame is usually not created in a leaf function.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * get_frame_size - Extract the stack adjustment from an</span>
<span class="cm"> *                  &quot;addik r1, r1, adjust&quot; instruction</span>
<span class="cm"> * @instr : Microblaze instruction</span>
<span class="cm"> *</span>
<span class="cm"> * Return - Number of stack bytes the instruction reserves or reclaims</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">long</span> <span class="nf">get_frame_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">abs</span><span class="p">((</span><span class="n">s16</span><span class="p">)(</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_frame_creation - Search backward to find the instruction that creates</span>
<span class="cm"> *                       the stack frame (hopefully, for the same function the</span>
<span class="cm"> *                       initial PC is in).</span>
<span class="cm"> * @pc : Program counter at which to begin the search</span>
<span class="cm"> *</span>
<span class="cm"> * Return - PC at which stack frame creation occurs</span>
<span class="cm"> *          NULL if this cannot be found, i.e. a leaf function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">find_frame_creation</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* NOTE: Distance to search is arbitrary</span>
<span class="cm">	 *	 250 works well for most things,</span>
<span class="cm">	 *	 750 picks up things like tcp_recvmsg(),</span>
<span class="cm">	 *	1000 needed for fat_fill_super()</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">pc</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span><span class="p">;</span>
		<span class="n">s16</span> <span class="n">frame_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kernel_text_address</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pc</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">instr</span> <span class="o">=</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

		<span class="cm">/* addik r1, r1, foo ? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x30210000</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* No */</span>

		<span class="n">frame_size</span> <span class="o">=</span> <span class="n">get_frame_size</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">frame_size</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">frame_size</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    Invalid frame size %d at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">frame_size</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    Found frame creation at 0x%p, size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span>
			 <span class="n">frame_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">pc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lookup_prev_stack_frame - Find the stack frame of the previous function.</span>
<span class="cm"> * @fp          : Frame (stack) pointer for current function</span>
<span class="cm"> * @pc          : Program counter within current function</span>
<span class="cm"> * @leaf_return : r15 value within current function. If the current function</span>
<span class="cm"> *		  is a leaf, this is the caller&#39;s return address.</span>
<span class="cm"> * @pprev_fp    : On exit, set to frame (stack) pointer for previous function</span>
<span class="cm"> * @pprev_pc    : On exit, set to current function caller&#39;s return address</span>
<span class="cm"> *</span>
<span class="cm"> * Return - 0 on success, -EINVAL if the previous frame cannot be found</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lookup_prev_stack_frame</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">leaf_return</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pprev_fp</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pprev_pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">prologue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* _switch_to is a special leaf function */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">_switch_to</span><span class="p">)</span>
		<span class="n">prologue</span> <span class="o">=</span> <span class="n">find_frame_creation</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">pc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prologue</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">frame_size</span> <span class="o">=</span> <span class="n">get_frame_size</span><span class="p">(</span><span class="o">*</span><span class="n">prologue</span><span class="p">);</span>

		<span class="o">*</span><span class="n">pprev_fp</span> <span class="o">=</span> <span class="n">fp</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pprev_pc</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">fp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leaf_return</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pprev_pc</span> <span class="o">=</span> <span class="n">leaf_return</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pprev_fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE: don&#39;t check kernel_text_address here, to allow display</span>
<span class="cm">	 *	 of userland return address</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!*</span><span class="n">pprev_pc</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">pprev_pc</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">microblaze_unwind_inner</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">leaf_return</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">stack_trace</span> <span class="o">*</span><span class="n">trace</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * unwind_trap - Unwind through a system trap, that stored previous state</span>
<span class="cm"> *		 on the stack.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unwind_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stack_trace</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* To be implemented */</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unwind_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stack_trace</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="p">;</span>
	<span class="n">microblaze_unwind_inner</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r1</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r15</span><span class="p">,</span> <span class="n">trace</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * microblaze_unwind_inner - Unwind the stack from the specified point</span>
<span class="cm"> * @task  : Task whose stack we are to unwind (may be NULL)</span>
<span class="cm"> * @pc    : Program counter from which we start unwinding</span>
<span class="cm"> * @fp    : Frame (stack) pointer from which we start unwinding</span>
<span class="cm"> * @leaf_return : Value of r15 at pc. If the function is a leaf, this is</span>
<span class="cm"> *				  the caller&#39;s return address.</span>
<span class="cm"> * @trace : Where to store stack backtrace (PC values).</span>
<span class="cm"> *	    NULL == print backtrace to kernel log</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">microblaze_unwind_inner</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">leaf_return</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">stack_trace</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    Unwinding with PC=%p, FP=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pc</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pc</span> <span class="o">||</span> <span class="o">!</span><span class="n">fp</span> <span class="o">||</span> <span class="p">(</span><span class="n">pc</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fp</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    Invalid state for unwind, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">pc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_fp</span><span class="p">,</span> <span class="n">next_pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">return_to</span> <span class="o">=</span> <span class="n">pc</span> <span class="o">+</span>  <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">trap_handler_info</span> <span class="o">*</span><span class="n">handler</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">microblaze_trap_handlers</span><span class="p">;</span>

		<span class="cm">/* Is previous function the HW exception handler? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">return_to</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_hw_exception_handler</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">return_to</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ex_handler_unhandled</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * HW exception handler doesn&#39;t save all registers,</span>
<span class="cm">			 * so we open-code a special case of unwind_trap()</span>
<span class="cm">			 */</span>
<span class="cp">#ifndef CONFIG_MMU</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;HW EXCEPTION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_MMU</span>
			<span class="n">microblaze_unwind_inner</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r17</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
						<span class="n">fp</span> <span class="o">+</span> <span class="n">EX_HANDLER_STACK_SIZ</span><span class="p">,</span>
						<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r15</span><span class="p">,</span> <span class="n">trace</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Is previous function a trap handler? */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">start_addr</span><span class="p">;</span> <span class="o">++</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">return_to</span> <span class="o">&gt;=</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">start_addr</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">return_to</span> <span class="o">&lt;=</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">end_addr</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trace</span><span class="p">)</span>
					<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handler</span><span class="o">-&gt;</span><span class="n">trap_name</span><span class="p">);</span>
				<span class="n">unwind_trap</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">trace</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pc</span> <span class="o">-=</span> <span class="n">ofs</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_STACKTRACE</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">trace</span><span class="o">-&gt;</span><span class="n">skip</span><span class="o">--</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">trace</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">nr_entries</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">trace</span><span class="o">-&gt;</span><span class="n">nr_entries</span> <span class="o">&gt;=</span> <span class="n">trace</span><span class="o">-&gt;</span><span class="n">max_entries</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Have we reached userland? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pc</span> <span class="o">==</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;[&lt;%p&gt;] PID %lu [%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">pc</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
					<span class="n">task</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Stop when we reach anything not part of the kernel */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kernel_text_address</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lookup_prev_stack_frame</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">leaf_return</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_fp</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">next_pc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
			<span class="n">pc</span> <span class="o">=</span> <span class="n">next_pc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
			<span class="n">fp</span> <span class="o">=</span> <span class="n">next_fp</span><span class="p">;</span>
			<span class="n">leaf_return</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    Failed to find previous stack frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    Next PC=%p, next FP=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">next_pc</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">next_fp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * microblaze_unwind - Stack unwinder for Microblaze (external entry point)</span>
<span class="cm"> * @task  : Task whose stack we are to unwind (NULL == current)</span>
<span class="cm"> * @trace : Where to store stack backtrace (PC values).</span>
<span class="cm"> *	    NULL == print backtrace to kernel log</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">microblaze_unwind</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stack_trace</span> <span class="o">*</span><span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="n">microblaze_unwind_inner</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r1</span><span class="p">,</span>
						<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r15</span><span class="p">,</span> <span class="n">trace</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">thread_info</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">);</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_context</span> <span class="o">*</span><span class="n">cpu_context</span> <span class="o">=</span>
				<span class="o">&amp;</span><span class="n">thread_info</span><span class="o">-&gt;</span><span class="n">cpu_context</span><span class="p">;</span>

			<span class="n">microblaze_unwind_inner</span><span class="p">(</span><span class="n">task</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">_switch_to</span><span class="p">,</span>
						<span class="n">cpu_context</span><span class="o">-&gt;</span><span class="n">r1</span><span class="p">,</span>
						<span class="n">cpu_context</span><span class="o">-&gt;</span><span class="n">r15</span><span class="p">,</span> <span class="n">trace</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span> <span class="n">fp</span><span class="p">;</span>

		<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;or %0, r1, r0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">fp</span><span class="p">));</span>

		<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
			<span class="s">&quot;brlid %0, 0f;&quot;</span>
			<span class="s">&quot;nop;&quot;</span>
			<span class="s">&quot;0:&quot;</span>
			<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">pc</span><span class="p">)</span>
		<span class="p">);</span>

		<span class="cm">/* Since we are not a leaf function, use leaf_return = 0 */</span>
		<span class="n">microblaze_unwind_inner</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
