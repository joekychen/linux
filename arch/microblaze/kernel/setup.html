<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › microblaze › kernel › setup.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>setup.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007-2009 Michal Simek &lt;monstr@monstr.eu&gt;</span>
<span class="cm"> * Copyright (C) 2007-2009 PetaLogix</span>
<span class="cm"> * Copyright (C) 2006 Atmark Techno, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License. See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>

<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/param.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/entry.h&gt;</span>
<span class="cp">#include &lt;asm/cpuinfo.h&gt;</span>

<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">KSP</span><span class="p">);</span>	<span class="cm">/* Saved kernel stack pointer */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">KM</span><span class="p">);</span>	<span class="cm">/* Kernel/user mode */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ENTRY_SP</span><span class="p">);</span>	<span class="cm">/* Saved SP on kernel entry */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">R11_SAVE</span><span class="p">);</span>	<span class="cm">/* Temp variable for entry */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">CURRENT_SAVE</span><span class="p">);</span>	<span class="cm">/* Saved current pointer */</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">boot_cpuid</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">cmd_line</span><span class="p">[</span><span class="n">COMMAND_LINE_SIZE</span><span class="p">];</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_arch</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">cmdline_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">cmdline_p</span> <span class="o">=</span> <span class="n">cmd_line</span><span class="p">;</span>

	<span class="n">console_verbose</span><span class="p">();</span>

	<span class="n">unflatten_device_tree</span><span class="p">();</span>

	<span class="n">setup_cpuinfo</span><span class="p">();</span>

	<span class="n">microblaze_cache_init</span><span class="p">();</span>

	<span class="n">setup_memory</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_EARLY_PRINTK</span>
	<span class="cm">/* remap early console to virtual address */</span>
	<span class="n">remap_early_printk</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">xilinx_pci_init</span><span class="p">();</span>

<span class="cp">#if defined(CONFIG_SELFMOD_INTC) || defined(CONFIG_SELFMOD_TIMER)</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Self modified code enable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_VT</span>
<span class="cp">#if defined(CONFIG_XILINX_CONSOLE)</span>
	<span class="n">conswitchp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xil_con</span><span class="p">;</span>
<span class="cp">#elif defined(CONFIG_DUMMY_CONSOLE)</span>
	<span class="n">conswitchp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy_con</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MTD_UCLINUX</span>
<span class="cm">/* Handle both romfs and cramfs types, without generating unnecessary</span>
<span class="cm"> code (ie no point checking for CRAMFS if it&#39;s not even enabled) */</span>
<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">get_romfs_len</span><span class="p">(</span><span class="kt">unsigned</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_ROMFS_FS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;-rom1fs-&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* romfs */</span>
		<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CRAMFS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="mh">0x28cd3d45</span><span class="p">))</span> <span class="cm">/* cramfs */</span>
		<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_MTD_UCLINUX_EBSS */</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_tlb</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">machine_early_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmdline</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ram</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fdt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tlb0</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tlb1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If CONFIG_MTD_UCLINUX is defined, assume ROMFS is at the</span>
<span class="cm">	 * end of kernel. There are two position which we want to check.</span>
<span class="cm">	 * The first is __init_end and the second __bss_start.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_MTD_UCLINUX</span>
	<span class="kt">int</span> <span class="n">romfs_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">romfs_base</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">old_klimit</span> <span class="o">=</span> <span class="n">klimit</span><span class="p">;</span>

	<span class="n">romfs_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">ram</span> <span class="o">?</span> <span class="n">ram</span> <span class="o">:</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__init_end</span><span class="p">);</span>
	<span class="n">romfs_size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">get_romfs_len</span><span class="p">((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="n">romfs_base</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">romfs_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">romfs_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__bss_start</span><span class="p">;</span>
		<span class="n">romfs_size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">get_romfs_len</span><span class="p">((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="n">romfs_base</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Move ROMFS out of BSS before clearing it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">romfs_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_ebss</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">romfs_base</span><span class="p">,</span> <span class="n">romfs_size</span><span class="p">);</span>
		<span class="n">klimit</span> <span class="o">+=</span> <span class="n">romfs_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* clearing bss section */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">__bss_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">__bss_stop</span><span class="o">-</span><span class="n">__bss_start</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">_ssbss</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_esbss</span><span class="o">-</span><span class="n">_ssbss</span><span class="p">);</span>

	<span class="cm">/* Copy command line passed from bootloader */</span>
<span class="cp">#ifndef CONFIG_CMDLINE_BOOL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmdline</span> <span class="o">&amp;&amp;</span> <span class="n">cmdline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">cmd_line</span><span class="p">,</span> <span class="n">cmdline</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">lockdep_init</span><span class="p">();</span>

<span class="cm">/* initialize device tree for usage in early_printk */</span>
	<span class="n">early_init_devtree</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_fdt_start</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_EARLY_PRINTK</span>
	<span class="n">setup_early_printk</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* setup kernel_tlb after BSS cleaning</span>
<span class="cm">	 * Maybe worth to move to asm code */</span>
	<span class="n">kernel_tlb</span> <span class="o">=</span> <span class="n">tlb0</span> <span class="o">+</span> <span class="n">tlb1</span><span class="p">;</span>
	<span class="cm">/* printk(&quot;TLB1 0x%08x, TLB0 0x%08x, tlb 0x%x\n&quot;, tlb0,</span>
<span class="cm">							tlb1, kernel_tlb); */</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Ramdisk addr 0x%08x, &quot;</span><span class="p">,</span> <span class="n">ram</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdt</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;FDT at 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fdt</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Compiled-in FDT at 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">_fdt_start</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MTD_UCLINUX</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Found romfs @ 0x%08x (0x%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">romfs_base</span><span class="p">,</span> <span class="n">romfs_size</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;#### klimit %p ####</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">old_klimit</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">romfs_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* What else can we do? */</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Moved 0x%08x bytes from 0x%08x to 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">romfs_size</span><span class="p">,</span> <span class="n">romfs_base</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_ebss</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;New klimit: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">klimit</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if CONFIG_XILINX_MICROBLAZE0_USE_MSR_INSTR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;!!!Your kernel has setup MSR instruction but &quot;</span>
				<span class="s">&quot;CPU don&#39;t have it %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msr</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;!!!Your kernel not setup MSR instruction but &quot;</span>
				<span class="s">&quot;CPU have it %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Do not copy reset vectors. offset = 0x2 means skip the first</span>
<span class="cm">	 * two instructions. dst is pointer to MB vectors which are placed</span>
<span class="cm">	 * in block ram. If you want to copy reset vector setup offset to 0x0 */</span>
<span class="cp">#if !CONFIG_MANUAL_RESET_VECTOR</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">src</span> <span class="o">=</span> <span class="n">__ivt_start</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span> <span class="n">src</span> <span class="o">&lt;</span> <span class="n">__ivt_end</span><span class="p">;</span> <span class="n">src</span><span class="o">++</span><span class="p">,</span> <span class="n">dst</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>

	<span class="cm">/* Initialize global data */</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">KM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>	<span class="cm">/* We start in kernel mode */</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">CURRENT_SAVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">current</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">of_debugfs_root</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">microblaze_debugfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">of_debugfs_root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;microblaze&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">of_debugfs_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">arch_initcall</span><span class="p">(</span><span class="n">microblaze_debugfs_init</span><span class="p">);</span>

<span class="cp"># ifdef CONFIG_MMU</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">debugfs_tlb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_debugfs_root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;tlb_skip&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">of_debugfs_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tlb_skip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">device_initcall</span><span class="p">(</span><span class="n">debugfs_tlb</span><span class="p">);</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dflt_bus_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* We are only intereted in device addition */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">!=</span> <span class="n">BUS_NOTIFY_ADD_DEVICE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">set_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_direct_ops</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">dflt_plat_bus_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">dflt_bus_notify</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_bus_notifier</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dflt_plat_bus_notifier</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">arch_initcall</span><span class="p">(</span><span class="n">setup_bus_notifier</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
