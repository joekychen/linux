<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › cris › arch-v32 › kernel › kgdb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>kgdb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  arch/cris/arch-v32/kernel/kgdb.c</span>
<span class="cm"> *</span>
<span class="cm"> *  CRIS v32 version by Orjan Friberg, Axis Communications AB.</span>
<span class="cm"> *</span>
<span class="cm"> *  S390 version</span>
<span class="cm"> *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation</span>
<span class="cm"> *    Author(s): Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com),</span>
<span class="cm"> *</span>
<span class="cm"> *  Originally written by Glenn Engel, Lake Stevens Instrument Division</span>
<span class="cm"> *</span>
<span class="cm"> *  Contributed by HP Systems</span>
<span class="cm"> *</span>
<span class="cm"> *  Modified for SPARC by Stu Grossman, Cygnus Support.</span>
<span class="cm"> *</span>
<span class="cm"> *  Modified for Linux/MIPS (and MIPS in general) by Andreas Busse</span>
<span class="cm"> *  Send complaints, suggestions etc. to &lt;andy@waldorf-gmbh.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1995 Andreas Busse</span>
<span class="cm"> */</span>

<span class="cm">/* FIXME: Check the documentation. */</span>

<span class="cm">/*</span>
<span class="cm"> *  kgdb usage notes:</span>
<span class="cm"> *  -----------------</span>
<span class="cm"> *</span>
<span class="cm"> * If you select CONFIG_ETRAX_KGDB in the configuration, the kernel will be</span>
<span class="cm"> * built with different gcc flags: &quot;-g&quot; is added to get debug infos, and</span>
<span class="cm"> * &quot;-fomit-frame-pointer&quot; is omitted to make debugging easier. Since the</span>
<span class="cm"> * resulting kernel will be quite big (approx. &gt; 7 MB), it will be stripped</span>
<span class="cm"> * before compresion. Such a kernel will behave just as usually, except if</span>
<span class="cm"> * given a &quot;debug=&lt;device&gt;&quot; command line option. (Only serial devices are</span>
<span class="cm"> * allowed for &lt;device&gt;, i.e. no printers or the like; possible values are</span>
<span class="cm"> * machine depedend and are the same as for the usual debug device, the one</span>
<span class="cm"> * for logging kernel messages.) If that option is given and the device can be</span>
<span class="cm"> * initialized, the kernel will connect to the remote gdb in trap_init(). The</span>
<span class="cm"> * serial parameters are fixed to 8N1 and 115200 bps, for easyness of</span>
<span class="cm"> * implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * To start a debugging session, start that gdb with the debugging kernel</span>
<span class="cm"> * image (the one with the symbols, vmlinux.debug) named on the command line.</span>
<span class="cm"> * This file will be used by gdb to get symbol and debugging infos about the</span>
<span class="cm"> * kernel. Next, select remote debug mode by</span>
<span class="cm"> *    target remote &lt;device&gt;</span>
<span class="cm"> * where &lt;device&gt; is the name of the serial device over which the debugged</span>
<span class="cm"> * machine is connected. Maybe you have to adjust the baud rate by</span>
<span class="cm"> *    set remotebaud &lt;rate&gt;</span>
<span class="cm"> * or also other parameters with stty:</span>
<span class="cm"> *    shell stty ... &lt;/dev/...</span>
<span class="cm"> * If the kernel to debug has already booted, it waited for gdb and now</span>
<span class="cm"> * connects, and you&#39;ll see a breakpoint being reported. If the kernel isn&#39;t</span>
<span class="cm"> * running yet, start it now. The order of gdb and the kernel doesn&#39;t matter.</span>
<span class="cm"> * Another thing worth knowing about in the getting-started phase is how to</span>
<span class="cm"> * debug the remote protocol itself. This is activated with</span>
<span class="cm"> *    set remotedebug 1</span>
<span class="cm"> * gdb will then print out each packet sent or received. You&#39;ll also get some</span>
<span class="cm"> * messages about the gdb stub on the console of the debugged machine.</span>
<span class="cm"> *</span>
<span class="cm"> * If all that works, you can use lots of the usual debugging techniques on</span>
<span class="cm"> * the kernel, e.g. inspecting and changing variables/memory, setting</span>
<span class="cm"> * breakpoints, single stepping and so on. It&#39;s also possible to interrupt the</span>
<span class="cm"> * debugged kernel by pressing C-c in gdb. Have fun! :-)</span>
<span class="cm"> *</span>
<span class="cm"> * The gdb stub is entered (and thus the remote gdb gets control) in the</span>
<span class="cm"> * following situations:</span>
<span class="cm"> *</span>
<span class="cm"> *  - If breakpoint() is called. This is just after kgdb initialization, or if</span>
<span class="cm"> *    a breakpoint() call has been put somewhere into the kernel source.</span>
<span class="cm"> *    (Breakpoints can of course also be set the usual way in gdb.)</span>
<span class="cm"> *    In eLinux, we call breakpoint() in init/main.c after IRQ initialization.</span>
<span class="cm"> *</span>
<span class="cm"> *  - If there is a kernel exception, i.e. bad_super_trap() or die_if_kernel()</span>
<span class="cm"> *    are entered. All the CPU exceptions are mapped to (more or less..., see</span>
<span class="cm"> *    the hard_trap_info array below) appropriate signal, which are reported</span>
<span class="cm"> *    to gdb. die_if_kernel() is usually called after some kind of access</span>
<span class="cm"> *    error and thus is reported as SIGSEGV.</span>
<span class="cm"> *</span>
<span class="cm"> *  - When panic() is called. This is reported as SIGABRT.</span>
<span class="cm"> *</span>
<span class="cm"> *  - If C-c is received over the serial line, which is treated as</span>
<span class="cm"> *    SIGINT.</span>
<span class="cm"> *</span>
<span class="cm"> * Of course, all these signals are just faked for gdb, since there is no</span>
<span class="cm"> * signal concept as such for the kernel. It also isn&#39;t possible --obviously--</span>
<span class="cm"> * to set signal handlers from inside gdb, or restart the kernel with a</span>
<span class="cm"> * signal.</span>
<span class="cm"> *</span>
<span class="cm"> * Current limitations:</span>
<span class="cm"> *</span>
<span class="cm"> *  - While the kernel is stopped, interrupts are disabled for safety reasons</span>
<span class="cm"> *    (i.e., variables not changing magically or the like). But this also</span>
<span class="cm"> *    means that the clock isn&#39;t running anymore, and that interrupts from the</span>
<span class="cm"> *    hardware may get lost/not be served in time. This can cause some device</span>
<span class="cm"> *    errors...</span>
<span class="cm"> *</span>
<span class="cm"> *  - When single-stepping, only one instruction of the current thread is</span>
<span class="cm"> *    executed, but interrupts are allowed for that time and will be serviced</span>
<span class="cm"> *    if pending. Be prepared for that.</span>
<span class="cm"> *</span>
<span class="cm"> *  - All debugging happens in kernel virtual address space. There&#39;s no way to</span>
<span class="cm"> *    access physical memory not mapped in kernel space, or to access user</span>
<span class="cm"> *    space. A way to work around this is using get_user_long &amp; Co. in gdb</span>
<span class="cm"> *    expressions, but only for the current process.</span>
<span class="cm"> *</span>
<span class="cm"> *  - Interrupting the kernel only works if interrupts are currently allowed,</span>
<span class="cm"> *    and the interrupt of the serial line isn&#39;t blocked by some other means</span>
<span class="cm"> *    (IPL too high, disabled, ...)</span>
<span class="cm"> *</span>
<span class="cm"> *  - The gdb stub is currently not reentrant, i.e. errors that happen therein</span>
<span class="cm"> *    (e.g. accessing invalid memory) may not be caught correctly. This could</span>
<span class="cm"> *    be removed in future by introducing a stack of struct registers.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  To enable debugger support, two things need to happen.  One, a</span>
<span class="cm"> *  call to kgdb_init() is necessary in order to allow any breakpoints</span>
<span class="cm"> *  or error conditions to be properly intercepted and reported to gdb.</span>
<span class="cm"> *  Two, a breakpoint needs to be generated to begin communication.  This</span>
<span class="cm"> *  is most easily accomplished by a call to breakpoint().</span>
<span class="cm"> *</span>
<span class="cm"> *    The following gdb commands are supported:</span>
<span class="cm"> *</span>
<span class="cm"> * command          function                               Return value</span>
<span class="cm"> *</span>
<span class="cm"> *    g             return the value of the CPU registers  hex data or ENN</span>
<span class="cm"> *    G             set the value of the CPU registers     OK or ENN</span>
<span class="cm"> *</span>
<span class="cm"> *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN</span>
<span class="cm"> *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN</span>
<span class="cm"> *</span>
<span class="cm"> *    c             Resume at current address              SNN   ( signal NN)</span>
<span class="cm"> *    cAA..AA       Continue at address AA..AA             SNN</span>
<span class="cm"> *</span>
<span class="cm"> *    s             Step one instruction                   SNN</span>
<span class="cm"> *    sAA..AA       Step one instruction from AA..AA       SNN</span>
<span class="cm"> *</span>
<span class="cm"> *    k             kill</span>
<span class="cm"> *</span>
<span class="cm"> *    ?             What was the last sigval ?             SNN   (signal NN)</span>
<span class="cm"> *</span>
<span class="cm"> *    bBB..BB	    Set baud rate to BB..BB		   OK or BNN, then sets</span>
<span class="cm"> *							   baud rate</span>
<span class="cm"> *</span>
<span class="cm"> * All commands and responses are sent with a packet which includes a</span>
<span class="cm"> * checksum.  A packet consists of</span>
<span class="cm"> *</span>
<span class="cm"> * $&lt;packet info&gt;#&lt;checksum&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * where</span>
<span class="cm"> * &lt;packet info&gt; :: &lt;characters representing the command or response&gt;</span>
<span class="cm"> * &lt;checksum&gt;    :: &lt; two hex digits computed as modulo 256 sum of &lt;packetinfo&gt;&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * When a packet is received, it is first acknowledged with either &#39;+&#39; or &#39;-&#39;.</span>
<span class="cm"> * &#39;+&#39; indicates a successful transfer.  &#39;-&#39; indicates a failed transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * Example:</span>
<span class="cm"> *</span>
<span class="cm"> * Host:                  Reply:</span>
<span class="cm"> * $m0,10#2a               +$00010203040506070809101112131415#42</span>
<span class="cm"> *</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>

<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>

<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;hwregs/reg_map.h&gt;</span>
<span class="cp">#include &lt;hwregs/reg_rdwr.h&gt;</span>
<span class="cp">#include &lt;hwregs/intr_vect_defs.h&gt;</span>
<span class="cp">#include &lt;hwregs/ser_defs.h&gt;</span>

<span class="cm">/* From entry.S. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gdb_handle_exception</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cm">/* From kgdb_asm.S. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kgdb_handle_exception</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">kgdb_started</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/********************************* Register image ****************************/</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">register_image</span>
<span class="p">{</span>
	                      <span class="cm">/* Offset */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r0</span><span class="p">;</span>    <span class="cm">/* 0x00 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r1</span><span class="p">;</span>    <span class="cm">/* 0x04 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r2</span><span class="p">;</span>    <span class="cm">/* 0x08 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r3</span><span class="p">;</span>    <span class="cm">/* 0x0C */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r4</span><span class="p">;</span>    <span class="cm">/* 0x10 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r5</span><span class="p">;</span>    <span class="cm">/* 0x14 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r6</span><span class="p">;</span>    <span class="cm">/* 0x18 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r7</span><span class="p">;</span>    <span class="cm">/* 0x1C */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r8</span><span class="p">;</span>    <span class="cm">/* 0x20; Frame pointer (if any) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r9</span><span class="p">;</span>    <span class="cm">/* 0x24 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r10</span><span class="p">;</span>   <span class="cm">/* 0x28 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r11</span><span class="p">;</span>   <span class="cm">/* 0x2C */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r12</span><span class="p">;</span>   <span class="cm">/* 0x30 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">r13</span><span class="p">;</span>   <span class="cm">/* 0x34 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">sp</span><span class="p">;</span>    <span class="cm">/* 0x38; R14, Stack pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">acr</span><span class="p">;</span>   <span class="cm">/* 0x3C; R15, Address calculation register. */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">bz</span><span class="p">;</span>    <span class="cm">/* 0x40; P0, 8-bit zero register */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">vr</span><span class="p">;</span>    <span class="cm">/* 0x41; P1, Version register (8-bit) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">pid</span><span class="p">;</span>   <span class="cm">/* 0x42; P2, Process ID */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">srs</span><span class="p">;</span>   <span class="cm">/* 0x46; P3, Support register select (8-bit) */</span>
        <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">wz</span><span class="p">;</span>    <span class="cm">/* 0x47; P4, 16-bit zero register */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">exs</span><span class="p">;</span>   <span class="cm">/* 0x49; P5, Exception status */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">eda</span><span class="p">;</span>   <span class="cm">/* 0x4D; P6, Exception data address */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">mof</span><span class="p">;</span>   <span class="cm">/* 0x51; P7, Multiply overflow register */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">dz</span><span class="p">;</span>    <span class="cm">/* 0x55; P8, 32-bit zero register */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">ebp</span><span class="p">;</span>   <span class="cm">/* 0x59; P9, Exception base pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">erp</span><span class="p">;</span>   <span class="cm">/* 0x5D; P10, Exception return pointer. Contains the PC we are interested in. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">srp</span><span class="p">;</span>   <span class="cm">/* 0x61; P11, Subroutine return pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">nrp</span><span class="p">;</span>   <span class="cm">/* 0x65; P12, NMI return pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">ccs</span><span class="p">;</span>   <span class="cm">/* 0x69; P13, Condition code stack */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">usp</span><span class="p">;</span>   <span class="cm">/* 0x6D; P14, User mode stack pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">spc</span><span class="p">;</span>   <span class="cm">/* 0x71; P15, Single step PC */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">pc</span><span class="p">;</span>    <span class="cm">/* 0x75; Pseudo register (for the most part set to ERP). */</span>

<span class="p">}</span> <span class="n">registers</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">bp_register_image</span>
<span class="p">{</span>
	<span class="cm">/* Support register bank 0. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s0_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s1_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s2_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s3_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s4_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s5_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s6_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s7_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s8_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s9_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s10_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s11_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s12_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s13_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s14_0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s15_0</span><span class="p">;</span>

	<span class="cm">/* Support register bank 1. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s0_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s1_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s2_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s3_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s4_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s5_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s6_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s7_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s8_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s9_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s10_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s11_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s12_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s13_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s14_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s15_1</span><span class="p">;</span>

	<span class="cm">/* Support register bank 2. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s0_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s1_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s2_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s3_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s4_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s5_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s6_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s7_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s8_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s9_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s10_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s11_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s12_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s13_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s14_2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s15_2</span><span class="p">;</span>

	<span class="cm">/* Support register bank 3. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s0_3</span><span class="p">;</span> <span class="cm">/* BP_CTRL */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s1_3</span><span class="p">;</span> <span class="cm">/* BP_I0_START */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s2_3</span><span class="p">;</span> <span class="cm">/* BP_I0_END */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s3_3</span><span class="p">;</span> <span class="cm">/* BP_D0_START */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s4_3</span><span class="p">;</span> <span class="cm">/* BP_D0_END */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s5_3</span><span class="p">;</span> <span class="cm">/* BP_D1_START */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s6_3</span><span class="p">;</span> <span class="cm">/* BP_D1_END */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s7_3</span><span class="p">;</span> <span class="cm">/* BP_D2_START */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s8_3</span><span class="p">;</span> <span class="cm">/* BP_D2_END */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s9_3</span><span class="p">;</span> <span class="cm">/* BP_D3_START */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s10_3</span><span class="p">;</span> <span class="cm">/* BP_D3_END */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s11_3</span><span class="p">;</span> <span class="cm">/* BP_D4_START */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s12_3</span><span class="p">;</span> <span class="cm">/* BP_D4_END */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s13_3</span><span class="p">;</span> <span class="cm">/* BP_D5_START */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s14_3</span><span class="p">;</span> <span class="cm">/* BP_D5_END */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">s15_3</span><span class="p">;</span> <span class="cm">/* BP_RESERVED */</span>

<span class="p">}</span> <span class="n">support_registers</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">register_name</span>
<span class="p">{</span>
	<span class="n">R0</span><span class="p">,</span>  <span class="n">R1</span><span class="p">,</span>  <span class="n">R2</span><span class="p">,</span>  <span class="n">R3</span><span class="p">,</span>
	<span class="n">R4</span><span class="p">,</span>  <span class="n">R5</span><span class="p">,</span>  <span class="n">R6</span><span class="p">,</span>  <span class="n">R7</span><span class="p">,</span>
	<span class="n">R8</span><span class="p">,</span>  <span class="n">R9</span><span class="p">,</span>  <span class="n">R10</span><span class="p">,</span> <span class="n">R11</span><span class="p">,</span>
	<span class="n">R12</span><span class="p">,</span> <span class="n">R13</span><span class="p">,</span> <span class="n">SP</span><span class="p">,</span>  <span class="n">ACR</span><span class="p">,</span>

	<span class="n">BZ</span><span class="p">,</span>  <span class="n">VR</span><span class="p">,</span>  <span class="n">PID</span><span class="p">,</span> <span class="n">SRS</span><span class="p">,</span>
	<span class="n">WZ</span><span class="p">,</span>  <span class="n">EXS</span><span class="p">,</span> <span class="n">EDA</span><span class="p">,</span> <span class="n">MOF</span><span class="p">,</span>
	<span class="n">DZ</span><span class="p">,</span>  <span class="n">EBP</span><span class="p">,</span> <span class="n">ERP</span><span class="p">,</span> <span class="n">SRP</span><span class="p">,</span>
	<span class="n">NRP</span><span class="p">,</span> <span class="n">CCS</span><span class="p">,</span> <span class="n">USP</span><span class="p">,</span> <span class="n">SPC</span><span class="p">,</span>
	<span class="n">PC</span><span class="p">,</span>

	<span class="n">S0</span><span class="p">,</span>  <span class="n">S1</span><span class="p">,</span>  <span class="n">S2</span><span class="p">,</span>  <span class="n">S3</span><span class="p">,</span>
	<span class="n">S4</span><span class="p">,</span>  <span class="n">S5</span><span class="p">,</span>  <span class="n">S6</span><span class="p">,</span>  <span class="n">S7</span><span class="p">,</span>
	<span class="n">S8</span><span class="p">,</span>  <span class="n">S9</span><span class="p">,</span>  <span class="n">S10</span><span class="p">,</span> <span class="n">S11</span><span class="p">,</span>
	<span class="n">S12</span><span class="p">,</span> <span class="n">S13</span><span class="p">,</span> <span class="n">S14</span><span class="p">,</span> <span class="n">S15</span>

<span class="p">};</span>

<span class="cm">/* The register sizes of the registers in register_name. An unimplemented register</span>
<span class="cm">   is designated by size 0 in this array. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">register_size</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>

	<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>

	<span class="mi">4</span><span class="p">,</span>

	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span>

<span class="p">};</span>

<span class="cm">/* Contains the register image of the kernel.</span>
<span class="cm">   (Global so that they can be reached from assembler code.) */</span>
<span class="n">registers</span> <span class="n">reg</span><span class="p">;</span>
<span class="n">support_registers</span> <span class="n">sreg</span><span class="p">;</span>

<span class="cm">/************** Prototypes for local library functions ***********************/</span>

<span class="cm">/* Copy of strcpy from libc. */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">);</span>

<span class="cm">/* Copy of strlen from libc. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gdb_cris_strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="cm">/* Copy of memchr from libc. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">gdb_cris_memchr</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="cm">/* Copy of strtol from libc. Does only support base 16. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">endptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">);</span>

<span class="cm">/********************** Prototypes for local functions. **********************/</span>

<span class="cm">/* Write a value to a specified register regno in the register image</span>
<span class="cm">   of the current thread. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">write_register</span><span class="p">(</span><span class="kt">int</span> <span class="n">regno</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>

<span class="cm">/* Read a value from a specified register in the register image. Returns the</span>
<span class="cm">   status of the read operation. The register value is returned in valptr. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">read_register</span><span class="p">(</span><span class="kt">char</span> <span class="n">regno</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">valptr</span><span class="p">);</span>

<span class="cm">/* Serial port, reads one character. ETRAX 100 specific. from debugport.c */</span>
<span class="kt">int</span> <span class="n">getDebugChar</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ETRAX_VCS_SIM</span>
<span class="kt">int</span> <span class="nf">getDebugChar</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">socketread</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Serial port, writes one character. ETRAX 100 specific. from debugport.c */</span>
<span class="kt">void</span> <span class="n">putDebugChar</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ETRAX_VCS_SIM</span>
<span class="kt">void</span> <span class="nf">putDebugChar</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">socketwrite</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Returns the integer equivalent of a hexadecimal character. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hex</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">);</span>

<span class="cm">/* Convert the memory, pointed to by mem into hexadecimal representation.</span>
<span class="cm">   Put the result in buf, and return a pointer to the last character</span>
<span class="cm">   in buf (null). */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem2hex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/* Convert the array, in hexadecimal representation, pointed to by buf into</span>
<span class="cm">   binary representation. Put the result in mem, and return a pointer to</span>
<span class="cm">   the character after the last byte written. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hex2mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/* Put the content of the array, in binary representation, pointed to by buf</span>
<span class="cm">   into memory pointed to by mem, and return a pointer to</span>
<span class="cm">   the character after the last byte written. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bin2mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/* Await the sequence $&lt;data&gt;#&lt;checksum&gt; and store &lt;data&gt; in the array buffer</span>
<span class="cm">   returned. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">getpacket</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>

<span class="cm">/* Send $&lt;data&gt;#&lt;checksum&gt; from the &lt;data&gt; in the array buffer. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">putpacket</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>

<span class="cm">/* Build and send a response packet in order to inform the host the</span>
<span class="cm">   stub is stopped. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">stub_is_stopped</span><span class="p">(</span><span class="kt">int</span> <span class="n">sigval</span><span class="p">);</span>

<span class="cm">/* All expected commands are sent from remote.c. Send a response according</span>
<span class="cm">   to the description in remote.c. Not static since it needs to be reached</span>
<span class="cm">   from assembler code. */</span>
<span class="kt">void</span> <span class="n">handle_exception</span><span class="p">(</span><span class="kt">int</span> <span class="n">sigval</span><span class="p">);</span>

<span class="cm">/* Performs a complete re-start from scratch. ETRAX specific. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">kill_restart</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/******************** Prototypes for global functions. ***********************/</span>

<span class="cm">/* The string str is prepended with the GDB printout token and sent. */</span>
<span class="kt">void</span> <span class="n">putDebugString</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* A static breakpoint to be used at startup. */</span>
<span class="kt">void</span> <span class="n">breakpoint</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Avoid warning as the internal_stack is not used in the C-code. */</span>
<span class="cp">#define USEDVAR(name)    { if (name) { ; } }</span>
<span class="cp">#define USEDFUN(name) { void (*pf)(void) = (void *)name; USEDVAR(pf) }</span>

<span class="cm">/********************************** Packet I/O ******************************/</span>
<span class="cm">/* BUFMAX defines the maximum number of characters in</span>
<span class="cm">   inbound/outbound buffers */</span>
<span class="cm">/* FIXME: How do we know it&#39;s enough? */</span>
<span class="cp">#define BUFMAX 512</span>

<span class="cm">/* Run-length encoding maximum length. Send 64 at most. */</span>
<span class="cp">#define RUNLENMAX 64</span>

<span class="cm">/* The inbound/outbound buffers used in packet I/O */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">input_buffer</span><span class="p">[</span><span class="n">BUFMAX</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">output_buffer</span><span class="p">[</span><span class="n">BUFMAX</span><span class="p">];</span>

<span class="cm">/* Error and warning messages. */</span>
<span class="k">enum</span> <span class="n">error_type</span>
<span class="p">{</span>
	<span class="n">SUCCESS</span><span class="p">,</span> <span class="n">E01</span><span class="p">,</span> <span class="n">E02</span><span class="p">,</span> <span class="n">E03</span><span class="p">,</span> <span class="n">E04</span><span class="p">,</span> <span class="n">E05</span><span class="p">,</span> <span class="n">E06</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">error_message</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="s">&quot;&quot;</span><span class="p">,</span>
	<span class="s">&quot;E01 Set current or general thread - H[c,g] - internal error.&quot;</span><span class="p">,</span>
	<span class="s">&quot;E02 Change register content - P - cannot change read-only register.&quot;</span><span class="p">,</span>
	<span class="s">&quot;E03 Thread is not alive.&quot;</span><span class="p">,</span> <span class="cm">/* T, not used. */</span>
	<span class="s">&quot;E04 The command is not supported - [s,C,S,!,R,d,r] - internal error.&quot;</span><span class="p">,</span>
	<span class="s">&quot;E05 Change register content - P - the register is not implemented..&quot;</span><span class="p">,</span>
	<span class="s">&quot;E06 Change memory content - M - internal error.&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/********************************** Breakpoint *******************************/</span>
<span class="cm">/* Use an internal stack in the breakpoint and interrupt response routines.</span>
<span class="cm">   FIXME: How do we know the size of this stack is enough?</span>
<span class="cm">   Global so it can be reached from assembler code. */</span>
<span class="cp">#define INTERNAL_STACK_SIZE 1024</span>
<span class="kt">char</span> <span class="n">internal_stack</span><span class="p">[</span><span class="n">INTERNAL_STACK_SIZE</span><span class="p">];</span>

<span class="cm">/* Due to the breakpoint return pointer, a state variable is needed to keep</span>
<span class="cm">   track of whether it is a static (compiled) or dynamic (gdb-invoked)</span>
<span class="cm">   breakpoint to be handled. A static breakpoint uses the content of register</span>
<span class="cm">   ERP as it is whereas a dynamic breakpoint requires subtraction with 2</span>
<span class="cm">   in order to execute the instruction. The first breakpoint is static; all</span>
<span class="cm">   following are assumed to be dynamic. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dynamic_bp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/********************************* String library ****************************/</span>
<span class="cm">/* Single-step over library functions creates trap loops. */</span>

<span class="cm">/* Copy char s2[] to s1[]. */</span>
<span class="k">static</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">gdb_cris_strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">s2</span><span class="o">++</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="p">)</span>
		<span class="p">;</span>
	<span class="k">return</span> <span class="n">s1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find length of s[]. */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">gdb_cris_strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sc</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="o">*</span><span class="n">sc</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">sc</span><span class="o">++</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sc</span> <span class="o">-</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Find first occurrence of c in s[n]. */</span>
<span class="k">static</span> <span class="kt">void</span><span class="o">*</span>
<span class="nf">gdb_cris_memchr</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uc</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">su</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">su</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">su</span><span class="p">,</span> <span class="o">--</span><span class="n">n</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">su</span> <span class="o">==</span> <span class="n">uc</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">su</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/******************************* Standard library ****************************/</span>
<span class="cm">/* Single-step over library functions creates trap loops. */</span>
<span class="cm">/* Convert string to long. */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">gdb_cris_strtol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">endptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">s1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span> <span class="p">(</span><span class="n">sd</span> <span class="o">=</span> <span class="n">gdb_cris_memchr</span><span class="p">(</span><span class="n">hex_asc</span><span class="p">,</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="n">base</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="o">++</span><span class="n">s1</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="n">sd</span> <span class="o">-</span> <span class="n">hex_asc</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">endptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Unconverted suffix is stored in endptr unless endptr is NULL. */</span>
                <span class="o">*</span><span class="n">endptr</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>
        <span class="p">}</span>

	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********************************* Register image ****************************/</span>

<span class="cm">/* Write a value to a specified register in the register image of the current</span>
<span class="cm">   thread. Returns status code SUCCESS, E02 or E05. */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">write_register</span><span class="p">(</span><span class="kt">int</span> <span class="n">regno</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&gt;=</span> <span class="n">R0</span> <span class="o">&amp;&amp;</span> <span class="n">regno</span> <span class="o">&lt;=</span> <span class="n">ACR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Consecutive 32-bit registers. */</span>
		<span class="n">hex2mem</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="n">regno</span> <span class="o">-</span> <span class="n">R0</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
			<span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">==</span> <span class="n">BZ</span> <span class="o">||</span> <span class="n">regno</span> <span class="o">==</span> <span class="n">VR</span> <span class="o">||</span> <span class="n">regno</span> <span class="o">==</span> <span class="n">WZ</span> <span class="o">||</span> <span class="n">regno</span> <span class="o">==</span> <span class="n">DZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read-only registers. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">E02</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">==</span> <span class="n">PID</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 32-bit register. (Even though we already checked SRS and WZ, we cannot</span>
<span class="cm">		   combine this with the EXS - SPC write since SRS and WZ have different size.) */</span>
		<span class="n">hex2mem</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">==</span> <span class="n">SRS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 8-bit register. */</span>
		<span class="n">hex2mem</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">srs</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&gt;=</span> <span class="n">EXS</span> <span class="o">&amp;&amp;</span> <span class="n">regno</span> <span class="o">&lt;=</span> <span class="n">SPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Consecutive 32-bit registers. */</span>
		<span class="n">hex2mem</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">exs</span> <span class="o">+</span> <span class="p">(</span><span class="n">regno</span> <span class="o">-</span> <span class="n">EXS</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
			 <span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>

       <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">==</span> <span class="n">PC</span><span class="p">)</span> <span class="p">{</span>
               <span class="cm">/* Pseudo-register. Treat as read-only. */</span>
               <span class="n">status</span> <span class="o">=</span> <span class="n">E02</span><span class="p">;</span>

       <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&gt;=</span> <span class="n">S0</span> <span class="o">&amp;&amp;</span> <span class="n">regno</span> <span class="o">&lt;=</span> <span class="n">S15</span><span class="p">)</span> <span class="p">{</span>
               <span class="cm">/* 32-bit registers. */</span>
               <span class="n">hex2mem</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sreg</span><span class="p">.</span><span class="n">s0_0</span> <span class="o">+</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">srs</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">regno</span> <span class="o">-</span> <span class="n">S0</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span> <span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Non-existing register. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">E05</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Read a value from a specified register in the register image. Returns the</span>
<span class="cm">   value in the register or -1 for non-implemented registers. */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">read_register</span><span class="p">(</span><span class="kt">char</span> <span class="n">regno</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">valptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>

	<span class="cm">/* We read the zero registers from the register struct (instead of just returning 0)</span>
<span class="cm">	   to catch errors. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&gt;=</span> <span class="n">R0</span> <span class="o">&amp;&amp;</span> <span class="n">regno</span> <span class="o">&lt;=</span> <span class="n">ACR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Consecutive 32-bit registers. */</span>
		<span class="o">*</span><span class="n">valptr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="n">regno</span> <span class="o">-</span> <span class="n">R0</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">==</span> <span class="n">BZ</span> <span class="o">||</span> <span class="n">regno</span> <span class="o">==</span> <span class="n">VR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Consecutive 8-bit registers. */</span>
		<span class="o">*</span><span class="n">valptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span>
                                         <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">bz</span> <span class="o">+</span> <span class="p">(</span><span class="n">regno</span> <span class="o">-</span> <span class="n">BZ</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">==</span> <span class="n">PID</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 32-bit register. */</span>
		<span class="o">*</span><span class="n">valptr</span> <span class="o">=</span>  <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">==</span> <span class="n">SRS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 8-bit register. */</span>
		<span class="o">*</span><span class="n">valptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">srs</span><span class="p">));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">==</span> <span class="n">WZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 16-bit register. */</span>
		<span class="o">*</span><span class="n">valptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">wz</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&gt;=</span> <span class="n">EXS</span> <span class="o">&amp;&amp;</span> <span class="n">regno</span> <span class="o">&lt;=</span> <span class="n">PC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Consecutive 32-bit registers. */</span>
		<span class="o">*</span><span class="n">valptr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">.</span><span class="n">exs</span> <span class="o">+</span> <span class="p">(</span><span class="n">regno</span> <span class="o">-</span> <span class="n">EXS</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&gt;=</span> <span class="n">S0</span> <span class="o">&amp;&amp;</span> <span class="n">regno</span> <span class="o">&lt;=</span> <span class="n">S15</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Consecutive 32-bit registers, located elsewhere. */</span>
		<span class="o">*</span><span class="n">valptr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sreg</span><span class="p">.</span><span class="n">s0_0</span> <span class="o">+</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">srs</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">regno</span> <span class="o">-</span> <span class="n">S0</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Non-existing register. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">E05</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/********************************** Packet I/O ******************************/</span>
<span class="cm">/* Returns the integer equivalent of a hexadecimal character. */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hex</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;f&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;F&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert the memory, pointed to by mem into hexadecimal representation.</span>
<span class="cm">   Put the result in buf, and return a pointer to the last character</span>
<span class="cm">   in buf (null). */</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">mem2hex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Invalid address, caught by &#39;m&#39; packet handler. */</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
                        <span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* Valid mem address. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="n">mem</span><span class="o">++</span><span class="p">;</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
		<span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* Terminate properly. */</span>
	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Same as mem2hex, but puts it in network byte order. */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">mem2hex_nbo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>

	<span class="n">mem</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="n">mem</span><span class="o">--</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Terminate properly. */</span>
	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert the array, in hexadecimal representation, pointed to by buf into</span>
<span class="cm">   binary representation. Put the result in mem, and return a pointer to</span>
<span class="cm">   the character after the last byte written. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">hex2mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">hex</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">+</span> <span class="n">hex</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">);</span>
		<span class="o">*</span><span class="n">mem</span><span class="o">++</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Put the content of the array, in binary representation, pointed to by buf</span>
<span class="cm">   into memory pointed to by mem, and return a pointer to the character after</span>
<span class="cm">   the last byte written.</span>
<span class="cm">   Gdb will escape $, #, and the escape char (0x7d). */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">bin2mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for any escaped characters. Be paranoid and</span>
<span class="cm">		   only unescape chars that should be escaped. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="mh">0x7d</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span> <span class="o">==</span> <span class="mh">0x3</span> <span class="o">||</span> <span class="o">*</span><span class="n">next</span> <span class="o">==</span> <span class="mh">0x4</span> <span class="o">||</span> <span class="o">*</span><span class="n">next</span> <span class="o">==</span> <span class="mh">0x5D</span><span class="p">)</span> <span class="p">{</span>
				 <span class="cm">/* #, $, ESC */</span>
				<span class="n">buf</span><span class="o">++</span><span class="p">;</span>
				<span class="o">*</span><span class="n">buf</span> <span class="o">+=</span> <span class="mh">0x20</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">mem</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Await the sequence $&lt;data&gt;#&lt;checksum&gt; and store &lt;data&gt; in the array buffer</span>
<span class="cm">   returned. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">getpacket</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xmitcsum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">getDebugChar</span> <span class="p">())</span> <span class="o">!=</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span>
			<span class="cm">/* Wait for the start character $ and ignore all other characters */</span><span class="p">;</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xmitcsum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Read until a # or the end of the buffer is reached */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">BUFMAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ch</span> <span class="o">=</span> <span class="n">getDebugChar</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span> <span class="o">+</span> <span class="n">ch</span><span class="p">;</span>
			<span class="n">buffer</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">BUFMAX</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">buffer</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xmitcsum</span> <span class="o">=</span> <span class="n">hex</span><span class="p">(</span><span class="n">getDebugChar</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">xmitcsum</span> <span class="o">+=</span> <span class="n">hex</span><span class="p">(</span><span class="n">getDebugChar</span><span class="p">());</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">!=</span> <span class="n">xmitcsum</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Wrong checksum */</span>
				<span class="n">putDebugChar</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Correct checksum */</span>
				<span class="n">putDebugChar</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">);</span>
				<span class="cm">/* If sequence characters are received, reply with them */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">putDebugChar</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
					<span class="n">putDebugChar</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
					<span class="cm">/* Remove the sequence characters from the buffer */</span>
					<span class="n">count</span> <span class="o">=</span> <span class="n">gdb_cris_strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
						<span class="n">buffer</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">!=</span> <span class="n">xmitcsum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send $&lt;data&gt;#&lt;checksum&gt; from the &lt;data&gt; in the array buffer. */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">putpacket</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">runlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">encode</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
		<span class="n">putDebugChar</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">);</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Do run length encoding */</span>
			<span class="n">putDebugChar</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">);</span>
			<span class="n">checksum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
			<span class="n">runlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">runlen</span> <span class="o">&lt;</span> <span class="n">RUNLENMAX</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">src</span> <span class="o">==</span> <span class="n">src</span><span class="p">[</span><span class="n">runlen</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">runlen</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">runlen</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Got a useful amount */</span>
				<span class="n">putDebugChar</span> <span class="p">(</span><span class="sc">&#39;*&#39;</span><span class="p">);</span>
				<span class="n">checksum</span> <span class="o">+=</span> <span class="sc">&#39;*&#39;</span><span class="p">;</span>
				<span class="n">encode</span> <span class="o">=</span> <span class="n">runlen</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">putDebugChar</span><span class="p">(</span><span class="n">encode</span><span class="p">);</span>
				<span class="n">checksum</span> <span class="o">+=</span> <span class="n">encode</span><span class="p">;</span>
				<span class="n">src</span> <span class="o">+=</span> <span class="n">runlen</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">src</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">putDebugChar</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">);</span>
		<span class="n">putDebugChar</span><span class="p">(</span><span class="n">hex_asc_hi</span><span class="p">(</span><span class="n">checksum</span><span class="p">));</span>
		<span class="n">putDebugChar</span><span class="p">(</span><span class="n">hex_asc_lo</span><span class="p">(</span><span class="n">checksum</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">kgdb_started</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">getDebugChar</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;+&#39;</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* The string str is prepended with the GDB printout token and sent. Required</span>
<span class="cm">   in traditional implementations. */</span>
<span class="kt">void</span>
<span class="nf">putDebugString</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Move SPC forward if we are single-stepping. */</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;spchere:&quot;</span><span class="p">);</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;move $spc, $r10&quot;</span><span class="p">);</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;cmp.d spchere, $r10&quot;</span><span class="p">);</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;bne nosstep&quot;</span><span class="p">);</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;nop&quot;</span><span class="p">);</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;move.d spccont, $r10&quot;</span><span class="p">);</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;move $r10, $spc&quot;</span><span class="p">);</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;nosstep:&quot;</span><span class="p">);</span>

        <span class="n">output_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;O&#39;</span><span class="p">;</span>
        <span class="n">mem2hex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">putpacket</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">);</span>

	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;spccont:&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********************************** Handle exceptions ************************/</span>
<span class="cm">/* Build and send a response packet in order to inform the host the</span>
<span class="cm">   stub is stopped. TAAn...:r...;n...:r...;n...:r...;</span>
<span class="cm">                    AA = signal number</span>
<span class="cm">                    n... = register number (hex)</span>
<span class="cm">                    r... = register contents</span>
<span class="cm">                    n... = `thread&#39;</span>
<span class="cm">                    r... = thread process ID.  This is a hex integer.</span>
<span class="cm">                    n... = other string not starting with valid hex digit.</span>
<span class="cm">                    gdb should ignore this n,r pair and go on to the next.</span>
<span class="cm">                    This way we can extend the protocol. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">stub_is_stopped</span><span class="p">(</span><span class="kt">int</span> <span class="n">sigval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">output_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg_cont</span><span class="p">;</span>

	<span class="cm">/* Send trap type (converted to signal) */</span>

	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;T&#39;</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">sigval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">reg</span><span class="p">.</span><span class="n">exs</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xc</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Some kind of hardware watchpoint triggered. Find which one</span>
<span class="cm">		   and determine its type (read/write/access).  */</span>
		<span class="kt">int</span> <span class="n">S</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">trig_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rw_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">trig_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bp_d_regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sreg</span><span class="p">.</span><span class="n">s3_3</span><span class="p">;</span>
		<span class="cm">/* In a lot of cases, the stopped data address will simply be EDA.</span>
<span class="cm">		   In some cases, we adjust it to match the watched data range.</span>
<span class="cm">		   (We don&#39;t want to change the actual EDA though). */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stopped_data_address</span><span class="p">;</span>
		<span class="cm">/* The S field of EXS. */</span>
		<span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">exs</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">S</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Instruction watchpoint. */</span>
			<span class="cm">/* FIXME: Check against, and possibly adjust reported EDA. */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Data watchpoint.  Find the one that triggered. */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bp</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">bp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

				<span class="cm">/* Dx_RD, Dx_WR in the S field of EXS for this BP. */</span>
				<span class="kt">int</span> <span class="n">bitpos_trig</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
				<span class="cm">/* Dx_BPRD, Dx_BPWR in BP_CTRL for this BP. */</span>
				<span class="kt">int</span> <span class="n">bitpos_config</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">bp</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

				<span class="cm">/* Get read/write trig bits for this BP. */</span>
				<span class="n">trig_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">bitpos_trig</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">bitpos_trig</span><span class="p">;</span>

				<span class="cm">/* Read/write config bits for this BP. */</span>
				<span class="n">rw_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">bitpos_config</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">bitpos_config</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">trig_bits</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Sanity check: the BP shouldn&#39;t trigger for accesses</span>
<span class="cm">					   that it isn&#39;t configured for. */</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">rw_bits</span> <span class="o">==</span> <span class="mh">0x1</span> <span class="o">&amp;&amp;</span> <span class="n">trig_bits</span> <span class="o">!=</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">||</span>
					    <span class="p">(</span><span class="n">rw_bits</span> <span class="o">==</span> <span class="mh">0x2</span> <span class="o">&amp;&amp;</span> <span class="n">trig_bits</span> <span class="o">!=</span> <span class="mh">0x2</span><span class="p">))</span>
						<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Invalid r/w trigging for this BP&quot;</span><span class="p">);</span>

					<span class="cm">/* Mark this BP as trigged for future reference. */</span>
					<span class="n">trig_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bp</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">eda</span> <span class="o">&gt;=</span> <span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
					    <span class="n">reg</span><span class="p">.</span><span class="n">eda</span> <span class="o">&lt;=</span> <span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
						<span class="cm">/* EDA within range for this BP; it must be the one</span>
<span class="cm">						   we&#39;re looking for. */</span>
						<span class="n">stopped_data_address</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">eda</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bp</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Found a trigged BP with EDA within its configured data range. */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">trig_mask</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Something triggered, but EDA doesn&#39;t match any BP&#39;s range. */</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bp</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">bp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Dx_BPRD, Dx_BPWR in BP_CTRL for this BP. */</span>
					<span class="kt">int</span> <span class="n">bitpos_config</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">bp</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

					<span class="cm">/* Read/write config bits for this BP (needed later). */</span>
					<span class="n">rw_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">bitpos_config</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">bitpos_config</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">trig_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
						<span class="cm">/* EDA within 31 bytes of the configured start address? */</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">eda</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">&gt;=</span> <span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
							<span class="cm">/* Changing the reported address to match</span>
<span class="cm">							   the start address of the first applicable BP. */</span>
							<span class="n">stopped_data_address</span> <span class="o">=</span> <span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
							<span class="k">break</span><span class="p">;</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
							<span class="cm">/* We continue since we might find another useful BP. */</span>
							<span class="n">printk</span><span class="p">(</span><span class="s">&quot;EDA doesn&#39;t match trigged BP&#39;s range&quot;</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/* No match yet? */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bp</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">);</span>
			<span class="cm">/* Note that we report the type according to what the BP is configured</span>
<span class="cm">			   for (otherwise we&#39;d never report an &#39;awatch&#39;), not according to how</span>
<span class="cm">			   it trigged. We did check that the trigged bits match what the BP is</span>
<span class="cm">			   configured for though. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rw_bits</span> <span class="o">==</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* read */</span>
				<span class="n">strncpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&quot;rwatch&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
				<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rw_bits</span> <span class="o">==</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* write */</span>
				<span class="n">strncpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&quot;watch&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
				<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rw_bits</span> <span class="o">==</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* access */</span>
				<span class="n">strncpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&quot;awatch&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
				<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Invalid r/w bits for this BP.&quot;</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
			<span class="cm">/* Note that we don&#39;t read_register(EDA, ...) */</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">mem2hex_nbo</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">stopped_data_address</span><span class="p">,</span> <span class="n">register_size</span><span class="p">[</span><span class="n">EDA</span><span class="p">]);</span>
			<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;;&#39;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Only send PC, frame and stack pointer. */</span>
	<span class="n">read_register</span><span class="p">(</span><span class="n">PC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_cont</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">PC</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">mem2hex</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg_cont</span><span class="p">,</span> <span class="n">register_size</span><span class="p">[</span><span class="n">PC</span><span class="p">]);</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;;&#39;</span><span class="p">;</span>

	<span class="n">read_register</span><span class="p">(</span><span class="n">R8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_cont</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">R8</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">mem2hex</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg_cont</span><span class="p">,</span> <span class="n">register_size</span><span class="p">[</span><span class="n">R8</span><span class="p">]);</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;;&#39;</span><span class="p">;</span>

	<span class="n">read_register</span><span class="p">(</span><span class="n">SP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_cont</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">SP</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">mem2hex</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg_cont</span><span class="p">,</span> <span class="n">register_size</span><span class="p">[</span><span class="n">SP</span><span class="p">]);</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;;&#39;</span><span class="p">;</span>

	<span class="cm">/* Send ERP as well; this will save us an entire register fetch in some cases. */</span>
        <span class="n">read_register</span><span class="p">(</span><span class="n">ERP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_cont</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">ERP</span><span class="p">);</span>
        <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">mem2hex</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg_cont</span><span class="p">,</span> <span class="n">register_size</span><span class="p">[</span><span class="n">ERP</span><span class="p">]);</span>
        <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;;&#39;</span><span class="p">;</span>

	<span class="cm">/* null-terminate and send it off */</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">putpacket</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns the size of an instruction that has a delay slot. */</span>

<span class="kt">int</span> <span class="nf">insn_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">opcode</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">pc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="mh">0x0f00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0</span>:
	<span class="k">case</span> <span class="mh">0x9</span>:
	<span class="k">case</span> <span class="mh">0xb</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xe</span>:
	<span class="k">case</span> <span class="mh">0xf</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xd</span>:
		<span class="cm">/* Could be 4 or 6; check more bits. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t find size of opcode 0x%x at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">register_fixup</span><span class="p">(</span><span class="kt">int</span> <span class="n">sigval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Compensate for ACR push at the beginning of exception handler. */</span>
	<span class="n">reg</span><span class="p">.</span><span class="n">sp</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Standard case. */</span>
	<span class="n">reg</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">erp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">erp</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Delay slot bit set.  Report as stopped on proper instruction.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">spc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Rely on SPC if set. */</span>
			<span class="n">reg</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">spc</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Calculate the PC from the size of the instruction</span>
<span class="cm">			   that the delay slot we&#39;re in belongs to. */</span>
			<span class="n">reg</span><span class="p">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="n">insn_size</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">erp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">reg</span><span class="p">.</span><span class="n">exs</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Bits 1 - 0 indicate the type of memory operation performed</span>
<span class="cm">		   by the interrupted instruction. 0 means no memory operation,</span>
<span class="cm">		   and EDA is undefined in that case. We zero it to avoid confusion. */</span>
		<span class="n">reg</span><span class="p">.</span><span class="n">eda</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sigval</span> <span class="o">==</span> <span class="n">SIGTRAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Break 8, single step or hardware breakpoint exception. */</span>

		<span class="cm">/* Check IDX field of EXS. */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">reg</span><span class="p">.</span><span class="n">exs</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x18</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Break 8. */</span>

                        <span class="cm">/* Static (compiled) breakpoints must return to the next instruction</span>
<span class="cm">			   in order to avoid infinite loops (default value of ERP). Dynamic</span>
<span class="cm">			   (gdb-invoked) must subtract the size of the break instruction from</span>
<span class="cm">			   the ERP so that the instruction that was originally in the break</span>
<span class="cm">			   instruction&#39;s place will be run when we return from the exception. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dynamic_bp</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Assuming that all breakpoints are dynamic from now on. */</span>
				<span class="n">dynamic_bp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

				<span class="cm">/* Only if not in a delay slot. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">erp</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">reg</span><span class="p">.</span><span class="n">erp</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
					<span class="n">reg</span><span class="p">.</span><span class="n">pc</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">reg</span><span class="p">.</span><span class="n">exs</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Single step. */</span>
			<span class="cm">/* Don&#39;t fiddle with S1. */</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">reg</span><span class="p">.</span><span class="n">exs</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xc</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Hardware watchpoint exception. */</span>

			<span class="cm">/* SPC has been updated so that we will get a single step exception</span>
<span class="cm">			   when we return, but we don&#39;t want that. */</span>
			<span class="n">reg</span><span class="p">.</span><span class="n">spc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Don&#39;t fiddle with S1. */</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sigval</span> <span class="o">==</span> <span class="n">SIGINT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Nothing special. */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_watchpoint</span><span class="p">(</span><span class="kt">char</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Breakpoint/watchpoint types (GDB terminology):</span>
<span class="cm">	   0 = memory breakpoint for instructions</span>
<span class="cm">	   (not supported; done via memory write instead)</span>
<span class="cm">	   1 = hardware breakpoint for instructions (supported)</span>
<span class="cm">	   2 = write watchpoint (supported)</span>
<span class="cm">	   3 = read watchpoint (supported)</span>
<span class="cm">	   4 = access watchpoint (supported) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="sc">&#39;1&#39;</span> <span class="o">||</span> <span class="n">type</span> <span class="o">&gt;</span> <span class="sc">&#39;4&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">output_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read watchpoints are set as access watchpoints, because of GDB&#39;s</span>
<span class="cm">	   inability to deal with pure read watchpoints. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;3&#39;</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="sc">&#39;4&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Hardware (instruction) breakpoint. */</span>
		<span class="cm">/* Bit 0 in BP_CTRL holds the configuration for I0. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Already in use. */</span>
			<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E04</span><span class="p">]);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Configure. */</span>
		<span class="n">sreg</span><span class="p">.</span><span class="n">s1_3</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">sreg</span><span class="p">.</span><span class="n">s2_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bp_d_regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sreg</span><span class="p">.</span><span class="n">s3_3</span><span class="p">;</span>

		<span class="cm">/* The watchpoint allocation scheme is the simplest possible.</span>
<span class="cm">		   For example, if a region is watched for read and</span>
<span class="cm">		   a write watch is requested, a new watchpoint will</span>
<span class="cm">		   be used. Also, if a watch for a region that is already</span>
<span class="cm">		   covered by one or more existing watchpoints, a new</span>
<span class="cm">		   watchpoint will be used. */</span>

		<span class="cm">/* First, find a free data watchpoint. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bp</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">bp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Each data watchpoint&#39;s control registers occupy 2 bits</span>
<span class="cm">			   (hence the 3), starting at bit 2 for D0 (hence the 2)</span>
<span class="cm">			   with 4 bits between for each watchpoint (yes, the 4). */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)))))</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We&#39;re out of watchpoints. */</span>
			<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E04</span><span class="p">]);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Configure the control register first. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;3&#39;</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;4&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Trigger on read. */</span>
			<span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">bp</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;2&#39;</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;4&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Trigger on write. */</span>
			<span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">bp</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* Ugly pointer arithmetics to configure the watched range. */</span>
		<span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set the S1 flag to enable watchpoints. */</span>
	<span class="n">reg</span><span class="p">.</span><span class="n">ccs</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">S_CCS_BITNR</span> <span class="o">+</span> <span class="n">CCS_SHIFT</span><span class="p">));</span>
	<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_watchpoint</span><span class="p">(</span><span class="kt">char</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Breakpoint/watchpoint types:</span>
<span class="cm">	   0 = memory breakpoint for instructions</span>
<span class="cm">	   (not supported; done via memory write instead)</span>
<span class="cm">	   1 = hardware breakpoint for instructions (supported)</span>
<span class="cm">	   2 = write watchpoint (supported)</span>
<span class="cm">	   3 = read watchpoint (supported)</span>
<span class="cm">	   4 = access watchpoint (supported) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="sc">&#39;1&#39;</span> <span class="o">||</span> <span class="n">type</span> <span class="o">&gt;</span> <span class="sc">&#39;4&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">output_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read watchpoints are set as access watchpoints, because of GDB&#39;s</span>
<span class="cm">	   inability to deal with pure read watchpoints. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;3&#39;</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="sc">&#39;4&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Hardware breakpoint. */</span>
		<span class="cm">/* Bit 0 in BP_CTRL holds the configuration for I0. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Not in use. */</span>
			<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E04</span><span class="p">]);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Deconfigure. */</span>
		<span class="n">sreg</span><span class="p">.</span><span class="n">s1_3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sreg</span><span class="p">.</span><span class="n">s2_3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bp_d_regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sreg</span><span class="p">.</span><span class="n">s3_3</span><span class="p">;</span>
		<span class="cm">/* Try to find a watchpoint that is configured for the</span>
<span class="cm">		   specified range, then check that read/write also matches. */</span>

		<span class="cm">/* Ugly pointer arithmetic, since I cannot rely on a</span>
<span class="cm">		   single switch (addr) as there may be several watchpoints with</span>
<span class="cm">		   the same start address for example. */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bp</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">bp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span>
			    <span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Matching range. */</span>
				<span class="kt">int</span> <span class="n">bitpos</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">bp</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">rw_bits</span><span class="p">;</span>

				<span class="cm">/* Read/write bits for this BP. */</span>
				<span class="n">rw_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">bitpos</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">bitpos</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;3&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">rw_bits</span> <span class="o">==</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;2&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">rw_bits</span> <span class="o">==</span> <span class="mh">0x2</span><span class="p">)</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;4&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">rw_bits</span> <span class="o">==</span> <span class="mh">0x3</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Read/write matched. */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No watchpoint matched. */</span>
			<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E04</span><span class="p">]);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Found a matching watchpoint. Now, deconfigure it by</span>
<span class="cm">		   both disabling read/write in bp_ctrl and zeroing its</span>
<span class="cm">		   start/end addresses. */</span>
		<span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)));</span>
		<span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bp_d_regs</span><span class="p">[</span><span class="n">bp</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Note that we don&#39;t clear the S1 flag here. It&#39;s done when continuing.  */</span>
	<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* All expected commands are sent from remote.c. Send a response according</span>
<span class="cm">   to the description in remote.c. */</span>
<span class="kt">void</span>
<span class="nf">handle_exception</span><span class="p">(</span><span class="kt">int</span> <span class="n">sigval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Avoid warning of not used. */</span>

	<span class="n">USEDFUN</span><span class="p">(</span><span class="n">handle_exception</span><span class="p">);</span>
	<span class="n">USEDVAR</span><span class="p">(</span><span class="n">internal_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">register_fixup</span><span class="p">(</span><span class="n">sigval</span><span class="p">);</span>

	<span class="cm">/* Send response. */</span>
	<span class="n">stub_is_stopped</span><span class="p">(</span><span class="n">sigval</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">output_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">getpacket</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">case</span> <span class="sc">&#39;g&#39;</span>:
				<span class="cm">/* Read registers: g</span>
<span class="cm">				   Success: Each byte of register data is described by two hex digits.</span>
<span class="cm">				   Registers are in the internal order for GDB, and the bytes</span>
<span class="cm">				   in a register  are in the same order the machine uses.</span>
<span class="cm">				   Failure: void. */</span>
			<span class="p">{</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
				<span class="cm">/* General and special registers. */</span>
				<span class="n">buf</span> <span class="o">=</span> <span class="n">mem2hex</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">registers</span><span class="p">));</span>
				<span class="cm">/* Support registers. */</span>
				<span class="cm">/* -1 because of the null termination that mem2hex adds. */</span>
				<span class="n">mem2hex</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sreg</span> <span class="o">+</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">srs</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)),</span>
					<span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">case</span> <span class="sc">&#39;G&#39;</span>:
				<span class="cm">/* Write registers. GXX..XX</span>
<span class="cm">				   Each byte of register data  is described by two hex digits.</span>
<span class="cm">				   Success: OK</span>
<span class="cm">				   Failure: void. */</span>
				<span class="cm">/* General and special registers. */</span>
				<span class="n">hex2mem</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">registers</span><span class="p">));</span>
				<span class="cm">/* Support registers. */</span>
				<span class="n">hex2mem</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sreg</span> <span class="o">+</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">srs</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)),</span>
					<span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">registers</span><span class="p">),</span>
					<span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>
				<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="sc">&#39;P&#39;</span>:
				<span class="cm">/* Write register. Pn...=r...</span>
<span class="cm">				   Write register n..., hex value without 0x, with value r...,</span>
<span class="cm">				   which contains a hex value without 0x and two hex digits</span>
<span class="cm">				   for each byte in the register (target byte order). P1f=11223344 means</span>
<span class="cm">				   set register 31 to 44332211.</span>
<span class="cm">				   Success: OK</span>
<span class="cm">				   Failure: E02, E05 */</span>
				<span class="p">{</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">;</span>
					<span class="kt">int</span> <span class="n">regno</span> <span class="o">=</span> <span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">suffix</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
					<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

					<span class="n">status</span> <span class="o">=</span> <span class="n">write_register</span><span class="p">(</span><span class="n">regno</span><span class="p">,</span> <span class="n">suffix</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

					<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">case</span> <span class="n">E02</span>:
							<span class="cm">/* Do not support read-only registers. */</span>
							<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E02</span><span class="p">]);</span>
							<span class="k">break</span><span class="p">;</span>
						<span class="k">case</span> <span class="n">E05</span>:
							<span class="cm">/* Do not support non-existing registers. */</span>
							<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E05</span><span class="p">]);</span>
							<span class="k">break</span><span class="p">;</span>
						<span class="nl">default:</span>
							<span class="cm">/* Valid register number. */</span>
							<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
							<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="sc">&#39;m&#39;</span>:
				<span class="cm">/* Read from memory. mAA..AA,LLLL</span>
<span class="cm">				   AA..AA is the address and LLLL is the length.</span>
<span class="cm">				   Success: XX..XX is the memory content.  Can be fewer bytes than</span>
<span class="cm">				   requested if only part of the data may be read. m6000120a,6c means</span>
<span class="cm">				   retrieve 108 byte from base address 6000120a.</span>
<span class="cm">				   Failure: void. */</span>
				<span class="p">{</span>
                                        <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">;</span>
					<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                                                               <span class="o">&amp;</span><span class="n">suffix</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
					<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="n">suffix</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

					<span class="cm">/* Bogus read (i.e. outside the kernel&#39;s</span>
<span class="cm">					   segment)? . */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="mh">0xc0000000</span> <span class="o">&amp;&amp;</span>
					      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="mh">0xd0000000</span><span class="p">))</span>
						<span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                                        <span class="n">mem2hex</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
                                <span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="sc">&#39;X&#39;</span>:
				<span class="cm">/* Write to memory. XAA..AA,LLLL:XX..XX</span>
<span class="cm">				   AA..AA is the start address,  LLLL is the number of bytes, and</span>
<span class="cm">				   XX..XX is the binary data.</span>
<span class="cm">				   Success: OK</span>
<span class="cm">				   Failure: void. */</span>
			<span class="k">case</span> <span class="sc">&#39;M&#39;</span>:
				<span class="cm">/* Write to memory. MAA..AA,LLLL:XX..XX</span>
<span class="cm">				   AA..AA is the start address,  LLLL is the number of bytes, and</span>
<span class="cm">				   XX..XX is the hexadecimal data.</span>
<span class="cm">				   Success: OK</span>
<span class="cm">				   Failure: void. */</span>
				<span class="p">{</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">lenptr</span><span class="p">;</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">dataptr</span><span class="p">;</span>
					<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
										      <span class="o">&amp;</span><span class="n">lenptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
					<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="n">lenptr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dataptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">lenptr</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">dataptr</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;M&#39;</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">hex2mem</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">dataptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
						<span class="p">}</span> <span class="k">else</span> <span class="cm">/* X */</span> <span class="p">{</span>
							<span class="n">bin2mem</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">dataptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
						<span class="p">}</span>
						<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">else</span> <span class="p">{</span>
						<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E06</span><span class="p">]);</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="sc">&#39;c&#39;</span>:
				<span class="cm">/* Continue execution. cAA..AA</span>
<span class="cm">				   AA..AA is the address where execution is resumed. If AA..AA is</span>
<span class="cm">				   omitted, resume at the present address.</span>
<span class="cm">				   Success: return to the executing thread.</span>
<span class="cm">				   Failure: will never know. */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* FIXME: Doesn&#39;t handle address argument. */</span>
					<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E04</span><span class="p">]);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Before continuing, make sure everything is set up correctly. */</span>

				<span class="cm">/* Set the SPC to some unlikely value.  */</span>
				<span class="n">reg</span><span class="p">.</span><span class="n">spc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="cm">/* Set the S1 flag to 0 unless some watchpoint is enabled (since setting</span>
<span class="cm">				   S1 to 0 would also disable watchpoints). (Note that bits 26-31 in BP_CTRL</span>
<span class="cm">				   are reserved, so don&#39;t check against those). */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">sreg</span><span class="p">.</span><span class="n">s0_3</span> <span class="o">&amp;</span> <span class="mh">0x3fff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">reg</span><span class="p">.</span><span class="n">ccs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">S_CCS_BITNR</span> <span class="o">+</span> <span class="n">CCS_SHIFT</span><span class="p">));</span>
				<span class="p">}</span>

				<span class="k">return</span><span class="p">;</span>

			<span class="k">case</span> <span class="sc">&#39;s&#39;</span>:
				<span class="cm">/* Step. sAA..AA</span>
<span class="cm">				   AA..AA is the address where execution is resumed. If AA..AA is</span>
<span class="cm">				   omitted, resume at the present address. Success: return to the</span>
<span class="cm">				   executing thread. Failure: will never know. */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* FIXME: Doesn&#39;t handle address argument. */</span>
					<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E04</span><span class="p">]);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Set the SPC to PC, which is where we&#39;ll return</span>
<span class="cm">				   (deduced previously). */</span>
				<span class="n">reg</span><span class="p">.</span><span class="n">spc</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">pc</span><span class="p">;</span>

				<span class="cm">/* Set the S1 (first stacked, not current) flag, which will</span>
<span class="cm">				   kick into action when we rfe. */</span>
				<span class="n">reg</span><span class="p">.</span><span class="n">ccs</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">S_CCS_BITNR</span> <span class="o">+</span> <span class="n">CCS_SHIFT</span><span class="p">));</span>
				<span class="k">return</span><span class="p">;</span>

                       <span class="k">case</span> <span class="sc">&#39;Z&#39;</span>:

                               <span class="cm">/* Insert breakpoint or watchpoint, Ztype,addr,length.</span>
<span class="cm">                                  Remote protocol says: A remote target shall return an empty string</span>
<span class="cm">                                  for an unrecognized breakpoint or watchpoint packet type. */</span>
                               <span class="p">{</span>
                                       <span class="kt">char</span> <span class="o">*</span><span class="n">lenptr</span><span class="p">;</span>
                                       <span class="kt">char</span> <span class="o">*</span><span class="n">dataptr</span><span class="p">;</span>
                                       <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">lenptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
                                       <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="n">lenptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dataptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
                                       <span class="kt">char</span> <span class="n">type</span> <span class="o">=</span> <span class="n">input_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

				       <span class="n">insert_watchpoint</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
                                       <span class="k">break</span><span class="p">;</span>
                               <span class="p">}</span>

                       <span class="k">case</span> <span class="sc">&#39;z&#39;</span>:
                               <span class="cm">/* Remove breakpoint or watchpoint, Ztype,addr,length.</span>
<span class="cm">                                  Remote protocol says: A remote target shall return an empty string</span>
<span class="cm">                                  for an unrecognized breakpoint or watchpoint packet type. */</span>
                               <span class="p">{</span>
                                       <span class="kt">char</span> <span class="o">*</span><span class="n">lenptr</span><span class="p">;</span>
                                       <span class="kt">char</span> <span class="o">*</span><span class="n">dataptr</span><span class="p">;</span>
                                       <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">lenptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
                                       <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">gdb_cris_strtol</span><span class="p">(</span><span class="n">lenptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dataptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
                                       <span class="kt">char</span> <span class="n">type</span> <span class="o">=</span> <span class="n">input_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

                                       <span class="n">remove_watchpoint</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
                                       <span class="k">break</span><span class="p">;</span>
                               <span class="p">}</span>


			<span class="k">case</span> <span class="sc">&#39;?&#39;</span>:
				<span class="cm">/* The last signal which caused a stop. ?</span>
<span class="cm">				   Success: SAA, where AA is the signal number.</span>
<span class="cm">				   Failure: void. */</span>
				<span class="n">output_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;S&#39;</span><span class="p">;</span>
				<span class="n">output_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex_asc_hi</span><span class="p">(</span><span class="n">sigval</span><span class="p">);</span>
				<span class="n">output_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex_asc_lo</span><span class="p">(</span><span class="n">sigval</span><span class="p">);</span>
				<span class="n">output_buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="sc">&#39;D&#39;</span>:
				<span class="cm">/* Detach from host. D</span>
<span class="cm">				   Success: OK, and return to the executing thread.</span>
<span class="cm">				   Failure: will never know */</span>
				<span class="n">putpacket</span><span class="p">(</span><span class="s">&quot;OK&quot;</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>

			<span class="k">case</span> <span class="sc">&#39;k&#39;</span>:
			<span class="k">case</span> <span class="sc">&#39;r&#39;</span>:
				<span class="cm">/* kill request or reset request.</span>
<span class="cm">				   Success: restart of target.</span>
<span class="cm">				   Failure: will never know. */</span>
				<span class="n">kill_restart</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="sc">&#39;C&#39;</span>:
			<span class="k">case</span> <span class="sc">&#39;S&#39;</span>:
			<span class="k">case</span> <span class="sc">&#39;!&#39;</span>:
			<span class="k">case</span> <span class="sc">&#39;R&#39;</span>:
			<span class="k">case</span> <span class="sc">&#39;d&#39;</span>:
				<span class="cm">/* Continue with signal sig. Csig;AA..AA</span>
<span class="cm">				   Step with signal sig. Ssig;AA..AA</span>
<span class="cm">				   Use the extended remote protocol. !</span>
<span class="cm">				   Restart the target system. R0</span>
<span class="cm">				   Toggle debug flag. d</span>
<span class="cm">				   Search backwards. tAA:PP,MM</span>
<span class="cm">				   Not supported: E04 */</span>

				<span class="cm">/* FIXME: What&#39;s the difference between not supported</span>
<span class="cm">				   and ignored (below)? */</span>
				<span class="n">gdb_cris_strcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">error_message</span><span class="p">[</span><span class="n">E04</span><span class="p">]);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span>
				<span class="cm">/* The stub should ignore other request and send an empty</span>
<span class="cm">				   response ($#&lt;checksum&gt;). This way we can extend the protocol and GDB</span>
<span class="cm">				   can tell whether the stub it is talking to uses the old or the new. */</span>
				<span class="n">output_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">putpacket</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">kgdb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reg_intr_vect_rw_mask</span> <span class="n">intr_mask</span><span class="p">;</span>
	<span class="n">reg_ser_rw_intr_mask</span> <span class="n">ser_intr_mask</span><span class="p">;</span>

	<span class="cm">/* Configure the kgdb serial port. */</span>
<span class="cp">#if defined(CONFIG_ETRAX_KGDB_PORT0)</span>
	<span class="cm">/* Note: no shortcut registered (not handled by multiple_interrupt).</span>
<span class="cm">	   See entry.S.  */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="n">SER0_INTR_VECT</span><span class="p">,</span> <span class="n">kgdb_handle_exception</span><span class="p">);</span>
	<span class="cm">/* Enable the ser irq in the global config. */</span>
	<span class="n">intr_mask</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">);</span>
	<span class="n">intr_mask</span><span class="p">.</span><span class="n">ser0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="n">intr_mask</span><span class="p">);</span>

	<span class="n">ser_intr_mask</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">regi_ser0</span><span class="p">,</span> <span class="n">rw_intr_mask</span><span class="p">);</span>
	<span class="n">ser_intr_mask</span><span class="p">.</span><span class="n">dav</span> <span class="o">=</span> <span class="n">regk_ser_yes</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">regi_ser0</span><span class="p">,</span> <span class="n">rw_intr_mask</span><span class="p">,</span> <span class="n">ser_intr_mask</span><span class="p">);</span>
<span class="cp">#elif defined(CONFIG_ETRAX_KGDB_PORT1)</span>
	<span class="cm">/* Note: no shortcut registered (not handled by multiple_interrupt).</span>
<span class="cm">	   See entry.S.  */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="n">SER1_INTR_VECT</span><span class="p">,</span> <span class="n">kgdb_handle_exception</span><span class="p">);</span>
	<span class="cm">/* Enable the ser irq in the global config. */</span>
	<span class="n">intr_mask</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">);</span>
	<span class="n">intr_mask</span><span class="p">.</span><span class="n">ser1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="n">intr_mask</span><span class="p">);</span>

	<span class="n">ser_intr_mask</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">regi_ser1</span><span class="p">,</span> <span class="n">rw_intr_mask</span><span class="p">);</span>
	<span class="n">ser_intr_mask</span><span class="p">.</span><span class="n">dav</span> <span class="o">=</span> <span class="n">regk_ser_yes</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">regi_ser1</span><span class="p">,</span> <span class="n">rw_intr_mask</span><span class="p">,</span> <span class="n">ser_intr_mask</span><span class="p">);</span>
<span class="cp">#elif defined(CONFIG_ETRAX_KGDB_PORT2)</span>
	<span class="cm">/* Note: no shortcut registered (not handled by multiple_interrupt).</span>
<span class="cm">	   See entry.S.  */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="n">SER2_INTR_VECT</span><span class="p">,</span> <span class="n">kgdb_handle_exception</span><span class="p">);</span>
	<span class="cm">/* Enable the ser irq in the global config. */</span>
	<span class="n">intr_mask</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">);</span>
	<span class="n">intr_mask</span><span class="p">.</span><span class="n">ser2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="n">intr_mask</span><span class="p">);</span>

	<span class="n">ser_intr_mask</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">regi_ser2</span><span class="p">,</span> <span class="n">rw_intr_mask</span><span class="p">);</span>
	<span class="n">ser_intr_mask</span><span class="p">.</span><span class="n">dav</span> <span class="o">=</span> <span class="n">regk_ser_yes</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">regi_ser2</span><span class="p">,</span> <span class="n">rw_intr_mask</span><span class="p">,</span> <span class="n">ser_intr_mask</span><span class="p">);</span>
<span class="cp">#elif defined(CONFIG_ETRAX_KGDB_PORT3)</span>
	<span class="cm">/* Note: no shortcut registered (not handled by multiple_interrupt).</span>
<span class="cm">	   See entry.S.  */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="n">SER3_INTR_VECT</span><span class="p">,</span> <span class="n">kgdb_handle_exception</span><span class="p">);</span>
	<span class="cm">/* Enable the ser irq in the global config. */</span>
	<span class="n">intr_mask</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">);</span>
	<span class="n">intr_mask</span><span class="p">.</span><span class="n">ser3</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="n">intr_mask</span><span class="p">);</span>

	<span class="n">ser_intr_mask</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">regi_ser3</span><span class="p">,</span> <span class="n">rw_intr_mask</span><span class="p">);</span>
	<span class="n">ser_intr_mask</span><span class="p">.</span><span class="n">dav</span> <span class="o">=</span> <span class="n">regk_ser_yes</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">regi_ser3</span><span class="p">,</span> <span class="n">rw_intr_mask</span><span class="p">,</span> <span class="n">ser_intr_mask</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="p">}</span>
<span class="cm">/* Performs a complete re-start from scratch. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">kill_restart</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">machine_restart</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Use this static breakpoint in the start-up only. */</span>

<span class="kt">void</span>
<span class="nf">breakpoint</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kgdb_started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dynamic_bp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="cm">/* This is a static, not a dynamic breakpoint. */</span>
	<span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;break 8&quot;</span><span class="p">);</span> <span class="cm">/* Jump to kgdb_handle_breakpoint. */</span>
<span class="p">}</span>

<span class="cm">/****************************** End of file **********************************/</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
