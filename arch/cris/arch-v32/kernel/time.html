<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › cris › arch-v32 › kernel › time.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>time.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/cris/arch-v32/kernel/time.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2003-2010 Axis Communications AB</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/cpufreq.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/signal.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>

<span class="cp">#include &lt;hwregs/reg_map.h&gt;</span>
<span class="cp">#include &lt;hwregs/reg_rdwr.h&gt;</span>
<span class="cp">#include &lt;hwregs/timer_defs.h&gt;</span>
<span class="cp">#include &lt;hwregs/intr_vect_defs.h&gt;</span>
<span class="cp">#ifdef CONFIG_CRIS_MACH_ARTPEC3</span>
<span class="cp">#include &lt;hwregs/clkgen_defs.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/* Watchdog defines */</span>
<span class="cp">#define ETRAX_WD_KEY_MASK	0x7F </span><span class="cm">/* key is 7 bit */</span><span class="cp"></span>
<span class="cp">#define ETRAX_WD_HZ		763 </span><span class="cm">/* watchdog counts at 763 Hz */</span><span class="cp"></span>
<span class="cm">/* Number of 763 counts before watchdog bites */</span>
<span class="cp">#define ETRAX_WD_CNT		((2*ETRAX_WD_HZ)/HZ + 1)</span>

<span class="cm">/* Register the continuos readonly timer available in FS and ARTPEC-3.  */</span>
<span class="k">static</span> <span class="n">cycle_t</span> <span class="nf">read_cont_rotime</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">REG_RD</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">regi_timer0</span><span class="p">,</span> <span class="n">r_time</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="n">cont_rotime</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>   <span class="o">=</span> <span class="s">&quot;crisv32_rotime&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>   <span class="o">=</span> <span class="n">read_cont_rotime</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask</span>   <span class="o">=</span> <span class="n">CLOCKSOURCE_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
	<span class="p">.</span><span class="n">flags</span>  <span class="o">=</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">etrax_init_cont_rotime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clocksource_register_khz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cont_rotime</span><span class="p">,</span> <span class="mi">100000</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">arch_initcall</span><span class="p">(</span><span class="n">etrax_init_cont_rotime</span><span class="p">);</span>


<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="n">regi_timer0</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">regi_timer2</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_rtc_mmss</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nowtime</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CPU_FREQ</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">cris_time_freq_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">cris_time_freq_notifier_block</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">cris_time_freq_notifier</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_ns_in_jiffie</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reg_timer_r_tmr0_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ns</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">regi_timer0</span><span class="p">,</span> <span class="n">r_tmr0_data</span><span class="p">);</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">TIMER0_DIV</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* From timer MDS describing the hardware watchdog:</span>
<span class="cm"> * 4.3.1 Watchdog Operation</span>
<span class="cm"> * The watchdog timer is an 8-bit timer with a configurable start value.</span>
<span class="cm"> * Once started the watchdog counts downwards with a frequency of 763 Hz</span>
<span class="cm"> * (100/131072 MHz). When the watchdog counts down to 1, it generates an</span>
<span class="cm"> * NMI (Non Maskable Interrupt), and when it counts down to 0, it resets the</span>
<span class="cm"> * chip.</span>
<span class="cm"> */</span>
<span class="cm">/* This gives us 1.3 ms to do something useful when the NMI comes */</span>

<span class="cm">/* Right now, starting the watchdog is the same as resetting it */</span>
<span class="cp">#define start_watchdog reset_watchdog</span>

<span class="cp">#if defined(CONFIG_ETRAX_WATCHDOG)</span>
<span class="k">static</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">watchdog_key</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="cm">/* arbitrary 7 bit number */</span>
<span class="cp">#endif</span>

<span class="cm">/* Number of pages to consider &quot;out of memory&quot;. It is normal that the memory</span>
<span class="cm"> * is used though, so set this really low. */</span>
<span class="cp">#define WATCHDOG_MIN_FREE_PAGES 8</span>

<span class="kt">void</span> <span class="nf">reset_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_ETRAX_WATCHDOG)</span>
	<span class="n">reg_timer_rw_wd_ctrl</span> <span class="n">wd_ctrl</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="cm">/* Only keep watchdog happy as long as we have memory left! */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nr_free_pages</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">WATCHDOG_MIN_FREE_PAGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset the watchdog with the inverse of the old key */</span>
		<span class="cm">/* Invert key, which is 7 bits */</span>
		<span class="n">watchdog_key</span> <span class="o">^=</span> <span class="n">ETRAX_WD_KEY_MASK</span><span class="p">;</span>
		<span class="n">wd_ctrl</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">ETRAX_WD_CNT</span><span class="p">;</span>
		<span class="n">wd_ctrl</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">regk_timer_start</span><span class="p">;</span>
		<span class="n">wd_ctrl</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">watchdog_key</span><span class="p">;</span>
		<span class="n">REG_WR</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">regi_timer0</span><span class="p">,</span> <span class="n">rw_wd_ctrl</span><span class="p">,</span> <span class="n">wd_ctrl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* stop the watchdog - we still need the correct key */</span>

<span class="kt">void</span> <span class="nf">stop_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_ETRAX_WATCHDOG)</span>
	<span class="n">reg_timer_rw_wd_ctrl</span> <span class="n">wd_ctrl</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">watchdog_key</span> <span class="o">^=</span> <span class="n">ETRAX_WD_KEY_MASK</span><span class="p">;</span> <span class="cm">/* invert key, which is 7 bits */</span>
	<span class="n">wd_ctrl</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">ETRAX_WD_CNT</span><span class="p">;</span>
	<span class="n">wd_ctrl</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">regk_timer_stop</span><span class="p">;</span>
	<span class="n">wd_ctrl</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">watchdog_key</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">regi_timer0</span><span class="p">,</span> <span class="n">rw_wd_ctrl</span><span class="p">,</span> <span class="n">wd_ctrl</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">show_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">handle_watchdog_bite</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_ETRAX_WATCHDOG)</span>
	<span class="k">extern</span> <span class="kt">int</span> <span class="n">cause_of_death</span><span class="p">;</span>

	<span class="n">oops_in_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Watchdog bite</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Check if forced restart or unexpected watchdog */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cause_of_death</span> <span class="o">==</span> <span class="mh">0xbedead</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_CRIS_MACH_ARTPEC3</span>
		<span class="cm">/* There is a bug in Artpec-3 (voodoo TR 78) that requires</span>
<span class="cm">		 * us to go to lower frequency for the reset to be reliable</span>
<span class="cm">		 */</span>
		<span class="n">reg_clkgen_rw_clk_ctrl</span> <span class="n">ctrl</span> <span class="o">=</span>
			<span class="n">REG_RD</span><span class="p">(</span><span class="n">clkgen</span><span class="p">,</span> <span class="n">regi_clkgen</span><span class="p">,</span> <span class="n">rw_clk_ctrl</span><span class="p">);</span>
		<span class="n">ctrl</span><span class="p">.</span><span class="n">pll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">REG_WR</span><span class="p">(</span><span class="n">clkgen</span><span class="p">,</span> <span class="n">regi_clkgen</span><span class="p">,</span> <span class="n">rw_clk_ctrl</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Unexpected watchdog, stop the watchdog and dump registers. */</span>
	<span class="n">stop_watchdog</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Oops: bitten by watchdog</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">show_registers</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">oops_in_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_ETRAX_WATCHDOG_NICE_DOGGY</span>
	<span class="n">reset_watchdog</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="cm">/* nothing */</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * timer_interrupt() needs to keep up the real-time clock,</span>
<span class="cm"> * as well as call the &quot;xtime_update()&quot; routine every clocktick.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cris_do_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">irqreturn_t</span> <span class="nf">timer_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">get_irq_regs</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">reg_timer_r_masked_intr</span> <span class="n">masked_intr</span><span class="p">;</span>
	<span class="n">reg_timer_rw_ack_intr</span> <span class="n">ack_intr</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="cm">/* Check if the timer interrupt is for us (a tmr0 int) */</span>
	<span class="n">masked_intr</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">r_masked_intr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">masked_intr</span><span class="p">.</span><span class="n">tmr0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Acknowledge the timer irq. */</span>
	<span class="n">ack_intr</span><span class="p">.</span><span class="n">tmr0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_ack_intr</span><span class="p">,</span> <span class="n">ack_intr</span><span class="p">);</span>

	<span class="cm">/* Reset watchdog otherwise it resets us! */</span>
	<span class="n">reset_watchdog</span><span class="p">();</span>

        <span class="cm">/* Update statistics. */</span>
	<span class="n">update_process_times</span><span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>

	<span class="n">cris_do_profile</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span> <span class="cm">/* Save profiling information */</span>

	<span class="cm">/* The master CPU is responsible for the time keeping. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="cm">/* Call the real timer interrupt handler */</span>
	<span class="n">xtime_update</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Timer is IRQF_SHARED so drivers can add stuff to the timer irq chain.</span>
<span class="cm"> * It needs to be IRQF_DISABLED to make the jiffies update work properly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">irq_timer</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">timer_interrupt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span> <span class="o">|</span> <span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;timer&quot;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">cris_timer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">reg_timer_rw_tmr0_ctrl</span> <span class="n">tmr0_ctrl</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">reg_timer_rw_tmr0_div</span> <span class="n">tmr0_div</span> <span class="o">=</span> <span class="n">TIMER0_DIV</span><span class="p">;</span>
	<span class="n">reg_timer_rw_intr_mask</span> <span class="n">timer_intr_mask</span><span class="p">;</span>

	<span class="cm">/* Setup the etrax timers.</span>
<span class="cm">	 * Base frequency is 100MHz, divider 1000000 -&gt; 100 HZ</span>
<span class="cm">	 * We use timer0, so timer1 is free.</span>
<span class="cm">	 * The trig timer is used by the fasttimer API if enabled.</span>
<span class="cm">	 */</span>

	<span class="n">tmr0_ctrl</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">regk_timer_ld</span><span class="p">;</span>
	<span class="n">tmr0_ctrl</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">regk_timer_f100</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_tmr0_div</span><span class="p">,</span> <span class="n">tmr0_div</span><span class="p">);</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_tmr0_ctrl</span><span class="p">,</span> <span class="n">tmr0_ctrl</span><span class="p">);</span> <span class="cm">/* Load */</span>
	<span class="n">tmr0_ctrl</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">regk_timer_run</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_tmr0_ctrl</span><span class="p">,</span> <span class="n">tmr0_ctrl</span><span class="p">);</span> <span class="cm">/* Start */</span>

	<span class="cm">/* Enable the timer irq. */</span>
	<span class="n">timer_intr_mask</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_intr_mask</span><span class="p">);</span>
	<span class="n">timer_intr_mask</span><span class="p">.</span><span class="n">tmr0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">REG_WR</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_intr_mask</span><span class="p">,</span> <span class="n">timer_intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">time_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reg_intr_vect_rw_mask</span> <span class="n">intr_mask</span><span class="p">;</span>

	<span class="cm">/* Probe for the RTC and read it if it exists.</span>
<span class="cm">	 * Before the RTC can be probed the loops_per_usec variable needs</span>
<span class="cm">	 * to be initialized to make usleep work. A better value for</span>
<span class="cm">	 * loops_per_usec is calculated by the kernel later once the</span>
<span class="cm">	 * clock has started.</span>
<span class="cm">	 */</span>
	<span class="n">loops_per_usec</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

	<span class="cm">/* Start CPU local timer. */</span>
	<span class="n">cris_timer_init</span><span class="p">();</span>

	<span class="cm">/* Enable the timer irq in global config. */</span>
	<span class="n">intr_mask</span> <span class="o">=</span> <span class="n">REG_RD_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">intr_mask</span><span class="p">.</span><span class="n">timer0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">REG_WR_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">intr_mask</span><span class="p">);</span>

	<span class="cm">/* Now actually register the timer irq handler that calls</span>
<span class="cm">	 * timer_interrupt(). */</span>
	<span class="n">setup_irq</span><span class="p">(</span><span class="n">TIMER0_INTR_VECT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_timer</span><span class="p">);</span>

	<span class="cm">/* Enable watchdog if we should use one. */</span>

<span class="cp">#if defined(CONFIG_ETRAX_WATCHDOG)</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Enabling watchdog...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">start_watchdog</span><span class="p">();</span>

	<span class="cm">/* If we use the hardware watchdog, we want to trap it as an NMI</span>
<span class="cm">	 * and dump registers before it resets us.  For this to happen, we</span>
<span class="cm">	 * must set the &quot;m&quot; NMI enable flag (which once set, is unset only</span>
<span class="cm">	 * when an NMI is taken). */</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">local_save_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">);</span> <span class="cm">/* NMI M flag is at bit 30 */</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CPU_FREQ</span>
	<span class="n">cpufreq_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cris_time_freq_notifier_block</span><span class="p">,</span>
		<span class="n">CPUFREQ_TRANSITION_NOTIFIER</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CPU_FREQ</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cris_time_freq_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpufreq_freqs</span> <span class="o">*</span><span class="n">freqs</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_POSTCHANGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_timer_r_tmr0_data</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">reg_timer_rw_tmr0_div</span> <span class="n">div</span> <span class="o">=</span> <span class="p">(</span><span class="n">freqs</span><span class="o">-&gt;</span><span class="n">new</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">REG_RD</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">freqs</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">],</span>
				<span class="n">r_tmr0_data</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">REG_WR</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_regs</span><span class="p">[</span><span class="n">freqs</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_tmr0_div</span><span class="p">,</span> <span class="n">div</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
