<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › cris › arch-v32 › kernel › irq.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>irq.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2003, Axis Communications AB.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;hwregs/reg_map.h&gt;</span>
<span class="cp">#include &lt;hwregs/reg_rdwr.h&gt;</span>
<span class="cp">#include &lt;hwregs/intr_vect.h&gt;</span>
<span class="cp">#include &lt;hwregs/intr_vect_defs.h&gt;</span>

<span class="cp">#define CPU_FIXED -1</span>

<span class="cm">/* IRQ masks (refer to comment for crisv32_do_multiple) */</span>
<span class="cp">#if TIMER0_INTR_VECT - FIRST_IRQ &lt; 32</span>
<span class="cp">#define TIMER_MASK (1 &lt;&lt; (TIMER0_INTR_VECT - FIRST_IRQ))</span>
<span class="cp">#undef TIMER_VECT1</span>
<span class="cp">#else</span>
<span class="cp">#define TIMER_MASK (1 &lt;&lt; (TIMER0_INTR_VECT - FIRST_IRQ - 32))</span>
<span class="cp">#define TIMER_VECT1</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_ETRAX_KGDB</span>
<span class="cp">#if defined(CONFIG_ETRAX_KGDB_PORT0)</span>
<span class="cp">#define IGNOREMASK (1 &lt;&lt; (SER0_INTR_VECT - FIRST_IRQ))</span>
<span class="cp">#elif defined(CONFIG_ETRAX_KGDB_PORT1)</span>
<span class="cp">#define IGNOREMASK (1 &lt;&lt; (SER1_INTR_VECT - FIRST_IRQ))</span>
<span class="cp">#elif defined(CONFIG_ETRAX_KGB_PORT2)</span>
<span class="cp">#define IGNOREMASK (1 &lt;&lt; (SER2_INTR_VECT - FIRST_IRQ))</span>
<span class="cp">#elif defined(CONFIG_ETRAX_KGDB_PORT3)</span>
<span class="cp">#define IGNOREMASK (1 &lt;&lt; (SER3_INTR_VECT - FIRST_IRQ))</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">irq_lock</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">cris_irq_allocation</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span> <span class="cm">/* The CPU to which the IRQ is currently allocated. */</span>
  <span class="n">cpumask_t</span> <span class="n">mask</span><span class="p">;</span> <span class="cm">/* The CPUs to which the IRQ may be allocated. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cris_irq_allocation</span> <span class="n">irq_allocations</span><span class="p">[</span><span class="n">NR_REAL_IRQS</span><span class="p">]</span> <span class="o">=</span>
  <span class="p">{</span> <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">NR_REAL_IRQS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">CPU_MASK_ALL</span><span class="p">}</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="n">regi_irq</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SMP</span>
  <span class="n">regi_irq2</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#if NR_REAL_IRQS &gt; 32</span>
<span class="cp">#define NBR_REGS 2</span>
<span class="cp">#else</span>
<span class="cp">#define NBR_REGS 1</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_irq_counters</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_counters</span><span class="p">[</span><span class="n">NR_REAL_IRQS</span><span class="p">];</span>

<span class="cm">/* From irq.c. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">weird_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* From entry.S. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">system_call</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nmi_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">multiple_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">gdb_handle_exception</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i_mmu_refill</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i_mmu_invalid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i_mmu_access</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i_mmu_execute</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_mmu_refill</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_mmu_invalid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_mmu_access</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_mmu_write</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* From kgdb.c. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kgdb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">breakpoint</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* From traps.c.  */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">breakh_BUG</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Build the IRQ handler stubs using macros from irq.h.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_CRIS_MACH_ARTPEC3</span>
<span class="n">BUILD_TIMER_IRQ</span><span class="p">(</span><span class="mh">0x31</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x32</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x33</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x34</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x35</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x36</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x37</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x38</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x39</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x3b</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x3c</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x3d</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x3e</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x3f</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x41</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x42</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x43</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x44</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x45</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x46</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x47</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x48</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x49</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x4a</span><span class="p">)</span>
<span class="cp">#ifdef CONFIG_ETRAXFS</span>
<span class="n">BUILD_TIMER_IRQ</span><span class="p">(</span><span class="mh">0x4b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x4b</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x4c</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x4d</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x4e</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x4f</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x50</span><span class="p">)</span>
<span class="cp">#if MACH_IRQS &gt; 32</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x51</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x52</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x53</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x54</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x55</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x56</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x57</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x58</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x59</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x5a</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x5b</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x5c</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x5d</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x5e</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x5f</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x60</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x62</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x63</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x64</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x65</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x66</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x67</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x68</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x69</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x6a</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x6b</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x6c</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x6d</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x6e</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x6f</span><span class="p">)</span>
<span class="n">BUILD_IRQ</span><span class="p">(</span><span class="mh">0x70</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="cm">/* Pointers to the low-level handlers. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interrupt</span><span class="p">[</span><span class="n">MACH_IRQS</span><span class="p">])(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">IRQ0x31_interrupt</span><span class="p">,</span> <span class="n">IRQ0x32_interrupt</span><span class="p">,</span> <span class="n">IRQ0x33_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x34_interrupt</span><span class="p">,</span> <span class="n">IRQ0x35_interrupt</span><span class="p">,</span> <span class="n">IRQ0x36_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x37_interrupt</span><span class="p">,</span> <span class="n">IRQ0x38_interrupt</span><span class="p">,</span> <span class="n">IRQ0x39_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x3a_interrupt</span><span class="p">,</span> <span class="n">IRQ0x3b_interrupt</span><span class="p">,</span> <span class="n">IRQ0x3c_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x3d_interrupt</span><span class="p">,</span> <span class="n">IRQ0x3e_interrupt</span><span class="p">,</span> <span class="n">IRQ0x3f_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x40_interrupt</span><span class="p">,</span> <span class="n">IRQ0x41_interrupt</span><span class="p">,</span> <span class="n">IRQ0x42_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x43_interrupt</span><span class="p">,</span> <span class="n">IRQ0x44_interrupt</span><span class="p">,</span> <span class="n">IRQ0x45_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x46_interrupt</span><span class="p">,</span> <span class="n">IRQ0x47_interrupt</span><span class="p">,</span> <span class="n">IRQ0x48_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x49_interrupt</span><span class="p">,</span> <span class="n">IRQ0x4a_interrupt</span><span class="p">,</span> <span class="n">IRQ0x4b_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x4c_interrupt</span><span class="p">,</span> <span class="n">IRQ0x4d_interrupt</span><span class="p">,</span> <span class="n">IRQ0x4e_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x4f_interrupt</span><span class="p">,</span> <span class="n">IRQ0x50_interrupt</span><span class="p">,</span>
<span class="cp">#if MACH_IRQS &gt; 32</span>
	<span class="n">IRQ0x51_interrupt</span><span class="p">,</span> <span class="n">IRQ0x52_interrupt</span><span class="p">,</span> <span class="n">IRQ0x53_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x54_interrupt</span><span class="p">,</span> <span class="n">IRQ0x55_interrupt</span><span class="p">,</span> <span class="n">IRQ0x56_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x57_interrupt</span><span class="p">,</span> <span class="n">IRQ0x58_interrupt</span><span class="p">,</span> <span class="n">IRQ0x59_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x5a_interrupt</span><span class="p">,</span> <span class="n">IRQ0x5b_interrupt</span><span class="p">,</span> <span class="n">IRQ0x5c_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x5d_interrupt</span><span class="p">,</span> <span class="n">IRQ0x5e_interrupt</span><span class="p">,</span> <span class="n">IRQ0x5f_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x60_interrupt</span><span class="p">,</span> <span class="n">IRQ0x61_interrupt</span><span class="p">,</span> <span class="n">IRQ0x62_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x63_interrupt</span><span class="p">,</span> <span class="n">IRQ0x64_interrupt</span><span class="p">,</span> <span class="n">IRQ0x65_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x66_interrupt</span><span class="p">,</span> <span class="n">IRQ0x67_interrupt</span><span class="p">,</span> <span class="n">IRQ0x68_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x69_interrupt</span><span class="p">,</span> <span class="n">IRQ0x6a_interrupt</span><span class="p">,</span> <span class="n">IRQ0x6b_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x6c_interrupt</span><span class="p">,</span> <span class="n">IRQ0x6d_interrupt</span><span class="p">,</span> <span class="n">IRQ0x6e_interrupt</span><span class="p">,</span>
	<span class="n">IRQ0x6f_interrupt</span><span class="p">,</span> <span class="n">IRQ0x70_interrupt</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="kt">void</span>
<span class="nf">block_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">intr_mask</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Remember, 1 let thru, 0 block. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intr_mask</span> <span class="o">=</span> <span class="n">REG_RD_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span>
			<span class="n">rw_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">intr_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span><span class="p">));</span>
		<span class="n">REG_WR_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_mask</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">intr_mask</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">intr_mask</span> <span class="o">=</span> <span class="n">REG_RD_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span>
			<span class="n">rw_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">intr_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span> <span class="o">-</span> <span class="mi">32</span><span class="p">));</span>
		<span class="n">REG_WR_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_mask</span><span class="p">,</span>
			<span class="mi">1</span><span class="p">,</span> <span class="n">intr_mask</span><span class="p">);</span>
	<span class="p">}</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">unblock_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">intr_mask</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Remember, 1 let thru, 0 block. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intr_mask</span> <span class="o">=</span> <span class="n">REG_RD_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span>
			<span class="n">rw_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">intr_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span><span class="p">));</span>
		<span class="n">REG_WR_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_mask</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">intr_mask</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">intr_mask</span> <span class="o">=</span> <span class="n">REG_RD_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span>
			<span class="n">rw_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">intr_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span> <span class="o">-</span> <span class="mi">32</span><span class="p">));</span>
		<span class="n">REG_WR_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_mask</span><span class="p">,</span>
			<span class="mi">1</span><span class="p">,</span> <span class="n">intr_mask</span><span class="p">);</span>
	<span class="p">}</span>
        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Find out which CPU the irq should be allocated to. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irq_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="n">cpu</span> <span class="o">=</span> <span class="n">irq_allocations</span><span class="p">[</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span><span class="p">].</span><span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* Fixed interrupts stay on the local CPU. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">CPU_FIXED</span><span class="p">)</span>
        <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">smp_processor_id</span><span class="p">();</span>
        <span class="p">}</span>


	<span class="cm">/* Let the interrupt stay if possible */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_allocations</span><span class="p">[</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span><span class="p">].</span><span class="n">mask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* IRQ must be moved to another CPU. */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_allocations</span><span class="p">[</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span><span class="p">].</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">irq_allocations</span><span class="p">[</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span><span class="p">].</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crisv32_mask_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">cpu</span><span class="o">++</span><span class="p">)</span>
		<span class="n">block_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crisv32_unmask_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unblock_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_cpu</span><span class="p">(</span><span class="n">irq</span><span class="p">));</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_crisv32_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">crisv32_unmask_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_crisv32_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">crisv32_mask_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_affinity_crisv32_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">irq_allocations</span><span class="p">[</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">crisv32_irq_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;CRISv32&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_shutdown</span>		<span class="o">=</span> <span class="n">disable_crisv32_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_enable</span>		<span class="o">=</span> <span class="n">enable_crisv32_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_disable</span>		<span class="o">=</span> <span class="n">disable_crisv32_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span>	<span class="o">=</span> <span class="n">set_affinity_crisv32_irq</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span>
<span class="nf">set_exception_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">irqvectptr</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">etrax_irv</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">irqvectptr</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">do_IRQ</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">regs</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">crisv32_do_IRQ</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span><span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Interrupts that may not be moved to another CPU and</span>
<span class="cm">         * are IRQF_DISABLED may skip blocking. This is currently</span>
<span class="cm">         * only valid for the timer IRQ and the IPI and is used</span>
<span class="cm">         * for the timer interrupt to avoid watchdog starvation.</span>
<span class="cm">         */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_IRQ</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">block_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">do_IRQ</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="n">unblock_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_cpu</span><span class="p">(</span><span class="n">irq</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* If multiple interrupts occur simultaneously we get a multiple</span>
<span class="cm"> * interrupt from the CPU and software has to sort out which</span>
<span class="cm"> * interrupts that happened. There are two special cases here:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Timer interrupts may never be blocked because of the</span>
<span class="cm"> *    watchdog (refer to comment in include/asr/arch/irq.h)</span>
<span class="cm"> * 2. GDB serial port IRQs are unhandled here and will be handled</span>
<span class="cm"> *    as a single IRQ when it strikes again because the GDB</span>
<span class="cm"> *    stubb wants to save the registers in its own fashion.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">crisv32_do_multiple</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">masked</span><span class="p">[</span><span class="n">NBR_REGS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/* An extra irq_enter here to prevent softIRQs to run after</span>
<span class="cm">         * each do_IRQ. This will decrease the interrupt latency.</span>
<span class="cm">	 */</span>
	<span class="n">irq_enter</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBR_REGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get which IRQs that happened. */</span>
		<span class="n">masked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">REG_RD_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span>
			<span class="n">r_masked_vect</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/* Calculate new IRQ mask with these IRQs disabled. */</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">REG_RD_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">masked</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/* Timer IRQ is never masked */</span>
<span class="cp">#ifdef TIMER_VECT1</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">TIMER_MASK</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">TIMER_MASK</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">TIMER_MASK</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">TIMER_MASK</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="cm">/* Block all the IRQs */</span>
		<span class="n">REG_WR_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* Check for timer IRQ and handle it special. */</span>
<span class="cp">#ifdef TIMER_VECT1</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">masked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">TIMER_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">masked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TIMER_MASK</span><span class="p">;</span>
			<span class="n">do_IRQ</span><span class="p">(</span><span class="n">TIMER0_INTR_VECT</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">masked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">TIMER_MASK</span><span class="p">))</span> <span class="p">{</span>
			 <span class="n">masked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TIMER_MASK</span><span class="p">;</span>
			 <span class="n">do_IRQ</span><span class="p">(</span><span class="n">TIMER0_INTR_VECT</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

<span class="cp">#ifdef IGNORE_MASK</span>
	<span class="cm">/* Remove IRQs that can&#39;t be handled as multiple. */</span>
	<span class="n">masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGNORE_MASK</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Handle the rest of the IRQs. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBR_REGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">bit</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">masked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">))</span>
				<span class="n">do_IRQ</span><span class="p">(</span><span class="n">bit</span> <span class="o">+</span> <span class="n">FIRST_IRQ</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">32</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Unblock all the IRQs. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBR_REGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">REG_RD_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">masked</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">REG_WR_INT_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">irq_regs</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* This irq_exit() will trigger the soft IRQs. */</span>
	<span class="n">irq_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called by start_kernel. It fixes the IRQ masks and setup the</span>
<span class="cm"> * interrupt vector table to point to bad_interrupt pointers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">init_IRQ</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">reg_intr_vect_rw_mask</span> <span class="n">vect_mask</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

	<span class="cm">/* Clear all interrupts masks. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBR_REGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">REG_WR_VECT</span><span class="p">(</span><span class="n">intr_vect</span><span class="p">,</span> <span class="n">regi_irq</span><span class="p">,</span> <span class="n">rw_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vect_mask</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">etrax_irv</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weird_irq</span><span class="p">;</span>

	<span class="cm">/* Point all IRQ&#39;s to bad handlers. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">FIRST_IRQ</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NR_IRQS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq_set_chip_and_handler</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">crisv32_irq_type</span><span class="p">,</span>
					 <span class="n">handle_simple_irq</span><span class="p">);</span>
		<span class="n">set_exception_vector</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Mark Timer and IPI IRQs as CPU local */</span>
	<span class="n">irq_allocations</span><span class="p">[</span><span class="n">TIMER0_INTR_VECT</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span><span class="p">].</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">CPU_FIXED</span><span class="p">;</span>
	<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">TIMER0_INTR_VECT</span><span class="p">,</span> <span class="n">IRQ_PER_CPU</span><span class="p">);</span>
	<span class="n">irq_allocations</span><span class="p">[</span><span class="n">IPI_INTR_VECT</span> <span class="o">-</span> <span class="n">FIRST_IRQ</span><span class="p">].</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">CPU_FIXED</span><span class="p">;</span>
	<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">IPI_INTR_VECT</span><span class="p">,</span> <span class="n">IRQ_PER_CPU</span><span class="p">);</span>

	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">nmi_interrupt</span><span class="p">);</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x30</span><span class="p">,</span> <span class="n">multiple_interrupt</span><span class="p">);</span>

	<span class="cm">/* Set up handler for various MMU bus faults. */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x04</span><span class="p">,</span> <span class="n">i_mmu_refill</span><span class="p">);</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x05</span><span class="p">,</span> <span class="n">i_mmu_invalid</span><span class="p">);</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x06</span><span class="p">,</span> <span class="n">i_mmu_access</span><span class="p">);</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x07</span><span class="p">,</span> <span class="n">i_mmu_execute</span><span class="p">);</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x08</span><span class="p">,</span> <span class="n">d_mmu_refill</span><span class="p">);</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x09</span><span class="p">,</span> <span class="n">d_mmu_invalid</span><span class="p">);</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x0a</span><span class="p">,</span> <span class="n">d_mmu_access</span><span class="p">);</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x0b</span><span class="p">,</span> <span class="n">d_mmu_write</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BUG</span>
	<span class="cm">/* Break 14 handler, used to implement cheap BUG().  */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x1e</span><span class="p">,</span> <span class="n">breakh_BUG</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* The system-call trap is reached by &quot;break 13&quot;. */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x1d</span><span class="p">,</span> <span class="n">system_call</span><span class="p">);</span>

	<span class="cm">/* Exception handlers for debugging, both user-mode and kernel-mode. */</span>

	<span class="cm">/* Break 8. */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x18</span><span class="p">,</span> <span class="n">gdb_handle_exception</span><span class="p">);</span>
	<span class="cm">/* Hardware single step. */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">gdb_handle_exception</span><span class="p">);</span>
	<span class="cm">/* Hardware breakpoint. */</span>
	<span class="n">set_exception_vector</span><span class="p">(</span><span class="mh">0xc</span><span class="p">,</span> <span class="n">gdb_handle_exception</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ETRAX_KGDB</span>
	<span class="n">kgdb_init</span><span class="p">();</span>
	<span class="cm">/* Everything is set up; now trap the kernel. */</span>
	<span class="n">breakpoint</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
