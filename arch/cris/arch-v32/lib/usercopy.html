<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › cris › arch-v32 › lib › usercopy.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>usercopy.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * User address space access functions.</span>
<span class="cm"> * The non-inlined parts of asm-cris/uaccess.h are here.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000, 2003 Axis Communications AB.</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Hans-Peter Nilsson.</span>
<span class="cm"> * Pieces used from memcpy, originally by Kenny Ranerup long time ago.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cm">/* Asm:s have been tweaked (within the domain of correctness) to give</span>
<span class="cm">   satisfactory results for &quot;gcc version 3.2.1 Axis release R53/1.53-v32&quot;.</span>

<span class="cm">   Check regularly...</span>

<span class="cm">   Note that for CRISv32, the PC saved at a bus-fault is the address</span>
<span class="cm">   *at* the faulting instruction, with a special case for instructions</span>
<span class="cm">   in delay slots: then it&#39;s the address of the branch.  Note also that</span>
<span class="cm">   in contrast to v10, a postincrement in the instruction is *not*</span>
<span class="cm">   performed at a bus-fault; the register is seen having the original</span>
<span class="cm">   value in fault handlers.  */</span>


<span class="cm">/* Copy to userspace.  This is based on the memcpy used for</span>
<span class="cm">   kernel-to-kernel copying; see &quot;string.c&quot;.  */</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">__copy_user</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pdst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">psrc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pn</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* We want the parameters put in special registers.</span>
<span class="cm">     Make sure the compiler is able to make something useful of this.</span>
<span class="cm">     As it is now: r10 -&gt; r13; r11 -&gt; r11 (nop); r12 -&gt; r12 (nop).</span>

<span class="cm">     FIXME: Comment for old gcc version.  Check.</span>
<span class="cm">     If gcc was alright, it really would need no temporaries, and no</span>
<span class="cm">     stack space to save stuff on. */</span>

  <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r13&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">pdst</span><span class="p">;</span>
  <span class="k">register</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">psrc</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">n</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r12&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">pn</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">retn</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r10&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


  <span class="cm">/* When src is aligned but not dst, this makes a few extra needless</span>
<span class="cm">     cycles.  I believe it would take as many to check that the</span>
<span class="cm">     re-alignment was unnecessary.  */</span>
  <span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dst</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="cm">/* Don&#39;t align if we wouldn&#39;t copy more than a few bytes; so we</span>
<span class="cm">	 don&#39;t have to check further for overflows.  */</span>
      <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dst</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">__asm_copy_to_user_1</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="n">n</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dst</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">__asm_copy_to_user_2</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="n">n</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/* Movem is dirt cheap.  The overheap is low enough to always use the</span>
<span class="cm">     minimum possible block size as the threshold.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">44</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* For large copies we use &#39;movem&#39;.  */</span>

    <span class="cm">/* It is not optimal to tell the compiler about clobbering any</span>
<span class="cm">       registers; that will move the saving/restoring of those registers</span>
<span class="cm">       to the function prologue/epilogue, and make non-movem sizes</span>
<span class="cm">       suboptimal.  */</span>
    <span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;\</span>
<span class="s">        ;; Check that the register asm declaration got right.		</span><span class="se">\n</span><span class="s">\</span>
<span class="s">        ;; The GCC manual explicitly says TRT will happen.		</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.ifnc %0%1%2%3,$r13$r11$r12$r10					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.err								</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.endif								</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Save the registers we&#39;ll use in the movem process		</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; on the stack.						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq	11*4,$sp						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem	$r10,[$sp]						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Now we&#39;ve got this:						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; r11 - src							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; r13 - dst							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; r12 - n							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Update n for the first loop					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq	44,$r12							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">0:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem	[$r11+],$r10						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq   44,$r12							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">1:	bge	0b							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem	$r10,[$r13+]						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">3:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	addq   44,$r12  ;; compensate for last loop underflowing n	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Restore registers from stack					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem [$sp+],$r10						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">2:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.section .fixup,</span><span class="se">\&quot;</span><span class="s">ax</span><span class="se">\&quot;</span><span class="s">						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">4:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">; When failing on any of the 1..44 bytes in a chunk, we adjust back the	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">; source pointer and just drop through	to the by-16 and by-4 loops to	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">; get the correct number of failing bytes.  This necessarily means a	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">; few extra exceptions, but invalid user pointers shouldn&#39;t happen in	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">; time-critical code anyway.						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	jump 3b								</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq 44,$r11							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.previous							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.section __ex_table,</span><span class="se">\&quot;</span><span class="s">a</span><span class="se">\&quot;</span><span class="s">					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.dword 1b,4b							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.previous&quot;</span>

     <span class="cm">/* Outputs */</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">retn</span><span class="p">)</span>
     <span class="cm">/* Inputs */</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="s">&quot;2&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s">&quot;3&quot;</span> <span class="p">(</span><span class="n">retn</span><span class="p">));</span>

  <span class="p">}</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">__asm_copy_to_user_16</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* Having a separate by-four loops cuts down on cache footprint.</span>
<span class="cm">     FIXME:  Test with and without; increasing switch to be 0..15.  */</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">__asm_copy_to_user_4</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span>:
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span>:
      <span class="n">__asm_copy_to_user_1</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span>:
      <span class="n">__asm_copy_to_user_2</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">3</span>:
      <span class="n">__asm_copy_to_user_3</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">retn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Copy from user to kernel, zeroing the bytes that were inaccessible in</span>
<span class="cm">   userland.  The return-value is the number of bytes that were</span>
<span class="cm">   inaccessible.  */</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">__copy_user_zeroing</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pdst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">psrc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pn</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* We want the parameters put in special registers.</span>
<span class="cm">     Make sure the compiler is able to make something useful of this.</span>
<span class="cm">     As it is now: r10 -&gt; r13; r11 -&gt; r11 (nop); r12 -&gt; r12 (nop).</span>

<span class="cm">     FIXME: Comment for old gcc version.  Check.</span>
<span class="cm">     If gcc was alright, it really would need no temporaries, and no</span>
<span class="cm">     stack space to save stuff on.  */</span>

  <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r13&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">pdst</span><span class="p">;</span>
  <span class="k">register</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">psrc</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">n</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r12&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">pn</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">retn</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r10&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/* The best reason to align src is that we then know that a read-fault</span>
<span class="cm">     was for aligned bytes; there&#39;s no 1..3 remaining good bytes to</span>
<span class="cm">     pickle.  */</span>
  <span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">src</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">src</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">__asm_copy_from_user_1</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="n">n</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">src</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">__asm_copy_from_user_2</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="n">n</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* We only need one check after the unalignment-adjustments, because</span>
<span class="cm">       if both adjustments were done, either both or neither reference</span>
<span class="cm">       had an exception.  */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">copy_exception_bytes</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* Movem is dirt cheap.  The overheap is low enough to always use the</span>
<span class="cm">     minimum possible block size as the threshold.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">44</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* It is not optimal to tell the compiler about clobbering any</span>
<span class="cm">       registers; that will move the saving/restoring of those registers</span>
<span class="cm">       to the function prologue/epilogue, and make non-movem sizes</span>
<span class="cm">       suboptimal.  */</span>
    <span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;\</span>
<span class="s">	.ifnc %0%1%2%3,$r13$r11$r12$r10					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.err								</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.endif								</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Save the registers we&#39;ll use in the movem process		</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; on the stack.						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq	11*4,$sp						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem	$r10,[$sp]						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Now we&#39;ve got this:						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; r11 - src							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; r13 - dst							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; r12 - n							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Update n for the first loop					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq	44,$r12							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">0:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem	[$r11+],$r10						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq   44,$r12							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	bge	0b							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem	$r10,[$r13+]						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">4:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	addq   44,$r12  ;; compensate for last loop underflowing n	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Restore registers from stack					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem [$sp+],$r10						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.section .fixup,</span><span class="se">\&quot;</span><span class="s">ax</span><span class="se">\&quot;</span><span class="s">						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; Do not jump back into the loop if we fail.  For some uses, we get a	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; page fault somewhere on the line.  Without checking for page limits,	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; we don&#39;t know where, but we need to copy accurately and keep an	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; accurate count; not just clear the whole line.  To do that, we fall	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; down in the code below, proceeding with smaller amounts.  It should	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; be kept in mind that we have to cater to code like what at one time	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; was in fs/super.c:							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;;  i = size - copy_from_user((void *)page, data, size);		</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; which would cause repeated faults while clearing the remainder of	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; the SIZE bytes at PAGE after the first fault.			</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; A caveat here is that we must not fall through from a failing page	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">;; to a valid page.							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">3:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	jump	4b ;; Fall through, pretending the fault didn&#39;t happen.	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	nop								</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.previous							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.section __ex_table,</span><span class="se">\&quot;</span><span class="s">a</span><span class="se">\&quot;</span><span class="s">					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.dword 0b,3b							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.previous&quot;</span>

     <span class="cm">/* Outputs */</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">retn</span><span class="p">)</span>
     <span class="cm">/* Inputs */</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="s">&quot;2&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s">&quot;3&quot;</span> <span class="p">(</span><span class="n">retn</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cm">/* Either we directly start copying here, using dword copying in a loop,</span>
<span class="cm">     or we copy as much as possible with &#39;movem&#39; and then the last block</span>
<span class="cm">     (&lt;44 bytes) is copied here.  This will work since &#39;movem&#39; will have</span>
<span class="cm">     updated src, dst and n.  (Except with failing src.)</span>

<span class="cm">     Since we want to keep src accurate, we can&#39;t use</span>
<span class="cm">     __asm_copy_from_user_N with N != (1, 2, 4); it updates dst and</span>
<span class="cm">     retn, but not src (by design; it&#39;s value is ignored elsewhere).  */</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">__asm_copy_from_user_4</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">retn</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">copy_exception_bytes</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* If we get here, there were no memory read faults.  */</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* These copies are at least &quot;naturally aligned&quot; (so we don&#39;t have</span>
<span class="cm">       to check each byte), due to the src alignment code before the</span>
<span class="cm">       movem loop.  The *_3 case *will* get the correct count for retn.  */</span>
    <span class="k">case</span> <span class="mi">0</span>:
      <span class="cm">/* This case deliberately left in (if you have doubts check the</span>
<span class="cm">	 generated assembly code).  */</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span>:
      <span class="n">__asm_copy_from_user_1</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span>:
      <span class="n">__asm_copy_from_user_2</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">3</span>:
      <span class="n">__asm_copy_from_user_3</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* If we get here, retn correctly reflects the number of failing</span>
<span class="cm">     bytes.  */</span>
  <span class="k">return</span> <span class="n">retn</span><span class="p">;</span>

<span class="nl">copy_exception_bytes:</span>
  <span class="cm">/* We already have &quot;retn&quot; bytes cleared, and need to clear the</span>
<span class="cm">     remaining &quot;n&quot; bytes.  A non-optimized simple byte-for-byte in-line</span>
<span class="cm">     memset is preferred here, since this isn&#39;t speed-critical code and</span>
<span class="cm">     we&#39;d rather have this a leaf-function than calling memset.  */</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">endp</span> <span class="o">=</span> <span class="n">dst</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="n">dst</span> <span class="o">&lt;</span> <span class="n">endp</span><span class="p">;</span> <span class="n">dst</span><span class="o">++</span><span class="p">)</span>
      <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">retn</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Zero userspace.  */</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">__do_clear_user</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pto</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pn</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* We want the parameters put in special registers.</span>
<span class="cm">     Make sure the compiler is able to make something useful of this.</span>
<span class="cm">      As it is now: r10 -&gt; r13; r11 -&gt; r11 (nop); r12 -&gt; r12 (nop).</span>

<span class="cm">     FIXME: Comment for old gcc version.  Check.</span>
<span class="cm">     If gcc was alright, it really would need no temporaries, and no</span>
<span class="cm">     stack space to save stuff on. */</span>

  <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r13&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">pto</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">n</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r12&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">pn</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">retn</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;r10&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


  <span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dst</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
     <span class="cm">/* Don&#39;t align if we wouldn&#39;t copy more than a few bytes.  */</span>
      <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dst</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">__asm_clear_1</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="n">n</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dst</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">__asm_clear_2</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="n">n</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/* Decide which copying method to use.</span>
<span class="cm">     FIXME: This number is from the &quot;ordinary&quot; kernel memset.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">48</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* For large clears we use &#39;movem&#39; */</span>

    <span class="cm">/* It is not optimal to tell the compiler about clobbering any</span>
<span class="cm">       call-saved registers; that will move the saving/restoring of</span>
<span class="cm">       those registers to the function prologue/epilogue, and make</span>
<span class="cm">       non-movem sizes suboptimal.</span>

<span class="cm">       This method is not foolproof; it assumes that the &quot;asm reg&quot;</span>
<span class="cm">       declarations at the beginning of the function really are used</span>
<span class="cm">       here (beware: they may be moved to temporary registers).</span>
<span class="cm">       This way, we do not have to save/move the registers around into</span>
<span class="cm">       temporaries; we can safely use them straight away.</span>

<span class="cm">      If you want to check that the allocation was right; then</span>
<span class="cm">      check the equalities in the first comment.  It should say</span>
<span class="cm">      something like &quot;r13=r13, r11=r11, r12=r12&quot;. */</span>
    <span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;\</span>
<span class="s">	.ifnc %0%1%2,$r13$r12$r10					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.err								</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.endif								</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Save the registers we&#39;ll clobber in the movem process	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; on the stack.  Don&#39;t mention them to gcc, it will only be	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; upset.							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq	11*4,$sp						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem	$r10,[$sp]						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r0							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r1							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r2							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r3							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r4							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r5							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r6							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r7							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r8							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r9							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r10							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r11							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Now we&#39;ve got this:						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; r13 - dst							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; r12 - n							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Update n for the first loop					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq	12*4,$r12						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">0:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	subq   12*4,$r12						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">1:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	bge	0b							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem	$r11,[$r13+]						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	addq   12*4,$r12 ;; compensate for last loop underflowing n	</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	;; Restore registers from stack					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem [$sp+],$r10						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">2:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.section .fixup,</span><span class="se">\&quot;</span><span class="s">ax</span><span class="se">\&quot;</span><span class="s">						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">3:									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem [$sp],$r10						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	addq 12*4,$r10							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	addq 12*4,$r13							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	movem $r10,[$sp]						</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	jump 0b								</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	clear.d $r10							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">									</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.previous							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.section __ex_table,</span><span class="se">\&quot;</span><span class="s">a</span><span class="se">\&quot;</span><span class="s">					</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.dword 1b,3b							</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	.previous&quot;</span>

     <span class="cm">/* Outputs */</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">retn</span><span class="p">)</span>
     <span class="cm">/* Inputs */</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s">&quot;2&quot;</span> <span class="p">(</span><span class="n">retn</span><span class="p">)</span>
     <span class="cm">/* Clobber */</span> <span class="o">:</span> <span class="s">&quot;r11&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">__asm_clear_16</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* Having a separate by-four loops cuts down on cache footprint.</span>
<span class="cm">     FIXME:  Test with and without; increasing switch to be 0..15.  */</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">__asm_clear_4</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span>:
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span>:
      <span class="n">__asm_clear_1</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span>:
      <span class="n">__asm_clear_2</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">3</span>:
      <span class="n">__asm_clear_3</span> <span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">retn</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">retn</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
