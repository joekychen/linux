<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › cris › include › arch-v10 › arch › irq.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>irq.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Interrupt handling assembler and defines for Linux/CRISv10</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_ARCH_IRQ_H</span>
<span class="cp">#define _ASM_ARCH_IRQ_H</span>

<span class="cp">#include &lt;arch/sv_addr_ag.h&gt;</span>

<span class="cp">#define NR_IRQS 32</span>

<span class="cm">/* The first vector number used for IRQs in v10 is really 0x20 */</span>
<span class="cm">/* but all the code and constants are offseted to make 0 the first */</span>
<span class="cp">#define FIRST_IRQ 0</span>

<span class="cp">#define SOME_IRQ_NBR        IO_BITNR(R_VECT_MASK_RD, some)   </span><span class="cm">/* 0 ? */</span><span class="cp"></span>
<span class="cp">#define NMI_IRQ_NBR         IO_BITNR(R_VECT_MASK_RD, nmi)    </span><span class="cm">/* 1 */</span><span class="cp"></span>
<span class="cp">#define TIMER0_IRQ_NBR      IO_BITNR(R_VECT_MASK_RD, timer0) </span><span class="cm">/* 2 */</span><span class="cp"></span>
<span class="cp">#define TIMER1_IRQ_NBR      IO_BITNR(R_VECT_MASK_RD, timer1) </span><span class="cm">/* 3 */</span><span class="cp"></span>
<span class="cm">/* mio, ata, par0, scsi0 on 4 */</span>
<span class="cm">/* par1, scsi1 on 5 */</span>
<span class="cp">#define NETWORK_STATUS_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, network) </span><span class="cm">/* 6 */</span><span class="cp"></span>

<span class="cp">#define SERIAL_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, serial) </span><span class="cm">/* 8 */</span><span class="cp"></span>
<span class="cp">#define PA_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, pa) </span><span class="cm">/* 11 */</span><span class="cp"></span>
<span class="cm">/* extdma0 and extdma1 is at irq 12 and 13 and/or same as dma5 and dma6 ? */</span>
<span class="cp">#define EXTDMA0_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, ext_dma0)</span>
<span class="cp">#define EXTDMA1_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, ext_dma1)</span>

<span class="cm">/* dma0-9 is irq 16..25 */</span>
<span class="cm">/* 16,17: network */</span>
<span class="cp">#define DMA0_TX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma0)</span>
<span class="cp">#define DMA1_RX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma1)</span>
<span class="cp">#define NETWORK_DMA_TX_IRQ_NBR DMA0_TX_IRQ_NBR</span>
<span class="cp">#define NETWORK_DMA_RX_IRQ_NBR DMA1_RX_IRQ_NBR</span>

<span class="cm">/* 18,19: dma2 and dma3 shared by par0, scsi0, ser2 and ata */</span>
<span class="cp">#define DMA2_TX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma2)</span>
<span class="cp">#define DMA3_RX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma3)</span>
<span class="cp">#define SER2_DMA_TX_IRQ_NBR DMA2_TX_IRQ_NBR</span>
<span class="cp">#define SER2_DMA_RX_IRQ_NBR DMA3_RX_IRQ_NBR</span>

<span class="cm">/* 20,21: dma4 and dma5 shared by par1, scsi1, ser3 and extdma0 */</span>
<span class="cp">#define DMA4_TX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma4)</span>
<span class="cp">#define DMA5_RX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma5)</span>
<span class="cp">#define SER3_DMA_TX_IRQ_NBR DMA4_TX_IRQ_NBR</span>
<span class="cp">#define SER3_DMA_RX_IRQ_NBR DMA5_RX_IRQ_NBR</span>

<span class="cm">/* 22,23: dma6 and dma7 shared by ser0, extdma1 and mem2mem */</span>
<span class="cp">#define DMA6_TX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma6)</span>
<span class="cp">#define DMA7_RX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma7)</span>
<span class="cp">#define SER0_DMA_TX_IRQ_NBR DMA6_TX_IRQ_NBR</span>
<span class="cp">#define SER0_DMA_RX_IRQ_NBR DMA7_RX_IRQ_NBR</span>
<span class="cp">#define MEM2MEM_DMA_TX_IRQ_NBR DMA6_TX_IRQ_NBR</span>
<span class="cp">#define MEM2MEM_DMA_RX_IRQ_NBR DMA7_RX_IRQ_NBR</span>

<span class="cm">/* 24,25: dma8 and dma9 shared by ser1 and usb */</span>
<span class="cp">#define DMA8_TX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma8)</span>
<span class="cp">#define DMA9_RX_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, dma9)</span>
<span class="cp">#define SER1_DMA_TX_IRQ_NBR DMA8_TX_IRQ_NBR</span>
<span class="cp">#define SER1_DMA_RX_IRQ_NBR DMA9_RX_IRQ_NBR</span>
<span class="cp">#define USB_DMA_TX_IRQ_NBR DMA8_TX_IRQ_NBR</span>
<span class="cp">#define USB_DMA_RX_IRQ_NBR DMA9_RX_IRQ_NBR</span>

<span class="cm">/* usb: controller at irq 31 + uses DMA8 and DMA9 */</span>
<span class="cp">#define USB_HC_IRQ_NBR IO_BITNR(R_VECT_MASK_RD, usb)</span>

<span class="cm">/* our fine, global, etrax irq vector! the pointer lives in the head.S file. */</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irqvectptr</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">etrax_interrupt_vector</span> <span class="p">{</span>
	<span class="n">irqvectptr</span> <span class="n">v</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">etrax_interrupt_vector</span> <span class="o">*</span><span class="n">etrax_irv</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">set_int_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">irqvectptr</span> <span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">set_break_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">irqvectptr</span> <span class="n">addr</span><span class="p">);</span>

<span class="cp">#define __STR(x) #x</span>
<span class="cp">#define STR(x) __STR(x)</span>
 
<span class="cm">/* SAVE_ALL saves registers so they match pt_regs */</span>

<span class="cp">#define SAVE_ALL \</span>
<span class="cp">  &quot;move $irp,[$sp=$sp-16]\n\t&quot; </span><span class="cm">/* push instruction pointer and fake SBFS struct */</span><span class="cp"> \</span>
<span class="cp">  &quot;push $srp\n\t&quot;       </span><span class="cm">/* push subroutine return pointer */</span><span class="cp"> \</span>
<span class="cp">  &quot;push $dccr\n\t&quot;      </span><span class="cm">/* push condition codes */</span><span class="cp"> \</span>
<span class="cp">  &quot;push $mof\n\t&quot;       </span><span class="cm">/* push multiply overflow reg */</span><span class="cp"> \</span>
<span class="cp">  &quot;di\n\t&quot;             </span><span class="cm">/* need to disable irq&#39;s at this point */</span><span class="cp">\</span>
<span class="cp">  &quot;subq 14*4,$sp\n\t&quot;   </span><span class="cm">/* make room for r0-r13 */</span><span class="cp"> \</span>
<span class="cp">  &quot;movem $r13,[$sp]\n\t&quot; </span><span class="cm">/* push the r0-r13 registers */</span><span class="cp"> \</span>
<span class="cp">  &quot;push $r10\n\t&quot;       </span><span class="cm">/* push orig_r10 */</span><span class="cp"> \</span>
<span class="cp">  &quot;clear.d [$sp=$sp-4]\n\t&quot;  </span><span class="cm">/* frametype - this is a normal stackframe */</span><span class="cp"></span>

<span class="cm">/* BLOCK_IRQ and UNBLOCK_IRQ do the same as</span>
<span class="cm"> * crisv10_mask_irq and crisv10_unmask_irq */</span>

<span class="cp">#define BLOCK_IRQ(mask,nr) \</span>
<span class="cp">  &quot;move.d &quot; #mask &quot;,$r0\n\t&quot; \</span>
<span class="cp">  &quot;move.d $r0,[0xb00000d8]\n\t&quot;</span>

<span class="cp">#define UNBLOCK_IRQ(mask) \</span>
<span class="cp">  &quot;move.d &quot; #mask &quot;,$r0\n\t&quot; \</span>
<span class="cp">  &quot;move.d $r0,[0xb00000dc]\n\t&quot;</span>

<span class="cp">#define IRQ_NAME2(nr) nr##_interrupt(void)</span>
<span class="cp">#define IRQ_NAME(nr) IRQ_NAME2(IRQ##nr)</span>
<span class="cp">#define sIRQ_NAME(nr) IRQ_NAME2(sIRQ##nr)</span>
<span class="cp">#define BAD_IRQ_NAME(nr) IRQ_NAME2(bad_IRQ##nr)</span>

  <span class="cm">/* the asm IRQ handler makes sure the causing IRQ is blocked, then it calls</span>
<span class="cm">   * do_IRQ (with irq disabled still). after that it unblocks and jumps to</span>
<span class="cm">   * ret_from_intr (entry.S)</span>
<span class="cm">   *</span>
<span class="cm">   * The reason the IRQ is blocked is to allow an sti() before the handler which</span>
<span class="cm">   * will acknowledge the interrupt is run.</span>
<span class="cm">   */</span>

<span class="cp">#define BUILD_IRQ(nr,mask) \</span>
<span class="cp">void IRQ_NAME(nr); \</span>
<span class="cp">__asm__ ( \</span>
<span class="cp">          &quot;.text\n\t&quot; \</span>
<span class="cp">          &quot;IRQ&quot; #nr &quot;_interrupt:\n\t&quot; \</span>
<span class="cp">	  SAVE_ALL \</span>
<span class="cp">	  BLOCK_IRQ(mask,nr) </span><span class="cm">/* this must be done to prevent irq loops when we ei later */</span><span class="cp"> \</span>
<span class="cp">	  &quot;moveq &quot;#nr&quot;,$r10\n\t&quot; \</span>
<span class="cp">	  &quot;move.d $sp,$r11\n\t&quot; \</span>
<span class="cp">	  &quot;jsr do_IRQ\n\t&quot; </span><span class="cm">/* irq.c, r10 and r11 are arguments */</span><span class="cp"> \</span>
<span class="cp">	  UNBLOCK_IRQ(mask) \</span>
<span class="cp">	  &quot;moveq 0,$r9\n\t&quot; </span><span class="cm">/* make ret_from_intr realise we came from an irq */</span><span class="cp"> \</span>
<span class="cp">	  &quot;jump ret_from_intr\n\t&quot;);</span>

<span class="cm">/* This is subtle. The timer interrupt is crucial and it should not be disabled for </span>
<span class="cm"> * too long. However, if it had been a normal interrupt as per BUILD_IRQ, it would</span>
<span class="cm"> * have been BLOCK&#39;ed, and then softirq&#39;s are run before we return here to UNBLOCK.</span>
<span class="cm"> * If the softirq&#39;s take too much time to run, the timer irq won&#39;t run and the </span>
<span class="cm"> * watchdog will kill us.</span>
<span class="cm"> *</span>
<span class="cm"> * Furthermore, if a lot of other irq&#39;s occur before we return here, the multiple_irq</span>
<span class="cm"> * handler is run and it prioritizes the timer interrupt. However if we had BLOCK&#39;ed</span>
<span class="cm"> * it here, we would not get the multiple_irq at all.</span>
<span class="cm"> *</span>
<span class="cm"> * The non-blocking here is based on the knowledge that the timer interrupt is </span>
<span class="cm"> * registred as a fast interrupt (IRQF_DISABLED) so that we _know_ there will not</span>
<span class="cm"> * be an sti() before the timer irq handler is run to acknowledge the interrupt.</span>
<span class="cm"> */</span>

<span class="cp">#define BUILD_TIMER_IRQ(nr,mask) \</span>
<span class="cp">void IRQ_NAME(nr); \</span>
<span class="cp">__asm__ ( \</span>
<span class="cp">          &quot;.text\n\t&quot; \</span>
<span class="cp">          &quot;IRQ&quot; #nr &quot;_interrupt:\n\t&quot; \</span>
<span class="cp">	  SAVE_ALL \</span>
<span class="cp">	  &quot;moveq &quot;#nr&quot;,$r10\n\t&quot; \</span>
<span class="cp">	  &quot;move.d $sp,$r11\n\t&quot; \</span>
<span class="cp">	  &quot;jsr do_IRQ\n\t&quot; </span><span class="cm">/* irq.c, r10 and r11 are arguments */</span><span class="cp"> \</span>
<span class="cp">	  &quot;moveq 0,$r9\n\t&quot; </span><span class="cm">/* make ret_from_intr realise we came from an irq */</span><span class="cp"> \</span>
<span class="cp">	  &quot;jump ret_from_intr\n\t&quot;);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
