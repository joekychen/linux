<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › cris › include › asm › etraxgpio.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>etraxgpio.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * The following devices are accessible using this driver using</span>
<span class="cm"> * GPIO_MAJOR (120) and a couple of minor numbers.</span>
<span class="cm"> *</span>
<span class="cm"> * For ETRAX 100LX (CONFIG_ETRAX_ARCH_V10):</span>
<span class="cm"> * /dev/gpioa  minor 0, 8 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/gpiob  minor 1, 8 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/leds   minor 2, Access to leds depending on kernelconfig</span>
<span class="cm"> * /dev/gpiog  minor 3</span>
<span class="cm"> *       g0dir, g8_15dir, g16_23dir, g24 dir configurable in R_GEN_CONFIG</span>
<span class="cm"> *       g1-g7 and g25-g31 is both input and outputs but on different pins</span>
<span class="cm"> *       Also note that some bits change pins depending on what interfaces</span>
<span class="cm"> *       are enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * For ETRAX FS (CONFIG_ETRAXFS):</span>
<span class="cm"> * /dev/gpioa  minor 0,  8 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/gpiob  minor 1, 18 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/gpioc  minor 3, 18 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/gpiod  minor 4, 18 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/gpioe  minor 5, 18 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/leds   minor 2, Access to leds depending on kernelconfig</span>
<span class="cm"> *</span>
<span class="cm"> * For ARTPEC-3 (CONFIG_CRIS_MACH_ARTPEC3):</span>
<span class="cm"> * /dev/gpioa  minor 0, 32 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/gpiob  minor 1, 32 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/gpioc  minor 3, 16 bit GPIO, each bit can change direction</span>
<span class="cm"> * /dev/gpiod  minor 4, 32 bit GPIO, input only</span>
<span class="cm"> * /dev/leds   minor 2, Access to leds depending on kernelconfig</span>
<span class="cm"> * /dev/pwm0   minor 16, PWM channel 0 on PA30</span>
<span class="cm"> * /dev/pwm1   minor 17, PWM channel 1 on PA31</span>
<span class="cm"> * /dev/pwm2   minor 18, PWM channel 2 on PB26</span>
<span class="cm"> * /dev/ppwm   minor 19, PPWM channel</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_ETRAXGPIO_H</span>
<span class="cp">#define _ASM_ETRAXGPIO_H</span>

<span class="cp">#define GPIO_MINOR_FIRST 0</span>

<span class="cp">#define ETRAXGPIO_IOCTYPE 43</span>

<span class="cm">/* etraxgpio _IOC_TYPE, bits 8 to 15 in ioctl cmd */</span>
<span class="cp">#ifdef CONFIG_ETRAX_ARCH_V10</span>
<span class="cp">#define GPIO_MINOR_A 0</span>
<span class="cp">#define GPIO_MINOR_B 1</span>
<span class="cp">#define GPIO_MINOR_LEDS 2</span>
<span class="cp">#define GPIO_MINOR_G 3</span>
<span class="cp">#define GPIO_MINOR_LAST 3</span>
<span class="cp">#define GPIO_MINOR_LAST_REAL GPIO_MINOR_LAST</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ETRAXFS</span>
<span class="cp">#define GPIO_MINOR_A 0</span>
<span class="cp">#define GPIO_MINOR_B 1</span>
<span class="cp">#define GPIO_MINOR_LEDS 2</span>
<span class="cp">#define GPIO_MINOR_C 3</span>
<span class="cp">#define GPIO_MINOR_D 4</span>
<span class="cp">#define GPIO_MINOR_E 5</span>
<span class="cp">#ifdef CONFIG_ETRAX_VIRTUAL_GPIO</span>
<span class="cp">#define GPIO_MINOR_V 6</span>
<span class="cp">#define GPIO_MINOR_LAST 6</span>
<span class="cp">#else</span>
<span class="cp">#define GPIO_MINOR_LAST 5</span>
<span class="cp">#endif</span>
<span class="cp">#define GPIO_MINOR_LAST_REAL GPIO_MINOR_LAST</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CRIS_MACH_ARTPEC3</span>
<span class="cp">#define GPIO_MINOR_A 0</span>
<span class="cp">#define GPIO_MINOR_B 1</span>
<span class="cp">#define GPIO_MINOR_LEDS 2</span>
<span class="cp">#define GPIO_MINOR_C 3</span>
<span class="cp">#define GPIO_MINOR_D 4</span>
<span class="cp">#ifdef CONFIG_ETRAX_VIRTUAL_GPIO</span>
<span class="cp">#define GPIO_MINOR_V 6</span>
<span class="cp">#define GPIO_MINOR_LAST 6</span>
<span class="cp">#else</span>
<span class="cp">#define GPIO_MINOR_LAST 4</span>
<span class="cp">#endif</span>
<span class="cp">#define GPIO_MINOR_FIRST_PWM 16</span>
<span class="cp">#define GPIO_MINOR_PWM0 (GPIO_MINOR_FIRST_PWM+0)</span>
<span class="cp">#define GPIO_MINOR_PWM1 (GPIO_MINOR_FIRST_PWM+1)</span>
<span class="cp">#define GPIO_MINOR_PWM2 (GPIO_MINOR_FIRST_PWM+2)</span>
<span class="cp">#define GPIO_MINOR_PPWM (GPIO_MINOR_FIRST_PWM+3)</span>
<span class="cp">#define GPIO_MINOR_LAST_PWM GPIO_MINOR_PPWM</span>
<span class="cp">#define GPIO_MINOR_LAST_REAL GPIO_MINOR_LAST_PWM</span>
<span class="cp">#endif</span>



<span class="cm">/* supported ioctl _IOC_NR&#39;s */</span>

<span class="cp">#define IO_READBITS  0x1  </span><span class="cm">/* read and return current port bits (obsolete) */</span><span class="cp"></span>
<span class="cp">#define IO_SETBITS   0x2  </span><span class="cm">/* set the bits marked by 1 in the argument */</span><span class="cp"></span>
<span class="cp">#define IO_CLRBITS   0x3  </span><span class="cm">/* clear the bits marked by 1 in the argument */</span><span class="cp"></span>

<span class="cm">/* the alarm is waited for by select() */</span>

<span class="cp">#define IO_HIGHALARM 0x4  </span><span class="cm">/* set alarm on high for bits marked by 1 */</span><span class="cp"></span>
<span class="cp">#define IO_LOWALARM  0x5  </span><span class="cm">/* set alarm on low for bits marked by 1 */</span><span class="cp"></span>
<span class="cp">#define IO_CLRALARM  0x6  </span><span class="cm">/* clear alarm for bits marked by 1 */</span><span class="cp"></span>

<span class="cm">/* LED ioctl */</span>
<span class="cp">#define IO_LEDACTIVE_SET 0x7 </span><span class="cm">/* set active led</span>
<span class="cm">                              * 0=off, 1=green, 2=red, 3=yellow */</span><span class="cp"></span>

<span class="cm">/* GPIO direction ioctl&#39;s */</span>
<span class="cp">#define IO_READDIR    0x8  </span><span class="cm">/* Read direction 0=input 1=output  (obsolete) */</span><span class="cp"></span>
<span class="cp">#define IO_SETINPUT   0x9  </span><span class="cm">/* Set direction for bits set, 0=unchanged 1=input,</span>
<span class="cm">                              returns mask with current inputs (obsolete) */</span><span class="cp"></span>
<span class="cp">#define IO_SETOUTPUT  0xA  </span><span class="cm">/* Set direction for bits set, 0=unchanged 1=output,</span>
<span class="cm">                              returns mask with current outputs (obsolete)*/</span><span class="cp"></span>

<span class="cm">/* LED ioctl extended */</span>
<span class="cp">#define IO_LED_SETBIT 0xB</span>
<span class="cp">#define IO_LED_CLRBIT 0xC</span>

<span class="cm">/* SHUTDOWN ioctl */</span>
<span class="cp">#define IO_SHUTDOWN   0xD</span>
<span class="cp">#define IO_GET_PWR_BT 0xE</span>

<span class="cm">/* Bit toggling in driver settings */</span>
<span class="cm">/* bit set in low byte0 is CLK mask (0x00FF),</span>
<span class="cm">   bit set in byte1 is DATA mask    (0xFF00)</span>
<span class="cm">   msb, data_mask[7:0] , clk_mask[7:0]</span>
<span class="cm"> */</span>
<span class="cp">#define IO_CFG_WRITE_MODE 0xF</span>
<span class="cp">#define IO_CFG_WRITE_MODE_VALUE(msb, data_mask, clk_mask) \</span>
<span class="cp">	( (((msb)&amp;1) &lt;&lt; 16) | (((data_mask) &amp;0xFF) &lt;&lt; 8) | ((clk_mask) &amp; 0xFF) )</span>

<span class="cm">/* The following 4 ioctl&#39;s take a pointer as argument and handles</span>
<span class="cm"> * 32 bit ports (port G) properly.</span>
<span class="cm"> * These replaces IO_READBITS,IO_SETINPUT AND IO_SETOUTPUT</span>
<span class="cm"> */</span>
<span class="cp">#define IO_READ_INBITS   0x10 </span><span class="cm">/* *arg is result of reading the input pins */</span><span class="cp"></span>
<span class="cp">#define IO_READ_OUTBITS  0x11 </span><span class="cm">/* *arg is result of reading the output shadow */</span><span class="cp"></span>
<span class="cp">#define IO_SETGET_INPUT  0x12 </span><span class="cm">/* bits set in *arg is set to input, */</span><span class="cp"></span>
			      <span class="cm">/* *arg updated with current input pins. */</span>
<span class="cp">#define IO_SETGET_OUTPUT 0x13 </span><span class="cm">/* bits set in *arg is set to output, */</span><span class="cp"></span>
			      <span class="cm">/* *arg updated with current output pins. */</span>

<span class="cm">/* The following ioctl&#39;s are applicable to the PWM channels only */</span>

<span class="cp">#define IO_PWM_SET_MODE     0x20</span>

<span class="k">enum</span> <span class="n">io_pwm_mode</span> <span class="p">{</span>
	<span class="n">PWM_OFF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* disabled, deallocated */</span>
	<span class="n">PWM_STANDARD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* 390 kHz, duty cycle 0..255/256 */</span>
	<span class="n">PWM_FAST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>		<span class="cm">/* variable freq, w/ 10ns active pulse len */</span>
	<span class="n">PWM_VARFREQ</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* individually configurable high/low periods */</span>
	<span class="n">PWM_SOFT</span> <span class="o">=</span> <span class="mi">4</span>		<span class="cm">/* software generated */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">io_pwm_set_mode</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">io_pwm_mode</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Only for mode PWM_VARFREQ. Period lo/high set in increments of 10ns</span>
<span class="cm"> * from 10ns (value = 0) to 81920ns (value = 8191)</span>
<span class="cm"> * (Resulting frequencies range from 50 MHz (10ns + 10ns) down to</span>
<span class="cm"> * 6.1 kHz (81920ns + 81920ns) at 50% duty cycle, to 12.2 kHz at min/max duty</span>
<span class="cm"> * cycle (81920 + 10ns or 10ns + 81920ns, respectively).)</span>
<span class="cm"> */</span>
<span class="cp">#define IO_PWM_SET_PERIOD   0x21</span>

<span class="k">struct</span> <span class="n">io_pwm_set_period</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lo</span><span class="p">;</span>		<span class="cm">/* 0..8191 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hi</span><span class="p">;</span>		<span class="cm">/* 0..8191 */</span>
<span class="p">};</span>

<span class="cm">/* Only for modes PWM_STANDARD and PWM_FAST.</span>
<span class="cm"> * For PWM_STANDARD, set duty cycle of 390 kHz PWM output signal, from</span>
<span class="cm"> * 0 (value = 0) to 255/256 (value = 255).</span>
<span class="cm"> * For PWM_FAST, set duty cycle of PWM output signal from</span>
<span class="cm"> * 0% (value = 0) to 100% (value = 255). Output signal in this mode</span>
<span class="cm"> * is a 10ns pulse surrounded by a high or low level depending on duty</span>
<span class="cm"> * cycle (except for 0% and 100% which result in a constant output).</span>
<span class="cm"> * Resulting output frequency varies from 50 MHz at 50% duty cycle,</span>
<span class="cm"> * down to 390 kHz at min/max duty cycle.</span>
<span class="cm"> */</span>
<span class="cp">#define IO_PWM_SET_DUTY     0x22</span>

<span class="k">struct</span> <span class="n">io_pwm_set_duty</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">duty</span><span class="p">;</span>		<span class="cm">/* 0..255 */</span>
<span class="p">};</span>

<span class="cm">/* Returns information about the latest PWM pulse.</span>
<span class="cm"> * lo: Length of the latest low period, in units of 10ns.</span>
<span class="cm"> * hi: Length of the latest high period, in units of 10ns.</span>
<span class="cm"> * cnt: Time since last detected edge, in units of 10ns.</span>
<span class="cm"> *</span>
<span class="cm"> * The input source to PWM is decied by IO_PWM_SET_INPUT_SRC.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: All PWM devices is connected to the same input source.</span>
<span class="cm"> */</span>
<span class="cp">#define IO_PWM_GET_PERIOD   0x23</span>

<span class="k">struct</span> <span class="n">io_pwm_get_period</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Sets the input source for the PWM input. For the src value see the</span>
<span class="cm"> * register description for gio:rw_pwm_in_cfg.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: All PWM devices is connected to the same input source.</span>
<span class="cm"> */</span>
<span class="cp">#define IO_PWM_SET_INPUT_SRC   0x24</span>
<span class="k">struct</span> <span class="n">io_pwm_set_input_src</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src</span><span class="p">;</span>	<span class="cm">/* 0..7 */</span>
<span class="p">};</span>

<span class="cm">/* Sets the duty cycles in steps of 1/256, 0 = 0%, 255 = 100% duty cycle */</span>
<span class="cp">#define IO_PPWM_SET_DUTY     0x25</span>

<span class="k">struct</span> <span class="n">io_ppwm_set_duty</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">duty</span><span class="p">;</span>		<span class="cm">/* 0..255 */</span>
<span class="p">};</span>

<span class="cm">/* Configuraton struct for the IO_PWMCLK_SET_CONFIG ioctl to configure</span>
<span class="cm"> * PWM capable gpio pins:</span>
<span class="cm"> */</span>
<span class="cp">#define IO_PWMCLK_SETGET_CONFIG 0x26</span>
<span class="k">struct</span> <span class="n">gpio_pwmclk_conf</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gpiopin</span><span class="p">;</span> <span class="cm">/* The pin number based on the opened device */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">baseclk</span><span class="p">;</span> <span class="cm">/* The base clock to use, or sw will select one close*/</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">low</span><span class="p">;</span>     <span class="cm">/* The number of low periods of the baseclk */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">high</span><span class="p">;</span>    <span class="cm">/* The number of high periods of the baseclk */</span>
<span class="p">};</span>

<span class="cm">/* Examples:</span>
<span class="cm"> * To get a symmetric 12 MHz clock without knowing anything about the hardware:</span>
<span class="cm"> * baseclk = 12000000, low = 0, high = 0</span>
<span class="cm"> * To just get info of current setting:</span>
<span class="cm"> * baseclk = 0, low = 0, high = 0, the values will be updated by driver.</span>
<span class="cm"> */</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
