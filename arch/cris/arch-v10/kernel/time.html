<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › cris › arch-v10 › kernel › time.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>time.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/cris/arch-v10/kernel/time.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992, 1995  Linus Torvalds</span>
<span class="cm"> *  Copyright (C) 1999-2002 Axis Communications AB</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;arch/svinto.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/signal.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>

<span class="cm">/* define this if you need to use print_timestamp */</span>
<span class="cm">/* it will make jiffies at 96 hz instead of 100 hz though */</span>
<span class="cp">#undef USE_CASCADE_TIMERS</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_ns_in_jiffie</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">timer_count</span><span class="p">,</span> <span class="n">t1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">presc_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">timer_count</span> <span class="o">=</span> <span class="o">*</span><span class="n">R_TIMER0_DATA</span><span class="p">;</span>
	<span class="n">presc_count</span> <span class="o">=</span> <span class="o">*</span><span class="n">R_TIM_PRESC_STATUS</span><span class="p">;</span>  
	<span class="cm">/* presc_count might be wrapped */</span>
	<span class="n">t1</span> <span class="o">=</span> <span class="o">*</span><span class="n">R_TIMER0_DATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer_count</span> <span class="o">!=</span> <span class="n">t1</span><span class="p">){</span>
		<span class="cm">/* it wrapped, read prescaler again...  */</span>
		<span class="n">presc_count</span> <span class="o">=</span> <span class="o">*</span><span class="n">R_TIM_PRESC_STATUS</span><span class="p">;</span>
		<span class="n">timer_count</span> <span class="o">=</span> <span class="n">t1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">presc_count</span> <span class="o">&gt;=</span> <span class="n">PRESCALE_VALUE</span><span class="o">/</span><span class="mi">2</span> <span class="p">){</span>
		<span class="n">presc_count</span> <span class="o">=</span>  <span class="n">PRESCALE_VALUE</span> <span class="o">-</span> <span class="n">presc_count</span> <span class="o">+</span> <span class="n">PRESCALE_VALUE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">presc_count</span> <span class="o">=</span>  <span class="n">PRESCALE_VALUE</span> <span class="o">-</span> <span class="n">presc_count</span> <span class="o">-</span> <span class="n">PRESCALE_VALUE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">TIMER0_DIV</span> <span class="o">-</span> <span class="n">timer_count</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1000000000</span><span class="o">/</span><span class="n">HZ</span><span class="p">)</span><span class="o">/</span><span class="n">TIMER0_DIV</span> <span class="p">))</span> <span class="o">+</span> 
	     <span class="p">(</span> <span class="p">(</span><span class="n">presc_count</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1000000000</span><span class="o">/</span><span class="n">PRESCALE_FREQ</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">do_slow_gettimeoffset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* The timer interrupt comes from Etrax timer 0. In order to get</span>
<span class="cm">	 * better precision, we check the current value. It might have</span>
<span class="cm">	 * underflowed already though.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="o">*</span><span class="n">R_TIMER0_DATA</span><span class="p">;</span>

	<span class="cm">/* Convert timer value to usec */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">TIMER0_DIV</span> <span class="o">-</span> <span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">NSEC_PER_SEC</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span><span class="o">/</span><span class="n">HZ</span><span class="p">)</span><span class="o">/</span><span class="n">TIMER0_DIV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Excerpt from the Etrax100 HSDD about the built-in watchdog:</span>
<span class="cm"> *</span>
<span class="cm"> * 3.10.4 Watchdog timer</span>

<span class="cm"> * When the watchdog timer is started, it generates an NMI if the watchdog</span>
<span class="cm"> * isn&#39;t restarted or stopped within 0.1 s. If it still isn&#39;t restarted or</span>
<span class="cm"> * stopped after an additional 3.3 ms, the watchdog resets the chip.</span>
<span class="cm"> * The watchdog timer is stopped after reset. The watchdog timer is controlled</span>
<span class="cm"> * by the R_WATCHDOG register. The R_WATCHDOG register contains an enable bit</span>
<span class="cm"> * and a 3-bit key value. The effect of writing to the R_WATCHDOG register is</span>
<span class="cm"> * described in the table below:</span>
<span class="cm"> * </span>
<span class="cm"> *   Watchdog    Value written:</span>
<span class="cm"> *   state:      To enable:  To key:      Operation:</span>
<span class="cm"> *   --------    ----------  -------      ----------</span>
<span class="cm"> *   stopped         0         X          No effect.</span>
<span class="cm"> *   stopped         1       key_val      Start watchdog with key = key_val.</span>
<span class="cm"> *   started         0       ~key         Stop watchdog</span>
<span class="cm"> *   started         1       ~key         Restart watchdog with key = ~key.</span>
<span class="cm"> *   started         X       new_key_val  Change key to new_key_val.</span>
<span class="cm"> * </span>
<span class="cm"> * Note: &#39;~&#39; is the bitwise NOT operator.</span>
<span class="cm"> * </span>
<span class="cm"> */</span>

<span class="cm">/* right now, starting the watchdog is the same as resetting it */</span>
<span class="cp">#define start_watchdog reset_watchdog</span>

<span class="cp">#if defined(CONFIG_ETRAX_WATCHDOG) &amp;&amp; !defined(CONFIG_SVINTO_SIM)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">watchdog_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* arbitrary number */</span>
<span class="cp">#endif</span>

<span class="cm">/* number of pages to consider &quot;out of memory&quot;. it is normal that the memory</span>
<span class="cm"> * is used though, so put this really low.</span>
<span class="cm"> */</span>

<span class="cp">#define WATCHDOG_MIN_FREE_PAGES 8</span>

<span class="kt">void</span>
<span class="nf">reset_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_ETRAX_WATCHDOG) &amp;&amp; !defined(CONFIG_SVINTO_SIM)</span>
	<span class="cm">/* only keep watchdog happy as long as we have memory left! */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nr_free_pages</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">WATCHDOG_MIN_FREE_PAGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* reset the watchdog with the inverse of the old key */</span>
		<span class="n">watchdog_key</span> <span class="o">^=</span> <span class="mh">0x7</span><span class="p">;</span> <span class="cm">/* invert key, which is 3 bits */</span>
		<span class="o">*</span><span class="n">R_WATCHDOG</span> <span class="o">=</span> <span class="n">IO_FIELD</span><span class="p">(</span><span class="n">R_WATCHDOG</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">watchdog_key</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_WATCHDOG</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* stop the watchdog - we still need the correct key */</span>

<span class="kt">void</span> 
<span class="nf">stop_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_ETRAX_WATCHDOG) &amp;&amp; !defined(CONFIG_SVINTO_SIM)</span>
	<span class="n">watchdog_key</span> <span class="o">^=</span> <span class="mh">0x7</span><span class="p">;</span> <span class="cm">/* invert key, which is 3 bits */</span>
	<span class="o">*</span><span class="n">R_WATCHDOG</span> <span class="o">=</span> <span class="n">IO_FIELD</span><span class="p">(</span><span class="n">R_WATCHDOG</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">watchdog_key</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_WATCHDOG</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">stop</span><span class="p">);</span>
<span class="cp">#endif	</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * timer_interrupt() needs to keep up the real-time clock,</span>
<span class="cm"> * as well as call the &quot;xtime_update()&quot; routine every clocktick</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>static unsigned short myjiff; /* used by our debug routine print_timestamp */</p></td><td class="code"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">void</span> <span class="n">cris_do_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">irqreturn_t</span>
<span class="nf">timer_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">get_irq_regs</span><span class="p">();</span>
	<span class="cm">/* acknowledge the timer irq */</span>

<span class="cp">#ifdef USE_CASCADE_TIMERS</span>
	<span class="o">*</span><span class="n">R_TIMER_CTRL</span> <span class="o">=</span>
		<span class="n">IO_FIELD</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_FIELD</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">clr</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm1</span><span class="p">,</span> <span class="n">run</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel1</span><span class="p">,</span> <span class="n">cascade0</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">clr</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm0</span><span class="p">,</span> <span class="n">run</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel0</span><span class="p">,</span> <span class="n">c6250kHz</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="o">*</span><span class="n">R_TIMER_CTRL</span> <span class="o">=</span> <span class="n">r_timer_ctrl_shadow</span> <span class="o">|</span> 
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">clr</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* reset watchdog otherwise it resets us! */</span>
	<span class="n">reset_watchdog</span><span class="p">();</span>
	
	<span class="cm">/* Update statistics. */</span>
	<span class="n">update_process_times</span><span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>

	<span class="cm">/* call the real timer interrupt handler */</span>

	<span class="n">xtime_update</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	
        <span class="n">cris_do_profile</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span> <span class="cm">/* Save profiling information */</span>
        <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* timer is IRQF_SHARED so drivers can add stuff to the timer irq chain</span>
<span class="cm"> * it needs to be IRQF_DISABLED to make the jiffies update work properly</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">irq2</span>  <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">timer_interrupt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span> <span class="o">|</span> <span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;timer&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">time_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>	
	<span class="cm">/* probe for the RTC and read it if it exists </span>
<span class="cm">	 * Before the RTC can be probed the loops_per_usec variable needs </span>
<span class="cm">	 * to be initialized to make usleep work. A better value for </span>
<span class="cm">	 * loops_per_usec is calculated by the kernel later once the </span>
<span class="cm">	 * clock has started.  </span>
<span class="cm">	 */</span>
	<span class="n">loops_per_usec</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

	<span class="cm">/* Setup the etrax timers</span>
<span class="cm">	 * Base frequency is 25000 hz, divider 250 -&gt; 100 HZ</span>
<span class="cm">	 * In normal mode, we use timer0, so timer1 is free. In cascade</span>
<span class="cm">	 * mode (which we sometimes use for debugging) both timers are used.</span>
<span class="cm">	 * Remember that linux/timex.h contains #defines that rely on the</span>
<span class="cm">	 * timer settings below (hz and divide factor) !!!</span>
<span class="cm">	 */</span>
	
<span class="cp">#ifdef USE_CASCADE_TIMERS</span>
	<span class="o">*</span><span class="n">R_TIMER_CTRL</span> <span class="o">=</span>
		<span class="n">IO_FIELD</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_FIELD</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">nop</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm1</span><span class="p">,</span> <span class="n">stop_ld</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel1</span><span class="p">,</span> <span class="n">cascade0</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">nop</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm0</span><span class="p">,</span> <span class="n">stop_ld</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel0</span><span class="p">,</span> <span class="n">c6250kHz</span><span class="p">);</span>
	
	<span class="o">*</span><span class="n">R_TIMER_CTRL</span> <span class="o">=</span> <span class="n">r_timer_ctrl_shadow</span> <span class="o">=</span> 
		<span class="n">IO_FIELD</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_FIELD</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">nop</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm1</span><span class="p">,</span> <span class="n">run</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel1</span><span class="p">,</span> <span class="n">cascade0</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">nop</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm0</span><span class="p">,</span> <span class="n">run</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span> <span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel0</span><span class="p">,</span> <span class="n">c6250kHz</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="o">*</span><span class="n">R_TIMER_CTRL</span> <span class="o">=</span> 
		<span class="n">IO_FIELD</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv1</span><span class="p">,</span> <span class="mi">192</span><span class="p">)</span>      <span class="o">|</span> 
		<span class="n">IO_FIELD</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv0</span><span class="p">,</span> <span class="n">TIMER0_DIV</span><span class="p">)</span>      <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span>        <span class="n">nop</span><span class="p">)</span>      <span class="o">|</span> 
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm1</span><span class="p">,</span>       <span class="n">stop_ld</span><span class="p">)</span>  <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel1</span><span class="p">,</span>   <span class="n">c19k2Hz</span><span class="p">)</span>  <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span>        <span class="n">nop</span><span class="p">)</span>      <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm0</span><span class="p">,</span>       <span class="n">stop_ld</span><span class="p">)</span>  <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel0</span><span class="p">,</span>   <span class="n">flexible</span><span class="p">);</span>
	
	<span class="o">*</span><span class="n">R_TIMER_CTRL</span> <span class="o">=</span> <span class="n">r_timer_ctrl_shadow</span> <span class="o">=</span>
		<span class="n">IO_FIELD</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv1</span><span class="p">,</span> <span class="mi">192</span><span class="p">)</span>      <span class="o">|</span> 
		<span class="n">IO_FIELD</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">timerdiv0</span><span class="p">,</span> <span class="n">TIMER0_DIV</span><span class="p">)</span>      <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span>        <span class="n">nop</span><span class="p">)</span>      <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm1</span><span class="p">,</span>       <span class="n">run</span><span class="p">)</span>      <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel1</span><span class="p">,</span>   <span class="n">c19k2Hz</span><span class="p">)</span>  <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span>        <span class="n">nop</span><span class="p">)</span>      <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">tm0</span><span class="p">,</span>       <span class="n">run</span><span class="p">)</span>      <span class="o">|</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_TIMER_CTRL</span><span class="p">,</span> <span class="n">clksel0</span><span class="p">,</span>   <span class="n">flexible</span><span class="p">);</span>

	<span class="o">*</span><span class="n">R_TIMER_PRESCALE</span> <span class="o">=</span> <span class="n">PRESCALE_VALUE</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="o">*</span><span class="n">R_IRQ_MASK0_SET</span> <span class="o">=</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_IRQ_MASK0_SET</span><span class="p">,</span> <span class="n">timer0</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span> <span class="cm">/* unmask the timer irq */</span>
	
	<span class="cm">/* now actually register the timer irq handler that calls timer_interrupt() */</span>
	
	<span class="n">setup_irq</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq2</span><span class="p">);</span> <span class="cm">/* irq 2 is the timer0 irq in etrax */</span>

	<span class="cm">/* enable watchdog if we should use one */</span>

<span class="cp">#if defined(CONFIG_ETRAX_WATCHDOG) &amp;&amp; !defined(CONFIG_SVINTO_SIM)</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Enabling watchdog...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">start_watchdog</span><span class="p">();</span>

	<span class="cm">/* If we use the hardware watchdog, we want to trap it as an NMI</span>
<span class="cm">	   and dump registers before it resets us.  For this to happen, we</span>
<span class="cm">	   must set the &quot;m&quot; NMI enable flag (which once set, is unset only</span>
<span class="cm">	   when an NMI is taken).</span>

<span class="cm">	   The same goes for the external NMI, but that doesn&#39;t have any</span>
<span class="cm">	   driver or infrastructure support yet.  */</span>
	<span class="n">asm</span> <span class="p">(</span><span class="s">&quot;setf m&quot;</span><span class="p">);</span>

	<span class="o">*</span><span class="n">R_IRQ_MASK0_SET</span> <span class="o">=</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_IRQ_MASK0_SET</span><span class="p">,</span> <span class="n">watchdog_nmi</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
	<span class="o">*</span><span class="n">R_VECT_MASK_SET</span> <span class="o">=</span>
		<span class="n">IO_STATE</span><span class="p">(</span><span class="n">R_VECT_MASK_SET</span><span class="p">,</span> <span class="n">nmi</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
