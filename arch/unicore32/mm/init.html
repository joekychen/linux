<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › unicore32 › mm › init.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>init.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/unicore32/mm/init.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2010 GUAN Xue-tao</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/sort.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/sizes.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/memblock.h&gt;</span>
<span class="cp">#include &lt;mach/map.h&gt;</span>

<span class="cp">#include &quot;mm.h&quot;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_initrd_start</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="mh">0x01000000</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_initrd_size</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="n">SZ_8M</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_initrd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">endp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">phys_initrd_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">phys_initrd_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;initrd&quot;</span><span class="p">,</span> <span class="n">early_initrd</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This keeps memory configuration data used by a couple memory</span>
<span class="cm"> * initialization functions, as well as show_mem() for the skipping</span>
<span class="cm"> * of holes in the memory map.  It is populated by uc32_add_memory().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">meminfo</span> <span class="n">meminfo</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">show_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cached</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">meminfo</span> <span class="o">*</span><span class="n">mi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">meminfo</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;Mem-info:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">show_free_areas</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>

	<span class="n">for_each_bank</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">membank</span> <span class="o">*</span><span class="n">bank</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pfn1</span><span class="p">,</span> <span class="n">pfn2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

		<span class="n">pfn1</span> <span class="o">=</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>
		<span class="n">pfn2</span> <span class="o">=</span> <span class="n">bank_pfn_end</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn1</span><span class="p">);</span>
		<span class="n">end</span>  <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">total</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">reserved</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">cached</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">slab</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">free</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">shared</span> <span class="o">+=</span> <span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">page</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;%d pages of RAM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;%d free pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">free</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;%d reserved pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reserved</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;%d slab pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slab</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;%d pages shared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shared</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;%d pages swap cached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cached</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">find_limits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">max_low</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">max_high</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">meminfo</span> <span class="o">*</span><span class="n">mi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">meminfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="o">*</span><span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1UL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">max_low</span> <span class="o">=</span> <span class="o">*</span><span class="n">max_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_bank</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">membank</span> <span class="o">*</span><span class="n">bank</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">bank_pfn_end</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">min</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
			<span class="o">*</span><span class="n">min</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">max_high</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="o">*</span><span class="n">max_high</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bank</span><span class="o">-&gt;</span><span class="n">highmem</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">max_low</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="o">*</span><span class="n">max_low</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">uc32_bootmem_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">boot_pages</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">bitmap</span><span class="p">;</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate the bootmem bitmap page.  This must be in a region</span>
<span class="cm">	 * of memory which has already been mapped.</span>
<span class="cm">	 */</span>
	<span class="n">boot_pages</span> <span class="o">=</span> <span class="n">bootmem_bootmap_pages</span><span class="p">(</span><span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">);</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">memblock_alloc_base</span><span class="p">(</span><span class="n">boot_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">L1_CACHE_BYTES</span><span class="p">,</span>
				<span class="n">__pfn_to_phys</span><span class="p">(</span><span class="n">end_pfn</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialise the bootmem allocator, handing the</span>
<span class="cm">	 * memory banks over to bootmem.</span>
<span class="cm">	 */</span>
	<span class="n">node_set_online</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">init_bootmem_node</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">bitmap</span><span class="p">),</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>

	<span class="cm">/* Free the lowmem regions from memblock into bootmem. */</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">end_pfn</span><span class="p">)</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">free_bootmem</span><span class="p">(</span><span class="n">__pfn_to_phys</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reserve the lowmem memblock reserved regions in bootmem. */</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">reserved</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">memblock_region_reserved_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">memblock_region_reserved_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">end_pfn</span><span class="p">)</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">reserve_bootmem</span><span class="p">(</span><span class="n">__pfn_to_phys</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
			<span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">uc32_bootmem_free</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_low</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_high</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone_size</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">],</span> <span class="n">zhole_size</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialise the zones.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">zone_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zone_size</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The memory size has already been determined.  If we need</span>
<span class="cm">	 * to do anything fancy with the allocation of this memory</span>
<span class="cm">	 * to the zones, now is the time to do it.</span>
<span class="cm">	 */</span>
	<span class="n">zone_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_low</span> <span class="o">-</span> <span class="n">min</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the size of the holes.</span>
<span class="cm">	 *  holes = node_size - sum(bank_sizes)</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">zhole_size</span><span class="p">,</span> <span class="n">zone_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zhole_size</span><span class="p">));</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">max_low</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">low_end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">max_low</span><span class="p">);</span>
			<span class="n">zhole_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">low_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Adjust the sizes according to any special requirements for</span>
<span class="cm">	 * this machine type.</span>
<span class="cm">	 */</span>
	<span class="n">arch_adjust_zones</span><span class="p">(</span><span class="n">zone_size</span><span class="p">,</span> <span class="n">zhole_size</span><span class="p">);</span>

	<span class="n">free_area_init_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zone_size</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">zhole_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pfn_valid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_is_memory</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pfn_valid</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uc32_memory_present</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">meminfo_cmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">membank</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">_a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">_b</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">uc32_memblock_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">meminfo</span><span class="p">.</span><span class="n">bank</span><span class="p">,</span> <span class="n">meminfo</span><span class="p">.</span><span class="n">nr_banks</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">meminfo</span><span class="p">.</span><span class="n">bank</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
		<span class="n">meminfo_cmp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">memblock_add</span><span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Register the kernel text, kernel data and initrd with memblock. */</span>
	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">_text</span><span class="p">),</span> <span class="n">_end</span> <span class="o">-</span> <span class="n">_text</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phys_initrd_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">phys_initrd_start</span><span class="p">,</span> <span class="n">phys_initrd_size</span><span class="p">);</span>

		<span class="cm">/* Now convert initrd to virtual addresses */</span>
		<span class="n">initrd_start</span> <span class="o">=</span> <span class="n">__phys_to_virt</span><span class="p">(</span><span class="n">phys_initrd_start</span><span class="p">);</span>
		<span class="n">initrd_end</span> <span class="o">=</span> <span class="n">initrd_start</span> <span class="o">+</span> <span class="n">phys_initrd_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">uc32_mm_memblock_reserve</span><span class="p">();</span>

	<span class="n">memblock_allow_resize</span><span class="p">();</span>
	<span class="n">memblock_dump_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">bootmem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="n">max_low</span><span class="p">,</span> <span class="n">max_high</span><span class="p">;</span>

	<span class="n">max_low</span> <span class="o">=</span> <span class="n">max_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">find_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_low</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_high</span><span class="p">);</span>

	<span class="n">uc32_bootmem_init</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max_low</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SWIOTLB</span>
	<span class="n">swiotlb_init</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sparsemem tries to allocate bootmem in memory_present(),</span>
<span class="cm">	 * so must be done after the fixed reservations</span>
<span class="cm">	 */</span>
	<span class="n">uc32_memory_present</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * sparse_init() needs the bootmem allocator up and running.</span>
<span class="cm">	 */</span>
	<span class="n">sparse_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now free the memory - free_area_init_node needs</span>
<span class="cm">	 * the sparse mem_map arrays initialized by sparse_init()</span>
<span class="cm">	 * for memmap_init_zone(), otherwise all PFNs are invalid.</span>
<span class="cm">	 */</span>
	<span class="n">uc32_bootmem_free</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max_low</span><span class="p">,</span> <span class="n">max_high</span><span class="p">);</span>

	<span class="n">high_memory</span> <span class="o">=</span> <span class="n">__va</span><span class="p">((</span><span class="n">max_low</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This doesn&#39;t seem to be used by the Linux memory manager any</span>
<span class="cm">	 * more, but is used by ll_rw_block.  If we can get rid of it, we</span>
<span class="cm">	 * also get rid of some of the stuff above as well.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: max_low_pfn and max_pfn reflect the number of _pages_ in</span>
<span class="cm">	 * the system, not the maximum PFN.</span>
<span class="cm">	 */</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">max_low</span> <span class="o">-</span> <span class="n">PHYS_PFN_OFFSET</span><span class="p">;</span>
	<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">max_high</span> <span class="o">-</span> <span class="n">PHYS_PFN_OFFSET</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">free_area</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">pfn</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">pfn</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Freeing %s memory: %dK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">free_memmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start_pg</span><span class="p">,</span> <span class="o">*</span><span class="n">end_pg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pg</span><span class="p">,</span> <span class="n">pgend</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert start_pfn/end_pfn to a struct page pointer.</span>
<span class="cm">	 */</span>
	<span class="n">start_pg</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">start_pfn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">end_pg</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">end_pfn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert to physical addresses, and</span>
<span class="cm">	 * round start upwards and end downwards.</span>
<span class="cm">	 */</span>
	<span class="n">pg</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start_pg</span><span class="p">));</span>
	<span class="n">pgend</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">end_pg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are free pages between these,</span>
<span class="cm">	 * free the section of the memmap array.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pg</span> <span class="o">&lt;</span> <span class="n">pgend</span><span class="p">)</span>
		<span class="n">free_bootmem</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">pgend</span> <span class="o">-</span> <span class="n">pg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The mem_map array can get very big.  Free the unused area of the memory map.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">free_unused_memmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bank_start</span><span class="p">,</span> <span class="n">prev_bank_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This relies on each bank being in address order.</span>
<span class="cm">	 * The banks are sorted previously in bootmem_init().</span>
<span class="cm">	 */</span>
	<span class="n">for_each_bank</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">membank</span> <span class="o">*</span><span class="n">bank</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">bank_start</span> <span class="o">=</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we had a previous bank, and there is a space</span>
<span class="cm">		 * between the current bank and the previous, free it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_bank_end</span> <span class="o">&amp;&amp;</span> <span class="n">prev_bank_end</span> <span class="o">&lt;</span> <span class="n">bank_start</span><span class="p">)</span>
			<span class="n">free_memmap</span><span class="p">(</span><span class="n">prev_bank_end</span><span class="p">,</span> <span class="n">bank_start</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Align up here since the VM subsystem insists that the</span>
<span class="cm">		 * memmap entries are valid from the bank end aligned to</span>
<span class="cm">		 * MAX_ORDER_NR_PAGES.</span>
<span class="cm">		 */</span>
		<span class="n">prev_bank_end</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">bank_pfn_end</span><span class="p">(</span><span class="n">bank</span><span class="p">),</span> <span class="n">MAX_ORDER_NR_PAGES</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mem_init() marks the free areas in the mem_map and tells us how much</span>
<span class="cm"> * memory is free.  This is done after various parts of the system have</span>
<span class="cm"> * claimed their memory after the kernel image.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">mem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserved_pages</span><span class="p">,</span> <span class="n">free_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">max_mapnr</span>   <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">max_pfn</span> <span class="o">+</span> <span class="n">PHYS_PFN_OFFSET</span><span class="p">)</span> <span class="o">-</span> <span class="n">mem_map</span><span class="p">;</span>

	<span class="cm">/* this will put all unused low memory onto the freelists */</span>
	<span class="n">free_unused_memmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">meminfo</span><span class="p">);</span>

	<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_all_bootmem</span><span class="p">();</span>

	<span class="n">reserved_pages</span> <span class="o">=</span> <span class="n">free_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_bank</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">meminfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">membank</span> <span class="o">*</span><span class="n">bank</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">meminfo</span><span class="p">.</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pfn1</span><span class="p">,</span> <span class="n">pfn2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

		<span class="n">pfn1</span> <span class="o">=</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>
		<span class="n">pfn2</span> <span class="o">=</span> <span class="n">bank_pfn_end</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn1</span><span class="p">);</span>
		<span class="n">end</span>  <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">reserved_pages</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">free_pages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">page</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since our memory may not be contiguous, calculate the</span>
<span class="cm">	 * real number of pages we have in this system</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Memory:&quot;</span><span class="p">);</span>
	<span class="n">num_physpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">num_physpages</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %ldMB&quot;</span><span class="p">,</span> <span class="n">pages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; = %luMB total</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_physpages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Memory: %luk/%luk available, %luk reserved, %luK highmem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nr_free_pages</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">free_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">reserved_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">totalhigh_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Virtual kernel memory layout:</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    vector  : 0x%08lx - 0x%08lx   (%4ld kB)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    vmalloc : 0x%08lx - 0x%08lx   (%4ld MB)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    lowmem  : 0x%08lx - 0x%08lx   (%4ld MB)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;    modules : 0x%08lx - 0x%08lx   (%4ld MB)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;      .init : 0x%p&quot;</span> <span class="s">&quot; - 0x%p&quot;</span> <span class="s">&quot;   (%4d kB)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;      .text : 0x%p&quot;</span> <span class="s">&quot; - 0x%p&quot;</span> <span class="s">&quot;   (%4d kB)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;      .data : 0x%p&quot;</span> <span class="s">&quot; - 0x%p&quot;</span> <span class="s">&quot;   (%4d kB)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>

		<span class="n">VECTORS_BASE</span><span class="p">,</span> <span class="n">VECTORS_BASE</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
		<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">SZ_1K</span><span class="p">),</span>
		<span class="n">VMALLOC_START</span><span class="p">,</span> <span class="n">VMALLOC_END</span><span class="p">,</span>
		<span class="n">DIV_ROUND_UP</span><span class="p">((</span><span class="n">VMALLOC_END</span> <span class="o">-</span> <span class="n">VMALLOC_START</span><span class="p">),</span> <span class="n">SZ_1M</span><span class="p">),</span>
		<span class="n">PAGE_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">high_memory</span><span class="p">,</span>
		<span class="n">DIV_ROUND_UP</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">high_memory</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span><span class="p">),</span> <span class="n">SZ_1M</span><span class="p">),</span>
		<span class="n">MODULES_VADDR</span><span class="p">,</span> <span class="n">MODULES_END</span><span class="p">,</span>
		<span class="n">DIV_ROUND_UP</span><span class="p">((</span><span class="n">MODULES_END</span> <span class="o">-</span> <span class="n">MODULES_VADDR</span><span class="p">),</span> <span class="n">SZ_1M</span><span class="p">),</span>

		<span class="n">__init_begin</span><span class="p">,</span> <span class="n">__init_end</span><span class="p">,</span>
		<span class="n">DIV_ROUND_UP</span><span class="p">((</span><span class="n">__init_end</span> <span class="o">-</span> <span class="n">__init_begin</span><span class="p">),</span> <span class="n">SZ_1K</span><span class="p">),</span>
		<span class="n">_stext</span><span class="p">,</span> <span class="n">_etext</span><span class="p">,</span>
		<span class="n">DIV_ROUND_UP</span><span class="p">((</span><span class="n">_etext</span> <span class="o">-</span> <span class="n">_stext</span><span class="p">),</span> <span class="n">SZ_1K</span><span class="p">),</span>
		<span class="n">_sdata</span><span class="p">,</span> <span class="n">_edata</span><span class="p">,</span>
		<span class="n">DIV_ROUND_UP</span><span class="p">((</span><span class="n">_edata</span> <span class="o">-</span> <span class="n">_sdata</span><span class="p">),</span> <span class="n">SZ_1K</span><span class="p">));</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">TASK_SIZE</span>				<span class="o">&gt;</span> <span class="n">MODULES_VADDR</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">TASK_SIZE</span>				<span class="o">&gt;</span> <span class="n">MODULES_VADDR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&gt;=</span> <span class="mi">16384</span> <span class="o">&amp;&amp;</span> <span class="n">num_physpages</span> <span class="o">&lt;=</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * On a machine this small we won&#39;t get</span>
<span class="cm">		 * anywhere without overcommit, so turn</span>
<span class="cm">		 * it on by default.</span>
<span class="cm">		 */</span>
		<span class="n">sysctl_overcommit_memory</span> <span class="o">=</span> <span class="n">OVERCOMMIT_ALWAYS</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_initmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_area</span><span class="p">(</span><span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">__init_begin</span><span class="p">)),</span>
				    <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">__init_end</span><span class="p">)),</span>
				    <span class="s">&quot;init&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">keep_initrd</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">free_initrd_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">keep_initrd</span><span class="p">)</span>
		<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_area</span><span class="p">(</span><span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">)),</span>
					    <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">end</span><span class="p">)),</span>
					    <span class="s">&quot;initrd&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">keepinitrd_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">keep_initrd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;keepinitrd&quot;</span><span class="p">,</span> <span class="n">keepinitrd_setup</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
