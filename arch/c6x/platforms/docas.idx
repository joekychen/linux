f | timer64.c | s | 6.0K | 208 | David Howells | dhowells@redhat.com | 1332955802 |  | Disintegrate asm/system.h for C6X  Disintegrate asm/system.h for C6X.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: Mark Salter <msalter@redhat.com> cc: linux-c6x-dev@linux-c6x.org
f | pll.c | s | 9.1K | 352 | Mark Salter | msalter@redhat.com | 1317944887 |  | C6X: clocks  The C6X SoCs contain several PLL controllers each with up to 16 clock outputs feeding into the cores or peripheral clock domains. The hardware is very similar to arm/mach-davinci clocks. This is still a work in progress which needs to be updated once device tree clock binding changes shake out.  Signed-off-by: Mark Salter <msalter@redhat.com> Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | plldata.c | s | 9.8K | 352 | Mark Salter | msalter@redhat.com | 1317944887 |  | C6X: clocks  The C6X SoCs contain several PLL controllers each with up to 16 clock outputs feeding into the cores or peripheral clock domains. The hardware is very similar to arm/mach-davinci clocks. This is still a work in progress which needs to be updated once device tree clock binding changes shake out.  Signed-off-by: Mark Salter <msalter@redhat.com> Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | Makefile | g | 277B |  | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944845 |  | C6X: build infrastructure  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | megamod-pic.c | s | 7.9K | 274 | Grant Likely | grant.likely@secretlab.ca | 1329397884 |  | irq_domain/c6x: Use library of xlate functions  The c6x irq controllers don't need to define custom .xlate hooks  Signed-off-by: Grant Likely <grant.likely@secretlab.ca> Cc: Rob Herring <rob.herring@calxeda.com> Cc: Mark Salter <msalter@redhat.com> Cc: Thomas Gleixner <tglx@linutronix.de>
f | emif.c | s | 2.0K | 76 | Mark Salter | msalter@redhat.com | 1326053529 |  | C6X: fix layout of EMIFA registers  Signed-off-by: Mark Salter <msalter@redhat.com>
f | cache.c | s | 9.9K | 379 | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944890 |  | C6X: cache control  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | platform.c | s | 461B | 15 | Mark Salter | msalter@redhat.com | 1317944853 |  | C6X: devicetree support  This is the basic devicetree support for C6X. Currently, four boards are supported. Each one uses a different SoC part. Two of the four supported SoCs are multicore. One with 3 cores and the other with 6 cores. There is no coherency between the core-level caches, so SMP is not an option. It is possible to run separate kernel instances on the various cores. There is currently no C6X bootloader support for device trees so we build in the DTB for now.  There are some interesting twists to the hardware which are of note for device tree support. Each core has its own interrupt controller which is controlled by special purpose core registers. This core controller provides 12 general purpose prioritized interrupt sources. Each core is contained within a hardware "module" which provides L1 and L2 caches, power control, and another interrupt controller which cascades into the core interrupt controller. These core module functions are controlled by memory mapped registers. The addresses for these registers are the same for each core. That is, when coreN accesses a module-level MMIO register at a given address, it accesses the register for coreN even though other cores would use the same address to access the register in the module containing those cores. Other hardware modules (timers, enet, etc) which are memory mapped can be accessed by all cores.  The timers need some further explanation for multicore SoCs. Even though all timer control registers are visible to all cores, interrupt routing or other considerations may make a given timer more suitable for use by a core than some other timer. Because of this and the desire to have the same image run on more than one core, the timer nodes have a "ti,core-mask" property which is used by the driver to scan for a suitable timer to use.  Signed-off-by: Mark Salter <msalter@redhat.com> Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | dscr.c | s | 16K | 519 | Mark Salter | msalter@redhat.com | 1317944916 |  | C6X: DSCR - Device State Configuration Registers  All SoCs provide an area of device configuration registers called the DSCR. The location of specific registers as well as their use varies considerably from implementation to implementation. Rather than having to rely on additional SoC-specific DSCR code for each new supported SoC, this code generalize things as much as possible using device tree properties. Initialization must take place early on (setup_arch time) in case the event timer device needs to be enable via the DSCR.  Signed-off-by: Mark Salter <msalter@redhat.com> Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | Kconfig | g | 220B |  | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944845 |  | C6X: build infrastructure  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
