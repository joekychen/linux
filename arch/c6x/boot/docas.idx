f | Makefile | g | 586B |  | Stephen Warren | swarren@nvidia.com | 1329272084 |  | Kbuild: Use dtc's -d (dependency) option  This hooks dtc into Kbuild's dependency system.  Thus, for example, "make dtbs" will rebuild tegra-harmony.dtb if only tegra20.dtsi has changed yet tegra-harmony.dts has not. The previous lack of this feature recently caused me to have very confusing "git bisect" results.  For ARM, it's obvious what to add to $(targets). I'm not familiar enough with other architectures to know what to add there. Powerpc appears to already add various .dtb files into $(targets), but the other archs may need something added to $(targets) to work.  Signed-off-by: Stephen Warren <swarren@nvidia.com> Acked-by: Shawn Guo <shawn.guo@linaro.org> Acked-by: Mark Salter <msalter@redhat.com>
f | linked_dtb.S | g | 60B |  | Mark Salter | msalter@redhat.com | 1317944853 |  | C6X: devicetree support  This is the basic devicetree support for C6X. Currently, four boards are supported. Each one uses a different SoC part. Two of the four supported SoCs are multicore. One with 3 cores and the other with 6 cores. There is no coherency between the core-level caches, so SMP is not an option. It is possible to run separate kernel instances on the various cores. There is currently no C6X bootloader support for device trees so we build in the DTB for now.  There are some interesting twists to the hardware which are of note for device tree support. Each core has its own interrupt controller which is controlled by special purpose core registers. This core controller provides 12 general purpose prioritized interrupt sources. Each core is contained within a hardware "module" which provides L1 and L2 caches, power control, and another interrupt controller which cascades into the core interrupt controller. These core module functions are controlled by memory mapped registers. The addresses for these registers are the same for each core. That is, when coreN accesses a module-level MMIO register at a given address, it accesses the register for coreN even though other cores would use the same address to access the register in the module containing those cores. Other hardware modules (timers, enet, etc) which are memory mapped can be accessed by all cores.  The timers need some further explanation for multicore SoCs. Even though all timer control registers are visible to all cores, interrupt routing or other considerations may make a given timer more suitable for use by a core than some other timer. Because of this and the desire to have the same image run on more than one core, the timer nodes have a "ti,core-mask" property which is used by the driver to scan for a suitable timer to use.  Signed-off-by: Mark Salter <msalter@redhat.com> Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
d | dts |  | 8 items |  | Mark Salter | msalter@redhat.com | 1317944853 |  | C6X: devicetree support  This is the basic devicetree support for C6X. Currently, four boards are supported. Each one uses a different SoC part. Two of the four supported SoCs are multicore. One with 3 cores and the other with 6 cores. There is no coherency between the core-level caches, so SMP is not an option. It is possible to run separate kernel instances on the various cores. There is currently no C6X bootloader support for device trees so we build in the DTB for now.  There are some interesting twists to the hardware which are of note for device tree support. Each core has its own interrupt controller which is controlled by special purpose core registers. This core controller provides 12 general purpose prioritized interrupt sources. Each core is contained within a hardware "module" which provides L1 and L2 caches, power control, and another interrupt controller which cascades into the core interrupt controller. These core module functions are controlled by memory mapped registers. The addresses for these registers are the same for each core. That is, when coreN accesses a module-level MMIO register at a given address, it accesses the register for coreN even though other cores would use the same address to access the register in the module containing those cores. Other hardware modules (timers, enet, etc) which are memory mapped can be accessed by all cores.  The timers need some further explanation for multicore SoCs. Even though all timer control registers are visible to all cores, interrupt routing or other considerations may make a given timer more suitable for use by a core than some other timer. Because of this and the desire to have the same image run on more than one core, the timer nodes have a "ti,core-mask" property which is used by the driver to scan for a suitable timer to use.  Signed-off-by: Mark Salter <msalter@redhat.com> Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
