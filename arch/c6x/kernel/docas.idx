f | time.c | s | 1.5K | 54 | David Howells | dhowells@redhat.com | 1332955802 |  | Disintegrate asm/system.h for C6X  Disintegrate asm/system.h for C6X.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: Mark Salter <msalter@redhat.com> cc: linux-c6x-dev@linux-c6x.org
f | sys_c6x.c | s | 1.9K | 62 | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944878 |  | C6X: syscalls  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de> [msalter@redhat.com: add include of linux/module.h to sys_c6x.c] Signed-off-by: Mark Salter <msalter@redhat.com>
f | Makefile | g | 283B |  | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944845 |  | C6X: build infrastructure  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | head.S | g | 1.7K |  | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944848 |  | C6X: early boot code  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  This patch provides the early boot code for C6X architecture. There is a 16 entry vector table which is used to direct reset and interrupt events. The vector table entries contain a small amount of code (maximum of 8 opcodes) which simply branches to the actual event handling code.  The head.S code simply clears BSS, setups up a few control registers, and calls machine_init followed by start_kernel. The machine_init code in setup.c does the early flat tree parsing (memory, commandline, etc). At setup_arch time, the code does the usual memory setup and minimally scans the devicetree for any needed information.  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | soc.c | s | 2.0K | 79 | David Howells | dhowells@redhat.com | 1332955802 |  | Disintegrate asm/system.h for C6X  Disintegrate asm/system.h for C6X.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: Mark Salter <msalter@redhat.com> cc: linux-c6x-dev@linux-c6x.org
f | vmlinux.lds.S | g | 2.4K |  | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944845 |  | C6X: build infrastructure  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | asm-offsets.c | s | 3.6K | 110 | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944882 |  | C6X: build infrastructure  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | dma.c | s | 3.6K | 117 | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944857 |  | C6X: memory management and DMA support  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  The C6X architecture currently lacks an MMU so memory management is relatively simple. There is no bus snooping between L2 and main memory but coherent DMA memory is supported by making regions of main memory uncached. If such a region is desired, it can be specified on the commandline with a "memdma=" argument.  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | irq.c | s | 3.1K | 105 | Grant Likely | grant.likely@secretlab.ca | 1334119157 |  | irq: Kill pointless irqd_to_hw export  It makes no sense to export this trivial function.  Make it a static inline instead.  This patch also drops virq_to_hw from arch/c6x since it is unused by that architecture.  v2: Move irq_hw_number_t into types.h to fix ARM build failure  Signed-off-by: Grant Likely <grant.likely@secretlab.ca> Acked-by: Thomas Gleixner <tglx@linutronix.de> Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | traps.c | s | 14K | 379 | David Howells | dhowells@redhat.com | 1332955802 |  | Disintegrate asm/system.h for C6X  Disintegrate asm/system.h for C6X.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: Mark Salter <msalter@redhat.com> cc: linux-c6x-dev@linux-c6x.org
f | c6x_ksyms.c | s | 2.0K | 50 | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944893 |  | C6X: loadable module support  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | ptrace.c | s | 4.1K | 159 | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944897 |  | C6X: ptrace support  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | setup.c | s | 11K | 420 | David Howells | dhowells@redhat.com | 1332955802 |  | Disintegrate asm/system.h for C6X  Disintegrate asm/system.h for C6X.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: Mark Salter <msalter@redhat.com> cc: linux-c6x-dev@linux-c6x.org
f | module.c | s | 3.2K | 111 | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944893 |  | C6X: loadable module support  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | switch_to.S | g | 1.6K |  | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944860 |  | C6X: process management  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | devicetree.c | s | 1.4K | 46 | Mark Salter | msalter@redhat.com | 1317944853 |  | C6X: devicetree support  This is the basic devicetree support for C6X. Currently, four boards are supported. Each one uses a different SoC part. Two of the four supported SoCs are multicore. One with 3 cores and the other with 6 cores. There is no coherency between the core-level caches, so SMP is not an option. It is possible to run separate kernel instances on the various cores. There is currently no C6X bootloader support for device trees so we build in the DTB for now.  There are some interesting twists to the hardware which are of note for device tree support. Each core has its own interrupt controller which is controlled by special purpose core registers. This core controller provides 12 general purpose prioritized interrupt sources. Each core is contained within a hardware "module" which provides L1 and L2 caches, power control, and another interrupt controller which cascades into the core interrupt controller. These core module functions are controlled by memory mapped registers. The addresses for these registers are the same for each core. That is, when coreN accesses a module-level MMIO register at a given address, it accesses the register for coreN even though other cores would use the same address to access the register in the module containing those cores. Other hardware modules (timers, enet, etc) which are memory mapped can be accessed by all cores.  The timers need some further explanation for multicore SoCs. Even though all timer control registers are visible to all cores, interrupt routing or other considerations may make a given timer more suitable for use by a core than some other timer. Because of this and the desire to have the same image run on more than one core, the timer nodes have a "ti,core-mask" property which is used by the driver to scan for a suitable timer to use.  Signed-off-by: Mark Salter <msalter@redhat.com> Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
f | signal.c | s | 8.5K | 275 | Al Viro | viro@zeniv.linux.org.uk | 1338569932 |  | new helper: signal_delivered()  Does block_sigmask() + tracehook_signal_handler();  called when sigframe has been successfully built.  All architectures converted to it; block_sigmask() itself is gone now (merged into this one).  I'm still not too happy with the signature, but that's a separate story (IMO we need a structure that would contain signal number + siginfo + k_sigaction, so that get_signal_to_deliver() would fill one, signal_delivered(), handle_signal() and probably setup...frame() - take one).  Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
f | process.c | s | 5.1K | 215 | Thomas Gleixner | tglx@linutronix.de | 1336215622 |  | c6x: Use generic init_task  Same code. Use the generic version.  Signed-off-by: Thomas Gleixner <tglx@linutronix.de> Acked-and-tested-by: Mark Salter <msalter@redhat.com> Link: http://lkml.kernel.org/r/20120503085034.412398724@linutronix.de
f | entry.S | g | 16K |  | Mark Salter | msalter@redhat.com | 1331904477 |  | C6X: remove dead code from entry.S  The ENDPROC() on sys_fadvise64_c6x() in arch/c6x/kernel/entry.S is outside of the conditional block with the matching ENTRY() macro. This leads a newer (v2.22 vs. v2.20) assembler to complain:    /tmp/ccGZBaPT.s: Assembler messages:   /tmp/ccGZBaPT.s: Error: .size expression for sys_fadvise64_c6x does not evaluate to a constant  The conditional block became dead code when c6x switched to generic unistd.h and should be removed along with the offending ENDPROC().  Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: David Howells <dhowells@redhat.com>
f | vectors.S | g | 1.7K |  | Aurelien Jacquiot | a-jacquiot@ti.com | 1317944848 |  | C6X: early boot code  Original port to early 2.6 kernel using TI COFF toolchain. Brought up to date by Mark Salter <msalter@redhat.com>  This patch provides the early boot code for C6X architecture. There is a 16 entry vector table which is used to direct reset and interrupt events. The vector table entries contain a small amount of code (maximum of 8 opcodes) which simply branches to the actual event handling code.  The head.S code simply clears BSS, setups up a few control registers, and calls machine_init followed by start_kernel. The machine_init code in setup.c does the early flat tree parsing (memory, commandline, etc). At setup_arch time, the code does the usual memory setup and minimally scans the devicetree for any needed information.  Signed-off-by: Aurelien Jacquiot <a-jacquiot@ti.com> Signed-off-by: Mark Salter <msalter@redhat.com> Acked-by: Arnd Bergmann <arnd@arndb.de>
