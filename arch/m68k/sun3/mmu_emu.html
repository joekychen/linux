<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › m68k › sun3 › mmu_emu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mmu_emu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Tablewalk MMU emulator</span>
<span class="cm">**</span>
<span class="cm">** by Toshiyasu Morita</span>
<span class="cm">**</span>
<span class="cm">** Started 1/16/98 @ 2:22 am</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/traps.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/sun3mmu.h&gt;</span>
<span class="cp">#include &lt;asm/segment.h&gt;</span>
<span class="cp">#include &lt;asm/oplib.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/dvma.h&gt;</span>


<span class="cp">#undef DEBUG_MMU_EMU</span>
<span class="cp">#define DEBUG_PROM_MAPS</span>

<span class="cm">/*</span>
<span class="cm">** Defines</span>
<span class="cm">*/</span>

<span class="cp">#define CONTEXTS_NUM		8</span>
<span class="cp">#define SEGMAPS_PER_CONTEXT_NUM 2048</span>
<span class="cp">#define PAGES_PER_SEGMENT	16</span>
<span class="cp">#define PMEGS_NUM		256</span>
<span class="cp">#define PMEG_MASK		0xFF</span>

<span class="cm">/*</span>
<span class="cm">** Globals</span>
<span class="cm">*/</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m68k_vmalloc_end</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">m68k_vmalloc_end</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmeg_vaddr</span><span class="p">[</span><span class="n">PMEGS_NUM</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">PMEGS_NUM</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pmeg_ctx</span><span class="p">[</span><span class="n">PMEGS_NUM</span><span class="p">];</span>

<span class="cm">/* pointers to the mm structs for each task in each</span>
<span class="cm">   context. 0xffffffff is a marker for kernel context */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">ctx_alloc</span><span class="p">[</span><span class="n">CONTEXTS_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xffffffff</span>
<span class="p">};</span>

<span class="cm">/* has this context been mmdrop&#39;d? */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ctx_avail</span> <span class="o">=</span> <span class="n">CONTEXTS_NUM</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="cm">/* array of pages to be marked off for the rom when we do mem_init later */</span>
<span class="cm">/* 256 pages lets the rom take up to 2mb of physical ram..  I really</span>
<span class="cm">   hope it never wants mote than that. */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rom_pages</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="cm">/* Print a PTE value in symbolic form. For debugging. */</span>
<span class="kt">void</span> <span class="nf">print_pte</span> <span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Verbose version. */</span>
<span class="c">	unsigned long val = pte_val (pte);</span>
<span class="c">	printk (&quot; pte=%lx [addr=%lx&quot;,</span>
<span class="c">		val, (val &amp; SUN3_PAGE_PGNUM_MASK) &lt;&lt; PAGE_SHIFT);</span>
<span class="c">	if (val &amp; SUN3_PAGE_VALID)	printk (&quot; valid&quot;);</span>
<span class="c">	if (val &amp; SUN3_PAGE_WRITEABLE)	printk (&quot; write&quot;);</span>
<span class="c">	if (val &amp; SUN3_PAGE_SYSTEM)	printk (&quot; sys&quot;);</span>
<span class="c">	if (val &amp; SUN3_PAGE_NOCACHE)	printk (&quot; nocache&quot;);</span>
<span class="c">	if (val &amp; SUN3_PAGE_ACCESSED)	printk (&quot; accessed&quot;);</span>
<span class="c">	if (val &amp; SUN3_PAGE_MODIFIED)	printk (&quot; modified&quot;);</span>
<span class="c">	switch (val &amp; SUN3_PAGE_TYPE_MASK) {</span>
<span class="c">		case SUN3_PAGE_TYPE_MEMORY: printk (&quot; memory&quot;); break;</span>
<span class="c">		case SUN3_PAGE_TYPE_IO:     printk (&quot; io&quot;);     break;</span>
<span class="c">		case SUN3_PAGE_TYPE_VME16:  printk (&quot; vme16&quot;);  break;</span>
<span class="c">		case SUN3_PAGE_TYPE_VME32:  printk (&quot; vme32&quot;);  break;</span>
<span class="c">	}</span>
<span class="c">	printk (&quot;]\n&quot;);</span>
<span class="cp">#else</span>
	<span class="cm">/* Terse version. More likely to fit on a line. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">pte_val</span> <span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">flags</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>

	<span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_VALID</span><span class="p">)</span>     <span class="o">?</span> <span class="sc">&#39;v&#39;</span> <span class="o">:</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="n">flags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_WRITEABLE</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;w&#39;</span> <span class="o">:</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="n">flags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_SYSTEM</span><span class="p">)</span>    <span class="o">?</span> <span class="sc">&#39;s&#39;</span> <span class="o">:</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="n">flags</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_NOCACHE</span><span class="p">)</span>   <span class="o">?</span> <span class="sc">&#39;x&#39;</span> <span class="o">:</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="n">flags</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_ACCESSED</span><span class="p">)</span>  <span class="o">?</span> <span class="sc">&#39;a&#39;</span> <span class="o">:</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="n">flags</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_MODIFIED</span><span class="p">)</span>  <span class="o">?</span> <span class="sc">&#39;m&#39;</span> <span class="o">:</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="n">flags</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_TYPE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SUN3_PAGE_TYPE_MEMORY</span>: <span class="n">type</span> <span class="o">=</span> <span class="s">&quot;memory&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SUN3_PAGE_TYPE_IO</span>:     <span class="n">type</span> <span class="o">=</span> <span class="s">&quot;io&quot;</span>    <span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SUN3_PAGE_TYPE_VME16</span>:  <span class="n">type</span> <span class="o">=</span> <span class="s">&quot;vme16&quot;</span> <span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SUN3_PAGE_TYPE_VME32</span>:  <span class="n">type</span> <span class="o">=</span> <span class="s">&quot;vme32&quot;</span> <span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="n">type</span> <span class="o">=</span> <span class="s">&quot;unknown?&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot; pte=%08lx [%07lx %s %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_PGNUM_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Print the PTE value for a given virtual address. For debugging. */</span>
<span class="kt">void</span> <span class="nf">print_pte_vaddr</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot; vaddr=%lx [%02lx]&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">sun3_get_segmap</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">));</span>
	<span class="n">print_pte</span> <span class="p">(</span><span class="n">__pte</span> <span class="p">(</span><span class="n">sun3_get_pte</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise the MMU emulator.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mmu_emu_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bootmem_end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seg</span><span class="p">,</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">rom_pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rom_pages</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pmeg_vaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmeg_vaddr</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pmeg_alloc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmeg_alloc</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pmeg_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmeg_ctx</span><span class="p">));</span>

	<span class="cm">/* pmeg align the end of bootmem, adding another pmeg,</span>
<span class="cm">	 * later bootmem allocations will likely need it */</span>
	<span class="n">bootmem_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">bootmem_end</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SUN3_PMEG_SIZE</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SUN3_PMEG_MASK</span><span class="p">;</span>

	<span class="cm">/* mark all of the pmegs used thus far as reserved */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">__pa</span><span class="p">(</span><span class="n">bootmem_end</span><span class="p">)</span> <span class="o">/</span> <span class="n">SUN3_PMEG_SIZE</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>


	<span class="cm">/* I&#39;m thinking that most of the top pmeg&#39;s are going to be</span>
<span class="cm">	   used for something, and we probably shouldn&#39;t risk it */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">num</span> <span class="o">=</span> <span class="mh">0xf0</span><span class="p">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mh">0xff</span><span class="p">;</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* liberate all existing mappings in the rest of kernel space */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="n">bootmem_end</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="mh">0x0f800000</span><span class="p">;</span> <span class="n">seg</span> <span class="o">+=</span> <span class="n">SUN3_PMEG_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">sun3_get_segmap</span><span class="p">(</span><span class="n">seg</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_MMU_EMU</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;freed: &quot;</span><span class="p">);</span>
			<span class="n">print_pte_vaddr</span> <span class="p">(</span><span class="n">seg</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">sun3_put_segmap</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">SUN3_INVALID_PMEG</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">num</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">seg</span><span class="o">=</span><span class="mh">0x0F800000</span><span class="p">;</span> <span class="n">seg</span><span class="o">&lt;</span><span class="mh">0x10000000</span><span class="p">;</span> <span class="n">seg</span><span class="o">+=</span><span class="mi">16</span><span class="o">*</span><span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sun3_get_segmap</span> <span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SUN3_INVALID_PMEG</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_PROM_MAPS</span>
			<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;mapped:&quot;</span><span class="p">);</span>
				<span class="n">print_pte_vaddr</span> <span class="p">(</span><span class="n">seg</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">PAGE_SIZE</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>the lowest mapping here is the end of our
vmalloc region</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m68k_vmalloc_end</span><span class="p">)</span>
				<span class="n">m68k_vmalloc_end</span> <span class="o">=</span> <span class="n">seg</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>mark the segmap alloc'd, and reserve any
of the first 0xbff pages the hardware is
already using...  does any sun3 support > 24mb?</p></td><td class="code"><div class="highlight"><pre>			<span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">sun3_get_segmap</span><span class="p">(</span><span class="n">seg</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dvma_init</span><span class="p">();</span>


	<span class="cm">/* blank everything below the kernel, and we&#39;ve got the base</span>
<span class="cm">	   mapping to start all the contexts off with... */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span> <span class="n">seg</span> <span class="o">+=</span> <span class="n">SUN3_PMEG_SIZE</span><span class="p">)</span>
		<span class="n">sun3_put_segmap</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">SUN3_INVALID_PMEG</span><span class="p">);</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">MAKE_MM_SEG</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
	<span class="k">for</span><span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="mh">0x10000000</span><span class="p">;</span> <span class="n">seg</span> <span class="o">+=</span> <span class="n">SUN3_PMEG_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">sun3_get_segmap</span><span class="p">(</span><span class="n">seg</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CONTEXTS_NUM</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">romvec</span><span class="o">-&gt;</span><span class="n">pv_setctxt</span><span class="p">))(</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">seg</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* erase the mappings for a dead context.  Uses the pg_dir for hints</span>
<span class="cm">   as the pmeg tables proved somewhat unreliable, and unmapping all of</span>
<span class="cm">   TASK_SIZE was much slower and no more stable. */</span>
<span class="cm">/* todo: find a better way to keep track of the pmegs used by a</span>
<span class="cm">   context for when they&#39;re cleared */</span>
<span class="kt">void</span> <span class="nf">clear_context</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">oldctx</span><span class="p">;</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

     <span class="k">if</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
	     <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ctx_alloc</span><span class="p">[</span><span class="n">context</span><span class="p">])</span>
		     <span class="n">panic</span><span class="p">(</span><span class="s">&quot;clear_context: context not allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	     <span class="n">ctx_alloc</span><span class="p">[</span><span class="n">context</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">SUN3_INVALID_CONTEXT</span><span class="p">;</span>
	     <span class="n">ctx_alloc</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	     <span class="n">ctx_avail</span><span class="o">++</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="n">oldctx</span> <span class="o">=</span> <span class="n">sun3_get_context</span><span class="p">();</span>

     <span class="n">sun3_put_context</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

     <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SUN3_INVALID_PMEG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	     <span class="k">if</span><span class="p">((</span><span class="n">pmeg_ctx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">context</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		     <span class="n">sun3_put_segmap</span><span class="p">(</span><span class="n">pmeg_vaddr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SUN3_INVALID_PMEG</span><span class="p">);</span>
		     <span class="n">pmeg_ctx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">pmeg_vaddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="p">}</span>
     <span class="p">}</span>

     <span class="n">sun3_put_context</span><span class="p">(</span><span class="n">oldctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* gets an empty context.  if full, kills the next context listed to</span>
<span class="cm">   die first */</span>
<span class="cm">/* This context invalidation scheme is, well, totally arbitrary, I&#39;m</span>
<span class="cm">   sure it could be much more intelligent...  but it gets the job done</span>
<span class="cm">   for now without much overhead in making it&#39;s decision. */</span>
<span class="cm">/* todo: come up with optimized scheme for flushing contexts */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_free_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">next_to_die</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ctx_avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* kill someone to get our context */</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">next_to_die</span><span class="p">;</span>
		<span class="n">clear_context</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="n">next_to_die</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_to_die</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">next_to_die</span><span class="p">)</span>
			<span class="n">next_to_die</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="n">new</span> <span class="o">&lt;</span> <span class="n">CONTEXTS_NUM</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">ctx_alloc</span><span class="p">[</span><span class="n">new</span><span class="p">])</span>
				<span class="n">new</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>check to make sure one was really free...</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span><span class="p">(</span><span class="n">new</span> <span class="o">==</span> <span class="n">CONTEXTS_NUM</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;get_free_context: failed to find free context&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ctx_alloc</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">ctx_avail</span><span class="o">--</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dynamically select a `spare&#39; PMEG and use it to map virtual `vaddr&#39; in</span>
<span class="cm"> * `context&#39;. Maintain internal PMEG management structures. This doesn&#39;t</span>
<span class="cm"> * actually map the physical address, but does clear the old mappings.</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>todo: better allocation scheme? but is extra complexity worthwhile?
todo: only clear old entries if necessary? how to tell?</p></td><td class="code"><div class="highlight"><pre><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_emu_map_pmeg</span> <span class="p">(</span><span class="kt">int</span> <span class="n">context</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">curr_pmeg</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Round address to PMEG boundary. */</span>
	<span class="n">vaddr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SUN3_PMEG_MASK</span><span class="p">;</span>

	<span class="cm">/* Find a spare one. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">curr_pmeg</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="o">++</span><span class="n">curr_pmeg</span><span class="p">;</span>


<span class="cp">#ifdef DEBUG_MMU_EMU</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;mmu_emu_map_pmeg: pmeg %x to context %d vaddr %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
       <span class="n">curr_pmeg</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Invalidate old mapping for the pmeg, if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">curr_pmeg</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sun3_put_context</span><span class="p">(</span><span class="n">pmeg_ctx</span><span class="p">[</span><span class="n">curr_pmeg</span><span class="p">]);</span>
		<span class="n">sun3_put_segmap</span> <span class="p">(</span><span class="n">pmeg_vaddr</span><span class="p">[</span><span class="n">curr_pmeg</span><span class="p">],</span> <span class="n">SUN3_INVALID_PMEG</span><span class="p">);</span>
		<span class="n">sun3_put_context</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Update PMEG management structures. */</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>don't take pmeg's away from the kernel...</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">&gt;=</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* map kernel pmegs into all contexts */</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CONTEXTS_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sun3_put_context</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="n">sun3_put_segmap</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">curr_pmeg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sun3_put_context</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
		<span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">curr_pmeg</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">pmeg_ctx</span><span class="p">[</span><span class="n">curr_pmeg</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pmeg_alloc</span><span class="p">[</span><span class="n">curr_pmeg</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pmeg_ctx</span><span class="p">[</span><span class="n">curr_pmeg</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
		<span class="n">sun3_put_segmap</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">curr_pmeg</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="n">pmeg_vaddr</span><span class="p">[</span><span class="n">curr_pmeg</span><span class="p">]</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="cm">/* Set hardware mapping and clear the old PTE entries. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">SUN3_PMEG_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">SUN3_PTE_SIZE</span><span class="p">)</span>
		<span class="n">sun3_put_pte</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">SUN3_PAGE_SYSTEM</span><span class="p">);</span>

	<span class="cm">/* Consider a different one next time. */</span>
	<span class="o">++</span><span class="n">curr_pmeg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a pagefault at virtual address `vaddr&#39;; check if there should be a</span>
<span class="cm"> * page there (specifically, whether the software pagetables indicate that</span>
<span class="cm"> * there is). This is necessary due to the limited size of the second-level</span>
<span class="cm"> * Sun3 hardware pagetables (256 groups of 16 pages). If there should be a</span>
<span class="cm"> * mapping present, we select a `spare&#39; PMEG and use it to create a mapping.</span>
<span class="cm"> * `read_flag&#39; is nonzero for a read fault; zero for a write. Returns nonzero</span>
<span class="cm"> * if we successfully handled the fault.</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>todo: should we bump minor pagefault counter? if so, here or in caller?
todo: possibly inline this into bus_error030 in <asm/buserror.h> ?</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>kernel_fault is set when a kernel page couldn't be demand mapped,
and forces another try using the kernel page table.  basically a
hack so that vmalloc would work correctly.</p></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">mmu_emu_handle_fault</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read_flag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kernel_fault</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">segment</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">context</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span> <span class="n">crp</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">crp</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span><span class="p">;</span>
		<span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">kernel_fault</span><span class="p">)</span>
			<span class="n">crp</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">crp</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG_MMU_EMU</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;mmu_emu_handle_fault: vaddr=%lx type=%s crp=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">vaddr</span><span class="p">,</span> <span class="n">read_flag</span> <span class="o">?</span> <span class="s">&quot;read&quot;</span> <span class="o">:</span> <span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="n">crp</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&gt;&gt;</span> <span class="n">SUN3_PMEG_SIZE_BITS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7FF</span><span class="p">;</span>
	<span class="n">offset</span>  <span class="o">=</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&gt;&gt;</span> <span class="n">SUN3_PTE_SIZE_BITS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_MMU_EMU</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;mmu_emu_handle_fault: segment=%lx offset=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pgd_val</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">crp</span> <span class="o">+</span> <span class="n">segment</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>todo: next line should check for valid pmd properly.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><pre><code>           printk ("mmu_emu_handle_fault: invalid pmd\n");
</code></pre></td><td class="code"><div class="highlight"><pre>                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">__va</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">pte</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>

	<span class="cm">/* Make sure this is a valid page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pte_val</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_VALID</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Make sure there&#39;s a pmeg allocated for the page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sun3_get_segmap</span> <span class="p">(</span><span class="n">vaddr</span><span class="o">&amp;~</span><span class="n">SUN3_PMEG_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUN3_INVALID_PMEG</span><span class="p">)</span>
		<span class="n">mmu_emu_map_pmeg</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>

	<span class="cm">/* Write the pte value to hardware MMU */</span>
	<span class="n">sun3_put_pte</span> <span class="p">(</span><span class="n">vaddr</span><span class="o">&amp;</span><span class="n">PAGE_MASK</span><span class="p">,</span> <span class="n">pte_val</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>

	<span class="cm">/* Update software copy of the pte value */</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>I'm not sure this is necessary. If this is required, we ought to simply
copy this out when we reuse the PMEG or at some other convenient time.
Doing it here is fairly meaningless, anyway, as we only know about the
first access to a given page. --m</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_val</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SUN3_PAGE_WRITEABLE</span><span class="p">)</span>
			<span class="n">pte_val</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SUN3_PAGE_ACCESSED</span>
					   <span class="o">|</span> <span class="n">SUN3_PAGE_MODIFIED</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Write-protect error. */</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pte_val</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">SUN3_PAGE_ACCESSED</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_MMU_EMU</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;seg:%d crp:%p -&gt;&quot;</span><span class="p">,</span> <span class="n">get_fs</span><span class="p">().</span><span class="n">seg</span><span class="p">,</span> <span class="n">crp</span><span class="p">);</span>
	<span class="n">print_pte_vaddr</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
