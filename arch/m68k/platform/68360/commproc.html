<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › m68k › platform › 68360 › commproc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>commproc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * General Purpose functions for the global management of the</span>
<span class="cm"> * Communication Processor Module.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2000 Michael Leslie &lt;mleslie@lineo.com&gt;</span>
<span class="cm"> * Copyright (c) 1997 Dan Malek (dmalek@jlc.net)</span>
<span class="cm"> *</span>
<span class="cm"> * In addition to the individual control of the communication</span>
<span class="cm"> * channels, there are a few functions that globally affect the</span>
<span class="cm"> * communication processor.</span>
<span class="cm"> *</span>
<span class="cm"> * Buffer descriptors must be allocated from the dual ported memory</span>
<span class="cm"> * space.  The allocator for that is here.  When the communication</span>
<span class="cm"> * process is reset, we reclaim the memory available.  There is</span>
<span class="cm"> * currently no deallocator for this memory.</span>
<span class="cm"> * The amount of space available is platform dependent.  On the</span>
<span class="cm"> * MBX, the EPPC software loads additional microcode into the</span>
<span class="cm"> * communication processor, and uses some of the DP ram for this</span>
<span class="cm"> * purpose.  Current, the first 512 bytes and the last 256 bytes of</span>
<span class="cm"> * memory are used.  Right now I am conservative and only use the</span>
<span class="cm"> * memory that can never be used for microcode.  If there are</span>
<span class="cm"> * applications that require more DP ram, we can expand the boundaries</span>
<span class="cm"> * but then we have to be careful of any downloaded microcode.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Michael Leslie &lt;mleslie@lineo.com&gt;</span>
<span class="cm"> * adapted Dan Malek&#39;s ppc8xx drivers to M68360</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/param.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/m68360.h&gt;</span>
<span class="cp">#include &lt;asm/commproc.h&gt;</span>

<span class="cm">/* #include &lt;asm/page.h&gt; */</span>
<span class="cm">/* #include &lt;asm/pgtable.h&gt; */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_quicc_base</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">system_clock</span><span class="p">;</span>


<span class="k">static</span> <span class="n">uint</span> <span class="n">dp_alloc_base</span><span class="p">;</span>	<span class="cm">/* Starting offset in DP ram */</span>
<span class="k">static</span> <span class="n">uint</span> <span class="n">dp_alloc_top</span><span class="p">;</span>	<span class="cm">/* Max offset + 1 */</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static	void	*host_buffer;	/* One page of host buffer */</span>
<span class="c">static	void	*host_end;	    /* end + 1 */</span>
<span class="cp">#endif</span>

<span class="cm">/* struct  cpm360_t *cpmp; */</span>         <span class="cm">/* Pointer to comm processor space */</span>

<span class="n">QUICC</span>  <span class="o">*</span><span class="n">pquicc</span><span class="p">;</span>
<span class="cm">/* QUICC  *quicc_dpram; */</span> <span class="cm">/* mleslie - temporary; use extern pquicc elsewhere instead */</span>


<span class="cm">/* CPM interrupt vector functions. */</span>
<span class="k">struct</span>	<span class="n">cpm_action</span> <span class="p">{</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="o">*</span><span class="n">dev_id</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span>	<span class="k">struct</span>	<span class="n">cpm_action</span> <span class="n">cpm_vecs</span><span class="p">[</span><span class="n">CPMVEC_NR</span><span class="p">];</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">cpm_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">regs</span><span class="p">);</span>
<span class="k">static</span>	<span class="kt">void</span>	<span class="n">cpm_error_interrupt</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* prototypes: */</span>
<span class="kt">void</span> <span class="n">cpm_install_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">m360_cpm_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>




<span class="kt">void</span> <span class="nf">m360_cpm_reset</span><span class="p">()</span>
<span class="p">{</span>
<span class="cm">/* 	pte_t		   *pte; */</span>

	<span class="n">pquicc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">quicc</span> <span class="o">*</span><span class="p">)(</span><span class="n">_quicc_base</span><span class="p">);</span> <span class="cm">/* initialized in crt0_rXm.S */</span>

	<span class="cm">/* Perform a CPM reset. */</span>
	<span class="n">pquicc</span><span class="o">-&gt;</span><span class="n">cp_cr</span> <span class="o">=</span> <span class="p">(</span><span class="n">SOFTWARE_RESET</span> <span class="o">|</span> <span class="n">CMD_FLAG</span><span class="p">);</span>

	<span class="cm">/* Wait for CPM to become ready (should be 2 clocks). */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pquicc</span><span class="o">-&gt;</span><span class="n">cp_cr</span> <span class="o">&amp;</span> <span class="n">CMD_FLAG</span><span class="p">);</span>

	<span class="cm">/* On the recommendation of the 68360 manual, p. 7-60</span>
<span class="cm">	 * - Set sdma interrupt service mask to 7</span>
<span class="cm">	 * - Set sdma arbitration ID to 4</span>
<span class="cm">	 */</span>
	<span class="n">pquicc</span><span class="o">-&gt;</span><span class="n">sdma_sdcr</span> <span class="o">=</span> <span class="mh">0x0740</span><span class="p">;</span>


	<span class="cm">/* Claim the DP memory for our use.</span>
<span class="cm">	 */</span>
	<span class="n">dp_alloc_base</span> <span class="o">=</span> <span class="n">CPM_DATAONLY_BASE</span><span class="p">;</span>
	<span class="n">dp_alloc_top</span> <span class="o">=</span> <span class="n">dp_alloc_base</span> <span class="o">+</span> <span class="n">CPM_DATAONLY_SIZE</span><span class="p">;</span>


	<span class="cm">/* Set the host page for allocation.</span>
<span class="cm">	 */</span>
	<span class="cm">/* 	host_buffer = host_page_addr; */</span>
	<span class="cm">/* 	host_end = host_page_addr + PAGE_SIZE; */</span>

	<span class="cm">/* 	pte = find_pte(&amp;init_mm, host_page_addr); */</span>
	<span class="cm">/* 	pte_val(*pte) |= _PAGE_NO_CACHE; */</span>
	<span class="cm">/* 	flush_tlb_page(current-&gt;mm-&gt;mmap, host_buffer); */</span>

	<span class="cm">/* Tell everyone where the comm processor resides.</span>
<span class="cm">	*/</span>
<span class="cm">/* 	cpmp = (cpm360_t *)commproc; */</span>
<span class="p">}</span>


<span class="cm">/* This is called during init_IRQ.  We used to do it above, but this</span>
<span class="cm"> * was too early since init_IRQ was not yet called.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">cpm_interrupt_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Initialize the CPM interrupt controller.</span>
<span class="cm">	 * NOTE THAT pquicc had better have been initialized!</span>
<span class="cm">	 * reference: MC68360UM p. 7-377</span>
<span class="cm">	 */</span>
	<span class="n">pquicc</span><span class="o">-&gt;</span><span class="n">intr_cicr</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">CICR_SCD_SCC4</span> <span class="o">|</span> <span class="n">CICR_SCC_SCC3</span> <span class="o">|</span> <span class="n">CICR_SCB_SCC2</span> <span class="o">|</span> <span class="n">CICR_SCA_SCC1</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">CPM_INTERRUPT</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">CICR_HP_MASK</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">CPM_VECTOR_BASE</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">CICR_SPS</span><span class="p">;</span>

	<span class="cm">/* mask all CPM interrupts from reaching the cpu32 core: */</span>
	<span class="n">pquicc</span><span class="o">-&gt;</span><span class="n">intr_cimr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="cm">/* mles - If I understand correctly, the 360 just pops over to the CPM</span>
<span class="cm">	 * specific vector, obviating the necessity to vector through the IRQ</span>
<span class="cm">	 * whose priority the CPM is set to. This needs a closer look, though.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Set our interrupt handler with the core CPU. */</span>
<span class="cm">/* 	if (request_irq(CPM_INTERRUPT, cpm_interrupt, 0, &quot;cpm&quot;, NULL) != 0) */</span>
<span class="cm">/* 		panic(&quot;Could not allocate CPM IRQ!&quot;); */</span>

	<span class="cm">/* Install our own error handler.</span>
<span class="cm">	 */</span>
	<span class="cm">/* I think we want to hold off on this one for the moment - mles */</span>
	<span class="cm">/* cpm_install_handler(CPMVEC_ERROR, cpm_error_interrupt, NULL); */</span>

	<span class="cm">/* master CPM interrupt enable */</span>
	<span class="cm">/* pquicc-&gt;intr_cicr |= CICR_IEN; */</span> <span class="cm">/* no such animal for 360 */</span>
<span class="p">}</span>



<span class="cm">/* CPM interrupt controller interrupt.</span>
<span class="cm">*/</span>
<span class="k">static</span>	<span class="kt">void</span>
<span class="nf">cpm_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* uint	vec; */</span>

	<span class="cm">/* mles: Note that this stuff is currently being performed by</span>
<span class="cm">	 * M68360_do_irq(int vec, struct pt_regs *fp), in ../ints.c  */</span>

	<span class="cm">/* figure out the vector */</span>
	<span class="cm">/* call that vector&#39;s handler */</span>
	<span class="cm">/* clear the irq&#39;s bit in the service register */</span>

<span class="cp">#if 0</span><span class="c"> /* old 860 stuff: */</span>
<span class="c">	/* Get the vector by setting the ACK bit and then reading</span>
<span class="c">	 * the register.</span>
<span class="c">	 */</span>
<span class="c">	((volatile immap_t *)IMAP_ADDR)-&gt;im_cpic.cpic_civr = 1;</span>
<span class="c">	vec = ((volatile immap_t *)IMAP_ADDR)-&gt;im_cpic.cpic_civr;</span>
<span class="c">	vec &gt;&gt;= 11;</span>


<span class="c">	if (cpm_vecs[vec].handler != 0)</span>
<span class="c">		(*cpm_vecs[vec].handler)(cpm_vecs[vec].dev_id);</span>
<span class="c">	else</span>
<span class="c">		((immap_t *)IMAP_ADDR)-&gt;im_cpic.cpic_cimr &amp;= ~(1 &lt;&lt; vec);</span>

<span class="c">	/* After servicing the interrupt, we have to remove the status</span>
<span class="c">	 * indicator.</span>
<span class="c">	 */</span>
<span class="c">	((immap_t *)IMAP_ADDR)-&gt;im_cpic.cpic_cisr |= (1 &lt;&lt; vec);</span>
<span class="cp">#endif</span>

<span class="p">}</span>

<span class="cm">/* The CPM can generate the error interrupt when there is a race condition</span>
<span class="cm"> * between generating and masking interrupts.  All we have to do is ACK it</span>
<span class="cm"> * and return.  This is a no-op function so we don&#39;t need any special</span>
<span class="cm"> * tests in the interrupt handler.</span>
<span class="cm"> */</span>
<span class="k">static</span>	<span class="kt">void</span>
<span class="nf">cpm_error_interrupt</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* Install a CPM interrupt handler.</span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="nf">cpm_install_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">request_irq</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;timer&quot;</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>

<span class="cm">/* 	if (cpm_vecs[vec].handler != 0) */</span>
<span class="cm">/* 		printk(KERN_INFO &quot;CPM interrupt %x replacing %x\n&quot;, */</span>
<span class="cm">/* 			(uint)handler, (uint)cpm_vecs[vec].handler); */</span>
<span class="cm">/* 	cpm_vecs[vec].handler = handler; */</span>
<span class="cm">/* 	cpm_vecs[vec].dev_id = dev_id; */</span>

	<span class="cm">/*              ((immap_t *)IMAP_ADDR)-&gt;im_cpic.cpic_cimr |= (1 &lt;&lt; vec); */</span>
<span class="cm">/* 	pquicc-&gt;intr_cimr |= (1 &lt;&lt; vec); */</span>

<span class="p">}</span>

<span class="cm">/* Free a CPM interrupt handler.</span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="nf">cpm_free_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpm_vecs</span><span class="p">[</span><span class="n">vec</span><span class="p">].</span><span class="n">handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cpm_vecs</span><span class="p">[</span><span class="n">vec</span><span class="p">].</span><span class="n">dev_id</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* ((immap_t *)IMAP_ADDR)-&gt;im_cpic.cpic_cimr &amp;= ~(1 &lt;&lt; vec); */</span>
	<span class="n">pquicc</span><span class="o">-&gt;</span><span class="n">intr_cimr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">);</span>
<span class="p">}</span>




<span class="cm">/* Allocate some memory from the dual ported ram.  We may want to</span>
<span class="cm"> * enforce alignment restrictions, but right now everyone is a good</span>
<span class="cm"> * citizen.</span>
<span class="cm"> */</span>
<span class="n">uint</span>
<span class="nf">m360_cpm_dpalloc</span><span class="p">(</span><span class="n">uint</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">uint</span>    <span class="n">retloc</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">dp_alloc_base</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">dp_alloc_top</span><span class="p">)</span>
                <span class="k">return</span><span class="p">(</span><span class="n">CPM_DP_NOSPACE</span><span class="p">);</span>

        <span class="n">retloc</span> <span class="o">=</span> <span class="n">dp_alloc_base</span><span class="p">;</span>
        <span class="n">dp_alloc_base</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>

        <span class="k">return</span><span class="p">(</span><span class="n">retloc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#if 0</span><span class="c"> /* mleslie - for now these are simply kmalloc&#39;d */</span>
<span class="c">/* We also own one page of host buffer space for the allocation of</span>
<span class="c"> * UART &quot;fifos&quot; and the like.</span>
<span class="c"> */</span>
<span class="c">uint</span>
<span class="c">m360_cpm_hostalloc(uint size)</span>
<span class="c">{</span>
<span class="c">	uint	retloc;</span>

<span class="c">	if ((host_buffer + size) &gt;= host_end)</span>
<span class="c">		return(0);</span>

<span class="c">	retloc = host_buffer;</span>
<span class="c">	host_buffer += size;</span>

<span class="c">	return(retloc);</span>
<span class="c">}</span>
<span class="cp">#endif</span>


<span class="cm">/* Set a baud rate generator.  This needs lots of work.  There are</span>
<span class="cm"> * four BRGs, any of which can be wired to any channel.</span>
<span class="cm"> * The internal baud rate clock is the system clock divided by 16.</span>
<span class="cm"> * This assumes the baudrate is 16x oversampled by the uart.</span>
<span class="cm"> */</span>
<span class="cm">/* #define BRG_INT_CLK	(((bd_t *)__res)-&gt;bi_intfreq * 1000000) */</span>
<span class="cp">#define BRG_INT_CLK		system_clock</span>
<span class="cp">#define BRG_UART_CLK	(BRG_INT_CLK/16)</span>

<span class="kt">void</span>
<span class="nf">m360_cpm_setbrg</span><span class="p">(</span><span class="n">uint</span> <span class="n">brg</span><span class="p">,</span> <span class="n">uint</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">uint</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="cm">/* This is good enough to get SMCs running.....</span>
<span class="cm">	 */</span>
	<span class="cm">/* bp = (uint *)&amp;cpmp-&gt;cp_brgc1; */</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">uint</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">pquicc</span><span class="o">-&gt;</span><span class="n">brgc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">l</span><span class="p">);</span>
	<span class="n">bp</span> <span class="o">+=</span> <span class="n">brg</span><span class="p">;</span>
	<span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="p">((</span><span class="n">BRG_UART_CLK</span> <span class="o">/</span> <span class="n">rate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">CPM_BRG_EN</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Local variables:</span>
<span class="cm"> *  c-indent-level: 4</span>
<span class="cm"> *  c-basic-offset: 4</span>
<span class="cm"> *  tab-width: 4</span>
<span class="cm"> * End:</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
