<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › m68k › mac › iop.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>iop.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * I/O Processor (IOP) management</span>
<span class="cm"> * Written and (C) 1999 by Joshua M. Thompson (funaho@jurai.org)</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice and this list of conditions.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice and this list of conditions in the documentation and/or other</span>
<span class="cm"> *    materials provided with the distribution.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The IOP chips are used in the IIfx and some Quadras (900, 950) to manage</span>
<span class="cm"> * serial and ADB. They are actually a 6502 processor and some glue logic.</span>
<span class="cm"> *</span>
<span class="cm"> * 990429 (jmt) - Initial implementation, just enough to knock the SCC IOP</span>
<span class="cm"> *		  into compatible mode so nobody has to fiddle with the</span>
<span class="cm"> *		  Serial Switch control panel anymore.</span>
<span class="cm"> * 990603 (jmt) - Added code to grab the correct ISM IOP interrupt for OSS</span>
<span class="cm"> *		  and non-OSS machines (at least I hope it&#39;s correct on a</span>
<span class="cm"> *		  non-OSS machine -- someone with a Q900 or Q950 needs to</span>
<span class="cm"> *		  check this.)</span>
<span class="cm"> * 990605 (jmt) - Rearranged things a bit wrt IOP detection; iop_present is</span>
<span class="cm"> *		  gone, IOP base addresses are now in an array and the</span>
<span class="cm"> *		  globally-visible functions take an IOP number instead of an</span>
<span class="cm"> *		  an actual base address.</span>
<span class="cm"> * 990610 (jmt) - Finished the message passing framework and it seems to work.</span>
<span class="cm"> *		  Sending _definitely_ works; my adb-bus.c mods can send</span>
<span class="cm"> *		  messages and receive the MSG_COMPLETED status back from the</span>
<span class="cm"> *		  IOP. The trick now is figuring out the message formats.</span>
<span class="cm"> * 990611 (jmt) - More cleanups. Fixed problem where unclaimed messages on a</span>
<span class="cm"> *		  receive channel were never properly acknowledged. Bracketed</span>
<span class="cm"> *		  the remaining debug printk&#39;s with #ifdef&#39;s and disabled</span>
<span class="cm"> *		  debugging. I can now type on the console.</span>
<span class="cm"> * 990612 (jmt) - Copyright notice added. Reworked the way replies are handled.</span>
<span class="cm"> *		  It turns out that replies are placed back in the send buffer</span>
<span class="cm"> *		  for that channel; messages on the receive channels are always</span>
<span class="cm"> *		  unsolicited messages from the IOP (and our replies to them</span>
<span class="cm"> *		  should go back in the receive channel.) Also added tracking</span>
<span class="cm"> *		  of device names to the listener functions ala the interrupt</span>
<span class="cm"> *		  handlers.</span>
<span class="cm"> * 990729 (jmt) - Added passing of pt_regs structure to IOP handlers. This is</span>
<span class="cm"> *		  used by the new unified ADB driver.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO:</span>
<span class="cm"> *</span>
<span class="cm"> * o Something should be periodically checking iop_alive() to make sure the</span>
<span class="cm"> *   IOP hasn&#39;t died.</span>
<span class="cm"> * o Some of the IOP manager routines need better error checking and</span>
<span class="cm"> *   return codes. Nothing major, just prettying up.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * -----------------------</span>
<span class="cm"> * IOP Message Passing 101</span>
<span class="cm"> * -----------------------</span>
<span class="cm"> *</span>
<span class="cm"> * The host talks to the IOPs using a rather simple message-passing scheme via</span>
<span class="cm"> * a shared memory area in the IOP RAM. Each IOP has seven &quot;channels&quot;; each</span>
<span class="cm"> * channel is conneced to a specific software driver on the IOP. For example</span>
<span class="cm"> * on the SCC IOP there is one channel for each serial port. Each channel has</span>
<span class="cm"> * an incoming and and outgoing message queue with a depth of one.</span>
<span class="cm"> *</span>
<span class="cm"> * A message is 32 bytes plus a state byte for the channel (MSG_IDLE, MSG_NEW,</span>
<span class="cm"> * MSG_RCVD, MSG_COMPLETE). To send a message you copy the message into the</span>
<span class="cm"> * buffer, set the state to MSG_NEW and signal the IOP by setting the IRQ flag</span>
<span class="cm"> * in the IOP control to 1. The IOP will move the state to MSG_RCVD when it</span>
<span class="cm"> * receives the message and then to MSG_COMPLETE when the message processing</span>
<span class="cm"> * has completed. It is the host&#39;s responsibility at that point to read the</span>
<span class="cm"> * reply back out of the send channel buffer and reset the channel state back</span>
<span class="cm"> * to MSG_IDLE.</span>
<span class="cm"> *</span>
<span class="cm"> * To receive message from the IOP the same procedure is used except the roles</span>
<span class="cm"> * are reversed. That is, the IOP puts message in the channel with a state of</span>
<span class="cm"> * MSG_NEW, and the host receives the message and move its state to MSG_RCVD</span>
<span class="cm"> * and then to MSG_COMPLETE when processing is completed and the reply (if any)</span>
<span class="cm"> * has been placed back in the receive channel. The IOP will then reset the</span>
<span class="cm"> * channel state to MSG_IDLE.</span>
<span class="cm"> *</span>
<span class="cm"> * Two sets of host interrupts are provided, INT0 and INT1. Both appear on one</span>
<span class="cm"> * interrupt level; they are distinguished by a pair of bits in the IOP status</span>
<span class="cm"> * register. The IOP will raise INT0 when one or more messages in the send</span>
<span class="cm"> * channels have gone to the MSG_COMPLETE state and it will raise INT1 when one</span>
<span class="cm"> * or more messages on the receive channels have gone to the MSG_NEW state.</span>
<span class="cm"> *</span>
<span class="cm"> * Since each channel handles only one message we have to implement a small</span>
<span class="cm"> * interrupt-driven queue on our end. Messages to be sent are placed on the</span>
<span class="cm"> * queue for sending and contain a pointer to an optional callback function.</span>
<span class="cm"> * The handler for a message is called when the message state goes to</span>
<span class="cm"> * MSG_COMPLETE.</span>
<span class="cm"> *</span>
<span class="cm"> * For receiving message we maintain a list of handler functions to call when</span>
<span class="cm"> * a message is received on that IOP/channel combination. The handlers are</span>
<span class="cm"> * called much like an interrupt handler and are passed a copy of the message</span>
<span class="cm"> * from the IOP. The message state will be in MSG_RCVD while the handler runs;</span>
<span class="cm"> * it is the handler&#39;s responsibility to call iop_complete_message() when</span>
<span class="cm"> * finished; this function moves the message state to MSG_COMPLETE and signals</span>
<span class="cm"> * the IOP. This two-step process is provided to allow the handler to defer</span>
<span class="cm"> * message processing to a bottom-half handler if the processing will take</span>
<span class="cm"> * a significant amount of time (handlers are called at interrupt time so they</span>
<span class="cm"> * should execute quickly.)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#include &lt;asm/bootinfo.h&gt;</span>
<span class="cp">#include &lt;asm/macintosh.h&gt;</span>
<span class="cp">#include &lt;asm/macints.h&gt;</span>
<span class="cp">#include &lt;asm/mac_iop.h&gt;</span>

<span class="cm">/*#define DEBUG_IOP*/</span>

<span class="cm">/* Set to non-zero if the IOPs are present. Set by iop_init() */</span>

<span class="kt">int</span> <span class="n">iop_scc_present</span><span class="p">,</span><span class="n">iop_ism_present</span><span class="p">;</span>

<span class="cm">/* structure for tracking channel listeners */</span>

<span class="k">struct</span> <span class="n">listener</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * IOP structures for the two IOPs</span>
<span class="cm"> *</span>
<span class="cm"> * The SCC IOP controls both serial ports (A and B) as its two functions.</span>
<span class="cm"> * The ISM IOP controls the SWIM (floppy drive) and ADB.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop_base</span><span class="p">[</span><span class="n">NUM_IOPS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * IOP message queues</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iop_msg</span> <span class="n">iop_msg_pool</span><span class="p">[</span><span class="n">NUM_IOP_MSGS</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="n">iop_send_queue</span><span class="p">[</span><span class="n">NUM_IOPS</span><span class="p">][</span><span class="n">NUM_IOP_CHAN</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">listener</span> <span class="n">iop_listeners</span><span class="p">[</span><span class="n">NUM_IOPS</span><span class="p">][</span><span class="n">NUM_IOP_CHAN</span><span class="p">];</span>

<span class="n">irqreturn_t</span> <span class="n">iop_ism_irq</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Private access functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">iop_loadaddr</span><span class="p">(</span><span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">ram_addr_lo</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">ram_addr_hi</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="n">__u8</span> <span class="nf">iop_readb</span><span class="p">(</span><span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">ram_addr_lo</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">ram_addr_hi</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">iop</span><span class="o">-&gt;</span><span class="n">ram_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">iop_writeb</span><span class="p">(</span><span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">ram_addr_lo</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">ram_addr_hi</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">ram_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">iop_stop</span><span class="p">(</span><span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IOP_RUN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">iop_start</span><span class="p">(</span><span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">=</span> <span class="n">IOP_RUN</span> <span class="o">|</span> <span class="n">IOP_AUTOINC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">iop_bypass</span><span class="p">(</span><span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">|=</span> <span class="n">IOP_BYPASS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">iop_interrupt</span><span class="p">(</span><span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">|=</span> <span class="n">IOP_IRQ</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iop_alive</span><span class="p">(</span><span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">iop_readb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">IOP_ADDR_ALIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">iop_writeb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">IOP_ADDR_ALIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="nf">iop_alloc_msg</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_IOP_MSGS</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iop_msg_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">==</span> <span class="n">IOP_MSGSTATUS_UNUSED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iop_msg_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOP_MSGSTATUS_WAITING</span><span class="p">;</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">iop_msg_pool</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iop_free_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOP_MSGSTATUS_UNUSED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called by the startup code before anything else. Its purpose</span>
<span class="cm"> * is to find and initialize the IOPs early in the boot sequence, so that</span>
<span class="cm"> * the serial IOP can be placed into bypass mode _before_ we try to</span>
<span class="cm"> * initialize the serial console.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">iop_preinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">macintosh_config</span><span class="o">-&gt;</span><span class="n">scc_type</span> <span class="o">==</span> <span class="n">MAC_SCC_IOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">macintosh_config</span><span class="o">-&gt;</span><span class="n">ident</span> <span class="o">==</span> <span class="n">MAC_MODEL_IIFX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_SCC</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="p">)</span> <span class="n">SCC_IOP_BASE_IIFX</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_SCC</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="p">)</span> <span class="n">SCC_IOP_BASE_QUADRA</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_SCC</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">=</span> <span class="mh">0x87</span><span class="p">;</span>
		<span class="n">iop_scc_present</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_SCC</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iop_scc_present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">macintosh_config</span><span class="o">-&gt;</span><span class="n">adb_type</span> <span class="o">==</span> <span class="n">MAC_ADB_IOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">macintosh_config</span><span class="o">-&gt;</span><span class="n">ident</span> <span class="o">==</span> <span class="n">MAC_MODEL_IIFX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="p">)</span> <span class="n">ISM_IOP_BASE_IIFX</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="p">)</span> <span class="n">ISM_IOP_BASE_QUADRA</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iop_ism_present</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iop_ism_present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the IOPs, if present.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">iop_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iop_scc_present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IOP: detected SCC IOP at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_SCC</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iop_ism_present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IOP: detected ISM IOP at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">]);</span>
		<span class="n">iop_start</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">]);</span>
		<span class="n">iop_alive</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">]);</span> <span class="cm">/* clears the alive flag */</span>
	<span class="p">}</span>

	<span class="cm">/* Make the whole pool available and empty the queues */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_IOP_MSGS</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iop_msg_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOP_MSGSTATUS_UNUSED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_IOP_CHAN</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iop_send_queue</span><span class="p">[</span><span class="n">IOP_NUM_SCC</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iop_send_queue</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iop_listeners</span><span class="p">[</span><span class="n">IOP_NUM_SCC</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">devname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iop_listeners</span><span class="p">[</span><span class="n">IOP_NUM_SCC</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iop_listeners</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">devname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iop_listeners</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register the interrupt handler for the IOPs.</span>
<span class="cm"> * TODO: might be wrong for non-OSS machines. Anyone?</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">iop_register_interrupts</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iop_ism_present</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">macintosh_config</span><span class="o">-&gt;</span><span class="n">ident</span> <span class="o">==</span> <span class="n">MAC_MODEL_IIFX</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">IRQ_MAC_ADB</span><span class="p">,</span> <span class="n">iop_ism_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="s">&quot;ISM IOP&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">IOP_NUM_ISM</span><span class="p">))</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t register ISM IOP interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">IRQ_VIA2_0</span><span class="p">,</span> <span class="n">iop_ism_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ISM IOP&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">IOP_NUM_ISM</span><span class="p">))</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t register ISM IOP interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iop_alive</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">IOP_NUM_ISM</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IOP: oh my god, they killed the ISM IOP!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IOP: the ISM IOP seems to be alive.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register or unregister a listener for a specific IOP and channel</span>
<span class="cm"> *</span>
<span class="cm"> * If the handler pointer is NULL the current listener (if any) is</span>
<span class="cm"> * unregistered. Otherwise the new listener is registered provided</span>
<span class="cm"> * there is no existing listener registered.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">iop_listen</span><span class="p">(</span><span class="n">uint</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">uint</span> <span class="n">chan</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="p">),</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iop_num</span> <span class="o">&gt;=</span> <span class="n">NUM_IOPS</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">])</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&gt;=</span> <span class="n">NUM_IOP_CHAN</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iop_listeners</span><span class="p">[</span><span class="n">iop_num</span><span class="p">][</span><span class="n">chan</span><span class="p">].</span><span class="n">handler</span> <span class="o">&amp;&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">iop_listeners</span><span class="p">[</span><span class="n">iop_num</span><span class="p">][</span><span class="n">chan</span><span class="p">].</span><span class="n">devname</span> <span class="o">=</span> <span class="n">devname</span><span class="p">;</span>
	<span class="n">iop_listeners</span><span class="p">[</span><span class="n">iop_num</span><span class="p">][</span><span class="n">chan</span><span class="p">].</span><span class="n">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Complete reception of a message, which just means copying the reply</span>
<span class="cm"> * into the buffer, setting the channel state to MSG_COMPLETE and</span>
<span class="cm"> * notifying the IOP.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">iop_complete_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iop_num</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">iop_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">offset</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_IOP</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iop_complete(%p): iop %d chan %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">iop_num</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">IOP_ADDR_RECV_MSG</span> <span class="o">+</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">*</span> <span class="n">IOP_MSG_LEN</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IOP_MSG_LEN</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iop_writeb</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">],</span> <span class="n">offset</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">iop_writeb</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">],</span>
		   <span class="n">IOP_ADDR_RECV_STATE</span> <span class="o">+</span> <span class="n">chan</span><span class="p">,</span> <span class="n">IOP_MSG_COMPLETE</span><span class="p">);</span>
	<span class="n">iop_interrupt</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">iop_num</span><span class="p">]);</span>

	<span class="n">iop_free_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Actually put a message into a send channel buffer</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iop_do_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span> <span class="o">=</span> <span class="n">iop_base</span><span class="p">[</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">iop_num</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">offset</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">IOP_ADDR_SEND_MSG</span> <span class="o">+</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">*</span> <span class="n">IOP_MSG_LEN</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IOP_MSG_LEN</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iop_writeb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">iop_writeb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">IOP_ADDR_SEND_STATE</span> <span class="o">+</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">IOP_MSG_NEW</span><span class="p">);</span>

	<span class="n">iop_interrupt</span><span class="p">(</span><span class="n">iop</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle sending a message on a channel that</span>
<span class="cm"> * has gone into the IOP_MSG_COMPLETE state.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iop_handle_send</span><span class="p">(</span><span class="n">uint</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">uint</span> <span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span> <span class="o">=</span> <span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="o">*</span><span class="n">msg2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">offset</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_IOP</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iop_handle_send: iop %d channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">iop_writeb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">IOP_ADDR_SEND_STATE</span> <span class="o">+</span> <span class="n">chan</span><span class="p">,</span> <span class="n">IOP_MSG_IDLE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="n">iop_send_queue</span><span class="p">[</span><span class="n">iop_num</span><span class="p">][</span><span class="n">chan</span><span class="p">]))</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOP_MSGSTATUS_COMPLETE</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">IOP_ADDR_SEND_MSG</span> <span class="o">+</span> <span class="p">(</span><span class="n">chan</span> <span class="o">*</span> <span class="n">IOP_MSG_LEN</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IOP_MSG_LEN</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">iop_readb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">)(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">msg2</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">iop_free_msg</span><span class="p">(</span><span class="n">msg2</span><span class="p">);</span>

	<span class="n">iop_send_queue</span><span class="p">[</span><span class="n">iop_num</span><span class="p">][</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="n">iop_do_send</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle reception of a message on a channel that has</span>
<span class="cm"> * gone into the IOP_MSG_NEW state.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iop_handle_recv</span><span class="p">(</span><span class="n">uint</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">uint</span> <span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span> <span class="o">=</span> <span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_IOP</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iop_handle_recv: iop %d channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">iop_alloc_msg</span><span class="p">();</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">iop_num</span> <span class="o">=</span> <span class="n">iop_num</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOP_MSGSTATUS_UNSOL</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="n">iop_listeners</span><span class="p">[</span><span class="n">iop_num</span><span class="p">][</span><span class="n">chan</span><span class="p">].</span><span class="n">handler</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">IOP_ADDR_RECV_MSG</span> <span class="o">+</span> <span class="p">(</span><span class="n">chan</span> <span class="o">*</span> <span class="n">IOP_MSG_LEN</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IOP_MSG_LEN</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">iop_readb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iop_writeb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">IOP_ADDR_RECV_STATE</span> <span class="o">+</span> <span class="n">chan</span><span class="p">,</span> <span class="n">IOP_MSG_RCVD</span><span class="p">);</span>

	<span class="cm">/* If there is a listener, call it now. Otherwise complete */</span>
	<span class="cm">/* the message ourselves to avoid possible stalls.         */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">)(</span><span class="n">msg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_IOP</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iop_handle_recv: unclaimed message on iop %d channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iop_handle_recv:&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IOP_MSG_LEN</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %02X&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">iop_complete_message</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send a message</span>
<span class="cm"> *</span>
<span class="cm"> * The message is placed at the end of the send queue. Afterwards if the</span>
<span class="cm"> * channel is idle we force an immediate send of the next message in the</span>
<span class="cm"> * queue.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">iop_send_message</span><span class="p">(</span><span class="n">uint</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">uint</span> <span class="n">chan</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span>
		      <span class="n">uint</span> <span class="n">msg_len</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">msg_data</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iop_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">iop_num</span> <span class="o">&gt;=</span> <span class="n">NUM_IOPS</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">])</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chan</span> <span class="o">&gt;=</span> <span class="n">NUM_IOP_CHAN</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg_len</span> <span class="o">&gt;</span> <span class="n">IOP_MSG_LEN</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">iop_alloc_msg</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOP_MSGSTATUS_WAITING</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">iop_num</span> <span class="o">=</span> <span class="n">iop_num</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">caller_priv</span> <span class="o">=</span> <span class="n">privdata</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="n">msg_data</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">iop_send_queue</span><span class="p">[</span><span class="n">iop_num</span><span class="p">][</span><span class="n">chan</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">iop_send_queue</span><span class="p">[</span><span class="n">iop_num</span><span class="p">][</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iop_readb</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">],</span>
	    <span class="n">IOP_ADDR_SEND_STATE</span> <span class="o">+</span> <span class="n">chan</span><span class="p">)</span> <span class="o">==</span> <span class="n">IOP_MSG_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iop_do_send</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Upload code to the shared RAM of an IOP.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">iop_upload_code</span><span class="p">(</span><span class="n">uint</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">code_start</span><span class="p">,</span>
		     <span class="n">uint</span> <span class="n">code_len</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">shared_ram_start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iop_num</span> <span class="o">&gt;=</span> <span class="n">NUM_IOPS</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">iop_loadaddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">],</span> <span class="n">shared_ram_start</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">code_len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ram_data</span> <span class="o">=</span> <span class="o">*</span><span class="n">code_start</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Download code from the shared RAM of an IOP.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">iop_download_code</span><span class="p">(</span><span class="n">uint</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">code_start</span><span class="p">,</span>
		       <span class="n">uint</span> <span class="n">code_len</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">shared_ram_start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iop_num</span> <span class="o">&gt;=</span> <span class="n">NUM_IOPS</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">iop_loadaddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">],</span> <span class="n">shared_ram_start</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">code_len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">code_start</span><span class="o">++</span> <span class="o">=</span> <span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ram_data</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compare the code in the shared RAM of an IOP with a copy in system memory</span>
<span class="cm"> * and return 0 on match or the first nonmatching system memory address on</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>

<span class="n">__u8</span> <span class="o">*</span><span class="nf">iop_compare_code</span><span class="p">(</span><span class="n">uint</span> <span class="n">iop_num</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">code_start</span><span class="p">,</span>
		       <span class="n">uint</span> <span class="n">code_len</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">shared_ram_start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iop_num</span> <span class="o">&gt;=</span> <span class="n">NUM_IOPS</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">])</span> <span class="k">return</span> <span class="n">code_start</span><span class="p">;</span>

	<span class="n">iop_loadaddr</span><span class="p">(</span><span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">],</span> <span class="n">shared_ram_start</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">code_len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">code_start</span> <span class="o">!=</span> <span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ram_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">code_start</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">code_start</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle an ISM IOP interrupt</span>
<span class="cm"> */</span>

<span class="n">irqreturn_t</span> <span class="nf">iop_ism_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span> <span class="n">iop_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">mac_iop</span> <span class="o">*</span><span class="n">iop</span> <span class="o">=</span> <span class="n">iop_base</span><span class="p">[</span><span class="n">iop_num</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">state</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_IOP</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iop_ism_irq: status = %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* INT0 indicates a state change on an outgoing message channel */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">&amp;</span> <span class="n">IOP_INT0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">=</span> <span class="n">IOP_INT0</span> <span class="o">|</span> <span class="n">IOP_RUN</span> <span class="o">|</span> <span class="n">IOP_AUTOINC</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_IOP</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iop_ism_irq: new status = %02X, send states&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_IOP_CHAN</span>  <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">iop_readb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">IOP_ADDR_SEND_STATE</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_IOP</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %02X&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">IOP_MSG_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iop_handle_send</span><span class="p">(</span><span class="n">iop_num</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#ifdef DEBUG_IOP</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">&amp;</span> <span class="n">IOP_INT1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* INT1 for incoming msgs */</span>
		<span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span> <span class="o">=</span> <span class="n">IOP_INT1</span> <span class="o">|</span> <span class="n">IOP_RUN</span> <span class="o">|</span> <span class="n">IOP_AUTOINC</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_IOP</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iop_ism_irq: new status = %02X, recv states&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">iop</span><span class="o">-&gt;</span><span class="n">status_ctrl</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_IOP_CHAN</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">iop_readb</span><span class="p">(</span><span class="n">iop</span><span class="p">,</span> <span class="n">IOP_ADDR_RECV_STATE</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_IOP</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %02X&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">IOP_MSG_NEW</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iop_handle_recv</span><span class="p">(</span><span class="n">iop_num</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#ifdef DEBUG_IOP</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
