<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › m68k › include › asm › dvma.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>dvma.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * include/asm-m68k/dma.h</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1995 (C) David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> *</span>
<span class="cm"> * Hacked to fit Sun3x needs by Thomas Bogendoerfer</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __M68K_DVMA_H</span>
<span class="cp">#define __M68K_DVMA_H</span>


<span class="cp">#define DVMA_PAGE_SHIFT	13</span>
<span class="cp">#define DVMA_PAGE_SIZE	(1UL &lt;&lt; DVMA_PAGE_SHIFT)</span>
<span class="cp">#define DVMA_PAGE_MASK	(~(DVMA_PAGE_SIZE-1))</span>
<span class="cp">#define DVMA_PAGE_ALIGN(addr)	ALIGN(addr, DVMA_PAGE_SIZE)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dvma_map_iommu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">baddr</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#define dvma_malloc(x) dvma_malloc_align(x, 0)</span>
<span class="cp">#define dvma_map(x, y) dvma_map_align(x, y, 0)</span>
<span class="cp">#define dvma_map_vme(x, y) (dvma_map(x, y) &amp; 0xfffff)</span>
<span class="cp">#define dvma_map_align_vme(x, y, z) (dvma_map_align (x, y, z) &amp; 0xfffff)</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dvma_map_align</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">align</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dvma_malloc_align</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvma_unmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">baddr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dvma_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">);</span>


<span class="cp">#ifdef CONFIG_SUN3</span>
<span class="cm">/* sun3 dvma page support */</span>

<span class="cm">/* memory and pmegs potentially reserved for dvma */</span>
<span class="cp">#define DVMA_PMEG_START 10</span>
<span class="cp">#define DVMA_PMEG_END 16</span>
<span class="cp">#define DVMA_START 0xf00000</span>
<span class="cp">#define DVMA_END 0xfe0000</span>
<span class="cp">#define DVMA_SIZE (DVMA_END-DVMA_START)</span>
<span class="cp">#define IOMMU_TOTAL_ENTRIES 128</span>
<span class="cp">#define IOMMU_ENTRIES 120</span>

<span class="cm">/* empirical kludge -- dvma regions only seem to work right on 0x10000</span>
<span class="cm">   byte boundaries */</span>
<span class="cp">#define DVMA_REGION_SIZE 0x10000</span>
<span class="cp">#define DVMA_ALIGN(addr) (((addr)+DVMA_REGION_SIZE-1) &amp; \</span>
<span class="cp">                         ~(DVMA_REGION_SIZE-1))</span>

<span class="cm">/* virt &lt;-&gt; phys conversions */</span>
<span class="cp">#define dvma_vtop(x) ((unsigned long)(x) &amp; 0xffffff)</span>
<span class="cp">#define dvma_ptov(x) ((unsigned long)(x) | 0xf000000)</span>
<span class="cp">#define dvma_vtovme(x) ((unsigned long)(x) &amp; 0x00fffff)</span>
<span class="cp">#define dvma_vmetov(x) ((unsigned long)(x) | 0xff00000)</span>
<span class="cp">#define dvma_vtob(x) dvma_vtop(x)</span>
<span class="cp">#define dvma_btov(x) dvma_ptov(x)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dvma_map_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* Sun3x */</span><span class="cp"></span>

<span class="cm">/* sun3x dvma page support */</span>

<span class="cp">#define DVMA_START 0x0</span>
<span class="cp">#define DVMA_END 0xf00000</span>
<span class="cp">#define DVMA_SIZE (DVMA_END-DVMA_START)</span>
<span class="cp">#define IOMMU_TOTAL_ENTRIES	   2048</span>
<span class="cm">/* the prom takes the top meg */</span>
<span class="cp">#define IOMMU_ENTRIES              (IOMMU_TOTAL_ENTRIES - 0x80)</span>

<span class="cp">#define dvma_vtob(x) ((unsigned long)(x) &amp; 0x00ffffff)</span>
<span class="cp">#define dvma_btov(x) ((unsigned long)(x) | 0xff000000)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">dvma_map_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>



<span class="cm">/* everything below this line is specific to dma used for the onboard</span>
<span class="cm">   ESP scsi on sun3x */</span>

<span class="cm">/* Structure to describe the current status of DMA registers on the Sparc */</span>
<span class="k">struct</span> <span class="n">sparc_dma_registers</span> <span class="p">{</span>
  <span class="n">__volatile__</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cond_reg</span><span class="p">;</span>	<span class="cm">/* DMA condition register */</span>
  <span class="n">__volatile__</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">st_addr</span><span class="p">;</span>	<span class="cm">/* Start address of this transfer */</span>
  <span class="n">__volatile__</span> <span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">cnt</span><span class="p">;</span>	<span class="cm">/* How many bytes to transfer */</span>
  <span class="n">__volatile__</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_test</span><span class="p">;</span>	<span class="cm">/* DMA test register */</span>
<span class="p">};</span>

<span class="cm">/* DVMA chip revisions */</span>
<span class="k">enum</span> <span class="n">dvma_rev</span> <span class="p">{</span>
	<span class="n">dvmarev0</span><span class="p">,</span>
	<span class="n">dvmaesc1</span><span class="p">,</span>
	<span class="n">dvmarev1</span><span class="p">,</span>
	<span class="n">dvmarev2</span><span class="p">,</span>
	<span class="n">dvmarev3</span><span class="p">,</span>
	<span class="n">dvmarevplus</span><span class="p">,</span>
	<span class="n">dvmahme</span>
<span class="p">};</span>

<span class="cp">#define DMA_HASCOUNT(rev)  ((rev)==dvmaesc1)</span>

<span class="cm">/* Linux DMA information structure, filled during probe. */</span>
<span class="k">struct</span> <span class="n">Linux_SBus_DMA</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Linux_SBus_DMA</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linux_sbus_device</span> <span class="o">*</span><span class="n">SBus_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sparc_dma_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="cm">/* Status, misc info */</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>                <span class="cm">/* Prom node for this DMA device */</span>
	<span class="kt">int</span> <span class="n">running</span><span class="p">;</span>             <span class="cm">/* Are we doing DMA now? */</span>
	<span class="kt">int</span> <span class="n">allocated</span><span class="p">;</span>           <span class="cm">/* Are we &quot;owned&quot; by anyone yet? */</span>

	<span class="cm">/* Transfer information. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>      <span class="cm">/* Start address of current transfer */</span>
	<span class="kt">int</span> <span class="n">nbytes</span><span class="p">;</span>              <span class="cm">/* Size of current transfer */</span>
	<span class="kt">int</span> <span class="n">realbytes</span><span class="p">;</span>           <span class="cm">/* For splitting up large transfers, etc. */</span>

	<span class="cm">/* DMA revision */</span>
	<span class="k">enum</span> <span class="n">dvma_rev</span> <span class="n">revision</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">Linux_SBus_DMA</span> <span class="o">*</span><span class="n">dma_chain</span><span class="p">;</span>

<span class="cm">/* Broken hardware... */</span>
<span class="cp">#define DMA_ISBROKEN(dma)    ((dma)-&gt;revision == dvmarev1)</span>
<span class="cp">#define DMA_ISESC1(dma)      ((dma)-&gt;revision == dvmaesc1)</span>

<span class="cm">/* Fields in the cond_reg register */</span>
<span class="cm">/* First, the version identification bits */</span>
<span class="cp">#define DMA_DEVICE_ID    0xf0000000        </span><span class="cm">/* Device identification bits */</span><span class="cp"></span>
<span class="cp">#define DMA_VERS0        0x00000000        </span><span class="cm">/* Sunray DMA version */</span><span class="cp"></span>
<span class="cp">#define DMA_ESCV1        0x40000000        </span><span class="cm">/* DMA ESC Version 1 */</span><span class="cp"></span>
<span class="cp">#define DMA_VERS1        0x80000000        </span><span class="cm">/* DMA rev 1 */</span><span class="cp"></span>
<span class="cp">#define DMA_VERS2        0xa0000000        </span><span class="cm">/* DMA rev 2 */</span><span class="cp"></span>
<span class="cp">#define DMA_VERHME       0xb0000000        </span><span class="cm">/* DMA hme gate array */</span><span class="cp"></span>
<span class="cp">#define DMA_VERSPLUS     0x90000000        </span><span class="cm">/* DMA rev 1 PLUS */</span><span class="cp"></span>

<span class="cp">#define DMA_HNDL_INTR    0x00000001        </span><span class="cm">/* An IRQ needs to be handled */</span><span class="cp"></span>
<span class="cp">#define DMA_HNDL_ERROR   0x00000002        </span><span class="cm">/* We need to take an error */</span><span class="cp"></span>
<span class="cp">#define DMA_FIFO_ISDRAIN 0x0000000c        </span><span class="cm">/* The DMA FIFO is draining */</span><span class="cp"></span>
<span class="cp">#define DMA_INT_ENAB     0x00000010        </span><span class="cm">/* Turn on interrupts */</span><span class="cp"></span>
<span class="cp">#define DMA_FIFO_INV     0x00000020        </span><span class="cm">/* Invalidate the FIFO */</span><span class="cp"></span>
<span class="cp">#define DMA_ACC_SZ_ERR   0x00000040        </span><span class="cm">/* The access size was bad */</span><span class="cp"></span>
<span class="cp">#define DMA_FIFO_STDRAIN 0x00000040        </span><span class="cm">/* DMA_VERS1 Drain the FIFO */</span><span class="cp"></span>
<span class="cp">#define DMA_RST_SCSI     0x00000080        </span><span class="cm">/* Reset the SCSI controller */</span><span class="cp"></span>
<span class="cp">#define DMA_RST_ENET     DMA_RST_SCSI      </span><span class="cm">/* Reset the ENET controller */</span><span class="cp"></span>
<span class="cp">#define DMA_ST_WRITE     0x00000100        </span><span class="cm">/* write from device to memory */</span><span class="cp"></span>
<span class="cp">#define DMA_ENABLE       0x00000200        </span><span class="cm">/* Fire up DMA, handle requests */</span><span class="cp"></span>
<span class="cp">#define DMA_PEND_READ    0x00000400        </span><span class="cm">/* DMA_VERS1/0/PLUS Pending Read */</span><span class="cp"></span>
<span class="cp">#define DMA_ESC_BURST    0x00000800        </span><span class="cm">/* 1=16byte 0=32byte */</span><span class="cp"></span>
<span class="cp">#define DMA_READ_AHEAD   0x00001800        </span><span class="cm">/* DMA read ahead partial longword */</span><span class="cp"></span>
<span class="cp">#define DMA_DSBL_RD_DRN  0x00001000        </span><span class="cm">/* No EC drain on slave reads */</span><span class="cp"></span>
<span class="cp">#define DMA_BCNT_ENAB    0x00002000        </span><span class="cm">/* If on, use the byte counter */</span><span class="cp"></span>
<span class="cp">#define DMA_TERM_CNTR    0x00004000        </span><span class="cm">/* Terminal counter */</span><span class="cp"></span>
<span class="cp">#define DMA_CSR_DISAB    0x00010000        </span><span class="cm">/* No FIFO drains during csr */</span><span class="cp"></span>
<span class="cp">#define DMA_SCSI_DISAB   0x00020000        </span><span class="cm">/* No FIFO drains during reg */</span><span class="cp"></span>
<span class="cp">#define DMA_DSBL_WR_INV  0x00020000        </span><span class="cm">/* No EC inval. on slave writes */</span><span class="cp"></span>
<span class="cp">#define DMA_ADD_ENABLE   0x00040000        </span><span class="cm">/* Special ESC DVMA optimization */</span><span class="cp"></span>
<span class="cp">#define DMA_E_BURST8	 0x00040000	   </span><span class="cm">/* ENET: SBUS r/w burst size */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST_SZ      0x000c0000        </span><span class="cm">/* SCSI: SBUS r/w burst size */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST64       0x00080000        </span><span class="cm">/* SCSI: 64byte bursts (HME on UltraSparc only) */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST32       0x00040000        </span><span class="cm">/* SCSI: 32byte bursts */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST16       0x00000000        </span><span class="cm">/* SCSI: 16byte bursts */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST0        0x00080000        </span><span class="cm">/* SCSI: no bursts (non-HME gate arrays) */</span><span class="cp"></span>
<span class="cp">#define DMA_ADDR_DISAB   0x00100000        </span><span class="cm">/* No FIFO drains during addr */</span><span class="cp"></span>
<span class="cp">#define DMA_2CLKS        0x00200000        </span><span class="cm">/* Each transfer = 2 clock ticks */</span><span class="cp"></span>
<span class="cp">#define DMA_3CLKS        0x00400000        </span><span class="cm">/* Each transfer = 3 clock ticks */</span><span class="cp"></span>
<span class="cp">#define DMA_EN_ENETAUI   DMA_3CLKS         </span><span class="cm">/* Put lance into AUI-cable mode */</span><span class="cp"></span>
<span class="cp">#define DMA_CNTR_DISAB   0x00800000        </span><span class="cm">/* No IRQ when DMA_TERM_CNTR set */</span><span class="cp"></span>
<span class="cp">#define DMA_AUTO_NADDR   0x01000000        </span><span class="cm">/* Use &quot;auto nxt addr&quot; feature */</span><span class="cp"></span>
<span class="cp">#define DMA_SCSI_ON      0x02000000        </span><span class="cm">/* Enable SCSI dma */</span><span class="cp"></span>
<span class="cp">#define DMA_PARITY_OFF   0x02000000        </span><span class="cm">/* HME: disable parity checking */</span><span class="cp"></span>
<span class="cp">#define DMA_LOADED_ADDR  0x04000000        </span><span class="cm">/* Address has been loaded */</span><span class="cp"></span>
<span class="cp">#define DMA_LOADED_NADDR 0x08000000        </span><span class="cm">/* Next address has been loaded */</span><span class="cp"></span>

<span class="cm">/* Values describing the burst-size property from the PROM */</span>
<span class="cp">#define DMA_BURST1       0x01</span>
<span class="cp">#define DMA_BURST2       0x02</span>
<span class="cp">#define DMA_BURST4       0x04</span>
<span class="cp">#define DMA_BURST8       0x08</span>
<span class="cp">#define DMA_BURST16      0x10</span>
<span class="cp">#define DMA_BURST32      0x20</span>
<span class="cp">#define DMA_BURST64      0x40</span>
<span class="cp">#define DMA_BURSTBITS    0x7f</span>

<span class="cm">/* Determine highest possible final transfer address given a base */</span>
<span class="cp">#define DMA_MAXEND(addr) (0x01000000UL-(((unsigned long)(addr))&amp;0x00ffffffUL))</span>

<span class="cm">/* Yes, I hack a lot of elisp in my spare time... */</span>
<span class="cp">#define DMA_ERROR_P(regs)  ((((regs)-&gt;cond_reg) &amp; DMA_HNDL_ERROR))</span>
<span class="cp">#define DMA_IRQ_P(regs)    ((((regs)-&gt;cond_reg) &amp; (DMA_HNDL_INTR | DMA_HNDL_ERROR)))</span>
<span class="cp">#define DMA_WRITE_P(regs)  ((((regs)-&gt;cond_reg) &amp; DMA_ST_WRITE))</span>
<span class="cp">#define DMA_OFF(regs)      ((((regs)-&gt;cond_reg) &amp;= (~DMA_ENABLE)))</span>
<span class="cp">#define DMA_INTSOFF(regs)  ((((regs)-&gt;cond_reg) &amp;= (~DMA_INT_ENAB)))</span>
<span class="cp">#define DMA_INTSON(regs)   ((((regs)-&gt;cond_reg) |= (DMA_INT_ENAB)))</span>
<span class="cp">#define DMA_PUNTFIFO(regs) ((((regs)-&gt;cond_reg) |= DMA_FIFO_INV))</span>
<span class="cp">#define DMA_SETSTART(regs, addr)  ((((regs)-&gt;st_addr) = (char *) addr))</span>
<span class="cp">#define DMA_BEGINDMA_W(regs) \</span>
<span class="cp">        ((((regs)-&gt;cond_reg |= (DMA_ST_WRITE|DMA_ENABLE|DMA_INT_ENAB))))</span>
<span class="cp">#define DMA_BEGINDMA_R(regs) \</span>
<span class="cp">        ((((regs)-&gt;cond_reg |= ((DMA_ENABLE|DMA_INT_ENAB)&amp;(~DMA_ST_WRITE)))))</span>

<span class="cm">/* For certain DMA chips, we need to disable ints upon irq entry</span>
<span class="cm"> * and turn them back on when we are done.  So in any ESP interrupt</span>
<span class="cm"> * handler you *must* call DMA_IRQ_ENTRY upon entry and DMA_IRQ_EXIT</span>
<span class="cm"> * when leaving the handler.  You have been warned...</span>
<span class="cm"> */</span>
<span class="cp">#define DMA_IRQ_ENTRY(dma, dregs) do { \</span>
<span class="cp">        if(DMA_ISBROKEN(dma)) DMA_INTSOFF(dregs); \</span>
<span class="cp">   } while (0)</span>

<span class="cp">#define DMA_IRQ_EXIT(dma, dregs) do { \</span>
<span class="cp">	if(DMA_ISBROKEN(dma)) DMA_INTSON(dregs); \</span>
<span class="cp">   } while(0)</span>

<span class="cm">/* Reset the friggin&#39; thing... */</span>
<span class="cp">#define DMA_RESET(dma) do { \</span>
<span class="cp">	struct sparc_dma_registers *regs = dma-&gt;regs;                      \</span>
<span class="cp">	</span><span class="cm">/* Let the current FIFO drain itself */</span><span class="cp">                            \</span>
<span class="cp">	sparc_dma_pause(regs, (DMA_FIFO_ISDRAIN));                         \</span>
<span class="cp">	</span><span class="cm">/* Reset the logic */</span><span class="cp">                                              \</span>
<span class="cp">	regs-&gt;cond_reg |= (DMA_RST_SCSI);     </span><span class="cm">/* assert */</span><span class="cp">                 \</span>
<span class="cp">	__delay(400);                         </span><span class="cm">/* let the bits set ;) */</span><span class="cp">    \</span>
<span class="cp">	regs-&gt;cond_reg &amp;= ~(DMA_RST_SCSI);    </span><span class="cm">/* de-assert */</span><span class="cp">              \</span>
<span class="cp">	sparc_dma_enable_interrupts(regs);    </span><span class="cm">/* Re-enable interrupts */</span><span class="cp">   \</span>
<span class="cp">	</span><span class="cm">/* Enable FAST transfers if available */</span><span class="cp">                           \</span>
<span class="cp">	if(dma-&gt;revision&gt;dvmarev1) regs-&gt;cond_reg |= DMA_3CLKS;            \</span>
<span class="cp">	dma-&gt;running = 0;                                                  \</span>
<span class="cp">} while(0)</span>


<span class="cp">#endif </span><span class="cm">/* !CONFIG_SUN3 */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* !(__M68K_DVMA_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
