<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › m68k › include › asm › oplib.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>oplib.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * oplib.h:  Describes the interface and available routines in the</span>
<span class="cm"> *           Linux Prom library.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __SPARC_OPLIB_H</span>
<span class="cp">#define __SPARC_OPLIB_H</span>

<span class="cp">#include &lt;asm/openprom.h&gt;</span>

<span class="cm">/* The master romvec pointer... */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">linux_romvec</span> <span class="o">*</span><span class="n">romvec</span><span class="p">;</span>

<span class="cm">/* Enumeration to describe the prom major version we have detected. */</span>
<span class="k">enum</span> <span class="n">prom_major_version</span> <span class="p">{</span>
	<span class="n">PROM_V0</span><span class="p">,</span>      <span class="cm">/* Original sun4c V0 prom */</span>
	<span class="n">PROM_V2</span><span class="p">,</span>      <span class="cm">/* sun4c and early sun4m V2 prom */</span>
	<span class="n">PROM_V3</span><span class="p">,</span>      <span class="cm">/* sun4m and later, up to sun4d/sun4e machines V3 */</span>
	<span class="n">PROM_P1275</span><span class="p">,</span>   <span class="cm">/* IEEE compliant ISA based Sun PROM, only sun4u */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">enum</span> <span class="n">prom_major_version</span> <span class="n">prom_vers</span><span class="p">;</span>
<span class="cm">/* Revision, and firmware revision. */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prom_rev</span><span class="p">,</span> <span class="n">prom_prev</span><span class="p">;</span>

<span class="cm">/* Root node of the prom device tree, this stays constant after</span>
<span class="cm"> * initialization is complete.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_root_node</span><span class="p">;</span>

<span class="cm">/* Pointer to prom structure containing the device tree traversal</span>
<span class="cm"> * and usage utility functions.  Only prom-lib should use these,</span>
<span class="cm"> * users use the interface defined by the library only!</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">linux_nodeops</span> <span class="o">*</span><span class="n">prom_nodeops</span><span class="p">;</span>

<span class="cm">/* The functions... */</span>

<span class="cm">/* You must call prom_init() before using any of the library services,</span>
<span class="cm"> * preferably as early as possible.  Pass it the romvec pointer.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_romvec</span> <span class="o">*</span><span class="n">rom_ptr</span><span class="p">);</span>

<span class="cm">/* Boot argument acquisition, returns the boot command line string. */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_getbootargs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Device utilities. */</span>

<span class="cm">/* Map and unmap devices in IO space at virtual addresses. Note that the</span>
<span class="cm"> * virtual address you pass is a request and the prom may put your mappings</span>
<span class="cm"> * somewhere else, so check your return value as that is where your new</span>
<span class="cm"> * mappings really are!</span>
<span class="cm"> *</span>
<span class="cm"> * Another note, these are only available on V2 or higher proms!</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_mapio</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">virt_hint</span><span class="p">,</span> <span class="kt">int</span> <span class="n">io_space</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_bytes</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_unmapio</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">virt_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_bytes</span><span class="p">);</span>

<span class="cm">/* Device operations. */</span>

<span class="cm">/* Open the device described by the passed string.  Note, that the format</span>
<span class="cm"> * of the string is different on V0 vs. V2-&gt;higher proms.  The caller must</span>
<span class="cm"> * know what he/she is doing!  Returns the device descriptor, an int.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_devopen</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">device_string</span><span class="p">);</span>

<span class="cm">/* Close a previously opened device described by the passed integer</span>
<span class="cm"> * descriptor.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_devclose</span><span class="p">(</span><span class="kt">int</span> <span class="n">device_handle</span><span class="p">);</span>

<span class="cm">/* Do a seek operation on the device described by the passed integer</span>
<span class="cm"> * descriptor.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_seek</span><span class="p">(</span><span class="kt">int</span> <span class="n">device_handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seek_hival</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seek_lowval</span><span class="p">);</span>

<span class="cm">/* Machine memory configuration routine. */</span>

<span class="cm">/* This function returns a V0 format memory descriptor table, it has three</span>
<span class="cm"> * entries.  One for the total amount of physical ram on the machine, one</span>
<span class="cm"> * for the amount of physical ram available, and one describing the virtual</span>
<span class="cm"> * areas which are allocated by the prom.  So, in a sense the physical</span>
<span class="cm"> * available is a calculation of the total physical minus the physical mapped</span>
<span class="cm"> * by the prom with virtual mappings.</span>
<span class="cm"> *</span>
<span class="cm"> * These lists are returned pre-sorted, this should make your life easier</span>
<span class="cm"> * since the prom itself is way too lazy to do such nice things.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">linux_mem_v0</span> <span class="o">*</span><span class="n">prom_meminfo</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Miscellaneous routines, don&#39;t really fit in any category per se. */</span>

<span class="cm">/* Reboot the machine with the command line passed. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_reboot</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">boot_command</span><span class="p">);</span>

<span class="cm">/* Evaluate the forth string passed. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_feval</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">forth_string</span><span class="p">);</span>

<span class="cm">/* Enter the prom, with possibility of continuation with the &#39;go&#39;</span>
<span class="cm"> * command in newer proms.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_cmdline</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Enter the prom, with no chance of continuation for the stand-alone</span>
<span class="cm"> * which calls this.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_halt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Set the PROM &#39;sync&#39; callback function to the passed function pointer.</span>
<span class="cm"> * When the user gives the &#39;sync&#39; command at the prom prompt while the</span>
<span class="cm"> * kernel is still active, the prom will call this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX The arguments are different on V0 vs. V2-&gt;higher proms, grrr! XXX</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_func_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_setsync</span><span class="p">(</span><span class="n">sync_func_t</span> <span class="n">func_ptr</span><span class="p">);</span>

<span class="cm">/* Acquire the IDPROM of the root node in the prom device tree.  This</span>
<span class="cm"> * gets passed a buffer where you would like it stuffed.  The return value</span>
<span class="cm"> * is the format type of this idprom or 0xff on error.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">prom_get_idprom</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">idp_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idpbuf_size</span><span class="p">);</span>

<span class="cm">/* Get the prom major version. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_version</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Get the prom plugin revision. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getrev</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Get the prom firmware revision. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getprev</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Character operations to/from the console.... */</span>

<span class="cm">/* Non-blocking get character from console. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_nbgetchar</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Non-blocking put character to console. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_nbputchar</span><span class="p">(</span><span class="kt">char</span> <span class="n">character</span><span class="p">);</span>

<span class="cm">/* Blocking get character from console. */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">prom_getchar</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Blocking put character to console. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_putchar</span><span class="p">(</span><span class="kt">char</span> <span class="n">character</span><span class="p">);</span>

<span class="cm">/* Prom&#39;s internal printf routine, don&#39;t use in kernel/boot code. */</span>
<span class="kt">void</span> <span class="n">prom_printf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="cm">/* Query for input device type */</span>

<span class="k">enum</span> <span class="n">prom_input_device</span> <span class="p">{</span>
	<span class="n">PROMDEV_IKBD</span><span class="p">,</span>			<span class="cm">/* input from keyboard */</span>
	<span class="n">PROMDEV_ITTYA</span><span class="p">,</span>			<span class="cm">/* input from ttya */</span>
	<span class="n">PROMDEV_ITTYB</span><span class="p">,</span>			<span class="cm">/* input from ttyb */</span>
	<span class="n">PROMDEV_I_UNK</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">enum</span> <span class="n">prom_input_device</span> <span class="n">prom_query_input_device</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Query for output device type */</span>

<span class="k">enum</span> <span class="n">prom_output_device</span> <span class="p">{</span>
	<span class="n">PROMDEV_OSCREEN</span><span class="p">,</span>		<span class="cm">/* to screen */</span>
	<span class="n">PROMDEV_OTTYA</span><span class="p">,</span>			<span class="cm">/* to ttya */</span>
	<span class="n">PROMDEV_OTTYB</span><span class="p">,</span>			<span class="cm">/* to ttyb */</span>
	<span class="n">PROMDEV_O_UNK</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">enum</span> <span class="n">prom_output_device</span> <span class="n">prom_query_output_device</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Multiprocessor operations... */</span>

<span class="cm">/* Start the CPU with the given device tree node, context table, and context</span>
<span class="cm"> * at the passed program counter.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_startcpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpunode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">linux_prom_registers</span> <span class="o">*</span><span class="n">context_table</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">context</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">program_counter</span><span class="p">);</span>

<span class="cm">/* Stop the CPU with the passed device tree node. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_stopcpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpunode</span><span class="p">);</span>

<span class="cm">/* Idle the CPU with the passed device tree node. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_idlecpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpunode</span><span class="p">);</span>

<span class="cm">/* Re-Start the CPU with the passed device tree node. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_restartcpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpunode</span><span class="p">);</span>

<span class="cm">/* PROM memory allocation facilities... */</span>

<span class="cm">/* Allocated at possibly the given virtual address a chunk of the</span>
<span class="cm"> * indicated size.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_alloc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">virt_hint</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* Free a previously allocated chunk. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_free</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">virt_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* Sun4/sun4c specific memory-management startup hook. */</span>

<span class="cm">/* Map the passed segment in the given context at the passed</span>
<span class="cm"> * virtual address.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_putsegment</span><span class="p">(</span><span class="kt">int</span> <span class="n">context</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">virt_addr</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">physical_segment</span><span class="p">);</span>

<span class="cm">/* PROM device tree traversal functions... */</span>

<span class="cm">/* Get the child node of the given node, or zero if no child exists. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getchild</span><span class="p">(</span><span class="kt">int</span> <span class="n">parent_node</span><span class="p">);</span>

<span class="cm">/* Get the next sibling node of the given node, or zero if no further</span>
<span class="cm"> * siblings exist.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getsibling</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">);</span>

<span class="cm">/* Get the length, at the passed node, of the given property type.</span>
<span class="cm"> * Returns -1 on error (ie. no such property at this node).</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getproplen</span><span class="p">(</span><span class="kt">int</span> <span class="n">thisnode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">);</span>

<span class="cm">/* Fetch the requested property using the given buffer.  Returns</span>
<span class="cm"> * the number of bytes the prom put into your buffer or -1 on error.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getproperty</span><span class="p">(</span><span class="kt">int</span> <span class="n">thisnode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">*</span><span class="n">prop_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">propbuf_size</span><span class="p">);</span>

<span class="cm">/* Acquire an integer property. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getint</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">);</span>

<span class="cm">/* Acquire an integer property, with a default value. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getintdefault</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span> <span class="kt">int</span> <span class="n">defval</span><span class="p">);</span>

<span class="cm">/* Acquire a boolean property, 0=FALSE 1=TRUE. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getbool</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop</span><span class="p">);</span>

<span class="cm">/* Acquire a string property, null string on error. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_getstring</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">);</span>

<span class="cm">/* Does the passed node have the given &quot;name&quot;? YES=1 NO=0 */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_nodematch</span><span class="p">(</span><span class="kt">int</span> <span class="n">thisnode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* Search all siblings starting at the passed node for &quot;name&quot; matching</span>
<span class="cm"> * the given string.  Returns the node on success, zero on failure.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_searchsiblings</span><span class="p">(</span><span class="kt">int</span> <span class="n">node_start</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* Return the first property type, as a string, for the given node.</span>
<span class="cm"> * Returns a null string on error.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_firstprop</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">);</span>

<span class="cm">/* Returns the next property after the passed property for the given</span>
<span class="cm"> * node.  Returns null string on failure.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_nextprop</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prev_property</span><span class="p">);</span>

<span class="cm">/* Returns 1 if the specified node has given property. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_node_has_property</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">);</span>

<span class="cm">/* Set the indicated property at the given node with the passed value.</span>
<span class="cm"> * Returns the number of bytes of your value that the prom took.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_setprop</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop_name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop_value</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">value_size</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_pathtoinode</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_inst2pkg</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* Dorking with Bus ranges... */</span>

<span class="cm">/* Adjust reg values with the passed ranges. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_adjust_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_prom_registers</span> <span class="o">*</span><span class="n">regp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nregs</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">linux_prom_ranges</span> <span class="o">*</span><span class="n">rangep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nranges</span><span class="p">);</span>

<span class="cm">/* Adjust child ranges with the passed parent ranges. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_adjust_ranges</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_prom_ranges</span> <span class="o">*</span><span class="n">cranges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncranges</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">linux_prom_ranges</span> <span class="o">*</span><span class="n">pranges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">npranges</span><span class="p">);</span>

<span class="cm">/* Apply promlib probed OBIO ranges to registers. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_apply_obio_ranges</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_prom_registers</span> <span class="o">*</span><span class="n">obioregs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nregs</span><span class="p">);</span>

<span class="cm">/* Apply ranges of any prom node (and optionally parent node as well) to registers. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_apply_generic_ranges</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">linux_prom_registers</span> <span class="o">*</span><span class="n">sbusregs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nregs</span><span class="p">);</span>


<span class="cp">#endif </span><span class="cm">/* !(__SPARC_OPLIB_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
