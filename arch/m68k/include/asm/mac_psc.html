<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › m68k › include › asm › mac_psc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>mac_psc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Apple Peripheral System Controller (PSC)</span>
<span class="cm"> *</span>
<span class="cm"> * The PSC is used on the AV Macs to control IO functions not handled</span>
<span class="cm"> * by the VIAs (Ethernet, DSP, SCC, Sound). This includes nine DMA</span>
<span class="cm"> * channels.</span>
<span class="cm"> *</span>
<span class="cm"> * The first seven DMA channels appear to be &quot;one-shot&quot; and are actually</span>
<span class="cm"> * sets of two channels; one member is active while the other is being</span>
<span class="cm"> * configured, and then you flip the active member and start all over again.</span>
<span class="cm"> * The one-shot channels are grouped together and are:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. SCSI</span>
<span class="cm"> * 2. Ethernet Read</span>
<span class="cm"> * 3. Ethernet Write</span>
<span class="cm"> * 4. Floppy Disk Controller</span>
<span class="cm"> * 5. SCC Channel A Receive</span>
<span class="cm"> * 6. SCC Channel B Receive</span>
<span class="cm"> * 7. SCC Channel A Transmit</span>
<span class="cm"> *</span>
<span class="cm"> * The remaining two channels are handled somewhat differently. They appear</span>
<span class="cm"> * to be closely tied and share one set of registers. They also seem to run</span>
<span class="cm"> * continuously, although how you keep the buffer filled in this scenario is</span>
<span class="cm"> * not understood as there seems to be only one input and one output buffer</span>
<span class="cm"> * pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Much of this was extrapolated from what was known about the Ethernet</span>
<span class="cm"> * registers and subsequently confirmed using MacsBug (ie by pinging the</span>
<span class="cm"> * machine with easy-to-find patterns and looking for them in the DMA</span>
<span class="cm"> * buffers, or by sending a file over the serial ports and finding the</span>
<span class="cm"> * file in the buffers.)</span>
<span class="cm"> *</span>
<span class="cm"> * 1999-05-25 (jmt)</span>
<span class="cm"> */</span>

<span class="cp">#define PSC_BASE	(0x50F31000)</span>

<span class="cm">/*</span>
<span class="cm"> * The IER/IFR registers work like the VIA, except that it has 4</span>
<span class="cm"> * of them each on different interrupt levels, and each register</span>
<span class="cm"> * set only seems to handle four interrupts instead of seven.</span>
<span class="cm"> *</span>
<span class="cm"> * To access a particular set of registers, add 0xn0 to the base</span>
<span class="cm"> * where n = 3,4,5 or 6.</span>
<span class="cm"> */</span>

<span class="cp">#define pIFRbase	0x100</span>
<span class="cp">#define pIERbase	0x104</span>

<span class="cm">/*</span>
<span class="cm"> * One-shot DMA control registers</span>
<span class="cm"> */</span>

<span class="cp">#define PSC_MYSTERY	0x804</span>

<span class="cp">#define PSC_CTL_BASE	0xC00</span>

<span class="cp">#define PSC_SCSI_CTL	0xC00</span>
<span class="cp">#define PSC_ENETRD_CTL  0xC10</span>
<span class="cp">#define PSC_ENETWR_CTL  0xC20</span>
<span class="cp">#define PSC_FDC_CTL	0xC30</span>
<span class="cp">#define PSC_SCCA_CTL	0xC40</span>
<span class="cp">#define PSC_SCCB_CTL	0xC50</span>
<span class="cp">#define PSC_SCCATX_CTL	0xC60</span>

<span class="cm">/*</span>
<span class="cm"> * DMA channels. Add +0x10 for the second channel in the set.</span>
<span class="cm"> * You&#39;re supposed to use one channel while the other runs and</span>
<span class="cm"> * then flip channels and do the whole thing again.</span>
<span class="cm"> */</span>

<span class="cp">#define PSC_ADDR_BASE	0x1000</span>
<span class="cp">#define PSC_LEN_BASE	0x1004</span>
<span class="cp">#define PSC_CMD_BASE	0x1008</span>

<span class="cp">#define PSC_SET0	0x00</span>
<span class="cp">#define PSC_SET1	0x10</span>

<span class="cp">#define PSC_SCSI_ADDR	0x1000	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCSI_LEN	0x1004	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCSI_CMD	0x1008	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_ENETRD_ADDR 0x1020	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_ENETRD_LEN  0x1024	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_ENETRD_CMD  0x1028	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_ENETWR_ADDR 0x1040	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_ENETWR_LEN  0x1044	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_ENETWR_CMD  0x1048	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_FDC_ADDR	0x1060	</span><span class="cm">/* strongly suspected */</span><span class="cp"></span>
<span class="cp">#define PSC_FDC_LEN	0x1064	</span><span class="cm">/* strongly suspected */</span><span class="cp"></span>
<span class="cp">#define PSC_FDC_CMD	0x1068	</span><span class="cm">/* strongly suspected */</span><span class="cp"></span>
<span class="cp">#define PSC_SCCA_ADDR	0x1080	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCCA_LEN	0x1084	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCCA_CMD	0x1088	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCCB_ADDR	0x10A0	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCCB_LEN	0x10A4	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCCB_CMD	0x10A8	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCCATX_ADDR	0x10C0	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCCATX_LEN	0x10C4	</span><span class="cm">/* confirmed */</span><span class="cp"></span>
<span class="cp">#define PSC_SCCATX_CMD	0x10C8	</span><span class="cm">/* confirmed */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Free-running DMA registers. The only part known for sure are the bits in</span>
<span class="cm"> * the control register, the buffer addresses and the buffer length. Everything</span>
<span class="cm"> * else is anybody&#39;s guess.</span>
<span class="cm"> *</span>
<span class="cm"> * These registers seem to be mirrored every thirty-two bytes up until offset</span>
<span class="cm"> * 0x300. It&#39;s safe to assume then that a new set of registers starts there.</span>
<span class="cm"> */</span>

<span class="cp">#define PSC_SND_CTL	0x200	</span><span class="cm">/*</span>
<span class="cm">				 * [ 16-bit ]</span>
<span class="cm">				 * Sound (Singer?) control register.</span>
<span class="cm">				 *</span>
<span class="cm">				 * bit 0  : ????</span>
<span class="cm">				 * bit 1  : ????</span>
<span class="cm">				 * bit 2  : Set to one to enable sound</span>
<span class="cm">				 *          output. Possibly a mute flag.</span>
<span class="cm">				 * bit 3  : ????</span>
<span class="cm">				 * bit 4  : ????</span>
<span class="cm">				 * bit 5  : ????</span>
<span class="cm">				 * bit 6  : Set to one to enable pass-thru</span>
<span class="cm">				 *          audio. In this mode the audio data</span>
<span class="cm">				 *          seems to appear in both the input</span>
<span class="cm">				 *          buffer and the output buffer.</span>
<span class="cm">				 * bit 7  : Set to one to activate the</span>
<span class="cm">				 *          sound input DMA or zero to</span>
<span class="cm">				 *          disable it.</span>
<span class="cm">				 * bit 8  : Set to one to activate the</span>
<span class="cm">				 *          sound output DMA or zero to</span>
<span class="cm">				 *          disable it.</span>
<span class="cm">				 * bit 9  : \</span>
<span class="cm">				 * bit 11 :  |</span>
<span class="cm">				 *          These two bits control the sample</span>
<span class="cm">				 *          rate. Usually set to binary 10 and</span>
<span class="cm">				 *	    MacOS 8.0 says I&#39;m at 48 KHz. Using</span>
<span class="cm">				 *	    a binary value of 01 makes things</span>
<span class="cm">				 *	    sound about 1/2 speed (24 KHz?) and</span>
<span class="cm">				 *          binary 00 is slower still (22 KHz?)</span>
<span class="cm">				 *</span>
<span class="cm">				 * Setting this to 0x0000 is a good way to</span>
<span class="cm">				 * kill all DMA at boot time so that the</span>
<span class="cm">				 * PSC won&#39;t overwrite the kernel image</span>
<span class="cm">				 * with sound data.</span>
<span class="cm">				 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 0x0202 - 0x0203 is unused. Writing there</span>
<span class="cm"> * seems to clobber the control register.</span>
<span class="cm"> */</span>

<span class="cp">#define PSC_SND_SOURCE	0x204	</span><span class="cm">/*</span>
<span class="cm">				 * [ 32-bit ]</span>
<span class="cm">				 * Controls input source and volume:</span>
<span class="cm">				 *</span>
<span class="cm">				 * bits 12-15 : input source volume, 0 - F</span>
<span class="cm">				 * bits 16-19 : unknown, always 0x5</span>
<span class="cm">				 * bits 20-23 : input source selection:</span>
<span class="cm">				 *                  0x3 = CD Audio</span>
<span class="cm">				 *                  0x4 = External Audio</span>
<span class="cm">				 *</span>
<span class="cm">				 * The volume is definitely not the general</span>
<span class="cm">				 * output volume as it doesn&#39;t affect the</span>
<span class="cm">				 * alert sound volume.</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define PSC_SND_STATUS1	0x208	</span><span class="cm">/*</span>
<span class="cm">				 * [ 32-bit ]</span>
<span class="cm">				 * Appears to be a read-only status register.</span>
<span class="cm">				 * The usual value is 0x00400002.</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define PSC_SND_HUH3	0x20C	</span><span class="cm">/*</span>
<span class="cm">				 * [ 16-bit ]</span>
<span class="cm">				 * Unknown 16-bit value, always 0x0000.</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define PSC_SND_BITS2GO	0x20E	</span><span class="cm">/*</span>
<span class="cm">				 * [ 16-bit ]</span>
<span class="cm">				 * Counts down to zero from some constant</span>
<span class="cm">				 * value. The value appears to be the</span>
<span class="cm">				 * number of _bits_ remaining before the</span>
<span class="cm">				 * buffer is full, which would make sense</span>
<span class="cm">				 * since Apple&#39;s docs say the sound DMA</span>
<span class="cm">				 * channels are 1 bit wide.</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define PSC_SND_INADDR	0x210	</span><span class="cm">/*</span>
<span class="cm">				 * [ 32-bit ]</span>
<span class="cm">				 * Address of the sound input DMA buffer</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define PSC_SND_OUTADDR	0x214	</span><span class="cm">/*</span>
<span class="cm">				 * [ 32-bit ]</span>
<span class="cm">				 * Address of the sound output DMA buffer</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define PSC_SND_LEN	0x218	</span><span class="cm">/*</span>
<span class="cm">				 * [ 16-bit ]</span>
<span class="cm">				 * Length of both buffers in eight-byte units.</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define PSC_SND_HUH4	0x21A	</span><span class="cm">/*</span>
<span class="cm">				 * [ 16-bit ]</span>
<span class="cm">				 * Unknown, always 0x0000.</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define PSC_SND_STATUS2	0x21C	</span><span class="cm">/*</span>
<span class="cm">				 * [ 16-bit ]</span>
<span class="cm">				 * Appears to e a read-only status register.</span>
<span class="cm">				 * The usual value is 0x0200.</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define PSC_SND_HUH5	0x21E	</span><span class="cm">/*</span>
<span class="cm">				 * [ 16-bit ]</span>
<span class="cm">				 * Unknown, always 0x0000.</span>
<span class="cm">				 */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="k">extern</span> <span class="k">volatile</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">psc</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">psc_present</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">psc_register_interrupts</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">psc_irq_enable</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">psc_irq_disable</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Access functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">psc_write_byte</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">__u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">psc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">))</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">psc_write_word</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">__u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">psc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">))</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">psc_write_long</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">__u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">psc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">))</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">psc_read_byte</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">__u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">psc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">psc_read_word</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">__u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">psc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">psc_read_long</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">__u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">psc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
