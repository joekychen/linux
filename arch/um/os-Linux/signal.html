<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › um › os-Linux › signal.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>signal.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2004 PathScale, Inc</span>
<span class="cm"> * Copyright (C) 2004 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)</span>
<span class="cm"> * Licensed under the GPL</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>
<span class="cp">#include &lt;signal.h&gt;</span>
<span class="cp">#include &lt;strings.h&gt;</span>
<span class="cp">#include &quot;as-layout.h&quot;</span>
<span class="cp">#include &quot;kern_util.h&quot;</span>
<span class="cp">#include &quot;os.h&quot;</span>
<span class="cp">#include &quot;sysdep/mcontext.h&quot;</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sig_info</span><span class="p">[</span><span class="n">NSIG</span><span class="p">])(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uml_pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SIGTRAP</span><span class="p">]</span>	<span class="o">=</span> <span class="n">relay_signal</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGFPE</span><span class="p">]</span>	<span class="o">=</span> <span class="n">relay_signal</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGILL</span><span class="p">]</span>	<span class="o">=</span> <span class="n">relay_signal</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGWINCH</span><span class="p">]</span>	<span class="o">=</span> <span class="n">winch</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGBUS</span><span class="p">]</span>	<span class="o">=</span> <span class="n">bus_handler</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGSEGV</span><span class="p">]</span>	<span class="o">=</span> <span class="n">segv_handler</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGIO</span><span class="p">]</span>		<span class="o">=</span> <span class="n">sigio_handler</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGVTALRM</span><span class="p">]</span>	<span class="o">=</span> <span class="n">timer_handler</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_handler_common</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mcontext_t</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uml_pt_regs</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">save_errno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>

	<span class="n">r</span><span class="p">.</span><span class="n">is_user</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGSEGV</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For segfaults, we want the data from the sigcontext. */</span>
		<span class="n">get_regs_from_mc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">mc</span><span class="p">);</span>
		<span class="n">GET_FAULTINFO_FROM_MC</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">faultinfo</span><span class="p">,</span> <span class="n">mc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* enable signals if sig isn&#39;t IRQ signal */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sig</span> <span class="o">!=</span> <span class="n">SIGIO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sig</span> <span class="o">!=</span> <span class="n">SIGWINCH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sig</span> <span class="o">!=</span> <span class="n">SIGVTALRM</span><span class="p">))</span>
		<span class="n">unblock_signals</span><span class="p">();</span>

	<span class="p">(</span><span class="o">*</span><span class="n">sig_info</span><span class="p">[</span><span class="n">sig</span><span class="p">])(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>

	<span class="n">errno</span> <span class="o">=</span> <span class="n">save_errno</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These are the asynchronous signals.  SIGPROF is excluded because we want to</span>
<span class="cm"> * be able to profile all of UML, not just the non-critical sections.  If</span>
<span class="cm"> * profiling is not thread-safe, then that is not my problem.  We can disable</span>
<span class="cm"> * profiling when SMP is enabled in that case.</span>
<span class="cm"> */</span>
<span class="cp">#define SIGIO_BIT 0</span>
<span class="cp">#define SIGIO_MASK (1 &lt;&lt; SIGIO_BIT)</span>

<span class="cp">#define SIGVTALRM_BIT 1</span>
<span class="cp">#define SIGVTALRM_MASK (1 &lt;&lt; SIGVTALRM_BIT)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">signals_enabled</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">signals_pending</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">sig_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mcontext_t</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">enabled</span><span class="p">;</span>

	<span class="n">enabled</span> <span class="o">=</span> <span class="n">signals_enabled</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enabled</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGIO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">signals_pending</span> <span class="o">|=</span> <span class="n">SIGIO_MASK</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">block_signals</span><span class="p">();</span>

	<span class="n">sig_handler_common</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">mc</span><span class="p">);</span>

	<span class="n">set_signals</span><span class="p">(</span><span class="n">enabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">real_alarm_handler</span><span class="p">(</span><span class="n">mcontext_t</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uml_pt_regs</span> <span class="n">regs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">get_regs_from_mc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="n">mc</span><span class="p">);</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">is_user</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">unblock_signals</span><span class="p">();</span>
	<span class="n">timer_handler</span><span class="p">(</span><span class="n">SIGVTALRM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">alarm_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mcontext_t</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">enabled</span><span class="p">;</span>

	<span class="n">enabled</span> <span class="o">=</span> <span class="n">signals_enabled</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signals_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">signals_pending</span> <span class="o">|=</span> <span class="n">SIGVTALRM_MASK</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">block_signals</span><span class="p">();</span>

	<span class="n">real_alarm_handler</span><span class="p">(</span><span class="n">mc</span><span class="p">);</span>
	<span class="n">set_signals</span><span class="p">(</span><span class="n">enabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">timer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_handler</span><span class="p">(</span><span class="n">SIGVTALRM</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_sigstack</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">sig_stack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stack_t</span> <span class="n">stack</span> <span class="o">=</span> <span class="p">((</span><span class="n">stack_t</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="n">ss_flags</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="p">.</span><span class="n">ss_sp</span>	<span class="o">=</span> <span class="p">(</span><span class="n">__ptr_t</span><span class="p">)</span> <span class="n">sig_stack</span><span class="p">,</span>
				     <span class="p">.</span><span class="n">ss_size</span> 	<span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">});</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sigaltstack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;enabling signal stack failed, errno = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handlers</span><span class="p">[</span><span class="n">_NSIG</span><span class="p">])(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mcontext_t</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SIGSEGV</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGBUS</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGILL</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGFPE</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGTRAP</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">,</span>

	<span class="p">[</span><span class="n">SIGIO</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGWINCH</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">,</span>
	<span class="p">[</span><span class="n">SIGVTALRM</span><span class="p">]</span> <span class="o">=</span> <span class="n">alarm_handler</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">hard_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ucontext</span> <span class="o">*</span><span class="n">uc</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">mcontext_t</span> <span class="o">*</span><span class="n">mc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nested</span><span class="p">,</span> <span class="n">bail</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * pending comes back with one bit set for each</span>
<span class="cm">		 * interrupt that arrived while setting up the stack,</span>
<span class="cm">		 * plus a bit for this interrupt, plus the zero bit is</span>
<span class="cm">		 * set if this is a nested interrupt.</span>
<span class="cm">		 * If bail is true, then we interrupted another</span>
<span class="cm">		 * handler setting up the stack.  In this case, we</span>
<span class="cm">		 * have to return, and the upper handler will deal</span>
<span class="cm">		 * with this interrupt.</span>
<span class="cm">		 */</span>
		<span class="n">bail</span> <span class="o">=</span> <span class="n">to_irq_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bail</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">nested</span> <span class="o">=</span> <span class="n">pending</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pending</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">sig</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">pending</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
			<span class="n">sig</span><span class="o">--</span><span class="p">;</span>
			<span class="n">pending</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">handlers</span><span class="p">[</span><span class="n">sig</span><span class="p">])(</span><span class="n">sig</span><span class="p">,</span> <span class="n">mc</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Again, pending comes back with a mask of signals</span>
<span class="cm">		 * that arrived while tearing down the stack.  If this</span>
<span class="cm">		 * is non-zero, we just go back, set up the stack</span>
<span class="cm">		 * again, and handle the new interrupts.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested</span><span class="p">)</span>
			<span class="n">pending</span> <span class="o">=</span> <span class="n">from_irq_stack</span><span class="p">(</span><span class="n">nested</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pending</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigaction</span> <span class="n">action</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">SA_SIGINFO</span> <span class="o">|</span> <span class="n">SA_ONSTACK</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">sig_mask</span><span class="p">;</span>

	<span class="n">action</span><span class="p">.</span><span class="n">sa_sigaction</span> <span class="o">=</span> <span class="n">hard_handler</span><span class="p">;</span>

	<span class="cm">/* block irq ones */</span>
	<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
	<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGVTALRM</span><span class="p">);</span>
	<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">);</span>
	<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGWINCH</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGSEGV</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">SA_NODEFER</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">SA_RESTART</span><span class="p">;</span> <span class="cm">/* if it&#39;s an irq signal */</span>

	<span class="n">action</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">action</span><span class="p">.</span><span class="n">sa_restorer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;sigaction failed - errno = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>

	<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig_mask</span><span class="p">);</span>
	<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig_mask</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig_mask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;sigprocmask failed - errno = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">change_sig</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">sigset</span><span class="p">;</span>

	<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">);</span>
	<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span> <span class="n">signal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">on</span> <span class="o">?</span> <span class="n">SIG_UNBLOCK</span> <span class="o">:</span> <span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">block_signals</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">signals_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This must return with signals disabled, so this barrier</span>
<span class="cm">	 * ensures that writes are flushed out before the return.</span>
<span class="cm">	 * This might matter if gcc figures out how to inline this and</span>
<span class="cm">	 * decides to shuffle this code into the caller.</span>
<span class="cm">	 */</span>
	<span class="n">barrier</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unblock_signals</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">save_pending</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">signals_enabled</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We loop because the IRQ handler returns with interrupts off.  So,</span>
<span class="cm">	 * interrupts may have arrived and we need to re-enable them and</span>
<span class="cm">	 * recheck signals_pending.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Save and reset save_pending after enabling signals.  This</span>
<span class="cm">		 * way, signals_pending won&#39;t be changed while we&#39;re reading it.</span>
<span class="cm">		 */</span>
		<span class="n">signals_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Setting signals_enabled and reading signals_pending must</span>
<span class="cm">		 * happen in this order.</span>
<span class="cm">		 */</span>
		<span class="n">barrier</span><span class="p">();</span>

		<span class="n">save_pending</span> <span class="o">=</span> <span class="n">signals_pending</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">save_pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">signals_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We have pending interrupts, so disable signals, as the</span>
<span class="cm">		 * handlers expect them off when they are called.  They will</span>
<span class="cm">		 * be enabled again above.</span>
<span class="cm">		 */</span>

		<span class="n">signals_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Deal with SIGIO first because the alarm handler might</span>
<span class="cm">		 * schedule, leaving the pending SIGIO stranded until we come</span>
<span class="cm">		 * back here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">save_pending</span> <span class="o">&amp;</span> <span class="n">SIGIO_MASK</span><span class="p">)</span>
			<span class="n">sig_handler_common</span><span class="p">(</span><span class="n">SIGIO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">save_pending</span> <span class="o">&amp;</span> <span class="n">SIGVTALRM_MASK</span><span class="p">)</span>
			<span class="n">real_alarm_handler</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_signals</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">signals_enabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_signals</span><span class="p">(</span><span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signals_enabled</span> <span class="o">==</span> <span class="n">enable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">enable</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">signals_enabled</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">unblock_signals</span><span class="p">();</span>
	<span class="k">else</span> <span class="n">block_signals</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
