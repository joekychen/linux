<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › um › include › shared › init.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>init.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_UML_INIT_H</span>
<span class="cp">#define _LINUX_UML_INIT_H</span>

<span class="cm">/* These macros are used to mark some functions or</span>
<span class="cm"> * initialized data (doesn&#39;t apply to uninitialized data)</span>
<span class="cm"> * as `initialization&#39; functions. The kernel can take this</span>
<span class="cm"> * as hint that the function is used only during the initialization</span>
<span class="cm"> * phase and free up used memory resources after</span>
<span class="cm"> *</span>
<span class="cm"> * Usage:</span>
<span class="cm"> * For functions:</span>
<span class="cm"> *</span>
<span class="cm"> * You should add __init immediately before the function name, like:</span>
<span class="cm"> *</span>
<span class="cm"> * static void __init initme(int x, int y)</span>
<span class="cm"> * {</span>
<span class="cm"> *    extern int z; z = x * y;</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * If the function has a prototype somewhere, you can also add</span>
<span class="cm"> * __init between closing brace of the prototype and semicolon:</span>
<span class="cm"> *</span>
<span class="cm"> * extern int initialize_foobar_device(int, int, int) __init;</span>
<span class="cm"> *</span>
<span class="cm"> * For initialized data:</span>
<span class="cm"> * You should insert __initdata between the variable name and equal</span>
<span class="cm"> * sign followed by value, e.g.:</span>
<span class="cm"> *</span>
<span class="cm"> * static int init_variable __initdata = 0;</span>
<span class="cm"> * static const char linux_logo[] __initconst = { 0x32, 0x36, ... };</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t forget to initialize data not at file scope, i.e. within a function,</span>
<span class="cm"> * as gcc otherwise puts the data into the bss section and not into the init</span>
<span class="cm"> * section.</span>
<span class="cm"> *</span>
<span class="cm"> * Also note, that this data cannot be &quot;const&quot;.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_INIT_H</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">initcall_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exitcall_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifndef __KERNEL__</span>
<span class="cp">#ifndef __section</span>
<span class="cp"># define __section(S) __attribute__ ((__section__(#S)))</span>
<span class="cp">#endif</span>

<span class="cp">#if __GNUC__ == 3</span>

<span class="cp">#if __GNUC_MINOR__ &gt;= 3</span>
<span class="cp"># define __used			__attribute__((__used__))</span>
<span class="cp">#else</span>
<span class="cp"># define __used			__attribute__((__unused__))</span>
<span class="cp">#endif</span>

<span class="cp">#else</span>
<span class="cp">#if __GNUC__ == 4</span>
<span class="cp"># define __used			__attribute__((__used__))</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#else</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#endif</span>
<span class="cm">/* These are for everybody (although not all archs will actually</span>
<span class="cm">   discard it in modules) */</span>
<span class="cp">#define __init		__section(.init.text)</span>
<span class="cp">#define __initdata	__section(.init.data)</span>
<span class="cp">#define __exitdata	__section(.exit.data)</span>
<span class="cp">#define __exit_call	__used __section(.exitcall.exit)</span>

<span class="cp">#ifdef MODULE</span>
<span class="cp">#define __exit		__section(.exit.text)</span>
<span class="cp">#else</span>
<span class="cp">#define __exit		__used __section(.exit.text)</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

<span class="cp">#ifndef MODULE</span>
<span class="k">struct</span> <span class="n">uml_param</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_func</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__uml_initcall_start</span><span class="p">,</span> <span class="n">__uml_initcall_end</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__uml_postsetup_start</span><span class="p">,</span> <span class="n">__uml_postsetup_end</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__uml_help_start</span><span class="p">,</span> <span class="o">*</span><span class="n">__uml_help_end</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#define __uml_initcall(fn)					  	\</span>
<span class="cp">	static initcall_t __uml_initcall_##fn __uml_init_call = fn</span>

<span class="cp">#define __uml_exitcall(fn)						\</span>
<span class="cp">	static exitcall_t __uml_exitcall_##fn __uml_exit_call = fn</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">uml_param</span> <span class="n">__uml_setup_start</span><span class="p">,</span> <span class="n">__uml_setup_end</span><span class="p">;</span>

<span class="cp">#define __uml_postsetup(fn)						\</span>
<span class="cp">	static initcall_t __uml_postsetup_##fn __uml_postsetup_call = fn</span>

<span class="cp">#define __non_empty_string(dummyname,string)				\</span>
<span class="cp">	struct __uml_non_empty_string_struct_##dummyname		\</span>
<span class="cp">	{								\</span>
<span class="cp">		char _string[sizeof(string)-2];				\</span>
<span class="cp">	}</span>

<span class="cp">#ifndef MODULE</span>
<span class="cp">#define __uml_setup(str, fn, help...)					\</span>
<span class="cp">	__non_empty_string(fn ##_setup, str);				\</span>
<span class="cp">	__uml_help(fn, help);						\</span>
<span class="cp">	static char __uml_setup_str_##fn[] __initdata = str;		\</span>
<span class="cp">	static struct uml_param __uml_setup_##fn __uml_init_setup = { __uml_setup_str_##fn, fn }</span>
<span class="cp">#else</span>
<span class="cp">#define __uml_setup(str, fn, help...)					\</span>

<span class="cp">#endif</span>

<span class="cp">#define __uml_help(fn, help...)						\</span>
<span class="cp">	__non_empty_string(fn ##__help, help);				\</span>
<span class="cp">	static char __uml_help_str_##fn[] __initdata = help;		\</span>
<span class="cp">	static const char *__uml_help_##fn __uml_setup_help = __uml_help_str_##fn</span>

<span class="cm">/*</span>
<span class="cm"> * Mark functions and data as being only used at initialization</span>
<span class="cm"> * or exit time.</span>
<span class="cm"> */</span>
<span class="cp">#define __uml_init_setup	__used __section(.uml.setup.init)</span>
<span class="cp">#define __uml_setup_help	__used __section(.uml.help.init)</span>
<span class="cp">#define __uml_init_call		__used __section(.uml.initcall.init)</span>
<span class="cp">#define __uml_postsetup_call	__used __section(.uml.postsetup.init)</span>
<span class="cp">#define __uml_exit_call		__used __section(.uml.exitcall.exit)</span>

<span class="cp">#ifndef __KERNEL__</span>

<span class="cp">#define __define_initcall(level,fn) \</span>
<span class="cp">	static initcall_t __initcall_##fn __used \</span>
<span class="cp">	__attribute__((__section__(&quot;.initcall&quot; level &quot;.init&quot;))) = fn</span>

<span class="cm">/* Userspace initcalls shouldn&#39;t depend on anything in the kernel, so we&#39;ll</span>
<span class="cm"> * make them run first.</span>
<span class="cm"> */</span>
<span class="cp">#define __initcall(fn) __define_initcall(&quot;1&quot;, fn)</span>

<span class="cp">#define __exitcall(fn) static exitcall_t __exitcall_##fn __exit_call = fn</span>

<span class="cp">#define __init_call	__used __section(.initcall.init)</span>

<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_UML_INIT_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
