<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › m32r › kernel › smpboot.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smpboot.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/m32r/kernel/smpboot.c</span>
<span class="cm"> *    orig : i386 2.4.10</span>
<span class="cm"> *</span>
<span class="cm"> *  M32R SMP booting functions</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2001, 2002, 2003  Hitoshi Yamamoto</span>
<span class="cm"> *</span>
<span class="cm"> *  Taken from i386 version.</span>
<span class="cm"> *	  (c) 1995 Alan Cox, Building #3 &lt;alan@redhat.com&gt;</span>
<span class="cm"> *	  (c) 1998, 1999, 2000 Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Much of the core SMP work is based on previous work by Thomas Radke, to</span>
<span class="cm"> *	whom a great many thanks are extended.</span>
<span class="cm"> *</span>
<span class="cm"> *	Thanks to Intel for making available several different Pentium,</span>
<span class="cm"> *	Pentium Pro and Pentium-II/Xeon MP machines.</span>
<span class="cm"> *	Original development of Linux SMP code supported by Caldera.</span>
<span class="cm"> *</span>
<span class="cm"> *	This code is released under the GNU General Public License version 2 or</span>
<span class="cm"> *	later.</span>
<span class="cm"> *</span>
<span class="cm"> *	Fixes</span>
<span class="cm"> *		Felix Koop	:	NR_CPUS used properly</span>
<span class="cm"> *		Jose Renau	:	Handle single CPU case.</span>
<span class="cm"> *		Alan Cox	:	By repeated request</span>
<span class="cm"> *					8) - Total BogoMIP report.</span>
<span class="cm"> *		Greg Wright	:	Fix for kernel stacks panic.</span>
<span class="cm"> *		Erich Boleyn	:	MP v1.4 and additional changes.</span>
<span class="cm"> *	Matthias Sattler	:	Changes for 2.1 kernel map.</span>
<span class="cm"> *	Michel Lespinasse	:	Changes for 2.1 kernel map.</span>
<span class="cm"> *	Michael Chastain	:	Change trampoline.S to gnu as.</span>
<span class="cm"> *		Alan Cox	:	Dumb bug: &#39;B&#39; step PPro&#39;s are fine</span>
<span class="cm"> *		Ingo Molnar	:	Added APIC timers, based on code</span>
<span class="cm"> *					from Jose Renau</span>
<span class="cm"> *		Ingo Molnar	:	various cleanups and rewrites</span>
<span class="cm"> *		Tigran Aivazian	:	fixed &quot;0.00 in /proc/uptime on SMP&quot; bug.</span>
<span class="cm"> *	Maciej W. Rozycki	:	Bits for genuine 82489DX APICs</span>
<span class="cm"> *		Martin J. Bligh	: 	Added support for multi-quad systems</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>

<span class="cp">#define DEBUG_SMP</span>
<span class="cp">#ifdef DEBUG_SMP</span>
<span class="cp">#define Dprintk(x...) printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define Dprintk(x...)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="n">cpumask_t</span> <span class="n">cpu_initialized</span><span class="p">;</span>

<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>
<span class="cm">/* Data structures and variables                                             */</span>
<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>

<span class="cm">/* Processor that is doing the boot up */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bsp_phys_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="cm">/* Bitmask of physically existing CPUs */</span>
<span class="n">physid_mask_t</span> <span class="n">phys_cpu_present_map</span><span class="p">;</span>

<span class="n">cpumask_t</span> <span class="n">cpu_bootout_map</span><span class="p">;</span>
<span class="n">cpumask_t</span> <span class="n">cpu_bootin_map</span><span class="p">;</span>
<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">cpu_callin_map</span><span class="p">;</span>
<span class="n">cpumask_t</span> <span class="n">cpu_callout_map</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_callout_map</span><span class="p">);</span>

<span class="cm">/* Per CPU bogomips and other parameters */</span>
<span class="k">struct</span> <span class="n">cpuinfo_m32r</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__cacheline_aligned</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cpucount</span><span class="p">;</span>
<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">smp_commenced_mask</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span> <span class="n">spi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ss</span><span class="p">;</span>
<span class="p">}</span> <span class="n">stack_start</span><span class="p">;</span>

<span class="cm">/* which physical physical ID maps to which logical CPU number */</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">physid_2_cpu</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="cp">#define physid_to_cpu(physid)	physid_2_cpu[physid]</span>

<span class="cm">/* which logical CPU number maps to which physical ID */</span>
<span class="k">volatile</span> <span class="kt">int</span> <span class="n">cpu_2_physid</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">prof_multiplier</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">prof_old_multiplier</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">prof_counter</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">spinlock_t</span> <span class="n">ipi_lock</span><span class="p">[</span><span class="n">NR_IPIS</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">calibration_result</span><span class="p">;</span>

<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>
<span class="cm">/* Function Prototypes                                                       */</span>
<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">init_ipi_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_boot_cpu</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">start_secondary</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_callin</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_online</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">show_mp_info</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">show_cpu_info</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">setup_profiling_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">init_cpu_to_physid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">map_cpu_to_physid</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">unmap_cpu_to_physid</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>
<span class="cm">/* Boot up APs Routines : BSP                                                */</span>
<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>
<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">smp_prepare_boot_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bsp_phys_id</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>
	<span class="n">physid_set</span><span class="p">(</span><span class="n">bsp_phys_id</span><span class="p">,</span> <span class="n">phys_cpu_present_map</span><span class="p">);</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>	<span class="cm">/* BSP&#39;s cpu_id == 0 */</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callout_map</span><span class="p">);</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the logical to physical CPU number mapping</span>
<span class="cm">	 */</span>
	<span class="n">init_cpu_to_physid</span><span class="p">();</span>
	<span class="n">map_cpu_to_physid</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bsp_phys_id</span><span class="p">);</span>
	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================================*</span>
<span class="cm"> * Name:         smp_prepare_cpus (old smp_boot_cpus)</span>
<span class="cm"> *</span>
<span class="cm"> * Description:  This routine boot up APs.</span>
<span class="cm"> *</span>
<span class="cm"> * Born on Date: 2002.02.05</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:    NONE</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:      void (cannot fail)</span>
<span class="cm"> *</span>
<span class="cm"> * Modification log:</span>
<span class="cm"> * Date       Who Description</span>
<span class="cm"> * ---------- --- --------------------------------------------------------</span>
<span class="cm"> * 2003-06-24 hy  modify for linux-2.5.69</span>
<span class="cm"> *</span>
<span class="cm"> *==========================================================================*/</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_prepare_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">phys_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_cpu</span><span class="p">;</span>

	<span class="n">nr_cpu</span> <span class="o">=</span> <span class="n">inl</span><span class="p">(</span><span class="n">M32R_FPGA_NUM_OF_CPUS_PORTL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_cpu</span> <span class="o">&gt;</span> <span class="n">NR_CPUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NUM_OF_CPUS reg. value [%ld] &gt; NR_CPU [%d]&quot;</span><span class="p">,</span>
			<span class="n">nr_cpu</span><span class="p">,</span> <span class="n">NR_CPUS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">smp_done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">phys_id</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">phys_id</span> <span class="o">&lt;</span> <span class="n">nr_cpu</span> <span class="p">;</span> <span class="n">phys_id</span><span class="o">++</span><span class="p">)</span>
		<span class="n">physid_set</span><span class="p">(</span><span class="n">phys_id</span><span class="p">,</span> <span class="n">phys_cpu_present_map</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_HOTPLUG_CPU</span>
	<span class="n">init_cpu_present</span><span class="p">(</span><span class="n">cpu_possible_mask</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">show_mp_info</span><span class="p">(</span><span class="n">nr_cpu</span><span class="p">);</span>

	<span class="n">init_ipi_lock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup boot CPU information</span>
<span class="cm">	 */</span>
	<span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* Final full version of the data */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If SMP should be disabled, then really disable it!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_cpus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMP mode deactivated by commandline.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">smp_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now scan the CPU present map and fire up the other CPUs.</span>
<span class="cm">	 */</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;CPU present map : %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">physids_coerce</span><span class="p">(</span><span class="n">phys_cpu_present_map</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">phys_id</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">phys_id</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span> <span class="p">;</span> <span class="n">phys_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t even attempt to start the boot CPU!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phys_id</span> <span class="o">==</span> <span class="n">bsp_phys_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">physid_isset</span><span class="p">(</span><span class="n">phys_id</span><span class="p">,</span> <span class="n">phys_cpu_present_map</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">max_cpus</span> <span class="o">&lt;=</span> <span class="n">cpucount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">do_boot_cpu</span><span class="p">(</span><span class="n">phys_id</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure we unmap all failed CPUs</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">physid_to_cpu</span><span class="p">(</span><span class="n">phys_id</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">physid_clear</span><span class="p">(</span><span class="n">phys_id</span><span class="p">,</span> <span class="n">phys_cpu_present_map</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;phys CPU#%d not responding - &quot;</span> \
				<span class="s">&quot;cannot use it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phys_id</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">smp_done:</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Boot done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * init_ipi_lock : Initialize IPI locks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_ipi_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ipi</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ipi</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">ipi</span> <span class="o">&lt;</span> <span class="n">NR_IPIS</span> <span class="p">;</span> <span class="n">ipi</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipi_lock</span><span class="p">[</span><span class="n">ipi</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*==========================================================================*</span>
<span class="cm"> * Name:         do_boot_cpu</span>
<span class="cm"> *</span>
<span class="cm"> * Description:  This routine boot up one AP.</span>
<span class="cm"> *</span>
<span class="cm"> * Born on Date: 2002.02.05</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:    phys_id - Target CPU physical ID</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:      void (cannot fail)</span>
<span class="cm"> *</span>
<span class="cm"> * Modification log:</span>
<span class="cm"> * Date       Who Description</span>
<span class="cm"> * ---------- --- --------------------------------------------------------</span>
<span class="cm"> * 2003-06-24 hy  modify for linux-2.5.69</span>
<span class="cm"> *</span>
<span class="cm"> *==========================================================================*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_boot_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">phys_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">send_status</span><span class="p">,</span> <span class="n">boot_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">;</span>

	<span class="n">cpu_id</span> <span class="o">=</span> <span class="o">++</span><span class="n">cpucount</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t use kernel_thread since we must avoid to</span>
<span class="cm">	 * reschedule the child.</span>
<span class="cm">	 */</span>
	<span class="n">idle</span> <span class="o">=</span> <span class="n">fork_idle</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">idle</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;failed fork for CPU#%d.&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">idle</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start_secondary</span><span class="p">;</span>

	<span class="n">map_cpu_to_physid</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="n">phys_id</span><span class="p">);</span>

	<span class="cm">/* So we see what&#39;s up   */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Booting processor %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phys_id</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
	<span class="n">stack_start</span><span class="p">.</span><span class="n">spi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">idle</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">task_thread_info</span><span class="p">(</span><span class="n">idle</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send Startup IPI</span>
<span class="cm">	 *   1.IPI received by CPU#(phys_id).</span>
<span class="cm">	 *   2.CPU#(phys_id) enter startup_AP (arch/m32r/kernel/head.S)</span>
<span class="cm">	 *   3.CPU#(phys_id) enter start_secondary()</span>
<span class="cm">	 */</span>
	<span class="n">send_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">boot_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">phys_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_bootout_map</span><span class="p">);</span>

	<span class="cm">/* Send Startup IPI */</span>
	<span class="n">send_IPI_mask_phys</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">phys_id</span><span class="p">),</span> <span class="n">CPU_BOOT_IPI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Waiting for send to finish...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait 100[ms] */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="n">send_status</span> <span class="o">=</span> <span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">phys_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_bootin_map</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">send_status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">timeout</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">));</span>

	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;After Startup.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">send_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * allow APs to start initializing.</span>
<span class="cm">		 */</span>
		<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Before Callout %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callout_map</span><span class="p">);</span>
		<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;After Callout %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait 5s total for a response</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">timeout</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* It has booted */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* number CPUs logically, starting from 1 (BSP is 0) */</span>
			<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;OK.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">boot_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Not responding.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IPI never delivered???</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">send_status</span> <span class="o">||</span> <span class="n">boot_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unmap_cpu_to_physid</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="n">phys_id</span><span class="p">);</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callout_map</span><span class="p">);</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">);</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_initialized</span><span class="p">);</span>
		<span class="n">cpucount</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">__cpu_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tidle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_commenced_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait 5s total for a response</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">timeout</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_cpus_done</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu_id</span><span class="p">,</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bogosum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">timeout</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cpu_id</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">cpu_id</span> <span class="o">&lt;</span> <span class="n">num_online_cpus</span><span class="p">()</span> <span class="p">;</span> <span class="n">cpu_id</span><span class="o">++</span><span class="p">)</span>
		<span class="n">show_cpu_info</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow the user to impress friends.</span>
<span class="cm">	 */</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Before bogomips.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpucount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span><span class="n">cpu_online_mask</span><span class="p">)</span>
			<span class="n">bogosum</span> <span class="o">+=</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu_id</span><span class="p">].</span><span class="n">loops_per_jiffy</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Total of %d processors activated &quot;</span> \
			<span class="s">&quot;(%lu.%02lu BogoMIPS).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpucount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">bogosum</span> <span class="o">/</span> <span class="p">(</span><span class="mi">500000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">),</span>
			<span class="p">(</span><span class="n">bogosum</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">))</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
		<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Before bogocount - setting activated=1.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>
<span class="cm">/* Activate a secondary processor Routines                                   */</span>
<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>

<span class="cm">/*==========================================================================*</span>
<span class="cm"> * Name:         start_secondary</span>
<span class="cm"> *</span>
<span class="cm"> * Description:  This routine activate a secondary processor.</span>
<span class="cm"> *</span>
<span class="cm"> * Born on Date: 2002.02.05</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:    *unused - currently unused.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:      void (cannot fail)</span>
<span class="cm"> *</span>
<span class="cm"> * Modification log:</span>
<span class="cm"> * Date       Who Description</span>
<span class="cm"> * ---------- --- --------------------------------------------------------</span>
<span class="cm"> * 2003-06-24 hy  modify for linux-2.5.69</span>
<span class="cm"> *</span>
<span class="cm"> *==========================================================================*/</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">start_secondary</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_init</span><span class="p">();</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">smp_callin</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">smp_commenced_mask</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="n">smp_online</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * low-memory mappings have been cleared, flush them from</span>
<span class="cm">	 * the local TLBs too.</span>
<span class="cm">	 */</span>
	<span class="n">local_flush_tlb_all</span><span class="p">();</span>

	<span class="n">cpu_idle</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*==========================================================================*</span>
<span class="cm"> * Name:         smp_callin</span>
<span class="cm"> *</span>
<span class="cm"> * Description:  This routine activate a secondary processor.</span>
<span class="cm"> *</span>
<span class="cm"> * Born on Date: 2002.02.05</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:    NONE</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:      void (cannot fail)</span>
<span class="cm"> *</span>
<span class="cm"> * Modification log:</span>
<span class="cm"> * Date       Who Description</span>
<span class="cm"> * ---------- --- --------------------------------------------------------</span>
<span class="cm"> * 2003-06-24 hy  modify for linux-2.5.69</span>
<span class="cm"> *</span>
<span class="cm"> *==========================================================================*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_callin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">phys_id</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">cpu_id</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;huh, phys CPU#%d, CPU#%d already present??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phys_id</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;CPU#%d (phys ID: %d) waiting for CALLOUT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">,</span> <span class="n">phys_id</span><span class="p">);</span>

	<span class="cm">/* Waiting 2s total for startup (udelay is not yet working) */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Has the boot CPU finished it&#39;s STARTUP sequence ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callout_map</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BUG: CPU#%d started up but did not get a callout!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cpu_id</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Allow the master to continue. */</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_online</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu_id</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">notify_cpu_starting</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="cm">/* Get our bogomips. */</span>
	<span class="n">calibrate_delay</span><span class="p">();</span>

	<span class="cm">/* Save our processor parameters */</span>
 	<span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>
<span class="cm">/* Boot up CPUs common Routines                                              */</span>
<span class="cm">/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">show_mp_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">cpu_model0</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span> <span class="n">cpu_model1</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span> <span class="n">cpu_ver</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">cpu_model0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">M32R_FPGA_CPU_NAME_ADDR</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">cpu_model1</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">M32R_FPGA_MODEL_ID_ADDR</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">cpu_ver</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">M32R_FPGA_VERSION_ADDR</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">cpu_model0</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">15</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_model0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpu_model0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpu_model1</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">15</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_model1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpu_model1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpu_ver</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">7</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_ver</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpu_ver</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;M32R-mp information</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  On-chip CPUs : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_cpu</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  CPU model : %s/%s(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_model0</span><span class="p">,</span>
		<span class="n">cpu_model1</span><span class="p">,</span> <span class="n">cpu_ver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The bootstrap kernel entry code has set these up. Save them for</span>
<span class="cm"> * a given CPU</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_store_cpu_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuinfo_m32r</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">cpu_data</span> <span class="o">+</span> <span class="n">cpu_id</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">boot_cpu_data</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">loops_per_jiffy</span> <span class="o">=</span> <span class="n">loops_per_jiffy</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">show_cpu_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuinfo_m32r</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu_id</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU#%d : &quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

<span class="cp">#define PRINT_CLOCK(name, value) \</span>
<span class="cp">	printk(name &quot; clock %d.%02dMHz&quot;, \</span>
<span class="cp">		((value) / 1000000), ((value) % 1000000) / 10000)</span>

	<span class="n">PRINT_CLOCK</span><span class="p">(</span><span class="s">&quot;CPU&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">cpu_clock</span><span class="p">);</span>
	<span class="n">PRINT_CLOCK</span><span class="p">(</span><span class="s">&quot;, Bus&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">bus_clock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, loops_per_jiffy[%ld]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">loops_per_jiffy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * the frequency of the profiling timer can be changed</span>
<span class="cm"> * by writing a multiplier value into /proc/profile.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">setup_profiling_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">multiplier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity check. [at least 500 APIC cycles should be</span>
<span class="cm">	 * between APIC interrupts as a rule of thumb, to avoid</span>
<span class="cm">	 * irqs flooding us]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="o">!</span><span class="n">multiplier</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">calibration_result</span> <span class="o">/</span> <span class="n">multiplier</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the new multiplier for each CPU. CPUs don&#39;t start using the</span>
<span class="cm">	 * new values until the next timer interrupt in which they do process</span>
<span class="cm">	 * accounting. At that time they also adjust their APIC timers</span>
<span class="cm">	 * accordingly.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">prof_multiplier</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">multiplier</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize all maps between cpu number and apicids */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_cpu_to_physid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>  <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_2_physid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">physid_2_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set up a mapping between cpu and apicid. Uses logical apicids for multiquad,</span>
<span class="cm"> * else physical apic ids</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">map_cpu_to_physid</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phys_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">physid_2_cpu</span><span class="p">[</span><span class="n">phys_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_id</span><span class="p">;</span>
	<span class="n">cpu_2_physid</span><span class="p">[</span><span class="n">cpu_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">phys_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * undo a mapping between cpu and apicid. Uses logical apicids for multiquad,</span>
<span class="cm"> * else physical apic ids</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">unmap_cpu_to_physid</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phys_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">physid_2_cpu</span><span class="p">[</span><span class="n">phys_id</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">cpu_2_physid</span><span class="p">[</span><span class="n">cpu_id</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
