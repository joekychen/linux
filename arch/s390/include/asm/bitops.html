<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › s390 › include › asm › bitops.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>bitops.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _S390_BITOPS_H</span>
<span class="cp">#define _S390_BITOPS_H</span>

<span class="cm">/*</span>
<span class="cm"> *  include/asm-s390/bitops.h</span>
<span class="cm"> *</span>
<span class="cm"> *  S390 version</span>
<span class="cm"> *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation</span>
<span class="cm"> *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> *  Derived from &quot;include/asm-i386/bitops.h&quot;</span>
<span class="cm"> *    Copyright (C) 1992, Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_BITOPS_H</span>
<span class="cp">#error only &lt;linux/bitops.h&gt; can be included directly</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * 32 bit bitops format:</span>
<span class="cm"> * bit 0 is the LSB of *addr; bit 31 is the MSB of *addr;</span>
<span class="cm"> * bit 32 is the LSB of *(addr+4). That combined with the</span>
<span class="cm"> * big endian byte order on S390 give the following bit</span>
<span class="cm"> * order in memory:</span>
<span class="cm"> *    1f 1e 1d 1c 1b 1a 19 18 17 16 15 14 13 12 11 10 \</span>
<span class="cm"> *    0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00</span>
<span class="cm"> * after that follows the next long with bit numbers</span>
<span class="cm"> *    3f 3e 3d 3c 3b 3a 39 38 37 36 35 34 33 32 31 30</span>
<span class="cm"> *    2f 2e 2d 2c 2b 2a 29 28 27 26 25 24 23 22 21 20</span>
<span class="cm"> * The reason for this bit ordering is the fact that</span>
<span class="cm"> * in the architecture independent code bits operations</span>
<span class="cm"> * of the form &quot;flags |= (1 &lt;&lt; bitnr)&quot; are used INTERMIXED</span>
<span class="cm"> * with operation of the form &quot;set_bit(bitnr, flags)&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * 64 bit bitops format:</span>
<span class="cm"> * bit 0 is the LSB of *addr; bit 63 is the MSB of *addr;</span>
<span class="cm"> * bit 64 is the LSB of *(addr+8). That combined with the</span>
<span class="cm"> * big endian byte order on S390 give the following bit</span>
<span class="cm"> * order in memory:</span>
<span class="cm"> *    3f 3e 3d 3c 3b 3a 39 38 37 36 35 34 33 32 31 30</span>
<span class="cm"> *    2f 2e 2d 2c 2b 2a 29 28 27 26 25 24 23 22 21 20</span>
<span class="cm"> *    1f 1e 1d 1c 1b 1a 19 18 17 16 15 14 13 12 11 10</span>
<span class="cm"> *    0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00</span>
<span class="cm"> * after that follows the next long with bit numbers</span>
<span class="cm"> *    7f 7e 7d 7c 7b 7a 79 78 77 76 75 74 73 72 71 70</span>
<span class="cm"> *    6f 6e 6d 6c 6b 6a 69 68 67 66 65 64 63 62 61 60</span>
<span class="cm"> *    5f 5e 5d 5c 5b 5a 59 58 57 56 55 54 53 52 51 50</span>
<span class="cm"> *    4f 4e 4d 4c 4b 4a 49 48 47 46 45 44 43 42 41 40</span>
<span class="cm"> * The reason for this bit ordering is the fact that</span>
<span class="cm"> * in the architecture independent code bits operations</span>
<span class="cm"> * of the form &quot;flags |= (1 &lt;&lt; bitnr)&quot; are used INTERMIXED</span>
<span class="cm"> * with operation of the form &quot;set_bit(bitnr, flags)&quot;.</span>
<span class="cm"> */</span>

<span class="cm">/* bitmap tables from arch/s390/kernel/bitmap.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">_oi_bitmap</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">_ni_bitmap</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">_zb_findmap</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">_sb_findmap</span><span class="p">[];</span>

<span class="cp">#ifndef CONFIG_64BIT</span>

<span class="cp">#define __BITOPS_ALIGN		3</span>
<span class="cp">#define __BITOPS_WORDSIZE	32</span>
<span class="cp">#define __BITOPS_OR		&quot;or&quot;</span>
<span class="cp">#define __BITOPS_AND		&quot;nr&quot;</span>
<span class="cp">#define __BITOPS_XOR		&quot;xr&quot;</span>

<span class="cp">#define __BITOPS_LOOP(__old, __new, __addr, __val, __op_string)	\</span>
<span class="cp">	asm volatile(						\</span>
<span class="cp">		&quot;	l	%0,%2\n&quot;			\</span>
<span class="cp">		&quot;0:	lr	%1,%0\n&quot;			\</span>
<span class="cp">		__op_string &quot;	%1,%3\n&quot;			\</span>
<span class="cp">		&quot;	cs	%0,%1,%2\n&quot;			\</span>
<span class="cp">		&quot;	jl	0b&quot;				\</span>
<span class="cp">		: &quot;=&amp;d&quot; (__old), &quot;=&amp;d&quot; (__new),			\</span>
<span class="cp">		  &quot;=Q&quot; (*(unsigned long *) __addr)		\</span>
<span class="cp">		: &quot;d&quot; (__val), &quot;Q&quot; (*(unsigned long *) __addr)	\</span>
<span class="cp">		: &quot;cc&quot;);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cp">#define __BITOPS_ALIGN		7</span>
<span class="cp">#define __BITOPS_WORDSIZE	64</span>
<span class="cp">#define __BITOPS_OR		&quot;ogr&quot;</span>
<span class="cp">#define __BITOPS_AND		&quot;ngr&quot;</span>
<span class="cp">#define __BITOPS_XOR		&quot;xgr&quot;</span>

<span class="cp">#define __BITOPS_LOOP(__old, __new, __addr, __val, __op_string)	\</span>
<span class="cp">	asm volatile(						\</span>
<span class="cp">		&quot;	lg	%0,%2\n&quot;			\</span>
<span class="cp">		&quot;0:	lgr	%1,%0\n&quot;			\</span>
<span class="cp">		__op_string &quot;	%1,%3\n&quot;			\</span>
<span class="cp">		&quot;	csg	%0,%1,%2\n&quot;			\</span>
<span class="cp">		&quot;	jl	0b&quot;				\</span>
<span class="cp">		: &quot;=&amp;d&quot; (__old), &quot;=&amp;d&quot; (__new),			\</span>
<span class="cp">		  &quot;=Q&quot; (*(unsigned long *) __addr)		\</span>
<span class="cp">		: &quot;d&quot; (__val), &quot;Q&quot; (*(unsigned long *) __addr)	\</span>
<span class="cp">		: &quot;cc&quot;);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cp">#define __BITOPS_WORDS(bits) (((bits)+__BITOPS_WORDSIZE-1)/__BITOPS_WORDSIZE)</span>
<span class="cp">#define __BITOPS_BARRIER() asm volatile(&quot;&quot; : : : &quot;memory&quot;)</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * SMP safe set_bit routine based on compare and swap (CS)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_bit_cs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="cm">/* calculate address for CS */</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="cm">/* make OR mask */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="cm">/* Do the atomic update. */</span>
	<span class="n">__BITOPS_LOOP</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">__BITOPS_OR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SMP safe clear_bit routine based on compare and swap (CS)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_bit_cs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="cm">/* calculate address for CS */</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="cm">/* make AND mask */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
	<span class="cm">/* Do the atomic update. */</span>
	<span class="n">__BITOPS_LOOP</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">__BITOPS_AND</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SMP safe change_bit routine based on compare and swap (CS)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">change_bit_cs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="cm">/* calculate address for CS */</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="cm">/* make XOR mask */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="cm">/* Do the atomic update. */</span>
	<span class="n">__BITOPS_LOOP</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">__BITOPS_XOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SMP safe test_and_set_bit routine based on compare and swap (CS)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">test_and_set_bit_cs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="cm">/* calculate address for CS */</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="cm">/* make OR/test mask */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="cm">/* Do the atomic update. */</span>
	<span class="n">__BITOPS_LOOP</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">__BITOPS_OR</span><span class="p">);</span>
	<span class="n">__BITOPS_BARRIER</span><span class="p">();</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SMP safe test_and_clear_bit routine based on compare and swap (CS)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">test_and_clear_bit_cs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="cm">/* calculate address for CS */</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="cm">/* make AND/test mask */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
	<span class="cm">/* Do the atomic update. */</span>
	<span class="n">__BITOPS_LOOP</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">__BITOPS_AND</span><span class="p">);</span>
	<span class="n">__BITOPS_BARRIER</span><span class="p">();</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">old</span> <span class="o">^</span> <span class="n">new</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SMP safe test_and_change_bit routine based on compare and swap (CS) </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">test_and_change_bit_cs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="cm">/* calculate address for CS */</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="cm">/* make XOR/test mask */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="cm">/* Do the atomic update. */</span>
	<span class="n">__BITOPS_LOOP</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">__BITOPS_XOR</span><span class="p">);</span>
	<span class="n">__BITOPS_BARRIER</span><span class="p">();</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * fast, non-SMP set_bit routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__set_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	oc	%O0(1,%R0),%1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=Q&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;Q&quot;</span> <span class="p">(</span><span class="n">_oi_bitmap</span><span class="p">[</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">])</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> 
<span class="nf">__constant_set_bit</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define set_bit_simple(nr,addr) \</span>
<span class="cp">(__builtin_constant_p((nr)) ? \</span>
<span class="cp"> __constant_set_bit((nr),(addr)) : \</span>
<span class="cp"> __set_bit((nr),(addr)) )</span>

<span class="cm">/*</span>
<span class="cm"> * fast, non-SMP clear_bit routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> 
<span class="nf">__clear_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	nc	%O0(1,%R0),%1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=Q&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;Q&quot;</span> <span class="p">(</span><span class="n">_ni_bitmap</span><span class="p">[</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">])</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> 
<span class="nf">__constant_clear_bit</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define clear_bit_simple(nr,addr) \</span>
<span class="cp">(__builtin_constant_p((nr)) ? \</span>
<span class="cp"> __constant_clear_bit((nr),(addr)) : \</span>
<span class="cp"> __clear_bit((nr),(addr)) )</span>

<span class="cm">/* </span>
<span class="cm"> * fast, non-SMP change_bit routine </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__change_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	xc	%O0(1,%R0),%1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=Q&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;Q&quot;</span> <span class="p">(</span><span class="n">_oi_bitmap</span><span class="p">[</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">])</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> 
<span class="nf">__constant_change_bit</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define change_bit_simple(nr,addr) \</span>
<span class="cp">(__builtin_constant_p((nr)) ? \</span>
<span class="cp"> __constant_change_bit((nr),(addr)) : \</span>
<span class="cp"> __change_bit((nr),(addr)) )</span>

<span class="cm">/*</span>
<span class="cm"> * fast, non-SMP test_and_set_bit routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">test_and_set_bit_simple</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	oc	%O0(1,%R0),%1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=Q&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span>	<span class="o">:</span> <span class="s">&quot;Q&quot;</span> <span class="p">(</span><span class="n">_oi_bitmap</span><span class="p">[</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">])</span>
		<span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define __test_and_set_bit(X,Y)		test_and_set_bit_simple(X,Y)</span>

<span class="cm">/*</span>
<span class="cm"> * fast, non-SMP test_and_clear_bit routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">test_and_clear_bit_simple</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	nc	%O0(1,%R0),%1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=Q&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span>	<span class="o">:</span> <span class="s">&quot;Q&quot;</span> <span class="p">(</span><span class="n">_ni_bitmap</span><span class="p">[</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">])</span>
		<span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define __test_and_clear_bit(X,Y)	test_and_clear_bit_simple(X,Y)</span>

<span class="cm">/*</span>
<span class="cm"> * fast, non-SMP test_and_change_bit routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">test_and_change_bit_simple</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	xc	%O0(1,%R0),%1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=Q&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span>	<span class="o">:</span> <span class="s">&quot;Q&quot;</span> <span class="p">(</span><span class="n">_oi_bitmap</span><span class="p">[</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">])</span>
		<span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define __test_and_change_bit(X,Y)	test_and_change_bit_simple(X,Y)</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#define set_bit             set_bit_cs</span>
<span class="cp">#define clear_bit           clear_bit_cs</span>
<span class="cp">#define change_bit          change_bit_cs</span>
<span class="cp">#define test_and_set_bit    test_and_set_bit_cs</span>
<span class="cp">#define test_and_clear_bit  test_and_clear_bit_cs</span>
<span class="cp">#define test_and_change_bit test_and_change_bit_cs</span>
<span class="cp">#else</span>
<span class="cp">#define set_bit             set_bit_simple</span>
<span class="cp">#define clear_bit           clear_bit_simple</span>
<span class="cp">#define change_bit          change_bit_simple</span>
<span class="cp">#define test_and_set_bit    test_and_set_bit_simple</span>
<span class="cp">#define test_and_clear_bit  test_and_clear_bit_simple</span>
<span class="cp">#define test_and_change_bit test_and_change_bit_simple</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * This routine doesn&#39;t need to be atomic.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__test_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">+</span> <span class="p">((</span><span class="n">nr</span> <span class="o">^</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> 
<span class="nf">__constant_test_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(((</span><span class="k">volatile</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span>
	    <span class="p">[(</span><span class="n">nr</span><span class="o">^</span><span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">nr</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define test_bit(nr,addr) \</span>
<span class="cp">(__builtin_constant_p((nr)) ? \</span>
<span class="cp"> __constant_test_bit((nr),(addr)) : \</span>
<span class="cp"> __test_bit((nr),(addr)) )</span>

<span class="cm">/*</span>
<span class="cm"> * Optimized find bit helper functions.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * __ffz_word_loop - find byte offset of first long != -1UL</span>
<span class="cm"> * @addr: pointer to array of unsigned long</span>
<span class="cm"> * @size: size of the array in bits</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__ffz_word_loop</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">long</span> <span class="n">_</span><span class="p">[</span><span class="n">__BITOPS_WORDS</span><span class="p">(</span><span class="n">size</span><span class="p">)];</span> <span class="p">}</span> <span class="n">addrtype</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
		<span class="s">&quot;	ahi	%1,-1</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	sra	%1,5</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	jz	1f</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;0:	c	%2,0(%0,%3)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	jne	1f</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	la	%0,4(%0)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	brct	%1,0b</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;1:</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#else</span>
		<span class="s">&quot;	aghi	%1,-1</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	srag	%1,%1,6</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	jz	1f</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;0:	cg	%2,0(%0,%3)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	jne	1f</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	la	%0,8(%0)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	brct	%1,0b</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;1:</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
		<span class="o">:</span> <span class="s">&quot;+&amp;a&quot;</span> <span class="p">(</span><span class="n">bytes</span><span class="p">),</span> <span class="s">&quot;+&amp;d&quot;</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;d&quot;</span> <span class="p">(</span><span class="o">-</span><span class="mi">1UL</span><span class="p">),</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">addrtype</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;cc&quot;</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __ffs_word_loop - find byte offset of first long != 0UL</span>
<span class="cm"> * @addr: pointer to array of unsigned long</span>
<span class="cm"> * @size: size of the array in bits</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__ffs_word_loop</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">long</span> <span class="n">_</span><span class="p">[</span><span class="n">__BITOPS_WORDS</span><span class="p">(</span><span class="n">size</span><span class="p">)];</span> <span class="p">}</span> <span class="n">addrtype</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
		<span class="s">&quot;	ahi	%1,-1</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	sra	%1,5</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	jz	1f</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;0:	c	%2,0(%0,%3)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	jne	1f</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	la	%0,4(%0)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	brct	%1,0b</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;1:</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#else</span>
		<span class="s">&quot;	aghi	%1,-1</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	srag	%1,%1,6</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	jz	1f</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;0:	cg	%2,0(%0,%3)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	jne	1f</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	la	%0,8(%0)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	brct	%1,0b</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;1:</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
		<span class="o">:</span> <span class="s">&quot;+&amp;a&quot;</span> <span class="p">(</span><span class="n">bytes</span><span class="p">),</span> <span class="s">&quot;+&amp;a&quot;</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;d&quot;</span> <span class="p">(</span><span class="mi">0UL</span><span class="p">),</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">addrtype</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;cc&quot;</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __ffz_word - add number of the first unset bit</span>
<span class="cm"> * @nr: base value the bit number is added to</span>
<span class="cm"> * @word: the word that is searched for unset bits</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__ffz_word</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">&gt;&gt;=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nr</span> <span class="o">+</span> <span class="n">_zb_findmap</span><span class="p">[(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">word</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __ffs_word - add number of the first set bit</span>
<span class="cm"> * @nr: base value the bit number is added to</span>
<span class="cm"> * @word: the word that is searched for set bits</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__ffs_word</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">&gt;&gt;=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nr</span> <span class="o">+</span> <span class="n">_sb_findmap</span><span class="p">[(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">word</span><span class="p">];</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * __load_ulong_be - load big endian unsigned long</span>
<span class="cm"> * @p: pointer to array of unsigned long</span>
<span class="cm"> * @offset: byte offset of source value in the array</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__load_ulong_be</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __load_ulong_le - load little endian unsigned long</span>
<span class="cm"> * @p: pointer to array of unsigned long</span>
<span class="cm"> * @offset: byte offset of source value in the array</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__load_ulong_le</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	ic	%0,%O1(%R1)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	icm	%0,2,%O1+1(%R1)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	icm	%0,4,%O1+2(%R1)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	icm	%0,8,%O1+3(%R1)&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=&amp;d&quot;</span> <span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;Q&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	lrvg	%0,%1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=d&quot;</span> <span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">word</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The various find bit functions.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * ffz - find first zero in word.</span>
<span class="cm"> * @word: The word to search</span>
<span class="cm"> *</span>
<span class="cm"> * Undefined if no zero exists, so code should check against ~0UL first.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ffz</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ffz_word</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __ffs - find first bit in word.</span>
<span class="cm"> * @word: The word to search</span>
<span class="cm"> *</span>
<span class="cm"> * Undefined if no bit exists, so code should check against 0 first.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__ffs</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ffs_word</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ffs - find first bit set</span>
<span class="cm"> * @x: the word to search</span>
<span class="cm"> *</span>
<span class="cm"> * This is defined the same way as</span>
<span class="cm"> * the libc and compiler builtin ffs routines, therefore</span>
<span class="cm"> * differs in spirit from the above ffz (man ffs).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ffs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__ffs_word</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_first_zero_bit - find the first zero bit in a memory region</span>
<span class="cm"> * @addr: The address to start the search at</span>
<span class="cm"> * @size: The maximum size to search</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the bit-number of the first zero bit, not the number of the byte</span>
<span class="cm"> * containing a bit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">find_first_zero_bit</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">__ffz_word_loop</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="n">__ffz_word</span><span class="p">(</span><span class="n">bytes</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="n">__load_ulong_be</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="o">?</span> <span class="n">bits</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define find_first_zero_bit find_first_zero_bit</span>

<span class="cm">/**</span>
<span class="cm"> * find_first_bit - find the first set bit in a memory region</span>
<span class="cm"> * @addr: The address to start the search at</span>
<span class="cm"> * @size: The maximum size to search</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the bit-number of the first set bit, not the number of the byte</span>
<span class="cm"> * containing a bit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">find_first_bit</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">__ffs_word_loop</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="n">__ffs_word</span><span class="p">(</span><span class="n">bytes</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="n">__load_ulong_be</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="o">?</span> <span class="n">bits</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define find_first_bit find_first_bit</span>

<span class="cm">/**</span>
<span class="cm"> * find_next_zero_bit - find the first zero bit in a memory region</span>
<span class="cm"> * @addr: The address to base the search on</span>
<span class="cm"> * @offset: The bitnumber to start searching at</span>
<span class="cm"> * @size: The maximum size to search</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find_next_zero_bit</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span><span class="p">,</span> <span class="n">set</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">-=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * __ffz_word returns __BITOPS_WORDSIZE</span>
<span class="cm">		 * if no zero bit is present in the word.</span>
<span class="cm">		 */</span>
		<span class="n">set</span> <span class="o">=</span> <span class="n">__ffz_word</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&lt;</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">set</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define find_next_zero_bit find_next_zero_bit</span>

<span class="cm">/**</span>
<span class="cm"> * find_next_bit - find the first set bit in a memory region</span>
<span class="cm"> * @addr: The address to base the search on</span>
<span class="cm"> * @offset: The bitnumber to start searching at</span>
<span class="cm"> * @size: The maximum size to search</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find_next_bit</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span><span class="p">,</span> <span class="n">set</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">-=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * __ffs_word returns __BITOPS_WORDSIZE</span>
<span class="cm">		 * if no one bit is present in the word.</span>
<span class="cm">		 */</span>
		<span class="n">set</span> <span class="o">=</span> <span class="n">__ffs_word</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">0UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&lt;</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">set</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define find_next_bit find_next_bit</span>

<span class="cm">/*</span>
<span class="cm"> * Every architecture must define this function. It&#39;s the fastest</span>
<span class="cm"> * way of searching a 140-bit bitmap where the first 100 bits are</span>
<span class="cm"> * unlikely to be set. It&#39;s guaranteed that at least one of the 140</span>
<span class="cm"> * bits is cleared.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sched_find_first_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">140</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#include &lt;asm-generic/bitops/fls.h&gt;</span>
<span class="cp">#include &lt;asm-generic/bitops/__fls.h&gt;</span>
<span class="cp">#include &lt;asm-generic/bitops/fls64.h&gt;</span>

<span class="cp">#include &lt;asm-generic/bitops/hweight.h&gt;</span>
<span class="cp">#include &lt;asm-generic/bitops/lock.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * ATTENTION: intel byte ordering convention for ext2 and minix !!</span>
<span class="cm"> * bit 0 is the LSB of addr; bit 31 is the MSB of addr;</span>
<span class="cm"> * bit 32 is the LSB of (addr+4).</span>
<span class="cm"> * That combined with the little endian byte order of Intel gives the</span>
<span class="cm"> * following bit order in memory:</span>
<span class="cm"> *    07 06 05 04 03 02 01 00 15 14 13 12 11 10 09 08 \</span>
<span class="cm"> *    23 22 21 20 19 18 17 16 31 30 29 28 27 26 25 24</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find_first_zero_bit_le</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">__ffz_word_loop</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="n">__ffz_word</span><span class="p">(</span><span class="n">bytes</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="n">__load_ulong_le</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="o">?</span> <span class="n">bits</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define find_first_zero_bit_le find_first_zero_bit_le</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find_next_zero_bit_le</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span><span class="p">,</span> <span class="n">set</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">-=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * s390 version of ffz returns __BITOPS_WORDSIZE</span>
<span class="cm">		 * if no zero bit is present in the word.</span>
<span class="cm">		 */</span>
		<span class="n">set</span> <span class="o">=</span> <span class="n">__ffz_word</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">__load_ulong_le</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&lt;</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">set</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
	<span class="k">return</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">find_first_zero_bit_le</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define find_next_zero_bit_le find_next_zero_bit_le</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">find_first_bit_le</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">__ffs_word_loop</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="n">__ffs_word</span><span class="p">(</span><span class="n">bytes</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="n">__load_ulong_le</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="o">?</span> <span class="n">bits</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define find_first_bit_le find_first_bit_le</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find_next_bit_le</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span><span class="p">,</span> <span class="n">set</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__BITOPS_WORDSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">-=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * s390 version of ffz returns __BITOPS_WORDSIZE</span>
<span class="cm">		 * if no zero bit is present in the word.</span>
<span class="cm">		 */</span>
		<span class="n">set</span> <span class="o">=</span> <span class="n">__ffs_word</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">__load_ulong_le</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">0UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&lt;</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">set</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">__BITOPS_WORDSIZE</span><span class="p">;</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">find_first_bit_le</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define find_next_bit_le find_next_bit_le</span>

<span class="cp">#include &lt;asm-generic/bitops/le.h&gt;</span>

<span class="cp">#include &lt;asm-generic/bitops/ext2-atomic-setbit.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* _S390_BITOPS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
