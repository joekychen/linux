<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › s390 › include › asm › pgtable.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  include/asm-s390/pgtable.h</span>
<span class="cm"> *</span>
<span class="cm"> *  S390 version</span>
<span class="cm"> *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation</span>
<span class="cm"> *    Author(s): Hartmut Penner (hp@de.ibm.com)</span>
<span class="cm"> *               Ulrich Weigand (weigand@de.ibm.com)</span>
<span class="cm"> *               Martin Schwidefsky (schwidefsky@de.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> *  Derived from &quot;include/asm-i386/pgtable.h&quot;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_S390_PGTABLE_H</span>
<span class="cp">#define _ASM_S390_PGTABLE_H</span>

<span class="cm">/*</span>
<span class="cm"> * The Linux memory management assumes a three-level page table setup. For</span>
<span class="cm"> * s390 31 bit we &quot;fold&quot; the mid level into the top-level page table, so</span>
<span class="cm"> * that we physically have the same two-level page table as the s390 mmu</span>
<span class="cm"> * expects in 31 bit mode. For s390 64 bit we use three of the five levels</span>
<span class="cm"> * the hardware provides (region first and region second tables are not</span>
<span class="cm"> * used).</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;pgd_xxx()&quot; functions are trivial for a folded two-level</span>
<span class="cm"> * setup: the pgd is never bad, and a pmd always exists (as it&#39;s folded</span>
<span class="cm"> * into the pgd entry)</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains the functions and defines necessary to modify and use</span>
<span class="cm"> * the S390 page table tree.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm_types.h&gt;</span>
<span class="cp">#include &lt;asm/bug.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="k">extern</span> <span class="n">pgd_t</span> <span class="n">swapper_pg_dir</span><span class="p">[]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">4096</span><span class="p">)));</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">vmem_map_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fault_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The S390 doesn&#39;t have any external MMU info: the kernel page</span>
<span class="cm"> * tables contain all the necessary information.</span>
<span class="cm"> */</span>
<span class="cp">#define update_mmu_cache(vma, address, ptep)     do { } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * ZERO_PAGE is a global shared page that is always zero; used</span>
<span class="cm"> * for zero-mapped memory areas etc..</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">empty_zero_page</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zero_page_mask</span><span class="p">;</span>

<span class="cp">#define ZERO_PAGE(vaddr) \</span>
<span class="cp">	(virt_to_page((void *)(empty_zero_page + \</span>
<span class="cp">	 (((unsigned long)(vaddr)) &amp;zero_page_mask))))</span>

<span class="cp">#define is_zero_pfn is_zero_pfn</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_zero_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zero_pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset_from_zero_pfn</span> <span class="o">=</span> <span class="n">pfn</span> <span class="o">-</span> <span class="n">zero_pfn</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">offset_from_zero_pfn</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">zero_page_mask</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define my_zero_pfn(addr)	page_to_pfn(ZERO_PAGE(addr))</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * PMD_SHIFT determines the size of the area a second-level page</span>
<span class="cm"> * table can map</span>
<span class="cm"> * PGDIR_SHIFT determines what a third-level page table entry can map</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="cp"># define PMD_SHIFT	20</span>
<span class="cp"># define PUD_SHIFT	20</span>
<span class="cp"># define PGDIR_SHIFT	20</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>
<span class="cp"># define PMD_SHIFT	20</span>
<span class="cp"># define PUD_SHIFT	31</span>
<span class="cp"># define PGDIR_SHIFT	42</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cp">#define PMD_SIZE        (1UL &lt;&lt; PMD_SHIFT)</span>
<span class="cp">#define PMD_MASK        (~(PMD_SIZE-1))</span>
<span class="cp">#define PUD_SIZE	(1UL &lt;&lt; PUD_SHIFT)</span>
<span class="cp">#define PUD_MASK	(~(PUD_SIZE-1))</span>
<span class="cp">#define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)</span>
<span class="cp">#define PGDIR_MASK	(~(PGDIR_SIZE-1))</span>

<span class="cm">/*</span>
<span class="cm"> * entries per page directory level: the S390 is two-level, so</span>
<span class="cm"> * we don&#39;t really have any PMD directory physically.</span>
<span class="cm"> * for S390 segment-table entries are combined to one PGD</span>
<span class="cm"> * that leads to 1024 pte per pgd</span>
<span class="cm"> */</span>
<span class="cp">#define PTRS_PER_PTE	256</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="cp">#define PTRS_PER_PMD	1</span>
<span class="cp">#define PTRS_PER_PUD	1</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>
<span class="cp">#define PTRS_PER_PMD	2048</span>
<span class="cp">#define PTRS_PER_PUD	2048</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>
<span class="cp">#define PTRS_PER_PGD	2048</span>

<span class="cp">#define FIRST_USER_ADDRESS  0</span>

<span class="cp">#define pte_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pte %p.\n&quot;, __FILE__, __LINE__, (void *) pte_val(e))</span>
<span class="cp">#define pmd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pmd %p.\n&quot;, __FILE__, __LINE__, (void *) pmd_val(e))</span>
<span class="cp">#define pud_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pud %p.\n&quot;, __FILE__, __LINE__, (void *) pud_val(e))</span>
<span class="cp">#define pgd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pgd %p.\n&quot;, __FILE__, __LINE__, (void *) pgd_val(e))</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cm">/*</span>
<span class="cm"> * The vmalloc area will always be on the topmost area of the kernel</span>
<span class="cm"> * mapping. We reserve 96MB (31bit) / 128GB (64bit) for vmalloc,</span>
<span class="cm"> * which should be enough for any sane case.</span>
<span class="cm"> * By putting vmalloc at the top, we maximise the gap between physical</span>
<span class="cm"> * memory and vmalloc to catch misplaced memory accesses. As a side</span>
<span class="cm"> * effect, this also makes sure that 64 bit module code cannot be used</span>
<span class="cm"> * as system call address.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">VMALLOC_START</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">VMALLOC_END</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">vmemmap</span><span class="p">;</span>

<span class="cp">#define VMEM_MAX_PHYS ((unsigned long) vmemmap)</span>

<span class="cm">/*</span>
<span class="cm"> * A 31 bit pagetable entry of S390 has following format:</span>
<span class="cm"> *  |   PFRA          |    |  OS  |</span>
<span class="cm"> * 0                   0IP0</span>
<span class="cm"> * 00000000001111111111222222222233</span>
<span class="cm"> * 01234567890123456789012345678901</span>
<span class="cm"> *</span>
<span class="cm"> * I Page-Invalid Bit:    Page is not available for address-translation</span>
<span class="cm"> * P Page-Protection Bit: Store access not possible for page</span>
<span class="cm"> *</span>
<span class="cm"> * A 31 bit segmenttable entry of S390 has following format:</span>
<span class="cm"> *  |   P-table origin      |  |PTL</span>
<span class="cm"> * 0                         IC</span>
<span class="cm"> * 00000000001111111111222222222233</span>
<span class="cm"> * 01234567890123456789012345678901</span>
<span class="cm"> *</span>
<span class="cm"> * I Segment-Invalid Bit:    Segment is not available for address-translation</span>
<span class="cm"> * C Common-Segment Bit:     Segment is not private (PoP 3-30)</span>
<span class="cm"> * PTL Page-Table-Length:    Page-table length (PTL+1*16 entries -&gt; up to 256)</span>
<span class="cm"> *</span>
<span class="cm"> * The 31 bit segmenttable origin of S390 has following format:</span>
<span class="cm"> *</span>
<span class="cm"> *  |S-table origin   |     | STL |</span>
<span class="cm"> * X                   **GPS</span>
<span class="cm"> * 00000000001111111111222222222233</span>
<span class="cm"> * 01234567890123456789012345678901</span>
<span class="cm"> *</span>
<span class="cm"> * X Space-Switch event:</span>
<span class="cm"> * G Segment-Invalid Bit:     *</span>
<span class="cm"> * P Private-Space Bit:       Segment is not private (PoP 3-30)</span>
<span class="cm"> * S Storage-Alteration:</span>
<span class="cm"> * STL Segment-Table-Length:  Segment-table length (STL+1*16 entries -&gt; up to 2048)</span>
<span class="cm"> *</span>
<span class="cm"> * A 64 bit pagetable entry of S390 has following format:</span>
<span class="cm"> * |			 PFRA			      |0IPC|  OS  |</span>
<span class="cm"> * 0000000000111111111122222222223333333333444444444455555555556666</span>
<span class="cm"> * 0123456789012345678901234567890123456789012345678901234567890123</span>
<span class="cm"> *</span>
<span class="cm"> * I Page-Invalid Bit:    Page is not available for address-translation</span>
<span class="cm"> * P Page-Protection Bit: Store access not possible for page</span>
<span class="cm"> * C Change-bit override: HW is not required to set change bit</span>
<span class="cm"> *</span>
<span class="cm"> * A 64 bit segmenttable entry of S390 has following format:</span>
<span class="cm"> * |        P-table origin                              |      TT</span>
<span class="cm"> * 0000000000111111111122222222223333333333444444444455555555556666</span>
<span class="cm"> * 0123456789012345678901234567890123456789012345678901234567890123</span>
<span class="cm"> *</span>
<span class="cm"> * I Segment-Invalid Bit:    Segment is not available for address-translation</span>
<span class="cm"> * C Common-Segment Bit:     Segment is not private (PoP 3-30)</span>
<span class="cm"> * P Page-Protection Bit: Store access not possible for page</span>
<span class="cm"> * TT Type 00</span>
<span class="cm"> *</span>
<span class="cm"> * A 64 bit region table entry of S390 has following format:</span>
<span class="cm"> * |        S-table origin                             |   TF  TTTL</span>
<span class="cm"> * 0000000000111111111122222222223333333333444444444455555555556666</span>
<span class="cm"> * 0123456789012345678901234567890123456789012345678901234567890123</span>
<span class="cm"> *</span>
<span class="cm"> * I Segment-Invalid Bit:    Segment is not available for address-translation</span>
<span class="cm"> * TT Type 01</span>
<span class="cm"> * TF</span>
<span class="cm"> * TL Table length</span>
<span class="cm"> *</span>
<span class="cm"> * The 64 bit regiontable origin of S390 has following format:</span>
<span class="cm"> * |      region table origon                          |       DTTL</span>
<span class="cm"> * 0000000000111111111122222222223333333333444444444455555555556666</span>
<span class="cm"> * 0123456789012345678901234567890123456789012345678901234567890123</span>
<span class="cm"> *</span>
<span class="cm"> * X Space-Switch event:</span>
<span class="cm"> * G Segment-Invalid Bit:  </span>
<span class="cm"> * P Private-Space Bit:    </span>
<span class="cm"> * S Storage-Alteration:</span>
<span class="cm"> * R Real space</span>
<span class="cm"> * TL Table-Length:</span>
<span class="cm"> *</span>
<span class="cm"> * A storage key has the following format:</span>
<span class="cm"> * | ACC |F|R|C|0|</span>
<span class="cm"> *  0   3 4 5 6 7</span>
<span class="cm"> * ACC: access key</span>
<span class="cm"> * F  : fetch protection bit</span>
<span class="cm"> * R  : referenced bit</span>
<span class="cm"> * C  : changed bit</span>
<span class="cm"> */</span>

<span class="cm">/* Hardware bits in the page table entry */</span>
<span class="cp">#define _PAGE_CO	0x100		</span><span class="cm">/* HW Change-bit override */</span><span class="cp"></span>
<span class="cp">#define _PAGE_RO	0x200		</span><span class="cm">/* HW read-only bit  */</span><span class="cp"></span>
<span class="cp">#define _PAGE_INVALID	0x400		</span><span class="cm">/* HW invalid bit    */</span><span class="cp"></span>

<span class="cm">/* Software bits in the page table entry */</span>
<span class="cp">#define _PAGE_SWT	0x001		</span><span class="cm">/* SW pte type bit t */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SWX	0x002		</span><span class="cm">/* SW pte type bit x */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SWC	0x004		</span><span class="cm">/* SW pte changed bit (for KVM) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SWR	0x008		</span><span class="cm">/* SW pte referenced bit (for KVM) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_SPECIAL	0x010		</span><span class="cm">/* SW associated with special page */</span><span class="cp"></span>
<span class="cp">#define __HAVE_ARCH_PTE_SPECIAL</span>

<span class="cm">/* Set of bits not changed in pte_modify */</span>
<span class="cp">#define _PAGE_CHG_MASK	(PAGE_MASK | _PAGE_SPECIAL | _PAGE_SWC | _PAGE_SWR)</span>

<span class="cm">/* Six different types of pages. */</span>
<span class="cp">#define _PAGE_TYPE_EMPTY	0x400</span>
<span class="cp">#define _PAGE_TYPE_NONE		0x401</span>
<span class="cp">#define _PAGE_TYPE_SWAP		0x403</span>
<span class="cp">#define _PAGE_TYPE_FILE		0x601	</span><span class="cm">/* bit 0x002 is used for offset !! */</span><span class="cp"></span>
<span class="cp">#define _PAGE_TYPE_RO		0x200</span>
<span class="cp">#define _PAGE_TYPE_RW		0x000</span>

<span class="cm">/*</span>
<span class="cm"> * Only four types for huge pages, using the invalid bit and protection bit</span>
<span class="cm"> * of a segment table entry.</span>
<span class="cm"> */</span>
<span class="cp">#define _HPAGE_TYPE_EMPTY	0x020	</span><span class="cm">/* _SEGMENT_ENTRY_INV */</span><span class="cp"></span>
<span class="cp">#define _HPAGE_TYPE_NONE	0x220</span>
<span class="cp">#define _HPAGE_TYPE_RO		0x200	</span><span class="cm">/* _SEGMENT_ENTRY_RO  */</span><span class="cp"></span>
<span class="cp">#define _HPAGE_TYPE_RW		0x000</span>

<span class="cm">/*</span>
<span class="cm"> * PTE type bits are rather complicated. handle_pte_fault uses pte_present,</span>
<span class="cm"> * pte_none and pte_file to find out the pte type WITHOUT holding the page</span>
<span class="cm"> * table lock. ptep_clear_flush on the other hand uses ptep_clear_flush to</span>
<span class="cm"> * invalidate a given pte. ipte sets the hw invalid bit and clears all tlbs</span>
<span class="cm"> * for the page. The page table entry is set to _PAGE_TYPE_EMPTY afterwards.</span>
<span class="cm"> * This change is done while holding the lock, but the intermediate step</span>
<span class="cm"> * of a previously valid pte with the hw invalid bit set can be observed by</span>
<span class="cm"> * handle_pte_fault. That makes it necessary that all valid pte types with</span>
<span class="cm"> * the hw invalid bit set must be distinguishable from the four pte types</span>
<span class="cm"> * empty, none, swap and file.</span>
<span class="cm"> *</span>
<span class="cm"> *			irxt  ipte  irxt</span>
<span class="cm"> * _PAGE_TYPE_EMPTY	1000   -&gt;   1000</span>
<span class="cm"> * _PAGE_TYPE_NONE	1001   -&gt;   1001</span>
<span class="cm"> * _PAGE_TYPE_SWAP	1011   -&gt;   1011</span>
<span class="cm"> * _PAGE_TYPE_FILE	11?1   -&gt;   11?1</span>
<span class="cm"> * _PAGE_TYPE_RO	0100   -&gt;   1100</span>
<span class="cm"> * _PAGE_TYPE_RW	0000   -&gt;   1000</span>
<span class="cm"> *</span>
<span class="cm"> * pte_none is true for bits combinations 1000, 1010, 1100, 1110</span>
<span class="cm"> * pte_present is true for bits combinations 0000, 0010, 0100, 0110, 1001</span>
<span class="cm"> * pte_file is true for bits combinations 1101, 1111</span>
<span class="cm"> * swap pte is 1011 and 0001, 0011, 0101, 0111 are invalid.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef CONFIG_64BIT</span>

<span class="cm">/* Bits in the segment table address-space-control-element */</span>
<span class="cp">#define _ASCE_SPACE_SWITCH	0x80000000UL	</span><span class="cm">/* space switch event	    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_ORIGIN_MASK	0x7ffff000UL	</span><span class="cm">/* segment table origin	    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_PRIVATE_SPACE	0x100	</span><span class="cm">/* private space control	    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_ALT_EVENT		0x80	</span><span class="cm">/* storage alteration event control */</span><span class="cp"></span>
<span class="cp">#define _ASCE_TABLE_LENGTH	0x7f	</span><span class="cm">/* 128 x 64 entries = 8k	    */</span><span class="cp"></span>

<span class="cm">/* Bits in the segment table entry */</span>
<span class="cp">#define _SEGMENT_ENTRY_ORIGIN	0x7fffffc0UL	</span><span class="cm">/* page table origin	    */</span><span class="cp"></span>
<span class="cp">#define _SEGMENT_ENTRY_RO	0x200	</span><span class="cm">/* page protection bit		    */</span><span class="cp"></span>
<span class="cp">#define _SEGMENT_ENTRY_INV	0x20	</span><span class="cm">/* invalid segment table entry	    */</span><span class="cp"></span>
<span class="cp">#define _SEGMENT_ENTRY_COMMON	0x10	</span><span class="cm">/* common segment bit		    */</span><span class="cp"></span>
<span class="cp">#define _SEGMENT_ENTRY_PTL	0x0f	</span><span class="cm">/* page table length		    */</span><span class="cp"></span>

<span class="cp">#define _SEGMENT_ENTRY		(_SEGMENT_ENTRY_PTL)</span>
<span class="cp">#define _SEGMENT_ENTRY_EMPTY	(_SEGMENT_ENTRY_INV)</span>

<span class="cm">/* Page status table bits for virtualization */</span>
<span class="cp">#define RCP_ACC_BITS	0xf0000000UL</span>
<span class="cp">#define RCP_FP_BIT	0x08000000UL</span>
<span class="cp">#define RCP_PCL_BIT	0x00800000UL</span>
<span class="cp">#define RCP_HR_BIT	0x00400000UL</span>
<span class="cp">#define RCP_HC_BIT	0x00200000UL</span>
<span class="cp">#define RCP_GR_BIT	0x00040000UL</span>
<span class="cp">#define RCP_GC_BIT	0x00020000UL</span>

<span class="cm">/* User dirty / referenced bit for KVM&#39;s migration feature */</span>
<span class="cp">#define KVM_UR_BIT	0x00008000UL</span>
<span class="cp">#define KVM_UC_BIT	0x00004000UL</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cm">/* Bits in the segment/region table address-space-control-element */</span>
<span class="cp">#define _ASCE_ORIGIN		~0xfffUL</span><span class="cm">/* segment table origin		    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_PRIVATE_SPACE	0x100	</span><span class="cm">/* private space control	    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_ALT_EVENT		0x80	</span><span class="cm">/* storage alteration event control */</span><span class="cp"></span>
<span class="cp">#define _ASCE_SPACE_SWITCH	0x40	</span><span class="cm">/* space switch event		    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_REAL_SPACE	0x20	</span><span class="cm">/* real space control		    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_TYPE_MASK		0x0c	</span><span class="cm">/* asce table type mask		    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_TYPE_REGION1	0x0c	</span><span class="cm">/* region first table type	    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_TYPE_REGION2	0x08	</span><span class="cm">/* region second table type	    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_TYPE_REGION3	0x04	</span><span class="cm">/* region third table type	    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_TYPE_SEGMENT	0x00	</span><span class="cm">/* segment table type		    */</span><span class="cp"></span>
<span class="cp">#define _ASCE_TABLE_LENGTH	0x03	</span><span class="cm">/* region table length		    */</span><span class="cp"></span>

<span class="cm">/* Bits in the region table entry */</span>
<span class="cp">#define _REGION_ENTRY_ORIGIN	~0xfffUL</span><span class="cm">/* region/segment table origin	    */</span><span class="cp"></span>
<span class="cp">#define _REGION_ENTRY_INV	0x20	</span><span class="cm">/* invalid region table entry	    */</span><span class="cp"></span>
<span class="cp">#define _REGION_ENTRY_TYPE_MASK	0x0c	</span><span class="cm">/* region/segment table type mask   */</span><span class="cp"></span>
<span class="cp">#define _REGION_ENTRY_TYPE_R1	0x0c	</span><span class="cm">/* region first table type	    */</span><span class="cp"></span>
<span class="cp">#define _REGION_ENTRY_TYPE_R2	0x08	</span><span class="cm">/* region second table type	    */</span><span class="cp"></span>
<span class="cp">#define _REGION_ENTRY_TYPE_R3	0x04	</span><span class="cm">/* region third table type	    */</span><span class="cp"></span>
<span class="cp">#define _REGION_ENTRY_LENGTH	0x03	</span><span class="cm">/* region third length		    */</span><span class="cp"></span>

<span class="cp">#define _REGION1_ENTRY		(_REGION_ENTRY_TYPE_R1 | _REGION_ENTRY_LENGTH)</span>
<span class="cp">#define _REGION1_ENTRY_EMPTY	(_REGION_ENTRY_TYPE_R1 | _REGION_ENTRY_INV)</span>
<span class="cp">#define _REGION2_ENTRY		(_REGION_ENTRY_TYPE_R2 | _REGION_ENTRY_LENGTH)</span>
<span class="cp">#define _REGION2_ENTRY_EMPTY	(_REGION_ENTRY_TYPE_R2 | _REGION_ENTRY_INV)</span>
<span class="cp">#define _REGION3_ENTRY		(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_LENGTH)</span>
<span class="cp">#define _REGION3_ENTRY_EMPTY	(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_INV)</span>

<span class="cm">/* Bits in the segment table entry */</span>
<span class="cp">#define _SEGMENT_ENTRY_ORIGIN	~0x7ffUL</span><span class="cm">/* segment table origin		    */</span><span class="cp"></span>
<span class="cp">#define _SEGMENT_ENTRY_RO	0x200	</span><span class="cm">/* page protection bit		    */</span><span class="cp"></span>
<span class="cp">#define _SEGMENT_ENTRY_INV	0x20	</span><span class="cm">/* invalid segment table entry	    */</span><span class="cp"></span>

<span class="cp">#define _SEGMENT_ENTRY		(0)</span>
<span class="cp">#define _SEGMENT_ENTRY_EMPTY	(_SEGMENT_ENTRY_INV)</span>

<span class="cp">#define _SEGMENT_ENTRY_LARGE	0x400	</span><span class="cm">/* STE-format control, large page   */</span><span class="cp"></span>
<span class="cp">#define _SEGMENT_ENTRY_CO	0x100	</span><span class="cm">/* change-recording override   */</span><span class="cp"></span>

<span class="cm">/* Page status table bits for virtualization */</span>
<span class="cp">#define RCP_ACC_BITS	0xf000000000000000UL</span>
<span class="cp">#define RCP_FP_BIT	0x0800000000000000UL</span>
<span class="cp">#define RCP_PCL_BIT	0x0080000000000000UL</span>
<span class="cp">#define RCP_HR_BIT	0x0040000000000000UL</span>
<span class="cp">#define RCP_HC_BIT	0x0020000000000000UL</span>
<span class="cp">#define RCP_GR_BIT	0x0004000000000000UL</span>
<span class="cp">#define RCP_GC_BIT	0x0002000000000000UL</span>

<span class="cm">/* User dirty / referenced bit for KVM&#39;s migration feature */</span>
<span class="cp">#define KVM_UR_BIT	0x0000800000000000UL</span>
<span class="cp">#define KVM_UC_BIT	0x0000400000000000UL</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * A user page table pointer has the space-switch-event bit, the</span>
<span class="cm"> * private-space-control bit and the storage-alteration-event-control</span>
<span class="cm"> * bit set. A kernel page table pointer doesn&#39;t need them.</span>
<span class="cm"> */</span>
<span class="cp">#define _ASCE_USER_BITS		(_ASCE_SPACE_SWITCH | _ASCE_PRIVATE_SPACE | \</span>
<span class="cp">				 _ASCE_ALT_EVENT)</span>

<span class="cm">/*</span>
<span class="cm"> * Page protection definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_NONE	__pgprot(_PAGE_TYPE_NONE)</span>
<span class="cp">#define PAGE_RO		__pgprot(_PAGE_TYPE_RO)</span>
<span class="cp">#define PAGE_RW		__pgprot(_PAGE_TYPE_RW)</span>

<span class="cp">#define PAGE_KERNEL	PAGE_RW</span>
<span class="cp">#define PAGE_COPY	PAGE_RO</span>

<span class="cm">/*</span>
<span class="cm"> * On s390 the page table entry has an invalid bit and a read-only bit.</span>
<span class="cm"> * Read permission implies execute permission and write permission</span>
<span class="cm"> * implies read permission.</span>
<span class="cm"> */</span>
         <span class="cm">/*xwr*/</span>
<span class="cp">#define __P000	PAGE_NONE</span>
<span class="cp">#define __P001	PAGE_RO</span>
<span class="cp">#define __P010	PAGE_RO</span>
<span class="cp">#define __P011	PAGE_RO</span>
<span class="cp">#define __P100	PAGE_RO</span>
<span class="cp">#define __P101	PAGE_RO</span>
<span class="cp">#define __P110	PAGE_RO</span>
<span class="cp">#define __P111	PAGE_RO</span>

<span class="cp">#define __S000	PAGE_NONE</span>
<span class="cp">#define __S001	PAGE_RO</span>
<span class="cp">#define __S010	PAGE_RW</span>
<span class="cp">#define __S011	PAGE_RW</span>
<span class="cp">#define __S100	PAGE_RO</span>
<span class="cp">#define __S101	PAGE_RO</span>
<span class="cp">#define __S110	PAGE_RW</span>
<span class="cp">#define __S111	PAGE_RW</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mm_exclusive</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">likely</span><span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">&amp;&amp;</span>
		      <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">attach_count</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mm_has_pgste</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">has_pgste</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * pgd/pmd/pte query functions</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_64BIT</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_present</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_none</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>    <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_bad</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>     <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pud_present</span><span class="p">(</span><span class="n">pud_t</span> <span class="n">pud</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pud_none</span><span class="p">(</span><span class="n">pud_t</span> <span class="n">pud</span><span class="p">)</span>	 <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pud_bad</span><span class="p">(</span><span class="n">pud_t</span> <span class="n">pud</span><span class="p">)</span>	 <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_present</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_TYPE_MASK</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_REGION_ENTRY_TYPE_R2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_ORIGIN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_none</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_TYPE_MASK</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_REGION_ENTRY_TYPE_R2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_INV</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_bad</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * With dynamic page table levels the pgd can be a region table</span>
<span class="cm">	 * entry or a segment table entry. Check for the bit that are</span>
<span class="cm">	 * invalid for either table entry.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span>
		<span class="o">~</span><span class="n">_SEGMENT_ENTRY_ORIGIN</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_REGION_ENTRY_INV</span> <span class="o">&amp;</span>
		<span class="o">~</span><span class="n">_REGION_ENTRY_TYPE_MASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_REGION_ENTRY_LENGTH</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pud_present</span><span class="p">(</span><span class="n">pud_t</span> <span class="n">pud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pud_val</span><span class="p">(</span><span class="n">pud</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_TYPE_MASK</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_REGION_ENTRY_TYPE_R3</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pud_val</span><span class="p">(</span><span class="n">pud</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_ORIGIN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pud_none</span><span class="p">(</span><span class="n">pud_t</span> <span class="n">pud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pud_val</span><span class="p">(</span><span class="n">pud</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_TYPE_MASK</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_REGION_ENTRY_TYPE_R3</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pud_val</span><span class="p">(</span><span class="n">pud</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_INV</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pud_bad</span><span class="p">(</span><span class="n">pud_t</span> <span class="n">pud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * With dynamic page table levels the pud can be a region table</span>
<span class="cm">	 * entry or a segment table entry. Check for the bit that are</span>
<span class="cm">	 * invalid for either table entry.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span>
		<span class="o">~</span><span class="n">_SEGMENT_ENTRY_ORIGIN</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_REGION_ENTRY_INV</span> <span class="o">&amp;</span>
		<span class="o">~</span><span class="n">_REGION_ENTRY_TYPE_MASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_REGION_ENTRY_LENGTH</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pud_val</span><span class="p">(</span><span class="n">pud</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_present</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_SEGMENT_ENTRY_ORIGIN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_none</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_SEGMENT_ENTRY_INV</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_bad</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">_SEGMENT_ENTRY_ORIGIN</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_SEGMENT_ENTRY_INV</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_SEGMENT_ENTRY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_none</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_INVALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SWT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_present</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_PAGE_RO</span> <span class="o">|</span> <span class="n">_PAGE_INVALID</span> <span class="o">|</span> <span class="n">_PAGE_SWT</span> <span class="o">|</span> <span class="n">_PAGE_SWX</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">_PAGE_TYPE_NONE</span> <span class="o">||</span>
		<span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_INVALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="o">!</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SWT</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_file</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_PAGE_RO</span> <span class="o">|</span> <span class="n">_PAGE_INVALID</span> <span class="o">|</span> <span class="n">_PAGE_SWT</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">_PAGE_TYPE_FILE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_special</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SPECIAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTE_SAME</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_same</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgste_t</span> <span class="nf">pgste_get_lock</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">asm</span><span class="p">(</span>
		<span class="s">&quot;	lg	%0,%2</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;0:	lgr	%1,%0</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	nihh	%0,0xff7f</span><span class="se">\n</span><span class="s">&quot;</span>	<span class="cm">/* clear RCP_PCL_BIT in old */</span>
		<span class="s">&quot;	oihh	%1,0x0080</span><span class="se">\n</span><span class="s">&quot;</span>	<span class="cm">/* set RCP_PCL_BIT in new */</span>
		<span class="s">&quot;	csg	%0,%1,%2</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	jl	0b</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=&amp;d&quot;</span> <span class="p">(</span><span class="n">old</span><span class="p">),</span> <span class="s">&quot;=&amp;d&quot;</span> <span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="s">&quot;=Q&quot;</span> <span class="p">(</span><span class="n">ptep</span><span class="p">[</span><span class="n">PTRS_PER_PTE</span><span class="p">])</span>
		<span class="o">:</span> <span class="s">&quot;Q&quot;</span> <span class="p">(</span><span class="n">ptep</span><span class="p">[</span><span class="n">PTRS_PER_PTE</span><span class="p">])</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">__pgste</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pgste_set_unlock</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="n">asm</span><span class="p">(</span>
		<span class="s">&quot;	nihh	%1,0xff7f</span><span class="se">\n</span><span class="s">&quot;</span>	<span class="cm">/* clear RCP_PCL_BIT */</span>
		<span class="s">&quot;	stg	%1,%0</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=Q&quot;</span> <span class="p">(</span><span class="n">ptep</span><span class="p">[</span><span class="n">PTRS_PER_PTE</span><span class="p">])</span>
		<span class="o">:</span> <span class="s">&quot;d&quot;</span> <span class="p">(</span><span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)),</span> <span class="s">&quot;Q&quot;</span> <span class="p">(</span><span class="n">ptep</span><span class="p">[</span><span class="n">PTRS_PER_PTE</span><span class="p">])</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgste_t</span> <span class="nf">pgste_update_all</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">skey</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pgste</span><span class="p">;</span>
	<span class="n">address</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">skey</span> <span class="o">=</span> <span class="n">page_get_storage_key</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="n">skey</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_PAGE_CHANGED</span> <span class="o">|</span> <span class="n">_PAGE_REFERENCED</span><span class="p">);</span>
	<span class="cm">/* Clear page changed &amp; referenced bit in the storage key */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">_PAGE_CHANGED</span><span class="p">)</span>
		<span class="n">page_set_storage_key</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">skey</span> <span class="o">^</span> <span class="n">bits</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bits</span><span class="p">)</span>
		<span class="n">page_reset_referenced</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="cm">/* Transfer page changed &amp; referenced bit to guest bits in pgste */</span>
	<span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">|=</span> <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="p">;</span>		<span class="cm">/* RCP_GR_BIT &amp; RCP_GC_BIT */</span>
	<span class="cm">/* Get host changed &amp; referenced bits from pgste */</span>
	<span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RCP_HR_BIT</span> <span class="o">|</span> <span class="n">RCP_HC_BIT</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">52</span><span class="p">;</span>
	<span class="cm">/* Clear host bits in pgste. */</span>
	<span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RCP_HR_BIT</span> <span class="o">|</span> <span class="n">RCP_HC_BIT</span><span class="p">);</span>
	<span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RCP_ACC_BITS</span> <span class="o">|</span> <span class="n">RCP_FP_BIT</span><span class="p">);</span>
	<span class="cm">/* Copy page access key and fetch protection bit to pgste */</span>
	<span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">|=</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">skey</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_PAGE_ACC_BITS</span> <span class="o">|</span> <span class="n">_PAGE_FP_BIT</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">56</span><span class="p">;</span>
	<span class="cm">/* Transfer changed and referenced to kvm user bits */</span>
	<span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">|=</span> <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">45</span><span class="p">;</span>		<span class="cm">/* KVM_UR_BIT &amp; KVM_UC_BIT */</span>
	<span class="cm">/* Transfer changed &amp; referenced to pte sofware bits */</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">|=</span> <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* _PAGE_SWR &amp; _PAGE_SWC */</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">pgste</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgste_t</span> <span class="nf">pgste_update_young</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="kt">int</span> <span class="n">young</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pgste</span><span class="p">;</span>
	<span class="n">young</span> <span class="o">=</span> <span class="n">page_reset_referenced</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>
	<span class="cm">/* Transfer page referenced bit to pte software bit (host view) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">young</span> <span class="o">||</span> <span class="p">(</span><span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RCP_HR_BIT</span><span class="p">))</span>
		<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_SWR</span><span class="p">;</span>
	<span class="cm">/* Clear host referenced bit in pgste. */</span>
	<span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RCP_HR_BIT</span><span class="p">;</span>
	<span class="cm">/* Transfer page referenced bit to guest bit in pgste */</span>
	<span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">young</span> <span class="o">&lt;&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="cm">/* set RCP_GR_BIT */</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">pgste</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pgste_set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">okey</span><span class="p">,</span> <span class="n">nkey</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">address</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">okey</span> <span class="o">=</span> <span class="n">nkey</span> <span class="o">=</span> <span class="n">page_get_storage_key</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="n">nkey</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">_PAGE_ACC_BITS</span> <span class="o">|</span> <span class="n">_PAGE_FP_BIT</span><span class="p">);</span>
	<span class="cm">/* Set page access key and fetch protection bit from pgste */</span>
	<span class="n">nkey</span> <span class="o">|=</span> <span class="p">(</span><span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RCP_ACC_BITS</span> <span class="o">|</span> <span class="n">RCP_FP_BIT</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">okey</span> <span class="o">!=</span> <span class="n">nkey</span><span class="p">)</span>
		<span class="n">page_set_storage_key</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">nkey</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct gmap_struct - guest address space</span>
<span class="cm"> * @mm: pointer to the parent mm_struct</span>
<span class="cm"> * @table: pointer to the page directory</span>
<span class="cm"> * @asce: address space control element for gmap page table</span>
<span class="cm"> * @crst_list: list of all crst tables used in the guest address space</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gmap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">asce</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">crst_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct gmap_rmap - reverse mapping for segment table entries</span>
<span class="cm"> * @next: pointer to the next gmap_rmap structure in the list</span>
<span class="cm"> * @entry: pointer to a segment table entry</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gmap_rmap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct gmap_pgtable - gmap information attached to a page table</span>
<span class="cm"> * @vmaddr: address of the 1MB segment in the process virtual memory</span>
<span class="cm"> * @mapper: list of segment table entries maping a page table</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gmap_pgtable</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vmaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mapper</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">gmap</span> <span class="o">*</span><span class="n">gmap_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gmap_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">gmap</span> <span class="o">*</span><span class="n">gmap</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gmap_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">gmap</span> <span class="o">*</span><span class="n">gmap</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gmap_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">gmap</span> <span class="o">*</span><span class="n">gmap</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">gmap_map_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">gmap</span> <span class="o">*</span><span class="n">gmap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">gmap_unmap_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">gmap</span> <span class="o">*</span><span class="n">gmap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__gmap_fault</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gmap</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gmap_fault</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gmap</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gmap_discard</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gmap</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Certain architectures need to do special things when PTEs</span>
<span class="cm"> * within a page table are directly modified.  Thus, the following</span>
<span class="cm"> * hook is made available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_pte_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			      <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
		<span class="n">pgste_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * query functions pte_write/pte_dirty/pte_young only work if</span>
<span class="cm"> * pte_present() is true. Undefined behaviour if not..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_write</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_RO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_dirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SWC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_young</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SWR</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pgd/pmd/pte modification functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pgd_clear</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pgd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">_REGION_ENTRY_TYPE_R2</span><span class="p">)</span>
		<span class="n">pgd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span> <span class="o">=</span> <span class="n">_REGION2_ENTRY_EMPTY</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pud_clear</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pud_val</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">_REGION_ENTRY_TYPE_R3</span><span class="p">)</span>
		<span class="n">pud_val</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)</span> <span class="o">=</span> <span class="n">_REGION3_ENTRY_EMPTY</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmd_clear</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pmdp</span><span class="p">)</span> <span class="o">=</span> <span class="n">_SEGMENT_ENTRY_EMPTY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pte_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">=</span> <span class="n">_PAGE_TYPE_EMPTY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following pte modification functions only work if</span>
<span class="cm"> * pte_present() is true. Undefined behaviour if not..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="n">_PAGE_CHG_MASK</span><span class="p">;</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">newprot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_wrprotect</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Do not clobber _PAGE_TYPE_NONE pages!  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_INVALID</span><span class="p">))</span>
		<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_RO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkwrite</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_RO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkclean</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_SWC</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkdirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkold</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PGSTE</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_SWR</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkyoung</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkspecial</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_SPECIAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkhuge</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * PROT_NONE needs to be remapped from the pte type to the ste type.</span>
<span class="cm">	 * The HW invalid bit is also different for pte and ste. The pte</span>
<span class="cm">	 * invalid bit happens to be the same as the ste _SEGMENT_ENTRY_LARGE</span>
<span class="cm">	 * bit, so we don&#39;t have to clear it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_INVALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SWT</span><span class="p">)</span>
			<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_HPAGE_TYPE_NONE</span><span class="p">;</span>
		<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_SEGMENT_ENTRY_INV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear SW pte bits SWT and SWX, there are no SW bits in a segment</span>
<span class="cm">	 * table entry.</span>
<span class="cm">	 */</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">_PAGE_SWT</span> <span class="o">|</span> <span class="n">_PAGE_SWX</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Also set the change-override bit because we don&#39;t need dirty bit</span>
<span class="cm">	 * tracking for hugetlbfs pages.</span>
<span class="cm">	 */</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="p">(</span><span class="n">_SEGMENT_ENTRY_LARGE</span> <span class="o">|</span> <span class="n">_SEGMENT_ENTRY_CO</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Get (and clear) the user dirty bit for a pte.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ptep_test_and_clear_user_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
						 <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_update_all</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">KVM_UC_BIT</span><span class="p">);</span>
		<span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KVM_UC_BIT</span><span class="p">;</span>
		<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dirty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get (and clear) the user referenced bit for a pte.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ptep_test_and_clear_user_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
						 <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">young</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_update_young</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
		<span class="n">young</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">KVM_UR_BIT</span><span class="p">);</span>
		<span class="n">pgste_val</span><span class="p">(</span><span class="n">pgste</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KVM_UR_BIT</span><span class="p">;</span>
		<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">young</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ptep_test_and_clear_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_update_young</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_mkold</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
		<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">pte_young</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTEP_CLEAR_YOUNG_FLUSH</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ptep_clear_flush_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* No need to flush TLB</span>
<span class="cm">	 * On s390 reference bits are in storage key and never in TLB</span>
<span class="cm">	 * With virtualization we handle the reference bit, without we</span>
<span class="cm">	 * we can simply return */</span>
	<span class="k">return</span> <span class="n">ptep_test_and_clear_young</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__ptep_ipte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_INVALID</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
		<span class="cm">/* pto must point to the start of the segment table */</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pto</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7ffffc00</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="cm">/* ipte in zarch mode can do the math */</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pto</span> <span class="o">=</span> <span class="n">ptep</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
			<span class="s">&quot;	ipte	%2,%3&quot;</span>
			<span class="o">:</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">),</span>
			  <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="n">pto</span><span class="p">),</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="n">address</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is hard to understand. ptep_get_and_clear and ptep_clear_flush</span>
<span class="cm"> * both clear the TLB for the unmapped pte. The reason is that</span>
<span class="cm"> * ptep_get_and_clear is used in common code (e.g. change_pte_range)</span>
<span class="cm"> * to modify an active pte. The sequence is</span>
<span class="cm"> *   1) ptep_get_and_clear</span>
<span class="cm"> *   2) set_pte_at</span>
<span class="cm"> *   3) flush_tlb_range</span>
<span class="cm"> * On s390 the tlb needs to get flushed with the modification of the pte</span>
<span class="cm"> * if the pte is active. The only way how this can be implemented is to</span>
<span class="cm"> * have ptep_get_and_clear do the tlb flush. In exchange flush_tlb_range</span>
<span class="cm"> * is a nop.</span>
<span class="cm"> */</span>
<span class="cp">#define __HAVE_ARCH_PTEP_GET_AND_CLEAR</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_get_and_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">flush_mm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_exclusive</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">__ptep_ipte</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">=</span> <span class="n">_PAGE_TYPE_EMPTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_update_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
		<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_modify_prot_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					   <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">flush_mm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_exclusive</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">__ptep_ipte</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptep_modify_prot_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					   <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">pgste_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">ptep</span> <span class="o">+</span> <span class="n">PTRS_PER_PTE</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTEP_CLEAR_FLUSH</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_clear_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">))</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">__ptep_ipte</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">=</span> <span class="n">_PAGE_TYPE_EMPTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_update_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
		<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The batched pte unmap code uses ptep_get_and_clear_full to clear the</span>
<span class="cm"> * ptes. Here an optimization is possible. tlb_gather_mmu flushes all</span>
<span class="cm"> * tlbs of an mm if it can guarantee that the ptes of the mm_struct</span>
<span class="cm"> * cannot be accessed while the batched unmap is running. In this case</span>
<span class="cm"> * full==1 and a simple pte_clear is enough. See tlb.h.</span>
<span class="cm"> */</span>
<span class="cp">#define __HAVE_ARCH_PTEP_GET_AND_CLEAR_FULL</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_get_and_clear_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					    <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">full</span><span class="p">)</span>
		<span class="n">__ptep_ipte</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">=</span> <span class="n">_PAGE_TYPE_EMPTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_update_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
		<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTEP_SET_WRPROTECT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte_write</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">flush_mm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
			<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_exclusive</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
			<span class="n">__ptep_ipte</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
			<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ptep_set_access_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span>
					<span class="n">pte_t</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgste_t</span> <span class="n">pgste</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">))</span>
		<span class="n">pgste</span> <span class="o">=</span> <span class="n">pgste_get_lock</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>

	<span class="n">__ptep_ipte</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_pgste</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">))</span>
		<span class="n">pgste_set_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pgste</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Conversion functions: convert a page and protection to a page entry,</span>
<span class="cm"> * and a page entry and page directory to the page they refer to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">mk_pte_phys</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physpage</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">__pte</span><span class="p">;</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">__pte</span><span class="p">)</span> <span class="o">=</span> <span class="n">physpage</span> <span class="o">+</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">pgprot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">mk_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physpage</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mk_pte_phys</span><span class="p">(</span><span class="n">physpage</span><span class="p">,</span> <span class="n">pgprot</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define pgd_index(address) (((address) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))</span>
<span class="cp">#define pud_index(address) (((address) &gt;&gt; PUD_SHIFT) &amp; (PTRS_PER_PUD-1))</span>
<span class="cp">#define pmd_index(address) (((address) &gt;&gt; PMD_SHIFT) &amp; (PTRS_PER_PMD-1))</span>
<span class="cp">#define pte_index(address) (((address) &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE-1))</span>

<span class="cp">#define pgd_offset(mm, address) ((mm)-&gt;pgd + pgd_index(address))</span>
<span class="cp">#define pgd_offset_k(address) pgd_offset(&amp;init_mm, address)</span>

<span class="cp">#ifndef CONFIG_64BIT</span>

<span class="cp">#define pmd_deref(pmd) (pmd_val(pmd) &amp; _SEGMENT_ENTRY_ORIGIN)</span>
<span class="cp">#define pud_deref(pmd) ({ BUG(); 0UL; })</span>
<span class="cp">#define pgd_deref(pmd) ({ BUG(); 0UL; })</span>

<span class="cp">#define pud_offset(pgd, address) ((pud_t *) pgd)</span>
<span class="cp">#define pmd_offset(pud, address) ((pmd_t *) pud + pmd_index(address))</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cp">#define pmd_deref(pmd) (pmd_val(pmd) &amp; _SEGMENT_ENTRY_ORIGIN)</span>
<span class="cp">#define pud_deref(pud) (pud_val(pud) &amp; _REGION_ENTRY_ORIGIN)</span>
<span class="cp">#define pgd_deref(pgd) (pgd_val(pgd) &amp; _REGION_ENTRY_ORIGIN)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pud_t</span> <span class="o">*</span><span class="nf">pud_offset</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span> <span class="o">=</span> <span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pgd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pgd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">_REGION_ENTRY_TYPE_R2</span><span class="p">)</span>
		<span class="n">pud</span> <span class="o">=</span> <span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pgd_deref</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pud</span>  <span class="o">+</span> <span class="n">pud_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="nf">pmd_offset</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pud</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pud_val</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_REGION_ENTRY_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">_REGION_ENTRY_TYPE_R3</span><span class="p">)</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pud_deref</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pmd</span> <span class="o">+</span> <span class="n">pmd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cp">#define pfn_pte(pfn,pgprot) mk_pte_phys(__pa((pfn) &lt;&lt; PAGE_SHIFT),(pgprot))</span>
<span class="cp">#define pte_pfn(x) (pte_val(x) &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define pte_page(x) pfn_to_page(pte_pfn(x))</span>

<span class="cp">#define pmd_page(pmd) pfn_to_page(pmd_val(pmd) &gt;&gt; PAGE_SHIFT)</span>

<span class="cm">/* Find an entry in the lowest level page table.. */</span>
<span class="cp">#define pte_offset(pmd, addr) ((pte_t *) pmd_deref(*(pmd)) + pte_index(addr))</span>
<span class="cp">#define pte_offset_kernel(pmd, address) pte_offset(pmd,address)</span>
<span class="cp">#define pte_offset_map(pmd, address) pte_offset_kernel(pmd, address)</span>
<span class="cp">#define pte_unmap(pte) do { } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * 31 bit swap entry format:</span>
<span class="cm"> * A page-table entry has some bits we have to treat in a special way.</span>
<span class="cm"> * Bits 0, 20 and bit 23 have to be zero, otherwise an specification</span>
<span class="cm"> * exception will occur instead of a page translation exception. The</span>
<span class="cm"> * specifiation exception has the bad habit not to store necessary</span>
<span class="cm"> * information in the lowcore.</span>
<span class="cm"> * Bit 21 and bit 22 are the page invalid bit and the page protection</span>
<span class="cm"> * bit. We set both to indicate a swapped page.</span>
<span class="cm"> * Bit 30 and 31 are used to distinguish the different page types. For</span>
<span class="cm"> * a swapped page these bits need to be zero.</span>
<span class="cm"> * This leaves the bits 1-19 and bits 24-29 to store type and offset.</span>
<span class="cm"> * We use the 5 bits from 25-29 for the type and the 20 bits from 1-19</span>
<span class="cm"> * plus 24 for the offset.</span>
<span class="cm"> * 0|     offset        |0110|o|type |00|</span>
<span class="cm"> * 0 0000000001111111111 2222 2 22222 33</span>
<span class="cm"> * 0 1234567890123456789 0123 4 56789 01</span>
<span class="cm"> *</span>
<span class="cm"> * 64 bit swap entry format:</span>
<span class="cm"> * A page-table entry has some bits we have to treat in a special way.</span>
<span class="cm"> * Bits 52 and bit 55 have to be zero, otherwise an specification</span>
<span class="cm"> * exception will occur instead of a page translation exception. The</span>
<span class="cm"> * specifiation exception has the bad habit not to store necessary</span>
<span class="cm"> * information in the lowcore.</span>
<span class="cm"> * Bit 53 and bit 54 are the page invalid bit and the page protection</span>
<span class="cm"> * bit. We set both to indicate a swapped page.</span>
<span class="cm"> * Bit 62 and 63 are used to distinguish the different page types. For</span>
<span class="cm"> * a swapped page these bits need to be zero.</span>
<span class="cm"> * This leaves the bits 0-51 and bits 56-61 to store type and offset.</span>
<span class="cm"> * We use the 5 bits from 57-61 for the type and the 53 bits from 0-51</span>
<span class="cm"> * plus 56 for the offset.</span>
<span class="cm"> * |                      offset                        |0110|o|type |00|</span>
<span class="cm"> *  0000000000111111111122222222223333333333444444444455 5555 5 55566 66</span>
<span class="cm"> *  0123456789012345678901234567890123456789012345678901 2345 6 78901 23</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="cp">#define __SWP_OFFSET_MASK (~0UL &gt;&gt; 12)</span>
<span class="cp">#else</span>
<span class="cp">#define __SWP_OFFSET_MASK (~0UL &gt;&gt; 11)</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">mk_swap_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">&amp;=</span> <span class="n">__SWP_OFFSET_MASK</span><span class="p">;</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="n">_PAGE_TYPE_SWAP</span> <span class="o">|</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mi">1UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __swp_type(entry)	(((entry).val &gt;&gt; 2) &amp; 0x1f)</span>
<span class="cp">#define __swp_offset(entry)	(((entry).val &gt;&gt; 11) | (((entry).val &gt;&gt; 7) &amp; 1))</span>
<span class="cp">#define __swp_entry(type,offset) ((swp_entry_t) { pte_val(mk_swap_pte((type),(offset))) })</span>

<span class="cp">#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })</span>
<span class="cp">#define __swp_entry_to_pte(x)	((pte_t) { (x).val })</span>

<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="cp"># define PTE_FILE_MAX_BITS	26</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>
<span class="cp"># define PTE_FILE_MAX_BITS	59</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cp">#define pte_to_pgoff(__pte) \</span>
<span class="cp">	((((__pte).pte &gt;&gt; 12) &lt;&lt; 7) + (((__pte).pte &gt;&gt; 1) &amp; 0x7f))</span>

<span class="cp">#define pgoff_to_pte(__off) \</span>
<span class="cp">	((pte_t) { ((((__off) &amp; 0x7f) &lt;&lt; 1) + (((__off) &gt;&gt; 7) &lt;&lt; 12)) \</span>
<span class="cp">		   | _PAGE_TYPE_FILE })</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define kern_addr_valid(addr)   (1)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmem_add_mapping</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmem_remove_mapping</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">s390_enable_sie</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * No page table caches to initialise</span>
<span class="cm"> */</span>
<span class="cp">#define pgtable_cache_init()	do { } while (0)</span>

<span class="cp">#include &lt;asm-generic/pgtable.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* _S390_PAGE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
