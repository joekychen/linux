<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › s390 › kernel › time.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>time.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  arch/s390/kernel/time.c</span>
<span class="cm"> *    Time of day based timer functions.</span>
<span class="cm"> *</span>
<span class="cm"> *  S390 version</span>
<span class="cm"> *    Copyright IBM Corp. 1999, 2008</span>
<span class="cm"> *    Author(s): Hartmut Penner (hp@de.ibm.com),</span>
<span class="cm"> *               Martin Schwidefsky (schwidefsky@de.ibm.com),</span>
<span class="cm"> *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)</span>
<span class="cm"> *</span>
<span class="cm"> *  Derived from &quot;arch/i386/kernel/time.c&quot;</span>
<span class="cm"> *    Copyright (C) 1991, 1992, 1995  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#define KMSG_COMPONENT &quot;time&quot;</span>
<span class="cp">#define pr_fmt(fmt) KMSG_COMPONENT &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/param.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/stop_machine.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &lt;asm/vdso.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>
<span class="cp">#include &lt;asm/timer.h&gt;</span>
<span class="cp">#include &lt;asm/etr.h&gt;</span>
<span class="cp">#include &lt;asm/cio.h&gt;</span>
<span class="cp">#include &quot;entry.h&quot;</span>

<span class="cm">/* change this if you have some constant time drift */</span>
<span class="cp">#define USECS_PER_JIFFY     ((unsigned long) 1000000/HZ)</span>
<span class="cp">#define CLK_TICKS_PER_JIFFY ((unsigned long) USECS_PER_JIFFY &lt;&lt; 12)</span>

<span class="n">u64</span> <span class="n">sched_clock_base_cc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Force to data section. */</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_clock_base_cc</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span><span class="p">,</span> <span class="n">comparators</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Scheduler clock - returns current time in nanosec units.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">notrace</span> <span class="n">__kprobes</span> <span class="nf">sched_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">get_clock_monotonic</span><span class="p">()</span> <span class="o">*</span> <span class="mi">125</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Monotonic_clock - returns # of nanoseconds passed since time_init()</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">monotonic_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sched_clock</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">monotonic_clock</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tod_to_timeval</span><span class="p">(</span><span class="n">__u64</span> <span class="n">todval</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">xt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sec</span><span class="p">;</span>

	<span class="n">sec</span> <span class="o">=</span> <span class="n">todval</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">);</span>
	<span class="n">xt</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sec</span><span class="p">;</span>
	<span class="n">todval</span> <span class="o">-=</span> <span class="p">(</span><span class="n">sec</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">xt</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="p">((</span><span class="n">todval</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tod_to_timeval</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">clock_comparator_work</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">cd</span><span class="p">;</span>

	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1ULL</span><span class="p">;</span>
	<span class="n">set_clock_comparator</span><span class="p">(</span><span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span><span class="p">);</span>
	<span class="n">cd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">comparators</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fixup the clock comparator.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_clock_comparator</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If nobody is waiting there&#39;s nothing to fix. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1ULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">set_clock_comparator</span><span class="p">(</span><span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s390_next_ktime</span><span class="p">(</span><span class="n">ktime_t</span> <span class="n">expires</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">nsecs</span><span class="p">;</span>

	<span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">monotonic_to_bootbased</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="n">nsecs</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_add</span><span class="p">(</span><span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">expires</span><span class="p">));</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">nsecs</span><span class="p">,</span> <span class="mi">125</span><span class="p">);</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span> <span class="o">=</span> <span class="n">sched_clock_base_cc</span> <span class="o">+</span> <span class="p">(</span><span class="n">nsecs</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">set_clock_comparator</span><span class="p">(</span><span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">s390_set_mode</span><span class="p">(</span><span class="k">enum</span> <span class="n">clock_event_mode</span> <span class="n">mode</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up lowcore and control register of the current cpu to</span>
<span class="cm"> * enable TOD clock and clock comparator interrupts.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">init_cpu_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">cd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1ULL</span><span class="p">;</span>
	<span class="n">set_clock_comparator</span><span class="p">(</span><span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">cd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">comparators</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;comparator&quot;</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">features</span>		<span class="o">=</span> <span class="n">CLOCK_EVT_FEAT_ONESHOT</span> <span class="o">|</span>
				  <span class="n">CLOCK_EVT_FEAT_KTIME</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">mult</span>		<span class="o">=</span> <span class="mi">16777</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">shift</span>		<span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">max_delta_ns</span>	<span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">rating</span>		<span class="o">=</span> <span class="mi">400</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">cpumask</span>		<span class="o">=</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">set_next_ktime</span>	<span class="o">=</span> <span class="n">s390_next_ktime</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">set_mode</span>		<span class="o">=</span> <span class="n">s390_set_mode</span><span class="p">;</span>

	<span class="n">clockevents_register_device</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>

	<span class="cm">/* Enable clock comparator timer interrupt. */</span>
	<span class="n">__ctl_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">11</span><span class="p">);</span>

	<span class="cm">/* Always allow the timing alert external interrupt. */</span>
	<span class="n">__ctl_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clock_comparator_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext_code</span> <span class="n">ext_code</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">param32</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kstat_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()).</span><span class="n">irqs</span><span class="p">[</span><span class="n">EXTINT_CLK</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1ULL</span><span class="p">)</span>
		<span class="n">set_clock_comparator</span><span class="p">(</span><span class="n">S390_lowcore</span><span class="p">.</span><span class="n">clock_comparator</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">etr_timing_alert</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_irq_parm</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">stp_timing_alert</span><span class="p">(</span><span class="k">struct</span> <span class="n">stp_irq_parm</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">timing_alert_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext_code</span> <span class="n">ext_code</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">param32</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kstat_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()).</span><span class="n">irqs</span><span class="p">[</span><span class="n">EXTINT_TLA</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param32</span> <span class="o">&amp;</span> <span class="mh">0x00c40000</span><span class="p">)</span>
		<span class="n">etr_timing_alert</span><span class="p">((</span><span class="k">struct</span> <span class="n">etr_irq_parm</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">param32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param32</span> <span class="o">&amp;</span> <span class="mh">0x00038000</span><span class="p">)</span>
		<span class="n">stp_timing_alert</span><span class="p">((</span><span class="k">struct</span> <span class="n">stp_irq_parm</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">param32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">etr_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">stp_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">read_persistent_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tod_to_timeval</span><span class="p">(</span><span class="n">get_clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">TOD_UNIX_EPOCH</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_boot_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tod_to_timeval</span><span class="p">(</span><span class="n">sched_clock_base_cc</span> <span class="o">-</span> <span class="n">TOD_UNIX_EPOCH</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">cycle_t</span> <span class="nf">read_tod_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_clock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="n">clocksource_tod</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;tod&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span>		<span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">read_tod_clock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1ULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mult</span>		<span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shift</span>		<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">clocksource_default_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">clocksource_tod</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">update_vsyscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">wall_time</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">wtm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mult</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clock</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">clocksource_tod</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Make userspace gettimeofday spin until we&#39;re done. */</span>
	<span class="o">++</span><span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">tb_update_count</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">xtime_tod_stamp</span> <span class="o">=</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">cycle_last</span><span class="p">;</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">xtime_clock_sec</span> <span class="o">=</span> <span class="n">wall_time</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">xtime_clock_nsec</span> <span class="o">=</span> <span class="n">wall_time</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">wtom_clock_sec</span> <span class="o">=</span> <span class="n">wtm</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">wtom_clock_nsec</span> <span class="o">=</span> <span class="n">wtm</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">ntp_mult</span> <span class="o">=</span> <span class="n">mult</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="o">++</span><span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">tb_update_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="n">sys_tz</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">update_vsyscall_tz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Make userspace gettimeofday spin until we&#39;re done. */</span>
	<span class="o">++</span><span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">tb_update_count</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">tz_minuteswest</span> <span class="o">=</span> <span class="n">sys_tz</span><span class="p">.</span><span class="n">tz_minuteswest</span><span class="p">;</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">tz_dsttime</span> <span class="o">=</span> <span class="n">sys_tz</span><span class="p">.</span><span class="n">tz_dsttime</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="o">++</span><span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">tb_update_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the TOD clock and the CPU timer of</span>
<span class="cm"> * the boot cpu.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">time_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Reset time synchronization interfaces. */</span>
	<span class="n">etr_reset</span><span class="p">();</span>
	<span class="n">stp_reset</span><span class="p">();</span>

	<span class="cm">/* request the clock comparator external interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_external_interrupt</span><span class="p">(</span><span class="mh">0x1004</span><span class="p">,</span> <span class="n">clock_comparator_interrupt</span><span class="p">))</span>
                <span class="n">panic</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t request external interrupt 0x1004&quot;</span><span class="p">);</span>

	<span class="cm">/* request the timing alert external interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_external_interrupt</span><span class="p">(</span><span class="mh">0x1406</span><span class="p">,</span> <span class="n">timing_alert_interrupt</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t request external interrupt 0x1406&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clocksource_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_tod</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Could not register TOD clock source&quot;</span><span class="p">);</span>

	<span class="cm">/* Enable TOD clock interrupts on the boot cpu. */</span>
	<span class="n">init_cpu_timer</span><span class="p">();</span>

	<span class="cm">/* Enable cpu timer interrupts on the boot cpu. */</span>
	<span class="n">vtime_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The time is &quot;clock&quot;. old is what we think the time is.</span>
<span class="cm"> * Adjust the value by a multiple of jiffies and add the delta to ntp.</span>
<span class="cm"> * &quot;delay&quot; is an approximation how long the synchronization took. If</span>
<span class="cm"> * the time correction is positive, then &quot;delay&quot; is subtracted from</span>
<span class="cm"> * the time difference and only the remaining part is passed to ntp.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">adjust_time</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">old</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">clock</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="n">ticks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timex</span> <span class="n">adjust</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clock</span> <span class="o">&gt;</span> <span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* It is later than we thought. */</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">ticks</span> <span class="o">=</span> <span class="n">clock</span> <span class="o">-</span> <span class="n">old</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">ticks</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">delay</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">delta</span> <span class="o">-</span> <span class="n">delay</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">-=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">ticks</span><span class="p">,</span> <span class="n">CLK_TICKS_PER_JIFFY</span><span class="p">);</span>
		<span class="n">adjust</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ticks</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* It is earlier than we thought. */</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">ticks</span> <span class="o">=</span> <span class="n">old</span> <span class="o">-</span> <span class="n">clock</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">-=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">ticks</span><span class="p">,</span> <span class="n">CLK_TICKS_PER_JIFFY</span><span class="p">);</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span>
		<span class="n">adjust</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">ticks</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sched_clock_base_cc</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adjust</span><span class="p">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;The ETR interface has adjusted the clock &quot;</span>
			  <span class="s">&quot;by %li microseconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adjust</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">adjust</span><span class="p">.</span><span class="n">modes</span> <span class="o">=</span> <span class="n">ADJ_OFFSET_SINGLESHOT</span><span class="p">;</span>
		<span class="n">do_adjtimex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjust</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">atomic_t</span><span class="p">,</span> <span class="n">clock_sync_word</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">clock_sync_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clock_sync_flags</span><span class="p">;</span>

<span class="cp">#define CLOCK_SYNC_HAS_ETR	0</span>
<span class="cp">#define CLOCK_SYNC_HAS_STP	1</span>
<span class="cp">#define CLOCK_SYNC_ETR		2</span>
<span class="cp">#define CLOCK_SYNC_STP		3</span>

<span class="cm">/*</span>
<span class="cm"> * The synchronous get_clock function. It will write the current clock</span>
<span class="cm"> * value to the clock pointer and return 0 if the clock is in sync with</span>
<span class="cm"> * the external time source. If the clock mode is local it will return</span>
<span class="cm"> * -ENOSYS and -EAGAIN if the clock is not in sync with the external</span>
<span class="cm"> * reference.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">get_sync_clock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">clock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">sw_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sw0</span><span class="p">,</span> <span class="n">sw1</span><span class="p">;</span>

	<span class="n">sw_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">clock_sync_word</span><span class="p">);</span>
	<span class="n">sw0</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="n">sw_ptr</span><span class="p">);</span>
	<span class="o">*</span><span class="n">clock</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
	<span class="n">sw1</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="n">sw_ptr</span><span class="p">);</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">clock_sync_word</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw0</span> <span class="o">==</span> <span class="n">sw1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sw0</span> <span class="o">&amp;</span> <span class="mh">0x80000000U</span><span class="p">))</span>
		<span class="cm">/* Success: time is in sync. */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_HAS_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_HAS_STP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_STP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_sync_clock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Make get_sync_clock return -EAGAIN.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_sync_clock</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">sw_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">clock_sync_word</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear the in-sync bit 2^31. All get_sync_clock calls will</span>
<span class="cm">	 * fail until the sync bit is turned back on. In addition</span>
<span class="cm">	 * increase the &quot;sequence&quot; counter to avoid the race of an</span>
<span class="cm">	 * etr event and the complete recovery against get_sync_clock.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_clear_mask</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="n">sw_ptr</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="n">sw_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make get_sync_clock return 0 again.</span>
<span class="cm"> * Needs to be called from a context disabled for preemption.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_sync_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">sw_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">clock_sync_word</span><span class="p">);</span>
	<span class="n">atomic_set_mask</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="n">sw_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function to check if the clock is in sync.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_sync_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">sw_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">sw_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">clock_sync_word</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="n">sw_ptr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80000000U</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">clock_sync_word</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Single threaded workqueue used for etr and stp sync events */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">time_sync_wq</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">time_init_wq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_sync_wq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">time_sync_wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;timesync&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * External Time Reference (ETR) code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">etr_port0_online</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">etr_port1_online</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">etr_steai_available</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_parse_etr</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">etr_port0_online</span> <span class="o">=</span> <span class="n">etr_port1_online</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;port0&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">etr_port0_online</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;port1&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">etr_port1_online</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">etr_port0_online</span> <span class="o">=</span> <span class="n">etr_port1_online</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;etr&quot;</span><span class="p">,</span> <span class="n">early_parse_etr</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">etr_event</span> <span class="p">{</span>
	<span class="n">ETR_EVENT_PORT0_CHANGE</span><span class="p">,</span>
	<span class="n">ETR_EVENT_PORT1_CHANGE</span><span class="p">,</span>
	<span class="n">ETR_EVENT_PORT_ALERT</span><span class="p">,</span>
	<span class="n">ETR_EVENT_SYNC_CHECK</span><span class="p">,</span>
	<span class="n">ETR_EVENT_SWITCH_LOCAL</span><span class="p">,</span>
	<span class="n">ETR_EVENT_UPDATE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Valid bit combinations of the eacr register are (x = don&#39;t care):</span>
<span class="cm"> * e0 e1 dp p0 p1 ea es sl</span>
<span class="cm"> *  0  0  x  0	0  0  0  0  initial, disabled state</span>
<span class="cm"> *  0  0  x  0	1  1  0  0  port 1 online</span>
<span class="cm"> *  0  0  x  1	0  1  0  0  port 0 online</span>
<span class="cm"> *  0  0  x  1	1  1  0  0  both ports online</span>
<span class="cm"> *  0  1  x  0	1  1  0  0  port 1 online and usable, ETR or PPS mode</span>
<span class="cm"> *  0  1  x  0	1  1  0  1  port 1 online, usable and ETR mode</span>
<span class="cm"> *  0  1  x  0	1  1  1  0  port 1 online, usable, PPS mode, in-sync</span>
<span class="cm"> *  0  1  x  0	1  1  1  1  port 1 online, usable, ETR mode, in-sync</span>
<span class="cm"> *  0  1  x  1	1  1  0  0  both ports online, port 1 usable</span>
<span class="cm"> *  0  1  x  1	1  1  1  0  both ports online, port 1 usable, PPS mode, in-sync</span>
<span class="cm"> *  0  1  x  1	1  1  1  1  both ports online, port 1 usable, ETR mode, in-sync</span>
<span class="cm"> *  1  0  x  1	0  1  0  0  port 0 online and usable, ETR or PPS mode</span>
<span class="cm"> *  1  0  x  1	0  1  0  1  port 0 online, usable and ETR mode</span>
<span class="cm"> *  1  0  x  1	0  1  1  0  port 0 online, usable, PPS mode, in-sync</span>
<span class="cm"> *  1  0  x  1	0  1  1  1  port 0 online, usable, ETR mode, in-sync</span>
<span class="cm"> *  1  0  x  1	1  1  0  0  both ports online, port 0 usable</span>
<span class="cm"> *  1  0  x  1	1  1  1  0  both ports online, port 0 usable, PPS mode, in-sync</span>
<span class="cm"> *  1  0  x  1	1  1  1  1  both ports online, port 0 usable, ETR mode, in-sync</span>
<span class="cm"> *  1  1  x  1	1  1  1  0  both ports online &amp; usable, ETR, in-sync</span>
<span class="cm"> *  1  1  x  1	1  1  1  1  both ports online &amp; usable, ETR, in-sync</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">etr_eacr</span> <span class="n">etr_eacr</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">etr_tolec</span><span class="p">;</span>			<span class="cm">/* time of last eacr update */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">etr_aib</span> <span class="n">etr_port0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">etr_port0_uptodate</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">etr_aib</span> <span class="n">etr_port1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">etr_port1_uptodate</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">etr_events</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">etr_timer</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">etr_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">etr_work_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">etr_work_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">etr_work</span><span class="p">,</span> <span class="n">etr_work_fn</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Reset ETR attachment.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">etr_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">etr_eacr</span> <span class="o">=</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">etr_eacr</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">e0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">e1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">_pad0</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">p1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">_pad1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">ea</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">etr_setr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_eacr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">etr_tolec</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_HAS_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_online</span> <span class="o">&amp;&amp;</span> <span class="n">etr_port1_online</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_online</span> <span class="o">||</span> <span class="n">etr_port1_online</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;The real or virtual hardware system does &quot;</span>
			   <span class="s">&quot;not provide an ETR interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">etr_port0_online</span> <span class="o">=</span> <span class="n">etr_port1_online</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">etr_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="n">aib</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_HAS_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">time_init_wq</span><span class="p">();</span>
	<span class="cm">/* Check if this machine has the steai instruction. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">etr_steai</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aib</span><span class="p">,</span> <span class="n">ETR_STEAI_STEPPING_PORT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">etr_steai_available</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_timer</span><span class="p">,</span> <span class="n">etr_timeout</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_online</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT0_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">etr_port1_online</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT1_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">arch_initcall</span><span class="p">(</span><span class="n">etr_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Two sorts of ETR machine checks. The architecture reads:</span>
<span class="cm"> * &quot;When a machine-check niterruption occurs and if a switch-to-local or</span>
<span class="cm"> *  ETR-sync-check interrupt request is pending but disabled, this pending</span>
<span class="cm"> *  disabled interruption request is indicated and is cleared&quot;.</span>
<span class="cm"> * Which means that we can get etr_switch_to_local events from the machine</span>
<span class="cm"> * check handler although the interruption condition is disabled. Lovely..</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Switch to local machine check. This is called when the last usable</span>
<span class="cm"> * ETR port goes inactive. After switch to local the clock is not in sync.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">etr_switch_to_local</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">etr_eacr</span><span class="p">.</span><span class="n">sl</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">disable_sync_clock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_SWITCH_LOCAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">etr_eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="n">etr_eacr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">etr_setr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_eacr</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ETR sync check machine check. This is called when the ETR OTE and the</span>
<span class="cm"> * local clock OTE are farther apart than the ETR sync check tolerance.</span>
<span class="cm"> * After a ETR sync check the clock is not in sync. The machine check</span>
<span class="cm"> * is broadcasted to all cpus at the same time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">etr_sync_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">etr_eacr</span><span class="p">.</span><span class="n">es</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">disable_sync_clock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_SYNC_CHECK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">etr_eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">etr_setr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_eacr</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ETR timing alert. There are two causes:</span>
<span class="cm"> * 1) port state change, check the usability of the port</span>
<span class="cm"> * 2) port alert, one of the ETR-data-validity bits (v1-v2 bits of the</span>
<span class="cm"> *    sldr-status word) or ETR-data word 1 (edf1) or ETR-data word 3 (edf3)</span>
<span class="cm"> *    or ETR-data word 4 (edf4) has changed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">etr_timing_alert</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_irq_parm</span> <span class="o">*</span><span class="n">intparm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intparm</span><span class="o">-&gt;</span><span class="n">pc0</span><span class="p">)</span>
		<span class="cm">/* ETR port 0 state change. */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT0_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intparm</span><span class="o">-&gt;</span><span class="n">pc1</span><span class="p">)</span>
		<span class="cm">/* ETR port 1 state change. */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT1_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intparm</span><span class="o">-&gt;</span><span class="n">eai</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * ETR port alert on either port 0, 1 or both.</span>
<span class="cm">		 * Both ports are not up-to-date now.</span>
<span class="cm">		 */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT_ALERT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">etr_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_UPDATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if the etr mode is pss.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">etr_mode_is_pps</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_eacr</span> <span class="n">eacr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">sl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if the etr mode is etr.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">etr_mode_is_etr</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_eacr</span> <span class="n">eacr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">&amp;&amp;</span> <span class="n">eacr</span><span class="p">.</span><span class="n">sl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if the port can be used for TOD synchronization.</span>
<span class="cm"> * For PPS mode the port has to receive OTEs. For ETR mode</span>
<span class="cm"> * the port has to receive OTEs, the ETR stepping bit has to</span>
<span class="cm"> * be zero and the validity bits for data frame 1, 2, and 3</span>
<span class="cm"> * have to be 1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">etr_port_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">psc</span><span class="p">;</span>

	<span class="cm">/* Check that this port is receiving OTEs. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">tsp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">psc</span> <span class="o">=</span> <span class="n">port</span> <span class="o">?</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">:</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psc</span> <span class="o">==</span> <span class="n">etr_lpsc_pps_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psc</span> <span class="o">==</span> <span class="n">etr_lpsc_operational_step</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v1</span> <span class="o">&amp;&amp;</span>
			<span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v2</span> <span class="o">&amp;&amp;</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v3</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if two ports are on the same network.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">etr_compare_network</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib2</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>FIXME: any other fields we have to compare?</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="n">aib1</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">net_id</span> <span class="o">==</span> <span class="n">aib2</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">net_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper for etr_stei that converts physical port states</span>
<span class="cm"> * to logical port states to be consistent with the output</span>
<span class="cm"> * of stetr (see etr_psc vs. etr_lpsc).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">etr_steai_cv</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">etr_steai</span><span class="p">(</span><span class="n">aib</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Convert port state to logical port state. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">p</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if the aib a2 is still connected to the same attachment as</span>
<span class="cm"> * aib a1, the etv values differ by one and a2 is valid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">etr_aib_follows</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">a1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">a2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">state_a1</span><span class="p">,</span> <span class="n">state_a2</span><span class="p">;</span>

	<span class="cm">/* Paranoia check: e0/e1 should better be the same. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a1</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">!=</span> <span class="n">a2</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">||</span>
	    <span class="n">a1</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">!=</span> <span class="n">a2</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">eacr</span><span class="p">.</span><span class="n">e1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Still connected to the same etr ? */</span>
	<span class="n">state_a1</span> <span class="o">=</span> <span class="n">p</span> <span class="o">?</span> <span class="n">a1</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">:</span> <span class="n">a1</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span><span class="p">;</span>
	<span class="n">state_a2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">?</span> <span class="n">a2</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">:</span> <span class="n">a2</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state_a1</span> <span class="o">==</span> <span class="n">etr_lpsc_operational_step</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state_a2</span> <span class="o">!=</span> <span class="n">etr_lpsc_operational_step</span> <span class="o">||</span>
		    <span class="n">a1</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">net_id</span> <span class="o">!=</span> <span class="n">a2</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">net_id</span> <span class="o">||</span>
		    <span class="n">a1</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">etr_id</span> <span class="o">!=</span> <span class="n">a2</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">etr_id</span> <span class="o">||</span>
		    <span class="n">a1</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">etr_pn</span> <span class="o">!=</span> <span class="n">a2</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">etr_pn</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state_a2</span> <span class="o">!=</span> <span class="n">etr_lpsc_pps_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The ETV value of a2 needs to be ETV of a1 + 1. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a1</span><span class="o">-&gt;</span><span class="n">edf2</span><span class="p">.</span><span class="n">etv</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">a2</span><span class="o">-&gt;</span><span class="n">edf2</span><span class="p">.</span><span class="n">etv</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">etr_port_valid</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">clock_sync_data</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">cpus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">in_sync</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">fixup_cc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">etr_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">etr_aib</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clock_sync_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_sync_data</span> <span class="o">*</span><span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">);</span>
	<span class="n">enable_sync_clock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * This looks like a busy wait loop but it isn&#39;t. etr_sync_cpus</span>
<span class="cm">	 * is called on all other cpus while the TOD clocks is stopped.</span>
<span class="cm">	 * __udelay will stop the cpu on an enabled wait psw until the</span>
<span class="cm">	 * TOD is running again.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * A different cpu changes *in_sync. Therefore use</span>
<span class="cm">		 * barrier() to force memory access.</span>
<span class="cm">		 */</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* Didn&#39;t work. Clear per-cpu in sync bit again. */</span>
		<span class="n">disable_sync_clock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This round of TOD syncing is done. Set the clock comparator</span>
<span class="cm">	 * to the next tick and let the processor continue.</span>
<span class="cm">	 */</span>
	<span class="n">fixup_clock_comparator</span><span class="p">(</span><span class="n">sync</span><span class="o">-&gt;</span><span class="n">fixup_cc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sync the TOD clock using the port referred to by aibp. This port</span>
<span class="cm"> * has to be enabled and the other port has to be disabled. The</span>
<span class="cm"> * last eacr update has to be more than 1.6 seconds in the past.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">etr_sync_clock</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">first</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">clock</span><span class="p">,</span> <span class="n">old_clock</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clock_sync_data</span> <span class="o">*</span><span class="n">etr_sync</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">sync_port</span><span class="p">,</span> <span class="o">*</span><span class="n">aib</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">etr_sync</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Slave */</span>
		<span class="n">clock_sync_cpu</span><span class="p">(</span><span class="n">etr_sync</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait until all other cpus entered the sync function. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_sync</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">etr_sync</span><span class="o">-&gt;</span><span class="n">etr_port</span><span class="p">;</span>
	<span class="n">aib</span> <span class="o">=</span> <span class="n">etr_sync</span><span class="o">-&gt;</span><span class="n">etr_aib</span><span class="p">;</span>
	<span class="n">sync_port</span> <span class="o">=</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">etr_port0</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">etr_port1</span><span class="p">;</span>
	<span class="n">enable_sync_clock</span><span class="p">();</span>

	<span class="cm">/* Set clock to next OTE. */</span>
	<span class="n">__ctl_set_bit</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
	<span class="n">__ctl_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">29</span><span class="p">);</span>
	<span class="n">clock</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">edf2</span><span class="p">.</span><span class="n">etv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">old_clock</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_clock</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* Wait for the clock to start. */</span>
		<span class="n">__ctl_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">29</span><span class="p">);</span>
		<span class="n">__ctl_clear_bit</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
		<span class="n">etr_stetr</span><span class="p">(</span><span class="n">aib</span><span class="p">);</span>
		<span class="cm">/* Adjust Linux timing variables. */</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			<span class="p">(</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">edf2</span><span class="p">.</span><span class="n">etv</span> <span class="o">-</span> <span class="n">sync_port</span><span class="o">-&gt;</span><span class="n">edf2</span><span class="p">.</span><span class="n">etv</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">adjust_time</span><span class="p">(</span><span class="n">old_clock</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
		<span class="n">etr_sync</span><span class="o">-&gt;</span><span class="n">fixup_cc</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">fixup_clock_comparator</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
		<span class="cm">/* Verify that the clock is properly set. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">etr_aib_follows</span><span class="p">(</span><span class="n">sync_port</span><span class="p">,</span> <span class="n">aib</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Didn&#39;t work. */</span>
			<span class="n">disable_sync_clock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
			<span class="n">etr_sync</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">etr_sync</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Could not set the clock ?!? */</span>
		<span class="n">__ctl_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">29</span><span class="p">);</span>
		<span class="n">__ctl_clear_bit</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
		<span class="n">disable_sync_clock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="n">etr_sync</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">etr_sync_clock_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_sync_data</span> <span class="n">etr_sync</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">sync_port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">follows</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Check if the current aib is adjacent to the sync port aib. */</span>
	<span class="n">sync_port</span> <span class="o">=</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">etr_port0</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">etr_port1</span><span class="p">;</span>
	<span class="n">follows</span> <span class="o">=</span> <span class="n">etr_aib_follows</span><span class="p">(</span><span class="n">sync_port</span><span class="p">,</span> <span class="n">aib</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sync_port</span><span class="p">,</span> <span class="n">aib</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">aib</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">follows</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_sync</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">etr_sync</span><span class="p">));</span>
	<span class="n">etr_sync</span><span class="p">.</span><span class="n">etr_aib</span> <span class="o">=</span> <span class="n">aib</span><span class="p">;</span>
	<span class="n">etr_sync</span><span class="p">.</span><span class="n">etr_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_sync</span><span class="p">.</span><span class="n">cpus</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">stop_machine</span><span class="p">(</span><span class="n">etr_sync_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_sync</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle the immediate effects of the different events.</span>
<span class="cm"> * The port change event is used for online/offline changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">etr_eacr</span> <span class="nf">etr_handle_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_eacr</span> <span class="n">eacr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">ETR_EVENT_SYNC_CHECK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">))</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">ETR_EVENT_SWITCH_LOCAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">))</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="n">eacr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT_ALERT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">))</span>
		<span class="n">etr_port0_uptodate</span> <span class="o">=</span> <span class="n">etr_port1_uptodate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT0_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">e0</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * Port change of an enabled port. We have to</span>
<span class="cm">			 * assume that this can have caused an stepping</span>
<span class="cm">			 * port switch.</span>
<span class="cm">			 */</span>
			<span class="n">etr_tolec</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">p0</span> <span class="o">=</span> <span class="n">etr_port0_online</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">p0</span><span class="p">)</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">etr_port0_uptodate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT1_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">e1</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * Port change of an enabled port. We have to</span>
<span class="cm">			 * assume that this can have caused an stepping</span>
<span class="cm">			 * port switch.</span>
<span class="cm">			 */</span>
			<span class="n">etr_tolec</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">p1</span> <span class="o">=</span> <span class="n">etr_port1_online</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">p1</span><span class="p">)</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">etr_port1_uptodate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ETR_EVENT_UPDATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">eacr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up a timer that expires after the etr_tolec + 1.6 seconds if</span>
<span class="cm"> * one of the ports needs an update.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">etr_set_tolec_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">micros</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">etr_eacr</span><span class="p">.</span><span class="n">p0</span> <span class="o">||</span> <span class="n">etr_port0_uptodate</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">etr_eacr</span><span class="p">.</span><span class="n">p1</span> <span class="o">||</span> <span class="n">etr_port1_uptodate</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">micros</span> <span class="o">=</span> <span class="p">(</span><span class="n">now</span> <span class="o">&gt;</span> <span class="n">etr_tolec</span><span class="p">)</span> <span class="o">?</span> <span class="p">((</span><span class="n">now</span> <span class="o">-</span> <span class="n">etr_tolec</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">micros</span> <span class="o">=</span> <span class="p">(</span><span class="n">micros</span> <span class="o">&gt;</span> <span class="mi">1600000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1600000</span> <span class="o">-</span> <span class="n">micros</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">micros</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up a time that expires after 1/2 second.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">etr_set_sync_timeout</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the aib information for one or both ports.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">etr_eacr</span> <span class="nf">etr_handle_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">etr_eacr</span> <span class="n">eacr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* With both ports disabled the aib information is useless. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">e1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">eacr</span><span class="p">;</span>

	<span class="cm">/* Update port0 or port1 with aib stored in etr_work_fn. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Information for port 0 stored. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">p0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">etr_port0_uptodate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">etr_port0</span> <span class="o">=</span> <span class="o">*</span><span class="n">aib</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_online</span><span class="p">)</span>
				<span class="n">etr_port0_uptodate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Information for port 1 stored. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">p1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">etr_port1_uptodate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">etr_port1</span> <span class="o">=</span> <span class="o">*</span><span class="n">aib</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_online</span><span class="p">)</span>
				<span class="n">etr_port1_uptodate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not try to get the alternate port aib if the clock</span>
<span class="cm">	 * is not in sync yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">||</span> <span class="o">!</span><span class="n">check_sync_clock</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">eacr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If steai is available we can get the information about</span>
<span class="cm">	 * the other port immediately. If only stetr is available the</span>
<span class="cm">	 * data-port bit toggle has to be used.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">etr_steai_available</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">p0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">etr_port0_uptodate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">etr_steai_cv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port0</span><span class="p">,</span> <span class="n">ETR_STEAI_PORT_0</span><span class="p">);</span>
			<span class="n">etr_port0_uptodate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">p1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">etr_port1_uptodate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">etr_steai_cv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port1</span><span class="p">,</span> <span class="n">ETR_STEAI_PORT_1</span><span class="p">);</span>
			<span class="n">etr_port1_uptodate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * One port was updated above, if the other</span>
<span class="cm">		 * port is not uptodate toggle dp bit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">eacr</span><span class="p">.</span><span class="n">p0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">etr_port0_uptodate</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">p1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">etr_port1_uptodate</span><span class="p">))</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">dp</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">eacr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write new etr control register if it differs from the current one.</span>
<span class="cm"> * Return 1 if etr_tolec has been updated as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">etr_update_eacr</span><span class="p">(</span><span class="k">struct</span> <span class="n">etr_eacr</span> <span class="n">eacr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dp_changed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_eacr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eacr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">eacr</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* No change, return. */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The disable of an active port of the change of the data port</span>
<span class="cm">	 * bit can/will cause a change in the data port.</span>
<span class="cm">	 */</span>
	<span class="n">dp_changed</span> <span class="o">=</span> <span class="n">etr_eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">&gt;</span> <span class="n">eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">||</span> <span class="n">etr_eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">&gt;</span> <span class="n">eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">etr_eacr</span><span class="p">.</span><span class="n">dp</span> <span class="o">^</span> <span class="n">eacr</span><span class="p">.</span><span class="n">dp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">etr_eacr</span> <span class="o">=</span> <span class="n">eacr</span><span class="p">;</span>
	<span class="n">etr_setr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_eacr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp_changed</span><span class="p">)</span>
		<span class="n">etr_tolec</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ETR work. In this function you&#39;ll find the main logic. In</span>
<span class="cm"> * particular this is the only function that calls etr_update_eacr(),</span>
<span class="cm"> * it &quot;controls&quot; the etr control register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">etr_work_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">etr_eacr</span> <span class="n">eacr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="n">aib</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sync_port</span><span class="p">;</span>

	<span class="cm">/* prevent multiple execution. */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_work_mutex</span><span class="p">);</span>

	<span class="cm">/* Create working copy of etr_eacr. */</span>
	<span class="n">eacr</span> <span class="o">=</span> <span class="n">etr_eacr</span><span class="p">;</span>

	<span class="cm">/* Check for the different events and their immediate effects. */</span>
	<span class="n">eacr</span> <span class="o">=</span> <span class="n">etr_handle_events</span><span class="p">(</span><span class="n">eacr</span><span class="p">);</span>

	<span class="cm">/* Check if ETR is supposed to be active. */</span>
	<span class="n">eacr</span><span class="p">.</span><span class="n">ea</span> <span class="o">=</span> <span class="n">eacr</span><span class="p">.</span><span class="n">p0</span> <span class="o">||</span> <span class="n">eacr</span><span class="p">.</span><span class="n">p1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">ea</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Both ports offline. Reset everything. */</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="n">eacr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">disable_sync_clock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_timer</span><span class="p">);</span>
		<span class="n">etr_update_eacr</span><span class="p">(</span><span class="n">eacr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Store aib to get the current ETR status word. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">etr_stetr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aib</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">etr_port0</span><span class="p">.</span><span class="n">esw</span> <span class="o">=</span> <span class="n">etr_port1</span><span class="p">.</span><span class="n">esw</span> <span class="o">=</span> <span class="n">aib</span><span class="p">.</span><span class="n">esw</span><span class="p">;</span>	<span class="cm">/* Copy status word. */</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the port information if the last stepping port change</span>
<span class="cm">	 * or data port change is older than 1.6 seconds.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&gt;=</span> <span class="n">etr_tolec</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1600000</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">))</span>
		<span class="n">eacr</span> <span class="o">=</span> <span class="n">etr_handle_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aib</span><span class="p">,</span> <span class="n">eacr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Select ports to enable. The preferred synchronization mode is PPS.</span>
<span class="cm">	 * If a port can be enabled depends on a number of things:</span>
<span class="cm">	 * 1) The port needs to be online and uptodate. A port is not</span>
<span class="cm">	 *    disabled just because it is not uptodate, but it is only</span>
<span class="cm">	 *    enabled if it is uptodate.</span>
<span class="cm">	 * 2) The port needs to have the same mode (pps / etr).</span>
<span class="cm">	 * 3) The port needs to be usable -&gt; etr_port_valid() == 1</span>
<span class="cm">	 * 4) To enable the second port the clock needs to be in sync.</span>
<span class="cm">	 * 5) If both ports are useable and are ETR ports, the network id</span>
<span class="cm">	 *    has to be the same.</span>
<span class="cm">	 * The eacr.sl bit is used to indicate etr mode vs. pps mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">p0</span> <span class="o">&amp;&amp;</span> <span class="n">aib</span><span class="p">.</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span> <span class="o">==</span> <span class="n">etr_lpsc_pps_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">etr_mode_is_pps</span><span class="p">(</span><span class="n">etr_eacr</span><span class="p">))</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">||</span> <span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">p1</span> <span class="o">||</span> <span class="n">aib</span><span class="p">.</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">!=</span> <span class="n">etr_lpsc_pps_mode</span><span class="p">)</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>FIXME: uptodate checks ?</p></td><td class="code"><div class="highlight"><pre>		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_uptodate</span> <span class="o">&amp;&amp;</span> <span class="n">etr_port1_uptodate</span><span class="p">)</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sync_port</span> <span class="o">=</span> <span class="p">(</span><span class="n">etr_port0_uptodate</span> <span class="o">&amp;&amp;</span>
			     <span class="n">etr_port_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">p1</span> <span class="o">&amp;&amp;</span> <span class="n">aib</span><span class="p">.</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">==</span> <span class="n">etr_lpsc_pps_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">etr_mode_is_pps</span><span class="p">(</span><span class="n">etr_eacr</span><span class="p">))</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sync_port</span> <span class="o">=</span> <span class="p">(</span><span class="n">etr_port1_uptodate</span> <span class="o">&amp;&amp;</span>
			     <span class="n">etr_port_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">p0</span> <span class="o">&amp;&amp;</span> <span class="n">aib</span><span class="p">.</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span> <span class="o">==</span> <span class="n">etr_lpsc_operational_step</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">etr_mode_is_etr</span><span class="p">(</span><span class="n">etr_eacr</span><span class="p">))</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">||</span> <span class="o">!</span><span class="n">eacr</span><span class="p">.</span><span class="n">p1</span> <span class="o">||</span>
		    <span class="n">aib</span><span class="p">.</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">!=</span> <span class="n">etr_lpsc_operational_alt</span><span class="p">)</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_uptodate</span> <span class="o">&amp;&amp;</span> <span class="n">etr_port1_uptodate</span> <span class="o">&amp;&amp;</span>
			 <span class="n">etr_compare_network</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_port1</span><span class="p">))</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sync_port</span> <span class="o">=</span> <span class="p">(</span><span class="n">etr_port0_uptodate</span> <span class="o">&amp;&amp;</span>
			     <span class="n">etr_port_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eacr</span><span class="p">.</span><span class="n">p1</span> <span class="o">&amp;&amp;</span> <span class="n">aib</span><span class="p">.</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span> <span class="o">==</span> <span class="n">etr_lpsc_operational_step</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">e1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">etr_mode_is_etr</span><span class="p">(</span><span class="n">etr_eacr</span><span class="p">))</span>
			<span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sync_port</span> <span class="o">=</span> <span class="p">(</span><span class="n">etr_port1_uptodate</span> <span class="o">&amp;&amp;</span>
			     <span class="n">etr_port_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Both ports not usable. */</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="n">eacr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sync_port</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the clock is in sync just update the eacr and return.</span>
<span class="cm">	 * If there is no valid sync port wait for a port update.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">&amp;&amp;</span> <span class="n">check_sync_clock</span><span class="p">())</span> <span class="o">||</span> <span class="n">sync_port</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">etr_update_eacr</span><span class="p">(</span><span class="n">eacr</span><span class="p">);</span>
		<span class="n">etr_set_tolec_timeout</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare control register for clock syncing</span>
<span class="cm">	 * (reset data port bit, set sync check control.</span>
<span class="cm">	 */</span>
	<span class="n">eacr</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update eacr and try to synchronize the clock. If the update</span>
<span class="cm">	 * of eacr caused a stepping port switch (or if we have to</span>
<span class="cm">	 * assume that a stepping port switch has occurred) or the</span>
<span class="cm">	 * clock syncing failed, reset the sync check control bit</span>
<span class="cm">	 * and set up a timer to try again after 0.5 seconds</span>
<span class="cm">	 */</span>
	<span class="n">etr_update_eacr</span><span class="p">(</span><span class="n">eacr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">etr_tolec</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1600000</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">etr_sync_clock_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aib</span><span class="p">,</span> <span class="n">sync_port</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Sync failed. Try again in 1/2 second. */</span>
		<span class="n">eacr</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">etr_update_eacr</span><span class="p">(</span><span class="n">eacr</span><span class="p">);</span>
		<span class="n">etr_set_sync_timeout</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">etr_set_tolec_timeout</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_work_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sysfs interface functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">etr_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;etr&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_name</span>	<span class="o">=</span> <span class="s">&quot;etr&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="n">etr_port0_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">etr_subsys</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="n">etr_port1_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">etr_subsys</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ETR subsys attributes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_stepping_port_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">etr_port0</span><span class="p">.</span><span class="n">esw</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">stepping_port</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_stepping_port_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_stepping_mode_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mode_str</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">etr_mode_is_pps</span><span class="p">(</span><span class="n">etr_eacr</span><span class="p">))</span>
		<span class="n">mode_str</span> <span class="o">=</span> <span class="s">&quot;pps&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">etr_mode_is_etr</span><span class="p">(</span><span class="n">etr_eacr</span><span class="p">))</span>
		<span class="n">mode_str</span> <span class="o">=</span> <span class="s">&quot;etr&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mode_str</span> <span class="o">=</span> <span class="s">&quot;local&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mode_str</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">stepping_mode</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_stepping_mode_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ETR port attributes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="nf">etr_aib_from_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">etr_port0_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">etr_port0_online</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">etr_port0</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">etr_port1_online</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">etr_port1</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_online_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">online</span><span class="p">;</span>

	<span class="n">online</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">etr_port0_dev</span><span class="p">)</span> <span class="o">?</span> <span class="n">etr_port0_online</span> <span class="o">:</span> <span class="n">etr_port1_online</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">online</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_online_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_HAS_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clock_sync_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">etr_port0_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_online</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>	<span class="cm">/* Nothing to do. */</span>
		<span class="n">etr_port0_online</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_online</span> <span class="o">&amp;&amp;</span> <span class="n">etr_port1_online</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT0_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">etr_port1_online</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>	<span class="cm">/* Nothing to do. */</span>
		<span class="n">etr_port1_online</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">etr_port0_online</span> <span class="o">&amp;&amp;</span> <span class="n">etr_port1_online</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_ETR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ETR_EVENT_PORT1_CHANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_events</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etr_work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clock_sync_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">online</span><span class="p">,</span> <span class="mo">0600</span><span class="p">,</span> <span class="n">etr_online_show</span><span class="p">,</span> <span class="n">etr_online_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_stepping_control_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">etr_port0_dev</span><span class="p">)</span> <span class="o">?</span>
		       <span class="n">etr_eacr</span><span class="p">.</span><span class="n">e0</span> <span class="o">:</span> <span class="n">etr_eacr</span><span class="p">.</span><span class="n">e1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">stepping_control</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_stepping_control_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_mode_code_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">etr_port0_online</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">etr_port1_online</span><span class="p">)</span>
		<span class="cm">/* Status word is not uptodate if both ports are offline. */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">etr_port0_dev</span><span class="p">)</span> <span class="o">?</span>
		       <span class="n">etr_port0</span><span class="p">.</span><span class="n">esw</span><span class="p">.</span><span class="n">psc0</span> <span class="o">:</span> <span class="n">etr_port0</span><span class="p">.</span><span class="n">esw</span><span class="p">.</span><span class="n">psc1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">state_code</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_mode_code_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_untuned_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span> <span class="o">=</span> <span class="n">etr_aib_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aib</span> <span class="o">||</span> <span class="o">!</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">u</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">untuned</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_untuned_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_network_id_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span> <span class="o">=</span> <span class="n">etr_aib_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aib</span> <span class="o">||</span> <span class="o">!</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">net_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_network_id_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_id_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span> <span class="o">=</span> <span class="n">etr_aib_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aib</span> <span class="o">||</span> <span class="o">!</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">etr_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_id_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_port_number_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span> <span class="o">=</span> <span class="n">etr_aib_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aib</span> <span class="o">||</span> <span class="o">!</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">edf1</span><span class="p">.</span><span class="n">etr_pn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_port_number_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_coupled_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span> <span class="o">=</span> <span class="n">etr_aib_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aib</span> <span class="o">||</span> <span class="o">!</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">edf3</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">coupled</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_coupled_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_local_time_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span> <span class="o">=</span> <span class="n">etr_aib_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aib</span> <span class="o">||</span> <span class="o">!</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">edf3</span><span class="p">.</span><span class="n">blto</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">local_time</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_local_time_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">etr_utc_offset_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">etr_aib</span> <span class="o">*</span><span class="n">aib</span> <span class="o">=</span> <span class="n">etr_aib_from_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aib</span> <span class="o">||</span> <span class="o">!</span><span class="n">aib</span><span class="o">-&gt;</span><span class="n">slsw</span><span class="p">.</span><span class="n">v3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">aib</span><span class="o">-&gt;</span><span class="n">edf3</span><span class="p">.</span><span class="n">buo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">utc_offset</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">etr_utc_offset_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">etr_port_attributes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_online</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_stepping_control</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_state_code</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_untuned</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_network</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_id</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_port</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_coupled</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_local_time</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_utc_offset</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">etr_register_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">**</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">attr</span> <span class="o">=</span> <span class="n">etr_port_attributes</span><span class="p">;</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span> <span class="n">attr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unreg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unreg:</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">attr</span> <span class="o">&gt;=</span> <span class="n">etr_port_attributes</span><span class="p">;</span> <span class="n">attr</span><span class="o">--</span><span class="p">)</span>
		<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">etr_unregister_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">**</span><span class="n">attr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">attr</span> <span class="o">=</span> <span class="n">etr_port_attributes</span><span class="p">;</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span> <span class="n">attr</span><span class="o">++</span><span class="p">)</span>
		<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">etr_init_sysfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">subsys_system_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_subsys</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">etr_subsys</span><span class="p">.</span><span class="n">dev_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_stepping_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unreg_subsys</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">etr_subsys</span><span class="p">.</span><span class="n">dev_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_stepping_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_remove_stepping_port</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">etr_register_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port0_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_remove_stepping_mode</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">etr_register_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port1_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_remove_port0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_remove_port0:</span>
	<span class="n">etr_unregister_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_port0_dev</span><span class="p">);</span>
<span class="nl">out_remove_stepping_mode:</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">etr_subsys</span><span class="p">.</span><span class="n">dev_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_stepping_mode</span><span class="p">);</span>
<span class="nl">out_remove_stepping_port:</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">etr_subsys</span><span class="p">.</span><span class="n">dev_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_stepping_port</span><span class="p">);</span>
<span class="nl">out_unreg_subsys:</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">etr_subsys</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">device_initcall</span><span class="p">(</span><span class="n">etr_init_sysfs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Server Time Protocol (STP) code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">stp_online</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">stp_sstpi</span> <span class="n">stp_info</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">stp_page</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">stp_work_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">stp_work_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">stp_work</span><span class="p">,</span> <span class="n">stp_work_fn</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">stp_timer</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_parse_stp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">stp_online</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">stp_online</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;stp&quot;</span><span class="p">,</span> <span class="n">early_parse_stp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Reset STP attachment.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">stp_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">stp_page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">chsc_sstpc</span><span class="p">(</span><span class="n">stp_page</span><span class="p">,</span> <span class="n">STP_OP_CTRL</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_HAS_STP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stp_online</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;The real or virtual hardware system does &quot;</span>
			   <span class="s">&quot;not provide an STP interface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">stp_page</span><span class="p">);</span>
		<span class="n">stp_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">stp_online</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stp_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stp_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">stp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_HAS_STP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_timer</span><span class="p">,</span> <span class="n">stp_timeout</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
	<span class="n">time_init_wq</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stp_work</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">arch_initcall</span><span class="p">(</span><span class="n">stp_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * STP timing alert. There are three causes:</span>
<span class="cm"> * 1) timing status change</span>
<span class="cm"> * 2) link availability change</span>
<span class="cm"> * 3) time control parameter change</span>
<span class="cm"> * In all three cases we are only interested in the clock source state.</span>
<span class="cm"> * If a STP clock source is now available use it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stp_timing_alert</span><span class="p">(</span><span class="k">struct</span> <span class="n">stp_irq_parm</span> <span class="o">*</span><span class="n">intparm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intparm</span><span class="o">-&gt;</span><span class="n">tsc</span> <span class="o">||</span> <span class="n">intparm</span><span class="o">-&gt;</span><span class="n">lac</span> <span class="o">||</span> <span class="n">intparm</span><span class="o">-&gt;</span><span class="n">tcpc</span><span class="p">)</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stp_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * STP sync check machine check. This is called when the timing state</span>
<span class="cm"> * changes from the synchronized state to the unsynchronized state.</span>
<span class="cm"> * After a STP sync check the clock is not in sync. The machine check</span>
<span class="cm"> * is broadcasted to all cpus at the same time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">stp_sync_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_sync_clock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stp_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * STP island condition machine check. This is called when an attached</span>
<span class="cm"> * server  attempts to communicate over an STP link and the servers</span>
<span class="cm"> * have matching CTN ids and have a valid stratum-1 configuration</span>
<span class="cm"> * but the configurations do not match.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">stp_island_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_sync_clock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stp_work</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">stp_sync_clock</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">first</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">old_clock</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clock_sync_data</span> <span class="o">*</span><span class="n">stp_sync</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">stp_sync</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Slave */</span>
		<span class="n">clock_sync_cpu</span><span class="p">(</span><span class="n">stp_sync</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait until all other cpus entered the sync function. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_sync</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="n">enable_sync_clock</span><span class="p">();</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stp_info</span><span class="p">.</span><span class="n">todoff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">todoff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">||</span>
	    <span class="n">stp_info</span><span class="p">.</span><span class="n">todoff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">||</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">todoff</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">||</span>
	    <span class="n">stp_info</span><span class="p">.</span><span class="n">tmd</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old_clock</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">chsc_sstpc</span><span class="p">(</span><span class="n">stp_page</span><span class="p">,</span> <span class="n">STP_OP_SYNC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">adjust_time</span><span class="p">(</span><span class="n">old_clock</span><span class="p">,</span> <span class="n">get_clock</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">fixup_clock_comparator</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">chsc_sstpi</span><span class="p">(</span><span class="n">stp_page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stp_info</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stp_sstpi</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">tmd</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">disable_sync_clock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="n">stp_sync</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">stp_sync</span><span class="o">-&gt;</span><span class="n">in_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * STP work. Check for the STP state and take over the clock</span>
<span class="cm"> * synchronization if the STP clock source is usable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stp_work_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_sync_data</span> <span class="n">stp_sync</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* prevent multiple execution. */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_work_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chsc_sstpc</span><span class="p">(</span><span class="n">stp_page</span><span class="p">,</span> <span class="n">STP_OP_CTRL</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_timer</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">chsc_sstpc</span><span class="p">(</span><span class="n">stp_page</span><span class="p">,</span> <span class="n">STP_OP_CTRL</span><span class="p">,</span> <span class="mh">0xb0e0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">chsc_sstpi</span><span class="p">(</span><span class="n">stp_page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stp_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stp_sstpi</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Skip synchronization if the clock is already in sync. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_sync_clock</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_sync</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stp_sync</span><span class="p">));</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_sync</span><span class="p">.</span><span class="n">cpus</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">stop_machine</span><span class="p">(</span><span class="n">stp_sync_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stp_sync</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_sync_clock</span><span class="p">())</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is a usable clock but the synchonization failed.</span>
<span class="cm">		 * Retry after a second.</span>
<span class="cm">		 */</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_work_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * STP subsys sysfs interface functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">stp_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;stp&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_name</span>	<span class="o">=</span> <span class="s">&quot;stp&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_ctn_id_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">ctnid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">ctn_id</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">stp_ctn_id_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_ctn_type_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">ctn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">ctn_type</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">stp_ctn_type_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_dst_offset_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">stp_info</span><span class="p">.</span><span class="n">vbits</span> <span class="o">&amp;</span> <span class="mh">0x2000</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">s16</span><span class="p">)</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">dsto</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">dst_offset</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">stp_dst_offset_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_leap_seconds_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">stp_info</span><span class="p">.</span><span class="n">vbits</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">s16</span><span class="p">)</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">leaps</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">leap_seconds</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">stp_leap_seconds_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_stratum_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">s16</span><span class="p">)</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">stratum</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">stratum</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">stp_stratum_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_time_offset_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">stp_info</span><span class="p">.</span><span class="n">vbits</span> <span class="o">&amp;</span> <span class="mh">0x0800</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">tto</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">time_offset</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">stp_time_offset_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_time_zone_offset_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">stp_info</span><span class="p">.</span><span class="n">vbits</span> <span class="o">&amp;</span> <span class="mh">0x4000</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">s16</span><span class="p">)</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">tzo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">time_zone_offset</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span>
			 <span class="n">stp_time_zone_offset_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_timing_mode_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">tmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">timing_mode</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">stp_timing_mode_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_timing_state_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stp_online</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stp_info</span><span class="p">.</span><span class="n">tst</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">timing_state</span><span class="p">,</span> <span class="mo">0400</span><span class="p">,</span> <span class="n">stp_timing_state_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_online_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stp_online</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">stp_online_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_HAS_STP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clock_sync_mutex</span><span class="p">);</span>
	<span class="n">stp_online</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stp_online</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_STP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CLOCK_SYNC_STP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clock_sync_flags</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">time_sync_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stp_work</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clock_sync_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Can&#39;t use DEVICE_ATTR because the attribute should be named</span>
<span class="cm"> * stp/online but dev_attr_online already exists in this file ..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_attr_stp_online</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;online&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0600</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">stp_online_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span>	<span class="o">=</span> <span class="n">stp_online_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">stp_attributes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_ctn_id</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_ctn_type</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_dst_offset</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_leap_seconds</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_stp_online</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_stratum</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_time_offset</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_time_zone_offset</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_timing_mode</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_timing_state</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">stp_init_sysfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">**</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">subsys_system_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_subsys</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">attr</span> <span class="o">=</span> <span class="n">stp_attributes</span><span class="p">;</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span> <span class="n">attr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">stp_subsys</span><span class="p">.</span><span class="n">dev_root</span><span class="p">,</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unreg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unreg:</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">attr</span> <span class="o">&gt;=</span> <span class="n">stp_attributes</span><span class="p">;</span> <span class="n">attr</span><span class="o">--</span><span class="p">)</span>
		<span class="n">device_remove_file</span><span class="p">(</span><span class="n">stp_subsys</span><span class="p">.</span><span class="n">dev_root</span><span class="p">,</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stp_subsys</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">device_initcall</span><span class="p">(</span><span class="n">stp_init_sysfs</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
