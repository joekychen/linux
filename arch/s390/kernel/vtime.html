<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › s390 › kernel › vtime.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vtime.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  arch/s390/kernel/vtime.c</span>
<span class="cm"> *    Virtual cpu timer based timer functions.</span>
<span class="cm"> *</span>
<span class="cm"> *  S390 version</span>
<span class="cm"> *    Copyright (C) 2004 IBM Deutschland Entwicklung GmbH, IBM Corporation</span>
<span class="cm"> *    Author(s): Jan Glauber &lt;jan.glauber@de.ibm.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/posix-timers.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>

<span class="cp">#include &lt;asm/timer.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>
<span class="cp">#include &lt;asm/cputime.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &quot;entry.h&quot;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_queue</span><span class="p">,</span> <span class="n">virt_cpu_timer</span><span class="p">);</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">s390_idle_data</span><span class="p">,</span> <span class="n">s390_idle</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u64</span> <span class="nf">get_vtimer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span> <span class="n">timer</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;STPT %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="n">timer</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">timer</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_vtimer</span><span class="p">(</span><span class="n">__u64</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span> <span class="n">timer</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;  STPT %0</span><span class="se">\n</span><span class="s">&quot;</span>  <span class="cm">/* Store current cpu timer value */</span>
		      <span class="s">&quot;  SPT %1&quot;</span>     <span class="cm">/* Set new value immediately afterwards */</span>
		      <span class="o">:</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="n">expires</span><span class="p">)</span> <span class="p">);</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">system_timer</span> <span class="o">+=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_timer</span> <span class="o">-</span> <span class="n">timer</span><span class="p">;</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_timer</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update process times based on virtual cpu times stored by entry.S</span>
<span class="cm"> * to the lowcore fields user_timer, system_timer &amp; steal_clock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_account_vtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hardirq_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">__u64</span> <span class="n">timer</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">steal</span><span class="p">;</span>

	<span class="n">timer</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_timer</span><span class="p">;</span>
	<span class="n">clock</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_clock</span><span class="p">;</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;  STPT %0</span><span class="se">\n</span><span class="s">&quot;</span>    <span class="cm">/* Store current cpu timer value */</span>
		      <span class="s">&quot;  STCK %1&quot;</span>      <span class="cm">/* Store current tod clock value */</span>
		      <span class="o">:</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_timer</span><span class="p">),</span>
		        <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_clock</span><span class="p">)</span> <span class="p">);</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">system_timer</span> <span class="o">+=</span> <span class="n">timer</span> <span class="o">-</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_timer</span><span class="p">;</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">steal_timer</span> <span class="o">+=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_clock</span> <span class="o">-</span> <span class="n">clock</span><span class="p">;</span>

	<span class="n">user</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">user_timer</span> <span class="o">-</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">user_timer</span><span class="p">;</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">steal_timer</span> <span class="o">-=</span> <span class="n">user</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">user_timer</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">user_timer</span><span class="p">;</span>
	<span class="n">account_user_time</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>

	<span class="n">system</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">system_timer</span> <span class="o">-</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">system_timer</span><span class="p">;</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">steal_timer</span> <span class="o">-=</span> <span class="n">system</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">system_timer</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">system_timer</span><span class="p">;</span>
	<span class="n">account_system_time</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">hardirq_offset</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">system</span><span class="p">);</span>

	<span class="n">steal</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">steal_timer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span> <span class="n">steal</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">steal_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">account_steal_time</span><span class="p">(</span><span class="n">steal</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">account_vtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>

	<span class="n">do_account_vtime</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ti</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">user_timer</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">user_timer</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">system_timer</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">system_timer</span><span class="p">;</span>
	<span class="n">ti</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">user_timer</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">user_timer</span><span class="p">;</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">system_timer</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">system_timer</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">account_process_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user_tick</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_account_vtime</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">HARDIRQ_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update process times based on virtual cpu times stored by entry.S</span>
<span class="cm"> * to the lowcore fields user_timer, system_timer &amp; steal_clock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_system_vtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">__u64</span> <span class="n">timer</span><span class="p">,</span> <span class="n">system</span><span class="p">;</span>

	<span class="n">timer</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_timer</span><span class="p">;</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_timer</span> <span class="o">=</span> <span class="n">get_vtimer</span><span class="p">();</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">system_timer</span> <span class="o">+=</span> <span class="n">timer</span> <span class="o">-</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">last_update_timer</span><span class="p">;</span>

	<span class="n">system</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">system_timer</span> <span class="o">-</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">system_timer</span><span class="p">;</span>
	<span class="n">S390_lowcore</span><span class="p">.</span><span class="n">steal_timer</span> <span class="o">-=</span> <span class="n">system</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">system_timer</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">system_timer</span><span class="p">;</span>
	<span class="n">account_system_time</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">system</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">account_system_vtime</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">vtime_stop_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s390_idle_data</span> <span class="o">*</span><span class="n">idle</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">s390_idle</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vtimer_queue</span> <span class="o">*</span><span class="n">vq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">virt_cpu_timer</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">idle_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psw_mask</span><span class="p">;</span>

	<span class="n">trace_hardirqs_on</span><span class="p">();</span>
	<span class="cm">/* Don&#39;t trace preempt off for idle. */</span>
	<span class="n">stop_critical_timings</span><span class="p">();</span>

	<span class="cm">/* Wait for external, I/O or machine check interrupt. */</span>
	<span class="n">psw_mask</span> <span class="o">=</span> <span class="n">psw_kernel_bits</span> <span class="o">|</span> <span class="n">PSW_MASK_WAIT</span> <span class="o">|</span> <span class="n">PSW_MASK_DAT</span> <span class="o">|</span>
		<span class="n">PSW_MASK_IO</span> <span class="o">|</span> <span class="n">PSW_MASK_EXT</span> <span class="o">|</span> <span class="n">PSW_MASK_MCHECK</span><span class="p">;</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">nohz_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Call the assembler magic in entry.S */</span>
	<span class="n">psw_idle</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">vq</span><span class="p">,</span> <span class="n">psw_mask</span><span class="p">,</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>

	<span class="cm">/* Reenable preemption tracer. */</span>
	<span class="n">start_critical_timings</span><span class="p">();</span>

	<span class="cm">/* Account time spent with enabled wait psw loaded as idle time. */</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="o">++</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">idle_time</span> <span class="o">=</span> <span class="n">idle</span><span class="o">-&gt;</span><span class="n">idle_exit</span> <span class="o">-</span> <span class="n">idle</span><span class="o">-&gt;</span><span class="n">idle_enter</span><span class="p">;</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">idle_time</span> <span class="o">+=</span> <span class="n">idle_time</span><span class="p">;</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">idle_enter</span> <span class="o">=</span> <span class="n">idle</span><span class="o">-&gt;</span><span class="n">idle_exit</span> <span class="o">=</span> <span class="mi">0ULL</span><span class="p">;</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">idle_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">account_idle_time</span><span class="p">(</span><span class="n">idle_time</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cputime64_t</span> <span class="nf">s390_get_idle_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s390_idle_data</span> <span class="o">*</span><span class="n">idle</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">s390_idle</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span><span class="p">,</span> <span class="n">idle_enter</span><span class="p">,</span> <span class="n">idle_exit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sequence</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
		<span class="n">sequence</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">idle</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">);</span>
		<span class="n">idle_enter</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">idle</span><span class="o">-&gt;</span><span class="n">idle_enter</span><span class="p">);</span>
		<span class="n">idle_exit</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">idle</span><span class="o">-&gt;</span><span class="n">idle_exit</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">sequence</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">idle</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">!=</span> <span class="n">sequence</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">idle_enter</span> <span class="o">?</span> <span class="p">((</span><span class="n">idle_exit</span> <span class="o">?</span> <span class="o">:</span> <span class="n">now</span><span class="p">)</span> <span class="o">-</span> <span class="n">idle_enter</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sorted add to a list. List is linear searched until first bigger</span>
<span class="cm"> * element is found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">list_add_sorted</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">&gt;</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do the callback functions of expired vtimer events.</span>
<span class="cm"> * Called from within the interrupt handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cb_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vtimer_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">cb_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">virt_cpu_timer</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">cb_list</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
		<span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Recharge interval timer */</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">+</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">elapsed</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">list_add_sorted</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handler for the virtual CPU timer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_cpu_timer_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext_code</span> <span class="n">ext_code</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">param32</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vtimer_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cb_list</span><span class="p">;</span>	<span class="cm">/* the callback queue */</span>
	<span class="n">__u64</span> <span class="n">elapsed</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">kstat_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()).</span><span class="n">irqs</span><span class="p">[</span><span class="n">EXTINT_TMR</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cb_list</span><span class="p">);</span>
	<span class="n">vq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">virt_cpu_timer</span><span class="p">);</span>

	<span class="cm">/* walk timer list, fire all expired events */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">elapsed</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">elapsed</span> <span class="o">+</span> <span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">-</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">async_enter_timer</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span> <span class="n">elapsed</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">elapsed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">&lt;</span> <span class="n">elapsed</span><span class="p">)</span>
			<span class="cm">/* move expired timer to the callback queue */</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb_list</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">-=</span> <span class="n">elapsed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">do_callbacks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cb_list</span><span class="p">);</span>

	<span class="cm">/* next event is first in list */</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">VTIMER_MAX_SLICE</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vtimer_list</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * To improve precision add the time spent by the</span>
<span class="cm">	 * interrupt handler to the elapsed time.</span>
<span class="cm">	 * Note: CPU timer counts down and we got an interrupt,</span>
<span class="cm">	 *	 the current content is negative</span>
<span class="cm">	 */</span>
	<span class="n">elapsed</span> <span class="o">=</span> <span class="n">S390_lowcore</span><span class="p">.</span><span class="n">async_enter_timer</span> <span class="o">-</span> <span class="n">get_vtimer</span><span class="p">();</span>
	<span class="n">set_vtimer</span><span class="p">(</span><span class="n">next</span> <span class="o">-</span> <span class="n">elapsed</span><span class="p">);</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">elapsed</span><span class="p">;</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">elapsed</span> <span class="o">=</span> <span class="n">elapsed</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_virt_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">init_virt_timer</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vtimer_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this function should only run on the specified CPU</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_add_vtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vtimer_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">left</span><span class="p">,</span> <span class="n">expires</span><span class="p">;</span>

	<span class="n">vq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">virt_cpu_timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* First timer on this cpu, just program it. */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">set_vtimer</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">);</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">elapsed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Check progress of old timers. */</span>
		<span class="n">expires</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">get_vtimer</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span> <span class="n">expires</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">left</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* The new timer expires before the current timer. */</span>
			<span class="n">set_vtimer</span><span class="p">(</span><span class="n">expires</span><span class="p">);</span>
			<span class="n">vq</span><span class="o">-&gt;</span><span class="n">elapsed</span> <span class="o">+=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
			<span class="n">vq</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">vq</span><span class="o">-&gt;</span><span class="n">elapsed</span> <span class="o">+=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
			<span class="n">vq</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Insert new timer into per cpu list. */</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">+=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">elapsed</span><span class="p">;</span>
		<span class="n">list_add_sorted</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* release CPU acquired in prepare_vtimer or mod_virt_timer() */</span>
	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prepare_vtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">||</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">&gt;</span> <span class="n">VTIMER_MAX_SLICE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vtimer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">));</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add_virt_timer - add an oneshot virtual CPU timer</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">add_virt_timer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

	<span class="n">timer</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="p">)</span><span class="n">new</span><span class="p">;</span>
	<span class="n">prepare_vtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">internal_add_vtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">add_virt_timer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * add_virt_timer_int - add an interval virtual CPU timer</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">add_virt_timer_periodic</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

	<span class="n">timer</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="p">)</span><span class="n">new</span><span class="p">;</span>
	<span class="n">prepare_vtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
	<span class="n">internal_add_vtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">add_virt_timer_periodic</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__mod_vtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">expires</span><span class="p">,</span> <span class="kt">int</span> <span class="n">periodic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vtimer_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">expires</span> <span class="o">||</span> <span class="n">expires</span> <span class="o">&gt;</span> <span class="n">VTIMER_MAX_SLICE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">==</span> <span class="n">expires</span> <span class="o">&amp;&amp;</span> <span class="n">vtimer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">vq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">virt_cpu_timer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* disable interrupts before test if timer is pending */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* if timer isn&#39;t pending add it on the current CPU */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vtimer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">periodic</span><span class="p">)</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">internal_add_vtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if we run on the right CPU */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">periodic</span><span class="p">)</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>

	<span class="cm">/* the timer can&#39;t expire anymore so we can release the lock */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">internal_add_vtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we change a pending timer the function must be called on the CPU</span>
<span class="cm"> * where the timer is running on.</span>
<span class="cm"> *</span>
<span class="cm"> * returns whether it has modified a pending timer (1) or not (0)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mod_virt_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__mod_vtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mod_virt_timer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If we change a pending timer the function must be called on the CPU</span>
<span class="cm"> * where the timer is running on.</span>
<span class="cm"> *</span>
<span class="cm"> * returns whether it has modified a pending timer (1) or not (0)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mod_virt_timer_periodic</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__mod_vtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mod_virt_timer_periodic</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * delete a virtual timer</span>
<span class="cm"> *</span>
<span class="cm"> * returns whether the deleted timer was pending (1) or not (0)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">del_virt_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vtimer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vtimer_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>

	<span class="cm">/* check if timer is pending */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vtimer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">virt_cpu_timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* we don&#39;t interrupt a running timer, just let it expire! */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">del_virt_timer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Start the virtual CPU timer on the current CPU.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">init_cpu_vtimer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vtimer_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>

	<span class="cm">/* initialize per cpu vtimer structure */</span>
	<span class="n">vq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">virt_cpu_timer</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* enable cpu timer interrupts */</span>
	<span class="n">__ctl_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* set initial cpu timer */</span>
	<span class="n">set_vtimer</span><span class="p">(</span><span class="mh">0x7fffffffffffffffULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">s390_nohz_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s390_idle_data</span> <span class="o">*</span><span class="n">idle</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">hcpu</span><span class="p">;</span>

	<span class="n">idle</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">s390_idle</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DYING</span>:
	<span class="k">case</span> <span class="n">CPU_DYING_FROZEN</span>:
		<span class="n">idle</span><span class="o">-&gt;</span><span class="n">nohz_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">vtime_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* request the cpu timer external interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_external_interrupt</span><span class="p">(</span><span class="mh">0x1005</span><span class="p">,</span> <span class="n">do_cpu_timer_interrupt</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t request external interrupt 0x1005&quot;</span><span class="p">);</span>

	<span class="cm">/* Enable cpu timer interrupts on the boot cpu. */</span>
	<span class="n">init_cpu_vtimer</span><span class="p">();</span>
	<span class="n">cpu_notifier</span><span class="p">(</span><span class="n">s390_nohz_notify</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
