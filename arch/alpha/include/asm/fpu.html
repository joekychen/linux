<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › include › asm › fpu.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>fpu.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __ASM_ALPHA_FPU_H</span>
<span class="cp">#define __ASM_ALPHA_FPU_H</span>

<span class="cp">#include &lt;asm/special_insns.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Alpha floating-point control register defines:</span>
<span class="cm"> */</span>
<span class="cp">#define FPCR_DNOD	(1UL&lt;&lt;47)	</span><span class="cm">/* denorm INV trap disable */</span><span class="cp"></span>
<span class="cp">#define FPCR_DNZ	(1UL&lt;&lt;48)	</span><span class="cm">/* denorms to zero */</span><span class="cp"></span>
<span class="cp">#define FPCR_INVD	(1UL&lt;&lt;49)	</span><span class="cm">/* invalid op disable (opt.) */</span><span class="cp"></span>
<span class="cp">#define FPCR_DZED	(1UL&lt;&lt;50)	</span><span class="cm">/* division by zero disable (opt.) */</span><span class="cp"></span>
<span class="cp">#define FPCR_OVFD	(1UL&lt;&lt;51)	</span><span class="cm">/* overflow disable (optional) */</span><span class="cp"></span>
<span class="cp">#define FPCR_INV	(1UL&lt;&lt;52)	</span><span class="cm">/* invalid operation */</span><span class="cp"></span>
<span class="cp">#define FPCR_DZE	(1UL&lt;&lt;53)	</span><span class="cm">/* division by zero */</span><span class="cp"></span>
<span class="cp">#define FPCR_OVF	(1UL&lt;&lt;54)	</span><span class="cm">/* overflow */</span><span class="cp"></span>
<span class="cp">#define FPCR_UNF	(1UL&lt;&lt;55)	</span><span class="cm">/* underflow */</span><span class="cp"></span>
<span class="cp">#define FPCR_INE	(1UL&lt;&lt;56)	</span><span class="cm">/* inexact */</span><span class="cp"></span>
<span class="cp">#define FPCR_IOV	(1UL&lt;&lt;57)	</span><span class="cm">/* integer overflow */</span><span class="cp"></span>
<span class="cp">#define FPCR_UNDZ	(1UL&lt;&lt;60)	</span><span class="cm">/* underflow to zero (opt.) */</span><span class="cp"></span>
<span class="cp">#define FPCR_UNFD	(1UL&lt;&lt;61)	</span><span class="cm">/* underflow disable (opt.) */</span><span class="cp"></span>
<span class="cp">#define FPCR_INED	(1UL&lt;&lt;62)	</span><span class="cm">/* inexact disable (opt.) */</span><span class="cp"></span>
<span class="cp">#define FPCR_SUM	(1UL&lt;&lt;63)	</span><span class="cm">/* summary bit */</span><span class="cp"></span>

<span class="cp">#define FPCR_DYN_SHIFT	58		</span><span class="cm">/* first dynamic rounding mode bit */</span><span class="cp"></span>
<span class="cp">#define FPCR_DYN_CHOPPED (0x0UL &lt;&lt; FPCR_DYN_SHIFT)	</span><span class="cm">/* towards 0 */</span><span class="cp"></span>
<span class="cp">#define FPCR_DYN_MINUS	 (0x1UL &lt;&lt; FPCR_DYN_SHIFT)	</span><span class="cm">/* towards -INF */</span><span class="cp"></span>
<span class="cp">#define FPCR_DYN_NORMAL	 (0x2UL &lt;&lt; FPCR_DYN_SHIFT)	</span><span class="cm">/* towards nearest */</span><span class="cp"></span>
<span class="cp">#define FPCR_DYN_PLUS	 (0x3UL &lt;&lt; FPCR_DYN_SHIFT)	</span><span class="cm">/* towards +INF */</span><span class="cp"></span>
<span class="cp">#define FPCR_DYN_MASK	 (0x3UL &lt;&lt; FPCR_DYN_SHIFT)</span>

<span class="cp">#define FPCR_MASK	0xffff800000000000L</span>

<span class="cm">/*</span>
<span class="cm"> * IEEE trap enables are implemented in software.  These per-thread</span>
<span class="cm"> * bits are stored in the &quot;ieee_state&quot; field of &quot;struct thread_info&quot;.</span>
<span class="cm"> * Thus, the bits are defined so as not to conflict with the</span>
<span class="cm"> * floating-point enable bit (which is architected).  On top of that,</span>
<span class="cm"> * we want to make these bits compatible with OSF/1 so</span>
<span class="cm"> * ieee_set_fp_control() etc. can be implemented easily and</span>
<span class="cm"> * compatibly.  The corresponding definitions are in</span>
<span class="cm"> * /usr/include/machine/fpu.h under OSF/1.</span>
<span class="cm"> */</span>
<span class="cp">#define IEEE_TRAP_ENABLE_INV	(1UL&lt;&lt;1)	</span><span class="cm">/* invalid op */</span><span class="cp"></span>
<span class="cp">#define IEEE_TRAP_ENABLE_DZE	(1UL&lt;&lt;2)	</span><span class="cm">/* division by zero */</span><span class="cp"></span>
<span class="cp">#define IEEE_TRAP_ENABLE_OVF	(1UL&lt;&lt;3)	</span><span class="cm">/* overflow */</span><span class="cp"></span>
<span class="cp">#define IEEE_TRAP_ENABLE_UNF	(1UL&lt;&lt;4)	</span><span class="cm">/* underflow */</span><span class="cp"></span>
<span class="cp">#define IEEE_TRAP_ENABLE_INE	(1UL&lt;&lt;5)	</span><span class="cm">/* inexact */</span><span class="cp"></span>
<span class="cp">#define IEEE_TRAP_ENABLE_DNO	(1UL&lt;&lt;6)	</span><span class="cm">/* denorm */</span><span class="cp"></span>
<span class="cp">#define IEEE_TRAP_ENABLE_MASK	(IEEE_TRAP_ENABLE_INV | IEEE_TRAP_ENABLE_DZE |\</span>
<span class="cp">				 IEEE_TRAP_ENABLE_OVF | IEEE_TRAP_ENABLE_UNF |\</span>
<span class="cp">				 IEEE_TRAP_ENABLE_INE | IEEE_TRAP_ENABLE_DNO)</span>

<span class="cm">/* Denorm and Underflow flushing */</span>
<span class="cp">#define IEEE_MAP_DMZ		(1UL&lt;&lt;12)	</span><span class="cm">/* Map denorm inputs to zero */</span><span class="cp"></span>
<span class="cp">#define IEEE_MAP_UMZ		(1UL&lt;&lt;13)	</span><span class="cm">/* Map underflowed outputs to zero */</span><span class="cp"></span>

<span class="cp">#define IEEE_MAP_MASK		(IEEE_MAP_DMZ | IEEE_MAP_UMZ)</span>

<span class="cm">/* status bits coming from fpcr: */</span>
<span class="cp">#define IEEE_STATUS_INV		(1UL&lt;&lt;17)</span>
<span class="cp">#define IEEE_STATUS_DZE		(1UL&lt;&lt;18)</span>
<span class="cp">#define IEEE_STATUS_OVF		(1UL&lt;&lt;19)</span>
<span class="cp">#define IEEE_STATUS_UNF		(1UL&lt;&lt;20)</span>
<span class="cp">#define IEEE_STATUS_INE		(1UL&lt;&lt;21)</span>
<span class="cp">#define IEEE_STATUS_DNO		(1UL&lt;&lt;22)</span>

<span class="cp">#define IEEE_STATUS_MASK	(IEEE_STATUS_INV | IEEE_STATUS_DZE |	\</span>
<span class="cp">				 IEEE_STATUS_OVF | IEEE_STATUS_UNF |	\</span>
<span class="cp">				 IEEE_STATUS_INE | IEEE_STATUS_DNO)</span>

<span class="cp">#define IEEE_SW_MASK		(IEEE_TRAP_ENABLE_MASK |		\</span>
<span class="cp">				 IEEE_STATUS_MASK | IEEE_MAP_MASK)</span>

<span class="cp">#define IEEE_CURRENT_RM_SHIFT	32</span>
<span class="cp">#define IEEE_CURRENT_RM_MASK	(3UL&lt;&lt;IEEE_CURRENT_RM_SHIFT)</span>

<span class="cp">#define IEEE_STATUS_TO_EXCSUM_SHIFT	16</span>

<span class="cp">#define IEEE_INHERIT    (1UL&lt;&lt;63)	</span><span class="cm">/* inherit on thread create? */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Convert the software IEEE trap enable and status bits into the</span>
<span class="cm"> * hardware fpcr format. </span>
<span class="cm"> *</span>
<span class="cm"> * Digital Unix engineers receive my thanks for not defining the</span>
<span class="cm"> * software bits identical to the hardware bits.  The chip designers</span>
<span class="cm"> * receive my thanks for making all the not-implemented fpcr bits</span>
<span class="cm"> * RAZ forcing us to use system calls to read/write this value.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">ieee_swcr_to_fpcr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">;</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">IEEE_STATUS_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">35</span><span class="p">;</span>
	<span class="n">fp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">IEEE_MAP_DMZ</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">36</span><span class="p">;</span>
	<span class="n">fp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">IEEE_STATUS_MASK</span> <span class="o">?</span> <span class="n">FPCR_SUM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">fp</span> <span class="o">|=</span> <span class="p">(</span><span class="o">~</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE_TRAP_ENABLE_INV</span>
		      <span class="o">|</span> <span class="n">IEEE_TRAP_ENABLE_DZE</span>
		      <span class="o">|</span> <span class="n">IEEE_TRAP_ENABLE_OVF</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="p">;</span>
	<span class="n">fp</span> <span class="o">|=</span> <span class="p">(</span><span class="o">~</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE_TRAP_ENABLE_UNF</span> <span class="o">|</span> <span class="n">IEEE_TRAP_ENABLE_INE</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">57</span><span class="p">;</span>
	<span class="n">fp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">IEEE_MAP_UMZ</span> <span class="o">?</span> <span class="n">FPCR_UNDZ</span> <span class="o">|</span> <span class="n">FPCR_UNFD</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">fp</span> <span class="o">|=</span> <span class="p">(</span><span class="o">~</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">IEEE_TRAP_ENABLE_DNO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">41</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">ieee_fpcr_to_swcr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sw</span><span class="p">;</span>
	<span class="n">sw</span> <span class="o">=</span> <span class="p">(</span><span class="n">fp</span> <span class="o">&gt;&gt;</span> <span class="mi">35</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IEEE_STATUS_MASK</span><span class="p">;</span>
	<span class="n">sw</span> <span class="o">|=</span> <span class="p">(</span><span class="n">fp</span> <span class="o">&gt;&gt;</span> <span class="mi">36</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IEEE_MAP_DMZ</span><span class="p">;</span>
	<span class="n">sw</span> <span class="o">|=</span> <span class="p">(</span><span class="o">~</span><span class="n">fp</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE_TRAP_ENABLE_INV</span>
			     <span class="o">|</span> <span class="n">IEEE_TRAP_ENABLE_DZE</span>
			     <span class="o">|</span> <span class="n">IEEE_TRAP_ENABLE_OVF</span><span class="p">);</span>
	<span class="n">sw</span> <span class="o">|=</span> <span class="p">(</span><span class="o">~</span><span class="n">fp</span> <span class="o">&gt;&gt;</span> <span class="mi">57</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEEE_TRAP_ENABLE_UNF</span> <span class="o">|</span> <span class="n">IEEE_TRAP_ENABLE_INE</span><span class="p">);</span>
	<span class="n">sw</span> <span class="o">|=</span> <span class="p">(</span><span class="n">fp</span> <span class="o">&gt;&gt;</span> <span class="mi">47</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IEEE_MAP_UMZ</span><span class="p">;</span>
	<span class="n">sw</span> <span class="o">|=</span> <span class="p">(</span><span class="o">~</span><span class="n">fp</span> <span class="o">&gt;&gt;</span> <span class="mi">41</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IEEE_TRAP_ENABLE_DNO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sw</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/* The following two functions don&#39;t need trapb/excb instructions</span>
<span class="cm">   around the mf_fpcr/mt_fpcr instructions because (a) the kernel</span>
<span class="cm">   never generates arithmetic faults and (b) call_pal instructions</span>
<span class="cm">   are implied trap barriers.  */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">rdfpcr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_ALPHA_EV6) || defined(CONFIG_ALPHA_EV67)</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;ftoit $f0,%0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mf_fpcr $f0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ftoit $f0,%1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;itoft %0,$f0&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;stt $f0,%0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mf_fpcr $f0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;stt $f0,%1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldt $f0,%0&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=m&quot;</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">wrfpcr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_ALPHA_EV6) || defined(CONFIG_ALPHA_EV67)</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;ftoit $f0,%0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;itoft %1,$f0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mt_fpcr $f0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;itoft %0,$f0&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;stt $f0,%0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldt $f0,%1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mt_fpcr $f0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldt $f0,%0&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=m&quot;</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;m&quot;</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">swcr_update_status</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">swcr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fpcr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* EV6 implements most of the bits in hardware.  Collect</span>
<span class="cm">	   the acrued exception bits from the real fpcr.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">implver</span><span class="p">()</span> <span class="o">==</span> <span class="n">IMPLVER_EV6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swcr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IEEE_STATUS_MASK</span><span class="p">;</span>
		<span class="n">swcr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">fpcr</span> <span class="o">&gt;&gt;</span> <span class="mi">35</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IEEE_STATUS_MASK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">swcr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alpha_read_fp_reg</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">alpha_write_fp_reg</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alpha_read_fp_reg_s</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">alpha_write_fp_reg_s</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __ASM_ALPHA_FPU_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
