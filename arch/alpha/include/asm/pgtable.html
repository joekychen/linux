<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › include › asm › pgtable.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ALPHA_PGTABLE_H</span>
<span class="cp">#define _ALPHA_PGTABLE_H</span>

<span class="cp">#include &lt;asm-generic/4level-fixup.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This file contains the functions and defines necessary to modify and use</span>
<span class="cm"> * the Alpha page table tree.</span>
<span class="cm"> *</span>
<span class="cm"> * This hopefully works with any standard Alpha page-size, as defined</span>
<span class="cm"> * in &lt;asm/page.h&gt; (currently 8192).</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;	</span><span class="cm">/* For TASK_SIZE */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/machvec.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">;</span>

<span class="cm">/* Certain architectures need to do special things when PTEs</span>
<span class="cm"> * within a page table are directly modified.  Thus, the following</span>
<span class="cm"> * hook is made available.</span>
<span class="cm"> */</span>
<span class="cp">#define set_pte(pteptr, pteval) ((*(pteptr)) = (pteval))</span>
<span class="cp">#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)</span>

<span class="cm">/* PMD_SHIFT determines the size of the area a second-level page table can map */</span>
<span class="cp">#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT-3))</span>
<span class="cp">#define PMD_SIZE	(1UL &lt;&lt; PMD_SHIFT)</span>
<span class="cp">#define PMD_MASK	(~(PMD_SIZE-1))</span>

<span class="cm">/* PGDIR_SHIFT determines what a third-level page table entry can map */</span>
<span class="cp">#define PGDIR_SHIFT	(PAGE_SHIFT + 2*(PAGE_SHIFT-3))</span>
<span class="cp">#define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)</span>
<span class="cp">#define PGDIR_MASK	(~(PGDIR_SIZE-1))</span>

<span class="cm">/*</span>
<span class="cm"> * Entries per page directory level:  the Alpha is three-level, with</span>
<span class="cm"> * all levels having a one-page page table.</span>
<span class="cm"> */</span>
<span class="cp">#define PTRS_PER_PTE	(1UL &lt;&lt; (PAGE_SHIFT-3))</span>
<span class="cp">#define PTRS_PER_PMD	(1UL &lt;&lt; (PAGE_SHIFT-3))</span>
<span class="cp">#define PTRS_PER_PGD	(1UL &lt;&lt; (PAGE_SHIFT-3))</span>
<span class="cp">#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)</span>
<span class="cp">#define FIRST_USER_ADDRESS	0</span>

<span class="cm">/* Number of pointers that fit on a page:  this will go away. */</span>
<span class="cp">#define PTRS_PER_PAGE	(1UL &lt;&lt; (PAGE_SHIFT-3))</span>

<span class="cp">#ifdef CONFIG_ALPHA_LARGE_VMALLOC</span>
<span class="cp">#define VMALLOC_START		0xfffffe0000000000</span>
<span class="cp">#else</span>
<span class="cp">#define VMALLOC_START		(-2*PGDIR_SIZE)</span>
<span class="cp">#endif</span>
<span class="cp">#define VMALLOC_END		(-PGDIR_SIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * OSF/1 PAL-code-imposed page table bits</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_VALID	0x0001</span>
<span class="cp">#define _PAGE_FOR	0x0002	</span><span class="cm">/* used for page protection (fault on read) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_FOW	0x0004	</span><span class="cm">/* used for page protection (fault on write) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_FOE	0x0008	</span><span class="cm">/* used for page protection (fault on exec) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_ASM	0x0010</span>
<span class="cp">#define _PAGE_KRE	0x0100	</span><span class="cm">/* xxx - see below on the &quot;accessed&quot; bit */</span><span class="cp"></span>
<span class="cp">#define _PAGE_URE	0x0200	</span><span class="cm">/* xxx */</span><span class="cp"></span>
<span class="cp">#define _PAGE_KWE	0x1000	</span><span class="cm">/* used to do the dirty bit in software */</span><span class="cp"></span>
<span class="cp">#define _PAGE_UWE	0x2000	</span><span class="cm">/* used to do the dirty bit in software */</span><span class="cp"></span>

<span class="cm">/* .. and these are ours ... */</span>
<span class="cp">#define _PAGE_DIRTY	0x20000</span>
<span class="cp">#define _PAGE_ACCESSED	0x40000</span>
<span class="cp">#define _PAGE_FILE	0x80000	</span><span class="cm">/* set:pagecache, unset:swap */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * NOTE! The &quot;accessed&quot; bit isn&#39;t necessarily exact:  it can be kept exactly</span>
<span class="cm"> * by software (use the KRE/URE/KWE/UWE bits appropriately), but I&#39;ll fake it.</span>
<span class="cm"> * Under Linux/AXP, the &quot;accessed&quot; bit just means &quot;read&quot;, and I&#39;ll just use</span>
<span class="cm"> * the KRE/URE bits to watch for it. That way we don&#39;t need to overload the</span>
<span class="cm"> * KWE/UWE bits with both handling dirty and accessed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the kernel uses the accessed bit just to check whether to page</span>
<span class="cm"> * out a page or not, so it doesn&#39;t have to be exact anyway.</span>
<span class="cm"> */</span>

<span class="cp">#define __DIRTY_BITS	(_PAGE_DIRTY | _PAGE_KWE | _PAGE_UWE)</span>
<span class="cp">#define __ACCESS_BITS	(_PAGE_ACCESSED | _PAGE_KRE | _PAGE_URE)</span>

<span class="cp">#define _PFN_MASK	0xFFFFFFFF00000000UL</span>

<span class="cp">#define _PAGE_TABLE	(_PAGE_VALID | __DIRTY_BITS | __ACCESS_BITS)</span>
<span class="cp">#define _PAGE_CHG_MASK	(_PFN_MASK | __DIRTY_BITS | __ACCESS_BITS)</span>

<span class="cm">/*</span>
<span class="cm"> * All the normal masks have the &quot;page accessed&quot; bits on, as any time they are used,</span>
<span class="cm"> * the page is accessed. They are cleared only by the page-out routines</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_NONE	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOR | _PAGE_FOW | _PAGE_FOE)</span>
<span class="cp">#define PAGE_SHARED	__pgprot(_PAGE_VALID | __ACCESS_BITS)</span>
<span class="cp">#define PAGE_COPY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)</span>
<span class="cp">#define PAGE_READONLY	__pgprot(_PAGE_VALID | __ACCESS_BITS | _PAGE_FOW)</span>
<span class="cp">#define PAGE_KERNEL	__pgprot(_PAGE_VALID | _PAGE_ASM | _PAGE_KRE | _PAGE_KWE)</span>

<span class="cp">#define _PAGE_NORMAL(x) __pgprot(_PAGE_VALID | __ACCESS_BITS | (x))</span>

<span class="cp">#define _PAGE_P(x) _PAGE_NORMAL((x) | (((x) &amp; _PAGE_FOW)?0:_PAGE_FOW))</span>
<span class="cp">#define _PAGE_S(x) _PAGE_NORMAL(x)</span>

<span class="cm">/*</span>
<span class="cm"> * The hardware can handle write-only mappings, but as the Alpha</span>
<span class="cm"> * architecture does byte-wide writes with a read-modify-write</span>
<span class="cm"> * sequence, it&#39;s not practical to have write-without-read privs.</span>
<span class="cm"> * Thus the &quot;-w- -&gt; rw-&quot; and &quot;-wx -&gt; rwx&quot; mapping here (and in</span>
<span class="cm"> * arch/alpha/mm/fault.c)</span>
<span class="cm"> */</span>
	<span class="cm">/* xwr */</span>
<span class="cp">#define __P000	_PAGE_P(_PAGE_FOE | _PAGE_FOW | _PAGE_FOR)</span>
<span class="cp">#define __P001	_PAGE_P(_PAGE_FOE | _PAGE_FOW)</span>
<span class="cp">#define __P010	_PAGE_P(_PAGE_FOE)</span>
<span class="cp">#define __P011	_PAGE_P(_PAGE_FOE)</span>
<span class="cp">#define __P100	_PAGE_P(_PAGE_FOW | _PAGE_FOR)</span>
<span class="cp">#define __P101	_PAGE_P(_PAGE_FOW)</span>
<span class="cp">#define __P110	_PAGE_P(0)</span>
<span class="cp">#define __P111	_PAGE_P(0)</span>

<span class="cp">#define __S000	_PAGE_S(_PAGE_FOE | _PAGE_FOW | _PAGE_FOR)</span>
<span class="cp">#define __S001	_PAGE_S(_PAGE_FOE | _PAGE_FOW)</span>
<span class="cp">#define __S010	_PAGE_S(_PAGE_FOE)</span>
<span class="cp">#define __S011	_PAGE_S(_PAGE_FOE)</span>
<span class="cp">#define __S100	_PAGE_S(_PAGE_FOW | _PAGE_FOR)</span>
<span class="cp">#define __S101	_PAGE_S(_PAGE_FOW)</span>
<span class="cp">#define __S110	_PAGE_S(0)</span>
<span class="cp">#define __S111	_PAGE_S(0)</span>

<span class="cm">/*</span>
<span class="cm"> * pgprot_noncached() is only for infiniband pci support, and a real</span>
<span class="cm"> * implementation for RAM would be more complicated.</span>
<span class="cm"> */</span>
<span class="cp">#define pgprot_noncached(prot)	(prot)</span>

<span class="cm">/*</span>
<span class="cm"> * BAD_PAGETABLE is used when we need a bogus page-table, while</span>
<span class="cm"> * BAD_PAGE is used for a bogus page.</span>
<span class="cm"> *</span>
<span class="cm"> * ZERO_PAGE is a global shared page that is always zero:  used</span>
<span class="cm"> * for zero-mapped memory areas etc..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">pte_t</span> <span class="n">__bad_page</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">pmd_t</span> <span class="o">*</span> <span class="n">__bad_pagetable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__zero_page</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define BAD_PAGETABLE	__bad_pagetable()</span>
<span class="cp">#define BAD_PAGE	__bad_page()</span>
<span class="cp">#define ZERO_PAGE(vaddr)	(virt_to_page(ZERO_PGE))</span>

<span class="cm">/* number of bits that fit into a memory pointer */</span>
<span class="cp">#define BITS_PER_PTR			(8*sizeof(unsigned long))</span>

<span class="cm">/* to align the pointer to a pointer address */</span>
<span class="cp">#define PTR_MASK			(~(sizeof(void*)-1))</span>

<span class="cm">/* sizeof(void*)==1&lt;&lt;SIZEOF_PTR_LOG2 */</span>
<span class="cp">#define SIZEOF_PTR_LOG2			3</span>

<span class="cm">/* to find an entry in a page-table */</span>
<span class="cp">#define PAGE_PTR(address)		\</span>
<span class="cp">  ((unsigned long)(address)&gt;&gt;(PAGE_SHIFT-SIZEOF_PTR_LOG2)&amp;PTR_MASK&amp;~PAGE_MASK)</span>

<span class="cm">/*</span>
<span class="cm"> * On certain platforms whose physical address space can overlap KSEG,</span>
<span class="cm"> * namely EV6 and above, we must re-twiddle the physaddr to restore the</span>
<span class="cm"> * correct high-order bits.</span>
<span class="cm"> *</span>
<span class="cm"> * This is extremely confusing until you realize that this is actually</span>
<span class="cm"> * just working around a userspace bug.  The X server was intending to</span>
<span class="cm"> * provide the physical address but instead provided the KSEG address.</span>
<span class="cm"> * Or tried to, except it&#39;s not representable.</span>
<span class="cm"> * </span>
<span class="cm"> * On Tsunami there&#39;s nothing meaningful at 0x40000000000, so this is</span>
<span class="cm"> * a safe thing to do.  Come the first core logic that does put something</span>
<span class="cm"> * in this area -- memory or whathaveyou -- then this hack will have</span>
<span class="cm"> * to go away.  So be prepared!</span>
<span class="cm"> */</span>

<span class="cp">#if defined(CONFIG_ALPHA_GENERIC) &amp;&amp; defined(USE_48_BIT_KSEG)</span>
<span class="cp">#error &quot;EV6-only feature in a generic kernel&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_ALPHA_GENERIC) || \</span>
<span class="cp">    (defined(CONFIG_ALPHA_EV6) &amp;&amp; !defined(USE_48_BIT_KSEG))</span>
<span class="cp">#define KSEG_PFN	(0xc0000000000UL &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define PHYS_TWIDDLE(pfn) \</span>
<span class="cp">  ((((pfn) &amp; KSEG_PFN) == (0x40000000000UL &gt;&gt; PAGE_SHIFT)) \</span>
<span class="cp">  ? ((pfn) ^= KSEG_PFN) : (pfn))</span>
<span class="cp">#else</span>
<span class="cp">#define PHYS_TWIDDLE(pfn) (pfn)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Conversion functions:  convert a page and protection to a page entry,</span>
<span class="cm"> * and a page entry and page directory to the page they refer to.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_DISCONTIGMEM</span>
<span class="cp">#define page_to_pa(page)	(((page) - mem_map) &lt;&lt; PAGE_SHIFT)</span>

<span class="cp">#define pte_pfn(pte)	(pte_val(pte) &gt;&gt; 32)</span>
<span class="cp">#define pte_page(pte)	pfn_to_page(pte_pfn(pte))</span>
<span class="cp">#define mk_pte(page, pgprot)						\</span>
<span class="cp">({									\</span>
<span class="cp">	pte_t pte;							\</span>
<span class="cp">									\</span>
<span class="cp">	pte_val(pte) = (page_to_pfn(page) &lt;&lt; 32) | pgprot_val(pgprot);	\</span>
<span class="cp">	pte;								\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pfn_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physpfn</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">)</span>
<span class="p">{</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">PHYS_TWIDDLE</span><span class="p">(</span><span class="n">physpfn</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">pgprot</span><span class="p">);</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_CHG_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">newprot</span><span class="p">);</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmd_set</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span> <span class="n">pmdp</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span> <span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span> <span class="n">pmd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pmdp</span><span class="p">)</span> <span class="o">=</span> <span class="n">_PAGE_TABLE</span> <span class="o">|</span> <span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptep</span><span class="p">)</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">PAGE_SHIFT</span><span class="p">));</span> <span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pgd_set</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span> <span class="n">pgdp</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span> <span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span> <span class="n">pgd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pgdp</span><span class="p">)</span> <span class="o">=</span> <span class="n">_PAGE_TABLE</span> <span class="o">|</span> <span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pmdp</span><span class="p">)</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">PAGE_SHIFT</span><span class="p">));</span> <span class="p">}</span>


<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">pmd_page_vaddr</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PFN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">PAGE_SHIFT</span><span class="p">))</span> <span class="o">+</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_DISCONTIGMEM</span>
<span class="cp">#define pmd_page(pmd)	(mem_map + ((pmd_val(pmd) &amp; _PFN_MASK) &gt;&gt; 32))</span>
<span class="cp">#define pgd_page(pgd)	(mem_map + ((pgd_val(pgd) &amp; _PFN_MASK) &gt;&gt; 32))</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pgd_page_vaddr</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="p">((</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PFN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">PAGE_SHIFT</span><span class="p">));</span> <span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_none</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_present</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_VALID</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pte_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_none</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_bad</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PFN_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_PAGE_TABLE</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_present</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>	<span class="p">{</span> <span class="k">return</span> <span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_VALID</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmd_clear</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span> <span class="n">pmdp</span><span class="p">)</span>	<span class="p">{</span> <span class="n">pmd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pmdp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_none</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_bad</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PFN_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_PAGE_TABLE</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_present</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>	<span class="p">{</span> <span class="k">return</span> <span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_VALID</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pgd_clear</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span> <span class="n">pgdp</span><span class="p">)</span>	<span class="p">{</span> <span class="n">pgd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pgdp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following only work if pte_present() is true.</span>
<span class="cm"> * Undefined behaviour if not..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_write</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_FOW</span><span class="p">);</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_dirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_DIRTY</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_young</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_file</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_FILE</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_special</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_wrprotect</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_FOW</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkclean</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">__DIRTY_BITS</span><span class="p">);</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkold</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">__ACCESS_BITS</span><span class="p">);</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkwrite</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_FOW</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkdirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">__DIRTY_BITS</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkyoung</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">__ACCESS_BITS</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkspecial</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#define PAGE_DIR_OFFSET(tsk,address) pgd_offset((tsk),(address))</span>

<span class="cm">/* to find an entry in a kernel page-table-directory */</span>
<span class="cp">#define pgd_offset_k(address) pgd_offset(&amp;init_mm, (address))</span>

<span class="cm">/* to find an entry in a page-table-directory. */</span>
<span class="cp">#define pgd_index(address)	(((address) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))</span>
<span class="cp">#define pgd_offset(mm, address)	((mm)-&gt;pgd+pgd_index(address))</span>

<span class="cm">/*</span>
<span class="cm"> * The smp_read_barrier_depends() in the following functions are required to</span>
<span class="cm"> * order the load of *dir (the pointer in the top level page table) with any</span>
<span class="cm"> * subsequent load of the returned pmd_t *ret (ret is data dependent on *dir).</span>
<span class="cm"> *</span>
<span class="cm"> * If this ordering is not enforced, the CPU might load an older value of</span>
<span class="cm"> * *ret, which may be uninitialized data. See mm/memory.c:__pte_alloc for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we never change the mm-&gt;pgd pointer after the task is running, so</span>
<span class="cm"> * pgd_offset does not require such a barrier.</span>
<span class="cm"> */</span>

<span class="cm">/* Find an entry in the second-level page table.. */</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="o">*</span> <span class="nf">pmd_offset</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pgd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">dir</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">PMD_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTRS_PER_PAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">smp_read_barrier_depends</span><span class="p">();</span> <span class="cm">/* see above */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find an entry in the third-level page table.. */</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="o">*</span> <span class="nf">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">dir</span><span class="p">)</span>
		<span class="o">+</span> <span class="p">((</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTRS_PER_PAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">smp_read_barrier_depends</span><span class="p">();</span> <span class="cm">/* see above */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define pte_offset_map(dir,addr)	pte_offset_kernel((dir),(addr))</span>
<span class="cp">#define pte_unmap(pte)			do { } while (0)</span>

<span class="k">extern</span> <span class="n">pgd_t</span> <span class="n">swapper_pg_dir</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * The Alpha doesn&#39;t have any external MMU info:  the kernel page</span>
<span class="cm"> * tables contain all the necessary information.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_mmu_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Non-present pages:  high 24 bits are offset, next 8 bits type,</span>
<span class="cm"> * low 32 bits zero.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">mk_swap_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span><span class="p">);</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#define __swp_type(x)		(((x).val &gt;&gt; 32) &amp; 0xff)</span>
<span class="cp">#define __swp_offset(x)		((x).val &gt;&gt; 40)</span>
<span class="cp">#define __swp_entry(type, off)	((swp_entry_t) { pte_val(mk_swap_pte((type), (off))) })</span>
<span class="cp">#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })</span>
<span class="cp">#define __swp_entry_to_pte(x)	((pte_t) { (x).val })</span>

<span class="cp">#define pte_to_pgoff(pte)	(pte_val(pte) &gt;&gt; 32)</span>
<span class="cp">#define pgoff_to_pte(off)	((pte_t) { ((off) &lt;&lt; 32) | _PAGE_FILE })</span>

<span class="cp">#define PTE_FILE_MAX_BITS	32</span>

<span class="cp">#ifndef CONFIG_DISCONTIGMEM</span>
<span class="cp">#define kern_addr_valid(addr)	(1)</span>
<span class="cp">#endif</span>

<span class="cp">#define io_remap_pfn_range(vma, start, pfn, size, prot)	\</span>
<span class="cp">		remap_pfn_range(vma, start, pfn, size, prot)</span>

<span class="cp">#define pte_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pte %016lx.\n&quot;, __FILE__, __LINE__, pte_val(e))</span>
<span class="cp">#define pmd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pmd %016lx.\n&quot;, __FILE__, __LINE__, pmd_val(e))</span>
<span class="cp">#define pgd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pgd %016lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#include &lt;asm-generic/pgtable.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * No page table caches to initialise</span>
<span class="cm"> */</span>
<span class="cp">#define pgtable_cache_init()	do { } while (0)</span>

<span class="cm">/* We have our own get_unmapped_area to cope with ADDR_LIMIT_32BIT.  */</span>
<span class="cp">#define HAVE_ARCH_UNMAPPED_AREA</span>

<span class="cp">#endif </span><span class="cm">/* _ALPHA_PGTABLE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
