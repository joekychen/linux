<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › include › asm › uaccess.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>uaccess.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __ALPHA_UACCESS_H</span>
<span class="cp">#define __ALPHA_UACCESS_H</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * The fs value determines whether argument validity checking should be</span>
<span class="cm"> * performed or not.  If get_fs() == USER_DS, checking is performed, with</span>
<span class="cm"> * get_fs() == KERNEL_DS, checking is bypassed.</span>
<span class="cm"> *</span>
<span class="cm"> * Or at least it did once upon a time.  Nowadays it is a mask that</span>
<span class="cm"> * defines which bits of the address space are off limits.  This is a</span>
<span class="cm"> * wee bit faster than the above.</span>
<span class="cm"> *</span>
<span class="cm"> * For historical reasons, these macros are grossly misnamed.</span>
<span class="cm"> */</span>

<span class="cp">#define KERNEL_DS	((mm_segment_t) { 0UL })</span>
<span class="cp">#define USER_DS		((mm_segment_t) { -0x40000000000UL })</span>

<span class="cp">#define VERIFY_READ	0</span>
<span class="cp">#define VERIFY_WRITE	1</span>

<span class="cp">#define get_fs()  (current_thread_info()-&gt;addr_limit)</span>
<span class="cp">#define get_ds()  (KERNEL_DS)</span>
<span class="cp">#define set_fs(x) (current_thread_info()-&gt;addr_limit = (x))</span>

<span class="cp">#define segment_eq(a,b)	((a).seg == (b).seg)</span>

<span class="cm">/*</span>
<span class="cm"> * Is a address valid? This does a straightforward calculation rather</span>
<span class="cm"> * than tests.</span>
<span class="cm"> *</span>
<span class="cm"> * Address valid if:</span>
<span class="cm"> *  - &quot;addr&quot; doesn&#39;t have any high-bits set</span>
<span class="cm"> *  - AND &quot;size&quot; doesn&#39;t have any high-bits set</span>
<span class="cm"> *  - AND &quot;addr+size&quot; doesn&#39;t have any high-bits set</span>
<span class="cm"> *  - OR we are in kernel mode.</span>
<span class="cm"> */</span>
<span class="cp">#define __access_ok(addr,size,segment) \</span>
<span class="cp">	(((segment).seg &amp; (addr | size | (addr+size))) == 0)</span>

<span class="cp">#define access_ok(type,addr,size)				\</span>
<span class="cp">({								\</span>
<span class="cp">	__chk_user_ptr(addr);					\</span>
<span class="cp">	__access_ok(((unsigned long)(addr)),(size),get_fs());	\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * These are the main single-value transfer routines.  They automatically</span>
<span class="cm"> * use the right size if we just have the right pointer type.</span>
<span class="cm"> *</span>
<span class="cm"> * As the alpha uses the same address space for kernel and user</span>
<span class="cm"> * data, we can just do these as direct assignments.  (Of course, the</span>
<span class="cm"> * exception handling means that it&#39;s no longer &quot;just&quot;...)</span>
<span class="cm"> *</span>
<span class="cm"> * Careful to not</span>
<span class="cm"> * (a) re-use the arguments for side effects (sizeof/typeof is ok)</span>
<span class="cm"> * (b) require any knowledge of processes at this stage</span>
<span class="cm"> */</span>
<span class="cp">#define put_user(x,ptr) \</span>
<span class="cp">  __put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)),get_fs())</span>
<span class="cp">#define get_user(x,ptr) \</span>
<span class="cp">  __get_user_check((x),(ptr),sizeof(*(ptr)),get_fs())</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;__xxx&quot; versions do not do address space checking, useful when</span>
<span class="cm"> * doing multiple accesses to the same area (the programmer has to do the</span>
<span class="cm"> * checks by hand with &quot;access_ok()&quot;)</span>
<span class="cm"> */</span>
<span class="cp">#define __put_user(x,ptr) \</span>
<span class="cp">  __put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))</span>
<span class="cp">#define __get_user(x,ptr) \</span>
<span class="cp">  __get_user_nocheck((x),(ptr),sizeof(*(ptr)))</span>
  
<span class="cm">/*</span>
<span class="cm"> * The &quot;lda %1, 2b-1b(%0)&quot; bits are magic to get the assembler to</span>
<span class="cm"> * encode the bits we need for resolving the exception.  See the</span>
<span class="cm"> * more extensive comments with fixup_inline_exception below for</span>
<span class="cm"> * more information.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__get_user_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define __get_user_nocheck(x,ptr,size)				\</span>
<span class="cp">({								\</span>
<span class="cp">	long __gu_err = 0;					\</span>
<span class="cp">	unsigned long __gu_val;					\</span>
<span class="cp">	__chk_user_ptr(ptr);					\</span>
<span class="cp">	switch (size) {						\</span>
<span class="cp">	  case 1: __get_user_8(ptr); break;			\</span>
<span class="cp">	  case 2: __get_user_16(ptr); break;			\</span>
<span class="cp">	  case 4: __get_user_32(ptr); break;			\</span>
<span class="cp">	  case 8: __get_user_64(ptr); break;			\</span>
<span class="cp">	  default: __get_user_unknown(); break;			\</span>
<span class="cp">	}							\</span>
<span class="cp">	(x) = (__typeof__(*(ptr))) __gu_val;			\</span>
<span class="cp">	__gu_err;						\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_check(x,ptr,size,segment)				\</span>
<span class="cp">({									\</span>
<span class="cp">	long __gu_err = -EFAULT;					\</span>
<span class="cp">	unsigned long __gu_val = 0;					\</span>
<span class="cp">	const __typeof__(*(ptr)) __user *__gu_addr = (ptr);		\</span>
<span class="cp">	if (__access_ok((unsigned long)__gu_addr,size,segment)) {	\</span>
<span class="cp">		__gu_err = 0;						\</span>
<span class="cp">		switch (size) {						\</span>
<span class="cp">		  case 1: __get_user_8(__gu_addr); break;		\</span>
<span class="cp">		  case 2: __get_user_16(__gu_addr); break;		\</span>
<span class="cp">		  case 4: __get_user_32(__gu_addr); break;		\</span>
<span class="cp">		  case 8: __get_user_64(__gu_addr); break;		\</span>
<span class="cp">		  default: __get_user_unknown(); break;			\</span>
<span class="cp">		}							\</span>
<span class="cp">	}								\</span>
<span class="cp">	(x) = (__typeof__(*(ptr))) __gu_val;				\</span>
<span class="cp">	__gu_err;							\</span>
<span class="cp">})</span>

<span class="k">struct</span> <span class="n">__large_struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="p">};</span>
<span class="cp">#define __m(x) (*(struct __large_struct __user *)(x))</span>

<span class="cp">#define __get_user_64(addr)				\</span>
<span class="cp">	__asm__(&quot;1: ldq %0,%2\n&quot;			\</span>
<span class="cp">	&quot;2:\n&quot;						\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;			\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;				\</span>
<span class="cp">	&quot;	lda %0, 2b-1b(%1)\n&quot;			\</span>
<span class="cp">	&quot;.previous&quot;					\</span>
<span class="cp">		: &quot;=r&quot;(__gu_val), &quot;=r&quot;(__gu_err)	\</span>
<span class="cp">		: &quot;m&quot;(__m(addr)), &quot;1&quot;(__gu_err))</span>

<span class="cp">#define __get_user_32(addr)				\</span>
<span class="cp">	__asm__(&quot;1: ldl %0,%2\n&quot;			\</span>
<span class="cp">	&quot;2:\n&quot;						\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;			\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;				\</span>
<span class="cp">	&quot;	lda %0, 2b-1b(%1)\n&quot;			\</span>
<span class="cp">	&quot;.previous&quot;					\</span>
<span class="cp">		: &quot;=r&quot;(__gu_val), &quot;=r&quot;(__gu_err)	\</span>
<span class="cp">		: &quot;m&quot;(__m(addr)), &quot;1&quot;(__gu_err))</span>

<span class="cp">#ifdef __alpha_bwx__</span>
<span class="cm">/* Those lucky bastards with ev56 and later CPUs can do byte/word moves.  */</span>

<span class="cp">#define __get_user_16(addr)				\</span>
<span class="cp">	__asm__(&quot;1: ldwu %0,%2\n&quot;			\</span>
<span class="cp">	&quot;2:\n&quot;						\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;			\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;				\</span>
<span class="cp">	&quot;	lda %0, 2b-1b(%1)\n&quot;			\</span>
<span class="cp">	&quot;.previous&quot;					\</span>
<span class="cp">		: &quot;=r&quot;(__gu_val), &quot;=r&quot;(__gu_err)	\</span>
<span class="cp">		: &quot;m&quot;(__m(addr)), &quot;1&quot;(__gu_err))</span>

<span class="cp">#define __get_user_8(addr)				\</span>
<span class="cp">	__asm__(&quot;1: ldbu %0,%2\n&quot;			\</span>
<span class="cp">	&quot;2:\n&quot;						\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;			\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;				\</span>
<span class="cp">	&quot;	lda %0, 2b-1b(%1)\n&quot;			\</span>
<span class="cp">	&quot;.previous&quot;					\</span>
<span class="cp">		: &quot;=r&quot;(__gu_val), &quot;=r&quot;(__gu_err)	\</span>
<span class="cp">		: &quot;m&quot;(__m(addr)), &quot;1&quot;(__gu_err))</span>
<span class="cp">#else</span>
<span class="cm">/* Unfortunately, we can&#39;t get an unaligned access trap for the sub-word</span>
<span class="cm">   load, so we have to do a general unaligned operation.  */</span>

<span class="cp">#define __get_user_16(addr)						\</span>
<span class="cp">{									\</span>
<span class="cp">	long __gu_tmp;							\</span>
<span class="cp">	__asm__(&quot;1: ldq_u %0,0(%3)\n&quot;					\</span>
<span class="cp">	&quot;2:	ldq_u %1,1(%3)\n&quot;					\</span>
<span class="cp">	&quot;	extwl %0,%3,%0\n&quot;					\</span>
<span class="cp">	&quot;	extwh %1,%3,%1\n&quot;					\</span>
<span class="cp">	&quot;	or %0,%1,%0\n&quot;						\</span>
<span class="cp">	&quot;3:\n&quot;								\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;					\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;						\</span>
<span class="cp">	&quot;	lda %0, 3b-1b(%2)\n&quot;					\</span>
<span class="cp">	&quot;	.long 2b - .\n&quot;						\</span>
<span class="cp">	&quot;	lda %0, 3b-2b(%2)\n&quot;					\</span>
<span class="cp">	&quot;.previous&quot;							\</span>
<span class="cp">		: &quot;=&amp;r&quot;(__gu_val), &quot;=&amp;r&quot;(__gu_tmp), &quot;=r&quot;(__gu_err)	\</span>
<span class="cp">		: &quot;r&quot;(addr), &quot;2&quot;(__gu_err));				\</span>
<span class="cp">}</span>

<span class="cp">#define __get_user_8(addr)						\</span>
<span class="cp">	__asm__(&quot;1: ldq_u %0,0(%2)\n&quot;					\</span>
<span class="cp">	&quot;	extbl %0,%2,%0\n&quot;					\</span>
<span class="cp">	&quot;2:\n&quot;								\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;					\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;						\</span>
<span class="cp">	&quot;	lda %0, 2b-1b(%1)\n&quot;					\</span>
<span class="cp">	&quot;.previous&quot;							\</span>
<span class="cp">		: &quot;=&amp;r&quot;(__gu_val), &quot;=r&quot;(__gu_err)			\</span>
<span class="cp">		: &quot;r&quot;(addr), &quot;1&quot;(__gu_err))</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__put_user_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define __put_user_nocheck(x,ptr,size)				\</span>
<span class="cp">({								\</span>
<span class="cp">	long __pu_err = 0;					\</span>
<span class="cp">	__chk_user_ptr(ptr);					\</span>
<span class="cp">	switch (size) {						\</span>
<span class="cp">	  case 1: __put_user_8(x,ptr); break;			\</span>
<span class="cp">	  case 2: __put_user_16(x,ptr); break;			\</span>
<span class="cp">	  case 4: __put_user_32(x,ptr); break;			\</span>
<span class="cp">	  case 8: __put_user_64(x,ptr); break;			\</span>
<span class="cp">	  default: __put_user_unknown(); break;			\</span>
<span class="cp">	}							\</span>
<span class="cp">	__pu_err;						\</span>
<span class="cp">})</span>

<span class="cp">#define __put_user_check(x,ptr,size,segment)				\</span>
<span class="cp">({									\</span>
<span class="cp">	long __pu_err = -EFAULT;					\</span>
<span class="cp">	__typeof__(*(ptr)) __user *__pu_addr = (ptr);			\</span>
<span class="cp">	if (__access_ok((unsigned long)__pu_addr,size,segment)) {	\</span>
<span class="cp">		__pu_err = 0;						\</span>
<span class="cp">		switch (size) {						\</span>
<span class="cp">		  case 1: __put_user_8(x,__pu_addr); break;		\</span>
<span class="cp">		  case 2: __put_user_16(x,__pu_addr); break;		\</span>
<span class="cp">		  case 4: __put_user_32(x,__pu_addr); break;		\</span>
<span class="cp">		  case 8: __put_user_64(x,__pu_addr); break;		\</span>
<span class="cp">		  default: __put_user_unknown(); break;			\</span>
<span class="cp">		}							\</span>
<span class="cp">	}								\</span>
<span class="cp">	__pu_err;							\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;__put_user_xx()&quot; macros tell gcc they read from memory</span>
<span class="cm"> * instead of writing: this is because they do not write to</span>
<span class="cm"> * any memory gcc knows about, so there are no aliasing issues</span>
<span class="cm"> */</span>
<span class="cp">#define __put_user_64(x,addr)					\</span>
<span class="cp">__asm__ __volatile__(&quot;1: stq %r2,%1\n&quot;				\</span>
<span class="cp">	&quot;2:\n&quot;							\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31,2b-1b(%0)\n&quot;				\</span>
<span class="cp">	&quot;.previous&quot;						\</span>
<span class="cp">		: &quot;=r&quot;(__pu_err)				\</span>
<span class="cp">		: &quot;m&quot; (__m(addr)), &quot;rJ&quot; (x), &quot;0&quot;(__pu_err))</span>

<span class="cp">#define __put_user_32(x,addr)					\</span>
<span class="cp">__asm__ __volatile__(&quot;1: stl %r2,%1\n&quot;				\</span>
<span class="cp">	&quot;2:\n&quot;							\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31,2b-1b(%0)\n&quot;				\</span>
<span class="cp">	&quot;.previous&quot;						\</span>
<span class="cp">		: &quot;=r&quot;(__pu_err)				\</span>
<span class="cp">		: &quot;m&quot;(__m(addr)), &quot;rJ&quot;(x), &quot;0&quot;(__pu_err))</span>

<span class="cp">#ifdef __alpha_bwx__</span>
<span class="cm">/* Those lucky bastards with ev56 and later CPUs can do byte/word moves.  */</span>

<span class="cp">#define __put_user_16(x,addr)					\</span>
<span class="cp">__asm__ __volatile__(&quot;1: stw %r2,%1\n&quot;				\</span>
<span class="cp">	&quot;2:\n&quot;							\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31,2b-1b(%0)\n&quot;				\</span>
<span class="cp">	&quot;.previous&quot;						\</span>
<span class="cp">		: &quot;=r&quot;(__pu_err)				\</span>
<span class="cp">		: &quot;m&quot;(__m(addr)), &quot;rJ&quot;(x), &quot;0&quot;(__pu_err))</span>

<span class="cp">#define __put_user_8(x,addr)					\</span>
<span class="cp">__asm__ __volatile__(&quot;1: stb %r2,%1\n&quot;				\</span>
<span class="cp">	&quot;2:\n&quot;							\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31,2b-1b(%0)\n&quot;				\</span>
<span class="cp">	&quot;.previous&quot;						\</span>
<span class="cp">		: &quot;=r&quot;(__pu_err)				\</span>
<span class="cp">		: &quot;m&quot;(__m(addr)), &quot;rJ&quot;(x), &quot;0&quot;(__pu_err))</span>
<span class="cp">#else</span>
<span class="cm">/* Unfortunately, we can&#39;t get an unaligned access trap for the sub-word</span>
<span class="cm">   write, so we have to do a general unaligned operation.  */</span>

<span class="cp">#define __put_user_16(x,addr)					\</span>
<span class="cp">{								\</span>
<span class="cp">	long __pu_tmp1, __pu_tmp2, __pu_tmp3, __pu_tmp4;	\</span>
<span class="cp">	__asm__ __volatile__(					\</span>
<span class="cp">	&quot;1:	ldq_u %2,1(%5)\n&quot;				\</span>
<span class="cp">	&quot;2:	ldq_u %1,0(%5)\n&quot;				\</span>
<span class="cp">	&quot;	inswh %6,%5,%4\n&quot;				\</span>
<span class="cp">	&quot;	inswl %6,%5,%3\n&quot;				\</span>
<span class="cp">	&quot;	mskwh %2,%5,%2\n&quot;				\</span>
<span class="cp">	&quot;	mskwl %1,%5,%1\n&quot;				\</span>
<span class="cp">	&quot;	or %2,%4,%2\n&quot;					\</span>
<span class="cp">	&quot;	or %1,%3,%1\n&quot;					\</span>
<span class="cp">	&quot;3:	stq_u %2,1(%5)\n&quot;				\</span>
<span class="cp">	&quot;4:	stq_u %1,0(%5)\n&quot;				\</span>
<span class="cp">	&quot;5:\n&quot;							\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31, 5b-1b(%0)\n&quot;				\</span>
<span class="cp">	&quot;	.long 2b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31, 5b-2b(%0)\n&quot;				\</span>
<span class="cp">	&quot;	.long 3b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31, 5b-3b(%0)\n&quot;				\</span>
<span class="cp">	&quot;	.long 4b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31, 5b-4b(%0)\n&quot;				\</span>
<span class="cp">	&quot;.previous&quot;						\</span>
<span class="cp">		: &quot;=r&quot;(__pu_err), &quot;=&amp;r&quot;(__pu_tmp1),		\</span>
<span class="cp">		  &quot;=&amp;r&quot;(__pu_tmp2), &quot;=&amp;r&quot;(__pu_tmp3),		\</span>
<span class="cp">		  &quot;=&amp;r&quot;(__pu_tmp4)				\</span>
<span class="cp">		: &quot;r&quot;(addr), &quot;r&quot;((unsigned long)(x)), &quot;0&quot;(__pu_err)); \</span>
<span class="cp">}</span>

<span class="cp">#define __put_user_8(x,addr)					\</span>
<span class="cp">{								\</span>
<span class="cp">	long __pu_tmp1, __pu_tmp2;				\</span>
<span class="cp">	__asm__ __volatile__(					\</span>
<span class="cp">	&quot;1:	ldq_u %1,0(%4)\n&quot;				\</span>
<span class="cp">	&quot;	insbl %3,%4,%2\n&quot;				\</span>
<span class="cp">	&quot;	mskbl %1,%4,%1\n&quot;				\</span>
<span class="cp">	&quot;	or %1,%2,%1\n&quot;					\</span>
<span class="cp">	&quot;2:	stq_u %1,0(%4)\n&quot;				\</span>
<span class="cp">	&quot;3:\n&quot;							\</span>
<span class="cp">	&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\</span>
<span class="cp">	&quot;	.long 1b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31, 3b-1b(%0)\n&quot;				\</span>
<span class="cp">	&quot;	.long 2b - .\n&quot;					\</span>
<span class="cp">	&quot;	lda $31, 3b-2b(%0)\n&quot;				\</span>
<span class="cp">	&quot;.previous&quot;						\</span>
<span class="cp">		: &quot;=r&quot;(__pu_err),				\</span>
<span class="cp">	  	  &quot;=&amp;r&quot;(__pu_tmp1), &quot;=&amp;r&quot;(__pu_tmp2)		\</span>
<span class="cp">		: &quot;r&quot;((unsigned long)(x)), &quot;r&quot;(addr), &quot;0&quot;(__pu_err)); \</span>
<span class="cp">}</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * Complex access routines</span>
<span class="cm"> */</span>

<span class="cm">/* This little bit of silliness is to get the GP loaded for a function</span>
<span class="cm">   that ordinarily wouldn&#39;t.  Otherwise we could have it done by the macro</span>
<span class="cm">   directly, which can be optimized the linker.  */</span>
<span class="cp">#ifdef MODULE</span>
<span class="cp">#define __module_address(sym)		&quot;r&quot;(sym),</span>
<span class="cp">#define __module_call(ra, arg, sym)	&quot;jsr $&quot; #ra &quot;,(%&quot; #arg &quot;),&quot; #sym</span>
<span class="cp">#else</span>
<span class="cp">#define __module_address(sym)</span>
<span class="cp">#define __module_call(ra, arg, sym)	&quot;bsr $&quot; #ra &quot;,&quot; #sym &quot; !samegp&quot;</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__copy_user</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">__copy_tofrom_user_nocheck</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__cu_to</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;$6&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="k">register</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__cu_from</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;$7&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">long</span> <span class="n">__cu_len</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;$0&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="n">__module_call</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">__copy_user</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">__cu_len</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">__cu_from</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">__cu_to</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">__module_address</span><span class="p">(</span><span class="n">__copy_user</span><span class="p">)</span>
		  <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">__cu_len</span><span class="p">),</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">__cu_from</span><span class="p">),</span> <span class="s">&quot;2&quot;</span> <span class="p">(</span><span class="n">__cu_to</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;$1&quot;</span><span class="p">,</span><span class="s">&quot;$2&quot;</span><span class="p">,</span><span class="s">&quot;$3&quot;</span><span class="p">,</span><span class="s">&quot;$4&quot;</span><span class="p">,</span><span class="s">&quot;$5&quot;</span><span class="p">,</span><span class="s">&quot;$28&quot;</span><span class="p">,</span><span class="s">&quot;memory&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__cu_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">__copy_tofrom_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">validate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__access_ok</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">validate</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">get_fs</span><span class="p">()))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">__copy_tofrom_user_nocheck</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __copy_to_user(to,from,n)					\</span>
<span class="cp">({									\</span>
<span class="cp">	__chk_user_ptr(to);						\</span>
<span class="cp">	__copy_tofrom_user_nocheck((__force void *)(to),(from),(n));	\</span>
<span class="cp">})</span>
<span class="cp">#define __copy_from_user(to,from,n)					\</span>
<span class="cp">({									\</span>
<span class="cp">	__chk_user_ptr(from);						\</span>
<span class="cp">	__copy_tofrom_user_nocheck((to),(__force void *)(from),(n));	\</span>
<span class="cp">})</span>

<span class="cp">#define __copy_to_user_inatomic __copy_to_user</span>
<span class="cp">#define __copy_from_user_inatomic __copy_from_user</span>


<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_tofrom_user</span><span class="p">((</span><span class="n">__force</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">copy_from_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_tofrom_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__do_clear_user</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">__clear_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">__cl_to</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;$6&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">long</span> <span class="n">__cl_len</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;$0&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="n">__module_call</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">__do_clear_user</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">__cl_len</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">__cl_to</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">__module_address</span><span class="p">(</span><span class="n">__do_clear_user</span><span class="p">)</span>
		  <span class="s">&quot;0&quot;</span><span class="p">(</span><span class="n">__cl_len</span><span class="p">),</span> <span class="s">&quot;1&quot;</span><span class="p">(</span><span class="n">__cl_to</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;$1&quot;</span><span class="p">,</span><span class="s">&quot;$2&quot;</span><span class="p">,</span><span class="s">&quot;$3&quot;</span><span class="p">,</span><span class="s">&quot;$4&quot;</span><span class="p">,</span><span class="s">&quot;$5&quot;</span><span class="p">,</span><span class="s">&quot;$28&quot;</span><span class="p">,</span><span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__cl_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">clear_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__access_ok</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">to</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">get_fs</span><span class="p">()))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">__clear_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#undef __module_address</span>
<span class="cp">#undef __module_call</span>

<span class="cm">/* Returns: -EFAULT if exception before terminator, N if the entire</span>
<span class="cm">   buffer filled, else strlen.  */</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">__strncpy_from_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">__to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">__to_len</span><span class="p">);</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">strncpy_from_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__access_ok</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">get_fs</span><span class="p">()))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__strncpy_from_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns: 0 if bad, string length+1 (memory size) of string if ok */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">__strlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">strlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span><span class="n">str</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">__strlen_user</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns: 0 if exception before NUL or reaching the supplied limit (N),</span>
<span class="cm"> * a value greater than N if the limit would be exceeded, else strlen.  */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">__strnlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">strnlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span><span class="n">str</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">__strnlen_user</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * About the exception table:</span>
<span class="cm"> *</span>
<span class="cm"> * - insn is a 32-bit pc-relative offset from the faulting insn.</span>
<span class="cm"> * - nextinsn is a 16-bit offset off of the faulting instruction</span>
<span class="cm"> *   (not off of the *next* instruction as branches are).</span>
<span class="cm"> * - errreg is the register in which to place -EFAULT.</span>
<span class="cm"> * - valreg is the final target register for the load sequence</span>
<span class="cm"> *   and will be zeroed.</span>
<span class="cm"> *</span>
<span class="cm"> * Either errreg or valreg may be $31, in which case nothing happens.</span>
<span class="cm"> *</span>
<span class="cm"> * The exception fixup information &quot;just so happens&quot; to be arranged</span>
<span class="cm"> * as in a MEM format instruction.  This lets us emit our three</span>
<span class="cm"> * values like so:</span>
<span class="cm"> *</span>
<span class="cm"> *      lda valreg, nextinsn(errreg)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">exception_table_entry</span>
<span class="p">{</span>
	<span class="kt">signed</span> <span class="kt">int</span> <span class="n">insn</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">exception_fixup</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">unit</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">signed</span> <span class="kt">int</span> <span class="n">nextinsn</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">errreg</span> <span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valreg</span> <span class="o">:</span> <span class="mi">5</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">bits</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fixup</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Returns the new pc */</span>
<span class="cp">#define fixup_exception(map_reg, _fixup, pc)			\</span>
<span class="cp">({								\</span>
<span class="cp">	if ((_fixup)-&gt;fixup.bits.valreg != 31)			\</span>
<span class="cp">		map_reg((_fixup)-&gt;fixup.bits.valreg) = 0;	\</span>
<span class="cp">	if ((_fixup)-&gt;fixup.bits.errreg != 31)			\</span>
<span class="cp">		map_reg((_fixup)-&gt;fixup.bits.errreg) = -EFAULT;	\</span>
<span class="cp">	(pc) + (_fixup)-&gt;fixup.bits.nextinsn;			\</span>
<span class="cp">})</span>

<span class="cp">#define ARCH_HAS_SORT_EXTABLE</span>
<span class="cp">#define ARCH_HAS_SEARCH_EXTABLE</span>

<span class="cp">#endif </span><span class="cm">/* __ALPHA_UACCESS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
