<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › include › asm › core_lca.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>core_lca.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __ALPHA_LCA__H__</span>
<span class="cp">#define __ALPHA_LCA__H__</span>

<span class="cp">#include &lt;asm/compiler.h&gt;</span>
<span class="cp">#include &lt;asm/mce.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Low Cost Alpha (LCA) definitions (these apply to 21066 and 21068,</span>
<span class="cm"> * for example).</span>
<span class="cm"> *</span>
<span class="cm"> * This file is based on:</span>
<span class="cm"> *</span>
<span class="cm"> *	DECchip 21066 and DECchip 21068 Alpha AXP Microprocessors</span>
<span class="cm"> *	Hardware Reference Manual; Digital Equipment Corp.; May 1994;</span>
<span class="cm"> *	Maynard, MA; Order Number: EC-N2681-71.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: The LCA uses a Host Address Extension (HAE) register to access</span>
<span class="cm"> *	 PCI addresses that are beyond the first 27 bits of address</span>
<span class="cm"> *	 space.  Updating the HAE requires an external cycle (and</span>
<span class="cm"> *	 a memory barrier), which tends to be slow.  Instead of updating</span>
<span class="cm"> *	 it on each sparse memory access, we keep the current HAE value</span>
<span class="cm"> *	 cached in variable cache_hae.  Only if the cached HAE differs</span>
<span class="cm"> *	 from the desired HAE value do we actually updated HAE register.</span>
<span class="cm"> *	 The HAE register is preserved by the interrupt handler entry/exit</span>
<span class="cm"> *	 code, so this scheme works even in the presence of interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * Dense memory space doesn&#39;t require the HAE, but is restricted to</span>
<span class="cm"> * aligned 32 and 64 bit accesses.  Special Cycle and Interrupt</span>
<span class="cm"> * Acknowledge cycles may also require the use of the HAE.  The LCA</span>
<span class="cm"> * limits I/O address space to the bottom 24 bits of address space,</span>
<span class="cm"> * but this easily covers the 16 bit ISA I/O address space.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE 2! The memory operations do not set any memory barriers, as</span>
<span class="cm"> * it&#39;s not needed for cases like a frame buffer that is essentially</span>
<span class="cm"> * memory-like.  You need to do them by hand if the operations depend</span>
<span class="cm"> * on ordering.</span>
<span class="cm"> *</span>
<span class="cm"> * Similarly, the port I/O operations do a &quot;mb&quot; only after a write</span>
<span class="cm"> * operation: if an mb is needed before (as in the case of doing</span>
<span class="cm"> * memory mapped I/O first, and then a port I/O operation to the same</span>
<span class="cm"> * device), it needs to be done by hand.</span>
<span class="cm"> *</span>
<span class="cm"> * After the above has bitten me 100 times, I&#39;ll give up and just do</span>
<span class="cm"> * the mb all the time, but right now I&#39;m hoping this will work out.</span>
<span class="cm"> * Avoiding mb&#39;s may potentially be a noticeable speed improvement,</span>
<span class="cm"> * but I can&#39;t honestly say I&#39;ve tested it.</span>
<span class="cm"> *</span>
<span class="cm"> * Handling interrupts that need to do mb&#39;s to synchronize to</span>
<span class="cm"> * non-interrupts is another fun race area.  Don&#39;t do it (because if</span>
<span class="cm"> * you do, I&#39;ll have to do *everything* with interrupts disabled,</span>
<span class="cm"> * ugh).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Memory Controller registers:</span>
<span class="cm"> */</span>
<span class="cp">#define LCA_MEM_BCR0		(IDENT_ADDR + 0x120000000UL)</span>
<span class="cp">#define LCA_MEM_BCR1		(IDENT_ADDR + 0x120000008UL)</span>
<span class="cp">#define LCA_MEM_BCR2		(IDENT_ADDR + 0x120000010UL)</span>
<span class="cp">#define LCA_MEM_BCR3		(IDENT_ADDR + 0x120000018UL)</span>
<span class="cp">#define LCA_MEM_BMR0		(IDENT_ADDR + 0x120000020UL)</span>
<span class="cp">#define LCA_MEM_BMR1		(IDENT_ADDR + 0x120000028UL)</span>
<span class="cp">#define LCA_MEM_BMR2		(IDENT_ADDR + 0x120000030UL)</span>
<span class="cp">#define LCA_MEM_BMR3		(IDENT_ADDR + 0x120000038UL)</span>
<span class="cp">#define LCA_MEM_BTR0		(IDENT_ADDR + 0x120000040UL)</span>
<span class="cp">#define LCA_MEM_BTR1		(IDENT_ADDR + 0x120000048UL)</span>
<span class="cp">#define LCA_MEM_BTR2		(IDENT_ADDR + 0x120000050UL)</span>
<span class="cp">#define LCA_MEM_BTR3		(IDENT_ADDR + 0x120000058UL)</span>
<span class="cp">#define LCA_MEM_GTR		(IDENT_ADDR + 0x120000060UL)</span>
<span class="cp">#define LCA_MEM_ESR		(IDENT_ADDR + 0x120000068UL)</span>
<span class="cp">#define LCA_MEM_EAR		(IDENT_ADDR + 0x120000070UL)</span>
<span class="cp">#define LCA_MEM_CAR		(IDENT_ADDR + 0x120000078UL)</span>
<span class="cp">#define LCA_MEM_VGR		(IDENT_ADDR + 0x120000080UL)</span>
<span class="cp">#define LCA_MEM_PLM		(IDENT_ADDR + 0x120000088UL)</span>
<span class="cp">#define LCA_MEM_FOR		(IDENT_ADDR + 0x120000090UL)</span>

<span class="cm">/*</span>
<span class="cm"> * I/O Controller registers:</span>
<span class="cm"> */</span>
<span class="cp">#define LCA_IOC_HAE		(IDENT_ADDR + 0x180000000UL)</span>
<span class="cp">#define LCA_IOC_CONF		(IDENT_ADDR + 0x180000020UL)</span>
<span class="cp">#define LCA_IOC_STAT0		(IDENT_ADDR + 0x180000040UL)</span>
<span class="cp">#define LCA_IOC_STAT1		(IDENT_ADDR + 0x180000060UL)</span>
<span class="cp">#define LCA_IOC_TBIA		(IDENT_ADDR + 0x180000080UL)</span>
<span class="cp">#define LCA_IOC_TB_ENA		(IDENT_ADDR + 0x1800000a0UL)</span>
<span class="cp">#define LCA_IOC_SFT_RST		(IDENT_ADDR + 0x1800000c0UL)</span>
<span class="cp">#define LCA_IOC_PAR_DIS		(IDENT_ADDR + 0x1800000e0UL)</span>
<span class="cp">#define LCA_IOC_W_BASE0		(IDENT_ADDR + 0x180000100UL)</span>
<span class="cp">#define LCA_IOC_W_BASE1		(IDENT_ADDR + 0x180000120UL)</span>
<span class="cp">#define LCA_IOC_W_MASK0		(IDENT_ADDR + 0x180000140UL)</span>
<span class="cp">#define LCA_IOC_W_MASK1		(IDENT_ADDR + 0x180000160UL)</span>
<span class="cp">#define LCA_IOC_T_BASE0		(IDENT_ADDR + 0x180000180UL)</span>
<span class="cp">#define LCA_IOC_T_BASE1		(IDENT_ADDR + 0x1800001a0UL)</span>
<span class="cp">#define LCA_IOC_TB_TAG0		(IDENT_ADDR + 0x188000000UL)</span>
<span class="cp">#define LCA_IOC_TB_TAG1		(IDENT_ADDR + 0x188000020UL)</span>
<span class="cp">#define LCA_IOC_TB_TAG2		(IDENT_ADDR + 0x188000040UL)</span>
<span class="cp">#define LCA_IOC_TB_TAG3		(IDENT_ADDR + 0x188000060UL)</span>
<span class="cp">#define LCA_IOC_TB_TAG4		(IDENT_ADDR + 0x188000070UL)</span>
<span class="cp">#define LCA_IOC_TB_TAG5		(IDENT_ADDR + 0x1880000a0UL)</span>
<span class="cp">#define LCA_IOC_TB_TAG6		(IDENT_ADDR + 0x1880000c0UL)</span>
<span class="cp">#define LCA_IOC_TB_TAG7		(IDENT_ADDR + 0x1880000e0UL)</span>

<span class="cm">/*</span>
<span class="cm"> * Memory spaces:</span>
<span class="cm"> */</span>
<span class="cp">#define LCA_IACK_SC		(IDENT_ADDR + 0x1a0000000UL)</span>
<span class="cp">#define LCA_CONF		(IDENT_ADDR + 0x1e0000000UL)</span>
<span class="cp">#define LCA_IO			(IDENT_ADDR + 0x1c0000000UL)</span>
<span class="cp">#define LCA_SPARSE_MEM		(IDENT_ADDR + 0x200000000UL)</span>
<span class="cp">#define LCA_DENSE_MEM		(IDENT_ADDR + 0x300000000UL)</span>

<span class="cm">/*</span>
<span class="cm"> * Bit definitions for I/O Controller status register 0:</span>
<span class="cm"> */</span>
<span class="cp">#define LCA_IOC_STAT0_CMD		0xf</span>
<span class="cp">#define LCA_IOC_STAT0_ERR		(1&lt;&lt;4)</span>
<span class="cp">#define LCA_IOC_STAT0_LOST		(1&lt;&lt;5)</span>
<span class="cp">#define LCA_IOC_STAT0_THIT		(1&lt;&lt;6)</span>
<span class="cp">#define LCA_IOC_STAT0_TREF		(1&lt;&lt;7)</span>
<span class="cp">#define LCA_IOC_STAT0_CODE_SHIFT	8</span>
<span class="cp">#define LCA_IOC_STAT0_CODE_MASK		0x7</span>
<span class="cp">#define LCA_IOC_STAT0_P_NBR_SHIFT	13</span>
<span class="cp">#define LCA_IOC_STAT0_P_NBR_MASK	0x7ffff</span>

<span class="cp">#define LCA_HAE_ADDRESS		LCA_IOC_HAE</span>

<span class="cm">/* LCA PMR Power Management register defines */</span>
<span class="cp">#define LCA_PMR_ADDR	(IDENT_ADDR + 0x120000098UL)</span>
<span class="cp">#define LCA_PMR_PDIV    0x7                     </span><span class="cm">/* Primary clock divisor */</span><span class="cp"></span>
<span class="cp">#define LCA_PMR_ODIV    0x38                    </span><span class="cm">/* Override clock divisor */</span><span class="cp"></span>
<span class="cp">#define LCA_PMR_INTO    0x40                    </span><span class="cm">/* Interrupt override */</span><span class="cp"></span>
<span class="cp">#define LCA_PMR_DMAO    0x80                    </span><span class="cm">/* DMA override */</span><span class="cp"></span>
<span class="cp">#define LCA_PMR_OCCEB   0xffff0000L             </span><span class="cm">/* Override cycle counter - even bits */</span><span class="cp"></span>
<span class="cp">#define LCA_PMR_OCCOB   0xffff000000000000L     </span><span class="cm">/* Override cycle counter - even bits */</span><span class="cp"></span>
<span class="cp">#define LCA_PMR_PRIMARY_MASK    0xfffffffffffffff8L</span>

<span class="cm">/* LCA PMR Macros */</span>

<span class="cp">#define LCA_READ_PMR        (*(volatile unsigned long *)LCA_PMR_ADDR)</span>
<span class="cp">#define LCA_WRITE_PMR(d)    (*((volatile unsigned long *)LCA_PMR_ADDR) = (d))</span>

<span class="cp">#define LCA_GET_PRIMARY(r)  ((r) &amp; LCA_PMR_PDIV)</span>
<span class="cp">#define LCA_GET_OVERRIDE(r) (((r) &gt;&gt; 3) &amp; LCA_PMR_PDIV)</span>
<span class="cp">#define LCA_SET_PRIMARY_CLOCK(r, c) ((r) = (((r) &amp; LCA_PMR_PRIMARY_MASK)|(c)))</span>

<span class="cm">/* LCA PMR Divisor values */</span>
<span class="cp">#define LCA_PMR_DIV_1   0x0</span>
<span class="cp">#define LCA_PMR_DIV_1_5 0x1</span>
<span class="cp">#define LCA_PMR_DIV_2   0x2</span>
<span class="cp">#define LCA_PMR_DIV_4   0x3</span>
<span class="cp">#define LCA_PMR_DIV_8   0x4</span>
<span class="cp">#define LCA_PMR_DIV_16  0x5</span>
<span class="cp">#define LCA_PMR_DIV_MIN DIV_1</span>
<span class="cp">#define LCA_PMR_DIV_MAX DIV_16</span>


<span class="cm">/*</span>
<span class="cm"> * Data structure for handling LCA machine checks.  Correctable errors</span>
<span class="cm"> * result in a short logout frame, uncorrectable ones in a long one.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">el_lca_mcheck_short</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">el_common</span>	<span class="n">h</span><span class="p">;</span>		<span class="cm">/* common logout header */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">esr</span><span class="p">;</span>		<span class="cm">/* error-status register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ear</span><span class="p">;</span>		<span class="cm">/* error-address register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dc_stat</span><span class="p">;</span>	<span class="cm">/* dcache status register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ioc_stat0</span><span class="p">;</span>	<span class="cm">/* I/O controller status register 0 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ioc_stat1</span><span class="p">;</span>	<span class="cm">/* I/O controller status register 1 */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">el_lca_mcheck_long</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">el_common</span>	<span class="n">h</span><span class="p">;</span>		<span class="cm">/* common logout header */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pt</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>		<span class="cm">/* PAL temps */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">exc_addr</span><span class="p">;</span>	<span class="cm">/* exception address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pad1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pal_base</span><span class="p">;</span>	<span class="cm">/* PALcode base address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">hier</span><span class="p">;</span>		<span class="cm">/* hw interrupt enable */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">hirr</span><span class="p">;</span>		<span class="cm">/* hw interrupt request */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mm_csr</span><span class="p">;</span>		<span class="cm">/* MMU control &amp; status */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dc_stat</span><span class="p">;</span>	<span class="cm">/* data cache status */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dc_addr</span><span class="p">;</span>	<span class="cm">/* data cache addr register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">abox_ctl</span><span class="p">;</span>	<span class="cm">/* address box control register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">esr</span><span class="p">;</span>		<span class="cm">/* error status register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ear</span><span class="p">;</span>		<span class="cm">/* error address register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">car</span><span class="p">;</span>		<span class="cm">/* cache control register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ioc_stat0</span><span class="p">;</span>	<span class="cm">/* I/O controller status register 0 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ioc_stat1</span><span class="p">;</span>	<span class="cm">/* I/O controller status register 1 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">va</span><span class="p">;</span>		<span class="cm">/* virtual address register */</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">el_lca</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">el_common</span> <span class="o">*</span>		<span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">el_lca_mcheck_long</span> <span class="o">*</span>	<span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">el_lca_mcheck_short</span> <span class="o">*</span>	<span class="n">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#ifndef __EXTERN_INLINE</span>
<span class="cp">#define __EXTERN_INLINE extern inline</span>
<span class="cp">#define __IO_EXTERN_INLINE</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * I/O functions:</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike Jensen, the Noname machines have no concept of local</span>
<span class="cm"> * I/O---everything goes over the PCI bus.</span>
<span class="cm"> *</span>
<span class="cm"> * There is plenty room for optimization here.  In particular,</span>
<span class="cm"> * the Alpha&#39;s insb/insw/extb/extw should be useful in moving</span>
<span class="cm"> * data to/from the right byte-lanes.</span>
<span class="cm"> */</span>

<span class="cp">#define vip	volatile int __force *</span>
<span class="cp">#define vuip	volatile unsigned int __force *</span>
<span class="cp">#define vulp	volatile unsigned long __force *</span>

<span class="cp">#define LCA_SET_HAE						\</span>
<span class="cp">	do {							\</span>
<span class="cp">		if (addr &gt;= (1UL &lt;&lt; 24)) {			\</span>
<span class="cp">			unsigned long msb = addr &amp; 0xf8000000;	\</span>
<span class="cp">			addr -= msb;				\</span>
<span class="cp">			set_hae(msb);				\</span>
<span class="cp">		}						\</span>
<span class="cp">	} while (0)</span>


<span class="n">__EXTERN_INLINE</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">lca_ioread8</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">xaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span><span class="p">,</span> <span class="n">base_and_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">LCA_DENSE_MEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="n">LCA_DENSE_MEM</span><span class="p">;</span>
		<span class="n">LCA_SET_HAE</span><span class="p">;</span>
		<span class="n">base_and_type</span> <span class="o">=</span> <span class="n">LCA_SPARSE_MEM</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="n">LCA_IO</span><span class="p">;</span>
		<span class="n">base_and_type</span> <span class="o">=</span> <span class="n">LCA_IO</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">vip</span><span class="p">)</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">base_and_type</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__kernel_extbl</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__EXTERN_INLINE</span> <span class="kt">void</span> <span class="nf">lca_iowrite8</span><span class="p">(</span><span class="n">u8</span> <span class="n">b</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">xaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">w</span><span class="p">,</span> <span class="n">base_and_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">LCA_DENSE_MEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="n">LCA_DENSE_MEM</span><span class="p">;</span>
		<span class="n">LCA_SET_HAE</span><span class="p">;</span>
		<span class="n">base_and_type</span> <span class="o">=</span> <span class="n">LCA_SPARSE_MEM</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="n">LCA_IO</span><span class="p">;</span>
		<span class="n">base_and_type</span> <span class="o">=</span> <span class="n">LCA_IO</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">__kernel_insbl</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">vuip</span><span class="p">)</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">base_and_type</span><span class="p">)</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__EXTERN_INLINE</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">lca_ioread16</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">xaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span><span class="p">,</span> <span class="n">base_and_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">LCA_DENSE_MEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="n">LCA_DENSE_MEM</span><span class="p">;</span>
		<span class="n">LCA_SET_HAE</span><span class="p">;</span>
		<span class="n">base_and_type</span> <span class="o">=</span> <span class="n">LCA_SPARSE_MEM</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="n">LCA_IO</span><span class="p">;</span>
		<span class="n">base_and_type</span> <span class="o">=</span> <span class="n">LCA_IO</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">vip</span><span class="p">)</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">base_and_type</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__kernel_extwl</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__EXTERN_INLINE</span> <span class="kt">void</span> <span class="nf">lca_iowrite16</span><span class="p">(</span><span class="n">u16</span> <span class="n">b</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">xaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">w</span><span class="p">,</span> <span class="n">base_and_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">LCA_DENSE_MEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="n">LCA_DENSE_MEM</span><span class="p">;</span>
		<span class="n">LCA_SET_HAE</span><span class="p">;</span>
		<span class="n">base_and_type</span> <span class="o">=</span> <span class="n">LCA_SPARSE_MEM</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="n">LCA_IO</span><span class="p">;</span>
		<span class="n">base_and_type</span> <span class="o">=</span> <span class="n">LCA_IO</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">__kernel_inswl</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">vuip</span><span class="p">)</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">base_and_type</span><span class="p">)</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__EXTERN_INLINE</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">lca_ioread32</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">xaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">LCA_DENSE_MEM</span><span class="p">)</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">-</span> <span class="n">LCA_IO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">LCA_IO</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">vuip</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__EXTERN_INLINE</span> <span class="kt">void</span> <span class="nf">lca_iowrite32</span><span class="p">(</span><span class="n">u32</span> <span class="n">b</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">xaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">LCA_DENSE_MEM</span><span class="p">)</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">-</span> <span class="n">LCA_IO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">LCA_IO</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="n">vuip</span><span class="p">)</span><span class="n">addr</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__EXTERN_INLINE</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">lca_ioportmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">LCA_IO</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__EXTERN_INLINE</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">lca_ioremap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">LCA_DENSE_MEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__EXTERN_INLINE</span> <span class="kt">int</span> <span class="nf">lca_is_ioaddr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">IDENT_ADDR</span> <span class="o">+</span> <span class="mh">0x120000000UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__EXTERN_INLINE</span> <span class="kt">int</span> <span class="nf">lca_is_mmio</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">LCA_DENSE_MEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#undef vip</span>
<span class="cp">#undef vuip</span>
<span class="cp">#undef vulp</span>

<span class="cp">#undef __IO_PREFIX</span>
<span class="cp">#define __IO_PREFIX		lca</span>
<span class="cp">#define lca_trivial_rw_bw	2</span>
<span class="cp">#define lca_trivial_rw_lq	1</span>
<span class="cp">#define lca_trivial_io_bw	0</span>
<span class="cp">#define lca_trivial_io_lq	0</span>
<span class="cp">#define lca_trivial_iounmap	1</span>
<span class="cp">#include &lt;asm/io_trivial.h&gt;</span>

<span class="cp">#ifdef __IO_EXTERN_INLINE</span>
<span class="cp">#undef __EXTERN_INLINE</span>
<span class="cp">#undef __IO_EXTERN_INLINE</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __ALPHA_LCA__H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
