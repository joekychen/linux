<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › boot › bootpz.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bootpz.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * arch/alpha/boot/bootpz.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1997 Jay Estabrook</span>
<span class="cm"> *</span>
<span class="cm"> * This file is used for creating a compressed BOOTP file for the</span>
<span class="cm"> * Linux/AXP kernel</span>
<span class="cm"> *</span>
<span class="cm"> * based significantly on the arch/alpha/boot/main.c of Linus Torvalds</span>
<span class="cm"> * and the decompression code from MILO.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;generated/utsrelease.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>

<span class="cp">#include &lt;asm/console.h&gt;</span>
<span class="cp">#include &lt;asm/hwrpb.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="cp">#include &quot;kzsize.h&quot;</span>

<span class="cm">/* FIXME FIXME FIXME */</span>
<span class="cp">#define MALLOC_AREA_SIZE 0x200000 </span><span class="cm">/* 2MB for now */</span><span class="cp"></span>
<span class="cm">/* FIXME FIXME FIXME */</span>


<span class="cm">/*</span>
<span class="cm">  WARNING NOTE</span>

<span class="cm">  It is very possible that turning on additional messages may cause</span>
<span class="cm">  kernel image corruption due to stack usage to do the printing.</span>

<span class="cm">*/</span>

<span class="cp">#undef DEBUG_CHECK_RANGE</span>
<span class="cp">#undef DEBUG_ADDRESSES</span>
<span class="cp">#undef DEBUG_LAST_STEPS</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">switch_to_osf_pal</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pcb_struct</span> <span class="o">*</span> <span class="n">pcb_va</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pcb_struct</span> <span class="o">*</span> <span class="n">pcb_pa</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vptb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">decompress_kernel</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">destination</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">ksize</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">kzsize</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">move_stack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_stack</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">hwrpb_struct</span> <span class="o">*</span><span class="n">hwrpb</span> <span class="o">=</span> <span class="n">INIT_HWRPB</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pcb_struct</span> <span class="n">pcb_va</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Find a physical address of a virtual object..</span>
<span class="cm"> *</span>
<span class="cm"> * This is easy using the virtual page table address.</span>
<span class="cm"> */</span>
<span class="cp">#define VPTB	((unsigned long *) 0x200000000)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">find_pa</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">VPTB</span><span class="p">[</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">];</span>
	<span class="n">result</span> <span class="o">&gt;&gt;=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">&lt;&lt;=</span> <span class="mi">13</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">|=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0x1fff</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>	

<span class="kt">int</span>
<span class="nf">check_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vend</span><span class="p">,</span>
	    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_CHECK_RANGE</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;check_range: V[0x%lx:0x%lx] K[0x%lx:0x%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">vstart</span><span class="p">,</span> <span class="n">vend</span><span class="p">,</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">kend</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* do some range checking for detecting an overlap... */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">vstart</span><span class="p">;</span> <span class="n">vaddr</span> <span class="o">&lt;=</span> <span class="n">vend</span><span class="p">;</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">find_pa</span><span class="p">(</span><span class="n">vaddr</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAGE_OFFSET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kaddr</span> <span class="o">&gt;=</span> <span class="n">kstart</span> <span class="o">&amp;&amp;</span> <span class="n">kaddr</span> <span class="o">&lt;=</span> <span class="n">kend</span><span class="p">)</span>
		<span class="p">{</span>
<span class="cp">#ifdef DEBUG_CHECK_RANGE</span>
			<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;OVERLAP: vaddr 0x%lx kaddr 0x%lx&quot;</span>
				   <span class="s">&quot; [0x%lx:0x%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">vaddr</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">,</span> <span class="n">kstart</span><span class="p">,</span> <span class="n">kend</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function moves into OSF/1 pal-code, and has a temporary</span>
<span class="cm"> * PCB for that. The kernel proper should replace this PCB with</span>
<span class="cm"> * the real one as soon as possible.</span>
<span class="cm"> *</span>
<span class="cm"> * The page table muckery in here depends on the fact that the boot</span>
<span class="cm"> * code has the L1 page table identity-map itself in the second PTE</span>
<span class="cm"> * in the L1 page table. Thus the L1-page is virtually addressable</span>
<span class="cm"> * itself (through three levels) at virtual address 0x200802000.</span>
<span class="cm"> */</span>

<span class="cp">#define L1	((unsigned long *) 0x200802000)</span>

<span class="kt">void</span>
<span class="nf">pal_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">rev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_struct</span> <span class="o">*</span> <span class="n">percpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcb_struct</span> <span class="o">*</span> <span class="n">pcb_pa</span><span class="p">;</span>

	<span class="cm">/* Create the dummy PCB.  */</span>
	<span class="n">pcb_va</span><span class="o">-&gt;</span><span class="n">ksp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcb_va</span><span class="o">-&gt;</span><span class="n">usp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcb_va</span><span class="o">-&gt;</span><span class="n">ptbr</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">pcb_va</span><span class="o">-&gt;</span><span class="n">asn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcb_va</span><span class="o">-&gt;</span><span class="n">pcc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcb_va</span><span class="o">-&gt;</span><span class="n">unique</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcb_va</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pcb_va</span><span class="o">-&gt;</span><span class="n">res1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcb_va</span><span class="o">-&gt;</span><span class="n">res2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcb_pa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pcb_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">find_pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pcb_va</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * a0 = 2 (OSF)</span>
<span class="cm">	 * a1 = return address, but we give the asm the vaddr of the PCB</span>
<span class="cm">	 * a2 = physical addr of PCB</span>
<span class="cm">	 * a3 = new virtual page table pointer</span>
<span class="cm">	 * a4 = KSP (but the asm sets it)</span>
<span class="cm">	 */</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Switching to OSF PAL-code... &quot;</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">switch_to_osf_pal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pcb_va</span><span class="p">,</span> <span class="n">pcb_pa</span><span class="p">,</span> <span class="n">VPTB</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;failed, code %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">__halt</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">percpu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">percpu_struct</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">INIT_HWRPB</span><span class="o">-&gt;</span><span class="n">processor_offset</span> <span class="o">+</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">INIT_HWRPB</span><span class="p">);</span>
	<span class="n">rev</span> <span class="o">=</span> <span class="n">percpu</span><span class="o">-&gt;</span><span class="n">pal_revision</span> <span class="o">=</span> <span class="n">percpu</span><span class="o">-&gt;</span><span class="n">palcode_avail</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;OK (rev %lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rev</span><span class="p">);</span>

	<span class="n">tbia</span><span class="p">();</span> <span class="cm">/* do it directly in case we are SMP */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start the kernel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">runkernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;bis %0,%0,$27</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;jmp ($27)&quot;</span>
		<span class="o">:</span> <span class="cm">/* no outputs: it doesn&#39;t even return */</span>
		<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">START_ADDR</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Must record the SP (it is virtual) on entry, so we can make sure</span>
<span class="cm">   not to overwrite it during movement or decompression. */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">SP_on_entry</span><span class="p">;</span>

<span class="cm">/* Calculate the kernel image address based on the end of the BOOTP</span>
<span class="cm">   bootstrapper (ie this program).</span>
<span class="cm">*/</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">_end</span><span class="p">;</span>
<span class="cp">#define KERNEL_ORIGIN \</span>
<span class="cp">	((((unsigned long)&amp;_end) + 511) &amp; ~511)</span>

<span class="cm">/* Round address to next higher page boundary. */</span>
<span class="cp">#define NEXT_PAGE(a)	(((a) | (PAGE_SIZE - 1)) + 1)</span>

<span class="cp">#ifdef INITRD_IMAGE_SIZE</span>
<span class="cp"># define REAL_INITRD_SIZE INITRD_IMAGE_SIZE</span>
<span class="cp">#else</span>
<span class="cp"># define REAL_INITRD_SIZE 0</span>
<span class="cp">#endif</span>

<span class="cm">/* Defines from include/asm-alpha/system.h</span>

<span class="cm">	BOOT_ADDR	Virtual address at which the consoles loads</span>
<span class="cm">			the BOOTP image.</span>

<span class="cm">	KERNEL_START    KSEG address at which the kernel is built to run,</span>
<span class="cm">			which includes some initial data pages before the</span>
<span class="cm">			code.</span>

<span class="cm">	START_ADDR	KSEG address of the entry point of kernel code.</span>

<span class="cm">	ZERO_PGE	KSEG address of page full of zeroes, but </span>
<span class="cm">			upon entry to kerne cvan be expected</span>
<span class="cm">			to hold the parameter list and possible</span>
<span class="cm">			INTRD information.</span>

<span class="cm">   These are used in the local defines below.</span>
<span class="cm">*/</span>
  

<span class="cm">/* Virtual addresses for the BOOTP image. Note that this includes the</span>
<span class="cm">   bootstrapper code as well as the compressed kernel image, and</span>
<span class="cm">   possibly the INITRD image.</span>

<span class="cm">   Oh, and do NOT forget the STACK, which appears to be placed virtually</span>
<span class="cm">   beyond the end of the loaded image.</span>
<span class="cm">*/</span>
<span class="cp">#define V_BOOT_IMAGE_START	BOOT_ADDR</span>
<span class="cp">#define V_BOOT_IMAGE_END	SP_on_entry</span>

<span class="cm">/* Virtual addresses for just the bootstrapper part of the BOOTP image. */</span>
<span class="cp">#define V_BOOTSTRAPPER_START	BOOT_ADDR</span>
<span class="cp">#define V_BOOTSTRAPPER_END	KERNEL_ORIGIN</span>

<span class="cm">/* Virtual addresses for just the data part of the BOOTP</span>
<span class="cm">   image. This may also include the INITRD image, but always</span>
<span class="cm">   includes the STACK.</span>
<span class="cm">*/</span>
<span class="cp">#define V_DATA_START		KERNEL_ORIGIN</span>
<span class="cp">#define V_INITRD_START		(KERNEL_ORIGIN + KERNEL_Z_SIZE)</span>
<span class="cp">#define V_INTRD_END		(V_INITRD_START + REAL_INITRD_SIZE)</span>
<span class="cp">#define V_DATA_END	 	V_BOOT_IMAGE_END</span>

<span class="cm">/* KSEG addresses for the uncompressed kernel.</span>

<span class="cm">   Note that the end address includes workspace for the decompression.</span>
<span class="cm">   Note also that the DATA_START address is ZERO_PGE, to which we write</span>
<span class="cm">   just before jumping to the kernel image at START_ADDR.</span>
<span class="cm"> */</span>
<span class="cp">#define K_KERNEL_DATA_START	ZERO_PGE</span>
<span class="cp">#define K_KERNEL_IMAGE_START	START_ADDR</span>
<span class="cp">#define K_KERNEL_IMAGE_END	(START_ADDR + KERNEL_SIZE)</span>

<span class="cm">/* Define to where we may have to decompress the kernel image, before</span>
<span class="cm">   we move it to the final position, in case of overlap. This will be</span>
<span class="cm">   above the final position of the kernel.</span>

<span class="cm">   Regardless of overlap, we move the INITRD image to the end of this</span>
<span class="cm">   copy area, because there needs to be a buffer area after the kernel</span>
<span class="cm">   for &quot;bootmem&quot; anyway.</span>
<span class="cm">*/</span>
<span class="cp">#define K_COPY_IMAGE_START	NEXT_PAGE(K_KERNEL_IMAGE_END)</span>
<span class="cm">/* Reserve one page below INITRD for the new stack. */</span>
<span class="cp">#define K_INITRD_START \</span>
<span class="cp">    NEXT_PAGE(K_COPY_IMAGE_START + KERNEL_SIZE + PAGE_SIZE)</span>
<span class="cp">#define K_COPY_IMAGE_END \</span>
<span class="cp">    (K_INITRD_START + REAL_INITRD_SIZE + MALLOC_AREA_SIZE)</span>
<span class="cp">#define K_COPY_IMAGE_SIZE \</span>
<span class="cp">    NEXT_PAGE(K_COPY_IMAGE_END - K_COPY_IMAGE_START)</span>

<span class="kt">void</span>
<span class="nf">start_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">must_move</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Initialize these for the decompression-in-place situation,</span>
<span class="cm">	   which is the smallest amount of work and most likely to</span>
<span class="cm">	   occur when using the normal START_ADDR of the kernel</span>
<span class="cm">	   (currently set to 16MB, to clear all console code.</span>
<span class="cm">	*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uncompressed_image_start</span> <span class="o">=</span> <span class="n">K_KERNEL_IMAGE_START</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uncompressed_image_end</span> <span class="o">=</span> <span class="n">K_KERNEL_IMAGE_END</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">initrd_image_start</span> <span class="o">=</span> <span class="n">K_INITRD_START</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that this crufty stuff with static and envval</span>
<span class="cm">	 * and envbuf is because:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1. Frequently, the stack is short, and we don&#39;t want to overrun;</span>
<span class="cm">	 * 2. Frequently the stack is where we are going to copy the kernel to;</span>
<span class="cm">	 * 3. A certain SRM console required the GET_ENV output to stack.</span>
<span class="cm">	 *    ??? A comment in the aboot sources indicates that the GET_ENV</span>
<span class="cm">	 *    destination must be quadword aligned.  Might this explain the</span>
<span class="cm">	 *    behaviour, rather than requiring output to the stack, which</span>
<span class="cm">	 *    seems rather far-fetched.</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="kt">long</span> <span class="n">nbytes</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">envval</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">asm_sp</span> <span class="n">asm</span><span class="p">(</span><span class="s">&quot;30&quot;</span><span class="p">);</span>

	<span class="n">SP_on_entry</span> <span class="o">=</span> <span class="n">asm_sp</span><span class="p">;</span>

	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Linux/Alpha BOOTPZ Loader for Linux &quot;</span> <span class="n">UTS_RELEASE</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Validity check the HWRPB. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INIT_HWRPB</span><span class="o">-&gt;</span><span class="n">pagesize</span> <span class="o">!=</span> <span class="mi">8192</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Expected 8kB pages, got %ldkB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		           <span class="n">INIT_HWRPB</span><span class="o">-&gt;</span><span class="n">pagesize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INIT_HWRPB</span><span class="o">-&gt;</span><span class="n">vptb</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">VPTB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Expected vptb at %p, got %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">VPTB</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INIT_HWRPB</span><span class="o">-&gt;</span><span class="n">vptb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* PALcode (re)initialization. */</span>
	<span class="n">pal_init</span><span class="p">();</span>

	<span class="cm">/* Get the parameter list from the console environment variable. */</span>
	<span class="n">nbytes</span> <span class="o">=</span> <span class="n">callback_getenv</span><span class="p">(</span><span class="n">ENV_BOOTED_OSFLAGS</span><span class="p">,</span> <span class="n">envval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">envval</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nbytes</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">envval</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">envval</span><span class="p">[</span><span class="n">nbytes</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_ADDRESSES</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;START_ADDR 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">START_ADDR</span><span class="p">);</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;KERNEL_ORIGIN 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">KERNEL_ORIGIN</span><span class="p">);</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;KERNEL_SIZE 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">KERNEL_SIZE</span><span class="p">);</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;KERNEL_Z_SIZE 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">KERNEL_Z_SIZE</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Since all the SRM consoles load the BOOTP image at virtual</span>
<span class="cm">	 * 0x20000000, we have to ensure that the physical memory</span>
<span class="cm">	 * pages occupied by that image do NOT overlap the physical</span>
<span class="cm">	 * address range where the kernel wants to be run.  This</span>
<span class="cm">	 * causes real problems when attempting to cdecompress the</span>
<span class="cm">	 * former into the latter... :-(</span>
<span class="cm">	 *</span>
<span class="cm">	 * So, we may have to decompress/move the kernel/INITRD image</span>
<span class="cm">	 * virtual-to-physical someplace else first before moving</span>
<span class="cm">	 * kernel /INITRD to their final resting places... ;-}</span>
<span class="cm">	 *</span>
<span class="cm">	 * Sigh...</span>
<span class="cm">	 */</span>

	<span class="cm">/* First, check to see if the range of addresses occupied by</span>
<span class="cm">	   the bootstrapper part of the BOOTP image include any of the</span>
<span class="cm">	   physical pages into which the kernel will be placed for</span>
<span class="cm">	   execution.</span>

<span class="cm">	   We only need check on the final kernel image range, since we</span>
<span class="cm">	   will put the INITRD someplace that we can be sure is not</span>
<span class="cm">	   in conflict.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_range</span><span class="p">(</span><span class="n">V_BOOTSTRAPPER_START</span><span class="p">,</span> <span class="n">V_BOOTSTRAPPER_END</span><span class="p">,</span>
			<span class="n">K_KERNEL_DATA_START</span><span class="p">,</span> <span class="n">K_KERNEL_IMAGE_END</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;FATAL ERROR: overlap of bootstrapper code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">__halt</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Next, check to see if the range of addresses occupied by</span>
<span class="cm">	   the compressed kernel/INITRD/stack portion of the BOOTP</span>
<span class="cm">	   image include any of the physical pages into which the</span>
<span class="cm">	   decompressed kernel or the INITRD will be placed for</span>
<span class="cm">	   execution.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_range</span><span class="p">(</span><span class="n">V_DATA_START</span><span class="p">,</span> <span class="n">V_DATA_END</span><span class="p">,</span>
			<span class="n">K_KERNEL_IMAGE_START</span><span class="p">,</span> <span class="n">K_COPY_IMAGE_END</span><span class="p">))</span>
	<span class="p">{</span>
<span class="cp">#ifdef DEBUG_ADDRESSES</span>
		<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;OVERLAP: cannot decompress in place</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">uncompressed_image_start</span> <span class="o">=</span> <span class="n">K_COPY_IMAGE_START</span><span class="p">;</span>
		<span class="n">uncompressed_image_end</span> <span class="o">=</span> <span class="n">K_COPY_IMAGE_END</span><span class="p">;</span>
		<span class="n">must_move</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Finally, check to see if the range of addresses</span>
<span class="cm">		   occupied by the compressed kernel/INITRD part of</span>
<span class="cm">		   the BOOTP image include any of the physical pages</span>
<span class="cm">		   into which that part is to be copied for</span>
<span class="cm">		   decompression.</span>
<span class="cm">		*/</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">check_range</span><span class="p">(</span><span class="n">V_DATA_START</span><span class="p">,</span> <span class="n">V_DATA_END</span><span class="p">,</span>
				   <span class="n">uncompressed_image_start</span><span class="p">,</span>
				   <span class="n">uncompressed_image_end</span><span class="p">))</span>
		<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">			uncompressed_image_start += K_COPY_IMAGE_SIZE;</span>
<span class="c">			uncompressed_image_end += K_COPY_IMAGE_SIZE;</span>
<span class="c">			initrd_image_start += K_COPY_IMAGE_SIZE;</span>
<span class="cp">#else</span>
			<span class="cm">/* Keep as close as possible to end of BOOTP image. */</span>
			<span class="n">uncompressed_image_start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">uncompressed_image_end</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">initrd_image_start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Starting to load the kernel with args &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">envval</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_ADDRESSES</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Decompressing the kernel...</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;...from 0x%lx to 0x%lx size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">V_DATA_START</span><span class="p">,</span>
		   <span class="n">uncompressed_image_start</span><span class="p">,</span>
		   <span class="n">KERNEL_SIZE</span><span class="p">);</span>
<span class="cp">#endif</span>
        <span class="n">decompress_kernel</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">uncompressed_image_start</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">V_DATA_START</span><span class="p">,</span>
			  <span class="n">KERNEL_SIZE</span><span class="p">,</span> <span class="n">KERNEL_Z_SIZE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now, move things to their final positions, if/as required.</span>
<span class="cm">	 */</span>

<span class="cp">#ifdef INITRD_IMAGE_SIZE</span>

	<span class="cm">/* First, we always move the INITRD image, if present. */</span>
<span class="cp">#ifdef DEBUG_ADDRESSES</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Moving the INITRD image...</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot; from 0x%lx to 0x%lx size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">V_INITRD_START</span><span class="p">,</span>
		   <span class="n">initrd_image_start</span><span class="p">,</span>
		   <span class="n">INITRD_IMAGE_SIZE</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">initrd_image_start</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">V_INITRD_START</span><span class="p">,</span>
	       <span class="n">INITRD_IMAGE_SIZE</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* INITRD_IMAGE_SIZE */</span><span class="cp"></span>

	<span class="cm">/* Next, we may have to move the uncompressed kernel to the</span>
<span class="cm">	   final destination.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">must_move</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_ADDRESSES</span>
		<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Moving the uncompressed kernel...</span><span class="se">\n</span><span class="s">&quot;</span>
			   <span class="s">&quot;...from 0x%lx to 0x%lx size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">uncompressed_image_start</span><span class="p">,</span>
			   <span class="n">K_KERNEL_IMAGE_START</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">KERNEL_SIZE</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move the stack to a safe place to ensure it won&#39;t be</span>
<span class="cm">		 * overwritten by kernel image.</span>
<span class="cm">		 */</span>
		<span class="n">move_stack</span><span class="p">(</span><span class="n">initrd_image_start</span> <span class="o">-</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">K_KERNEL_IMAGE_START</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">uncompressed_image_start</span><span class="p">,</span> <span class="n">KERNEL_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="cm">/* Clear the zero page, then move the argument list in. */</span>
<span class="cp">#ifdef DEBUG_LAST_STEPS</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Preparing ZERO_PGE...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ZERO_PGE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ZERO_PGE</span><span class="p">,</span> <span class="n">envval</span><span class="p">);</span>

<span class="cp">#ifdef INITRD_IMAGE_SIZE</span>

<span class="cp">#ifdef DEBUG_LAST_STEPS</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Preparing INITRD info...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* Finally, set the INITRD paramenters for the kernel. */</span>
	<span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">ZERO_PGE</span><span class="o">+</span><span class="mi">256</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initrd_image_start</span><span class="p">;</span>
	<span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">ZERO_PGE</span><span class="o">+</span><span class="mi">256</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INITRD_IMAGE_SIZE</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* INITRD_IMAGE_SIZE */</span><span class="cp"></span>

<span class="cp">#ifdef DEBUG_LAST_STEPS</span>
	<span class="n">srm_printk</span><span class="p">(</span><span class="s">&quot;Doing &#39;runkernel()&#39;...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">runkernel</span><span class="p">();</span>
<span class="p">}</span>

 <span class="cm">/* dummy function, should never be called. */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
