<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › mm › fault.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fault.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/alpha/mm/fault.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1995  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#define __EXTERN_INLINE inline</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#undef  __EXTERN_INLINE</span>

<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">die_if_kernel</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">,</span><span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Force a new ASN for a task.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef CONFIG_SMP</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_asn</span> <span class="o">=</span> <span class="n">ASN_FIRST_VERSION</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="kt">void</span>
<span class="nf">__load_new_mm_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">next_mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcb_struct</span> <span class="o">*</span><span class="n">pcb</span><span class="p">;</span>

	<span class="n">mmc</span> <span class="o">=</span> <span class="n">__get_new_mm_context</span><span class="p">(</span><span class="n">next_mm</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">next_mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span> <span class="n">mmc</span><span class="p">;</span>

	<span class="n">pcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pcb</span><span class="p">;</span>
	<span class="n">pcb</span><span class="o">-&gt;</span><span class="n">asn</span> <span class="o">=</span> <span class="n">mmc</span> <span class="o">&amp;</span> <span class="n">HARDWARE_ASN_MASK</span><span class="p">;</span>
	<span class="n">pcb</span><span class="o">-&gt;</span><span class="n">ptbr</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">next_mm</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">-</span> <span class="n">IDENT_ADDR</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">__reload_thread</span><span class="p">(</span><span class="n">pcb</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This routine handles page faults.  It determines the address,</span>
<span class="cm"> * and the problem, and then passes it off to handle_mm_fault().</span>
<span class="cm"> *</span>
<span class="cm"> * mmcsr:</span>
<span class="cm"> *	0 = translation not valid</span>
<span class="cm"> *	1 = access violation</span>
<span class="cm"> *	2 = fault-on-read</span>
<span class="cm"> *	3 = fault-on-execute</span>
<span class="cm"> *	4 = fault-on-write</span>
<span class="cm"> *</span>
<span class="cm"> * cause:</span>
<span class="cm"> *	-1 = instruction fetch</span>
<span class="cm"> *	0 = load</span>
<span class="cm"> *	1 = store</span>
<span class="cm"> *</span>
<span class="cm"> * Registers $9 through $15 are saved in a block just prior to `regs&#39; and</span>
<span class="cm"> * are saved and restored around the call to allow exception code to</span>
<span class="cm"> * modify them.</span>
<span class="cm"> */</span>

<span class="cm">/* Macro for exception fixup code to access integer registers.  */</span>
<span class="cp">#define dpf_reg(r)							\</span>
<span class="cp">	(((unsigned long *)regs)[(r) &lt;= 8 ? (r) : (r) &lt;= 15 ? (r)-16 :	\</span>
<span class="cp">				 (r) &lt;= 18 ? (r)+8 : (r)-10])</span>

<span class="n">asmlinkage</span> <span class="kt">void</span>
<span class="nf">do_page_fault</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmcsr</span><span class="p">,</span>
	      <span class="kt">long</span> <span class="n">cause</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">fixup</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fault</span><span class="p">,</span> <span class="n">si_code</span> <span class="o">=</span> <span class="n">SEGV_MAPERR</span><span class="p">;</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="cm">/* As of EV6, a load into $31/$f31 is a prefetch, and never faults</span>
<span class="cm">	   (or is suppressed by the PALcode).  Support that for older CPUs</span>
<span class="cm">	   by ignoring such an instruction.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insn</span><span class="p">;</span>
		<span class="n">__get_user</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x1f</span> <span class="o">&amp;&amp;</span>
		    <span class="cm">/* ldq ldl ldt lds ldg ldf ldwu ldbu */</span>
		    <span class="p">(</span><span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x30f00001400ul</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If we&#39;re in an interrupt context, or have no user context,</span>
<span class="cm">	   we must not take the fault.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span> <span class="o">||</span> <span class="n">in_atomic</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">no_context</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ALPHA_LARGE_VMALLOC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">TASK_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">vmalloc_fault</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">address</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">good_area</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSDOWN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expand_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>

	<span class="cm">/* Ok, we have a good vm_area for this memory access, so</span>
<span class="cm">	   we can handle it.  */</span>
 <span class="nl">good_area:</span>
	<span class="n">si_code</span> <span class="o">=</span> <span class="n">SEGV_ACCERR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cause</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Allow reads even for write-only mappings */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_READ</span> <span class="o">|</span> <span class="n">VM_WRITE</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If for any reason at all we couldn&#39;t handle the fault,</span>
<span class="cm">	   make sure we exit gracefully rather than endlessly redo</span>
<span class="cm">	   the fault.  */</span>
	<span class="n">fault</span> <span class="o">=</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">cause</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">FAULT_FLAG_WRITE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_ERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_of_memory</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">do_sigbus</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">maj_flt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">min_flt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Something tried to access memory that isn&#39;t in our memory map.</span>
<span class="cm">	   Fix it, but check if it&#39;s kernel or user first.  */</span>
 <span class="nl">bad_area:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">do_sigsegv</span><span class="p">;</span>

 <span class="nl">no_context:</span>
	<span class="cm">/* Are we prepared to handle this fault as an exception?  */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fixup</span> <span class="o">=</span> <span class="n">search_exception_tables</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newpc</span><span class="p">;</span>
		<span class="n">newpc</span> <span class="o">=</span> <span class="n">fixup_exception</span><span class="p">(</span><span class="n">dpf_reg</span><span class="p">,</span> <span class="n">fixup</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">newpc</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Oops. The kernel tried to access some bad page. We&#39;ll have to</span>
<span class="cm">	   terminate things with extreme prejudice.  */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;Unable to handle kernel paging request at &quot;</span>
	       <span class="s">&quot;virtual address %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Oops&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">cause</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">regs</span> <span class="o">-</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">do_exit</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">);</span>

	<span class="cm">/* We ran out of memory, or some other thing happened to us that</span>
<span class="cm">	   made us unable to handle the page fault gracefully.  */</span>
 <span class="nl">out_of_memory:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_context</span><span class="p">;</span>
	<span class="n">pagefault_out_of_memory</span><span class="p">();</span>
	<span class="k">return</span><span class="p">;</span>

 <span class="nl">do_sigbus:</span>
	<span class="cm">/* Send a sigbus, regardless of whether we were in kernel</span>
<span class="cm">	   or user mode.  */</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGBUS</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">BUS_ADRERR</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_context</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

 <span class="nl">do_sigsegv:</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGSEGV</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">si_code</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ALPHA_LARGE_VMALLOC</span>
 <span class="nl">vmalloc_fault:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">do_sigsegv</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Synchronize this task&#39;s top level page-table</span>
<span class="cm">		   with the &quot;reference&quot; page table from init.  */</span>
		<span class="kt">long</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="o">*</span><span class="n">pgd_k</span><span class="p">;</span>

		<span class="n">pgd</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">pgd_k</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd_k</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pgd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span> <span class="o">=</span> <span class="n">pgd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pgd_k</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">no_context</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
