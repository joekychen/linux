<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › kernel › perf_event.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>perf_event.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Hardware performance events for the Alpha.</span>
<span class="cm"> *</span>
<span class="cm"> * We implement HW counts on the EV67 and subsequent CPUs only.</span>
<span class="cm"> *</span>
<span class="cm"> * (C) 2010 Michael J. Cree</span>
<span class="cm"> *</span>
<span class="cm"> * Somewhat based on the Sparc code, and to a lesser extent the PowerPC and</span>
<span class="cm"> * ARM code, which are copyright by their respective authors.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;asm/hwrpb.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>
<span class="cp">#include &lt;asm/pal.h&gt;</span>
<span class="cp">#include &lt;asm/wrperfmon.h&gt;</span>
<span class="cp">#include &lt;asm/hw_irq.h&gt;</span>


<span class="cm">/* The maximum number of PMCs on any Alpha CPU whatsoever. */</span>
<span class="cp">#define MAX_HWEVENTS 3</span>
<span class="cp">#define PMC_NO_INDEX -1</span>

<span class="cm">/* For tracking PMCs and the hw events they monitor on each CPU. */</span>
<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">enabled</span><span class="p">;</span>
	<span class="cm">/* Number of events scheduled; also number entries valid in arrays below. */</span>
	<span class="kt">int</span>			<span class="n">n_events</span><span class="p">;</span>
	<span class="cm">/* Number events added since last hw_perf_disable(). */</span>
	<span class="kt">int</span>			<span class="n">n_added</span><span class="p">;</span>
	<span class="cm">/* Events currently scheduled. */</span>
	<span class="k">struct</span> <span class="n">perf_event</span>	<span class="o">*</span><span class="n">event</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="cm">/* Event type of each scheduled event. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">evtype</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="cm">/* Current index of each scheduled event; if not yet determined</span>
<span class="cm">	 * contains PMC_NO_INDEX.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">current_idx</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="cm">/* The active PMCs&#39; config for easy use with wrperfmon(). */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">config</span><span class="p">;</span>
	<span class="cm">/* The active counters&#39; indices for easy use with wrperfmon(). */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">idx_mask</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span><span class="p">,</span> <span class="n">cpu_hw_events</span><span class="p">);</span>



<span class="cm">/*</span>
<span class="cm"> * A structure to hold the description of the PMCs available on a particular</span>
<span class="cm"> * type of Alpha CPU.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">alpha_pmu_t</span> <span class="p">{</span>
	<span class="cm">/* Mapping of the perf system hw event types to indigenous event types */</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">event_map</span><span class="p">;</span>
	<span class="cm">/* The number of entries in the event_map */</span>
	<span class="kt">int</span>  <span class="n">max_events</span><span class="p">;</span>
	<span class="cm">/* The number of PMCs on this Alpha */</span>
	<span class="kt">int</span>  <span class="n">num_pmcs</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * All PMC counters reside in the IBOX register PCTR.  This is the</span>
<span class="cm">	 * LSB of the counter.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="n">pmc_count_shift</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * The mask that isolates the PMC bits when the LSB of the counter</span>
<span class="cm">	 * is shifted to bit 0.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmc_count_mask</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="cm">/* The maximum period the PMC can count. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmc_max_period</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * The maximum value that may be written to the counter due to</span>
<span class="cm">	 * hardware restrictions is pmc_max_period - pmc_left.</span>
<span class="cm">	 */</span>
	<span class="kt">long</span> <span class="n">pmc_left</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	 <span class="cm">/* Subroutine for allocation of PMCs.  Enforces constraints. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_constraints</span><span class="p">)(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">**</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The Alpha CPU PMU description currently in operation.  This is set during</span>
<span class="cm"> * the boot process to the specific CPU of the machine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">alpha_pmu_t</span> <span class="o">*</span><span class="n">alpha_pmu</span><span class="p">;</span>


<span class="cp">#define HW_OP_UNSUPPORTED -1</span>

<span class="cm">/*</span>
<span class="cm"> * The hardware description of the EV67, EV68, EV69, EV7 and EV79 PMUs</span>
<span class="cm"> * follow. Since they are identical we refer to them collectively as the</span>
<span class="cm"> * EV67 henceforth.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * EV67 PMC event types</span>
<span class="cm"> *</span>
<span class="cm"> * There is no one-to-one mapping of the possible hw event types to the</span>
<span class="cm"> * actual codes that are used to program the PMCs hence we introduce our</span>
<span class="cm"> * own hw event type identifiers.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ev67_pmc_event_type</span> <span class="p">{</span>
	<span class="n">EV67_CYCLES</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">EV67_INSTRUCTIONS</span><span class="p">,</span>
	<span class="n">EV67_BCACHEMISS</span><span class="p">,</span>
	<span class="n">EV67_MBOXREPLAY</span><span class="p">,</span>
	<span class="n">EV67_LAST_ET</span>
<span class="p">};</span>
<span class="cp">#define EV67_NUM_EVENT_TYPES (EV67_LAST_ET-EV67_CYCLES)</span>


<span class="cm">/* Mapping of the hw event types to the perf tool interface */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ev67_perfmon_event_map</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">PERF_COUNT_HW_CPU_CYCLES</span><span class="p">]</span>	 <span class="o">=</span> <span class="n">EV67_CYCLES</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_COUNT_HW_INSTRUCTIONS</span><span class="p">]</span>	 <span class="o">=</span> <span class="n">EV67_INSTRUCTIONS</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_REFERENCES</span><span class="p">]</span> <span class="o">=</span> <span class="n">HW_OP_UNSUPPORTED</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_MISSES</span><span class="p">]</span>	 <span class="o">=</span> <span class="n">EV67_BCACHEMISS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ev67_mapping_t</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">config</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The mapping used for one event only - these must be in same order as enum</span>
<span class="cm"> * ev67_pmc_event_type definition.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ev67_mapping_t</span> <span class="n">ev67_mapping</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">EV67_PCTR_INSTR_CYCLES</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>	 <span class="cm">/* EV67_CYCLES, */</span>
	<span class="p">{</span><span class="n">EV67_PCTR_INSTR_CYCLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	 <span class="cm">/* EV67_INSTRUCTIONS */</span>
	<span class="p">{</span><span class="n">EV67_PCTR_INSTR_BCACHEMISS</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="cm">/* EV67_BCACHEMISS */</span>
	<span class="p">{</span><span class="n">EV67_PCTR_CYCLES_MBOX</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>	 <span class="cm">/* EV67_MBOXREPLAY */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Check that a group of events can be simultaneously scheduled on to the</span>
<span class="cm"> * EV67 PMU.  Also allocate counter indices and config.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ev67_check_constraints</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">**</span><span class="n">event</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">evtype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_ev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">config</span><span class="p">;</span>

	<span class="n">idx0</span> <span class="o">=</span> <span class="n">ev67_mapping</span><span class="p">[</span><span class="n">evtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">idx</span><span class="p">;</span>
	<span class="n">config</span> <span class="o">=</span> <span class="n">ev67_mapping</span><span class="p">[</span><span class="n">evtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">config</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_ev</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n_ev</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">evtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_MBOXREPLAY</span> <span class="o">||</span> <span class="n">evtype</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_MBOXREPLAY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* MBOX replay traps must be on PMC 1 */</span>
		<span class="n">idx0</span> <span class="o">=</span> <span class="p">(</span><span class="n">evtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_MBOXREPLAY</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Only cycles can accompany MBOX replay traps */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">evtype</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_CYCLES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">config</span> <span class="o">=</span> <span class="n">EV67_PCTR_CYCLES_MBOX</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">evtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_BCACHEMISS</span> <span class="o">||</span> <span class="n">evtype</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_BCACHEMISS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Bcache misses must be on PMC 1 */</span>
		<span class="n">idx0</span> <span class="o">=</span> <span class="p">(</span><span class="n">evtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_BCACHEMISS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Only instructions can accompany Bcache misses */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">evtype</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_INSTRUCTIONS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">config</span> <span class="o">=</span> <span class="n">EV67_PCTR_INSTR_BCACHEMISS</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">evtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_INSTRUCTIONS</span> <span class="o">||</span> <span class="n">evtype</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_INSTRUCTIONS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Instructions must be on PMC 0 */</span>
		<span class="n">idx0</span> <span class="o">=</span> <span class="p">(</span><span class="n">evtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_INSTRUCTIONS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* By this point only cycles can accompany instructions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">evtype</span><span class="p">[</span><span class="n">idx0</span><span class="o">^</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">EV67_CYCLES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">config</span> <span class="o">=</span> <span class="n">EV67_PCTR_INSTR_CYCLES</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Otherwise, darn it, there is a conflict.  */</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="nl">success:</span>
	<span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx0</span><span class="p">;</span>
	<span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config_base</span> <span class="o">=</span> <span class="n">config</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_ev</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx0</span> <span class="o">^</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config_base</span> <span class="o">=</span> <span class="n">config</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">alpha_pmu_t</span> <span class="n">ev67_pmu</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">event_map</span> <span class="o">=</span> <span class="n">ev67_perfmon_event_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_events</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ev67_perfmon_event_map</span><span class="p">),</span>
	<span class="p">.</span><span class="n">num_pmcs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pmc_count_shift</span> <span class="o">=</span> <span class="p">{</span><span class="n">EV67_PCTR_0_COUNT_SHIFT</span><span class="p">,</span> <span class="n">EV67_PCTR_1_COUNT_SHIFT</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">.</span><span class="n">pmc_count_mask</span> <span class="o">=</span> <span class="p">{</span><span class="n">EV67_PCTR_0_COUNT_MASK</span><span class="p">,</span>  <span class="n">EV67_PCTR_1_COUNT_MASK</span><span class="p">,</span>  <span class="mi">0</span><span class="p">},</span>
	<span class="p">.</span><span class="n">pmc_max_period</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">.</span><span class="n">pmc_left</span> <span class="o">=</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">.</span><span class="n">check_constraints</span> <span class="o">=</span> <span class="n">ev67_check_constraints</span>
<span class="p">};</span>



<span class="cm">/*</span>
<span class="cm"> * Helper routines to ensure that we read/write only the correct PMC bits</span>
<span class="cm"> * when calling the wrperfmon PALcall.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">alpha_write_pmc</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_count_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">val</span> <span class="o">&lt;&lt;=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_count_shift</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">idx</span><span class="p">);</span>
	<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_WRITE</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">alpha_read_pmc</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&gt;&gt;=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_count_shift</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_count_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set a new period to sample over */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alpha_perf_event_set_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">left</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">period</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">period</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">left</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hardware restrictions require that the counters must not be</span>
<span class="cm">	 * written with values that are too close to the maximum period.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_left</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_left</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_max_period</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_max_period</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">prev_count</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="o">-</span><span class="n">left</span><span class="p">));</span>

	<span class="n">alpha_write_pmc</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="o">-</span><span class="n">left</span><span class="p">));</span>

	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Calculates the count (the &#39;delta&#39;) since the last time the PMC was read.</span>
<span class="cm"> *</span>
<span class="cm"> * As the PMCs&#39; full period can easily be exceeded within the perf system</span>
<span class="cm"> * sampling period we cannot use any high order bits as a guard bit in the</span>
<span class="cm"> * PMCs to detect overflow as is done by other architectures.  The code here</span>
<span class="cm"> * calculates the delta on the basis that there is no overflow when ovf is</span>
<span class="cm"> * zero.  The value passed via ovf by the interrupt handler corrects for</span>
<span class="cm"> * overflow.</span>
<span class="cm"> *</span>
<span class="cm"> * This can be racey on rare occasions -- a call to this routine can occur</span>
<span class="cm"> * with an overflowed counter just before the PMI service routine is called.</span>
<span class="cm"> * The check for delta negative hopefully always rectifies this situation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">alpha_perf_event_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">long</span> <span class="n">ovf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">prev_raw_count</span><span class="p">,</span> <span class="n">new_raw_count</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">prev_raw_count</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">prev_count</span><span class="p">);</span>
	<span class="n">new_raw_count</span> <span class="o">=</span> <span class="n">alpha_read_pmc</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local64_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">prev_raw_count</span><span class="p">,</span>
			     <span class="n">new_raw_count</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev_raw_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_raw_count</span> <span class="o">-</span> <span class="p">(</span><span class="n">prev_raw_count</span> <span class="o">&amp;</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_count_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span> <span class="o">+</span> <span class="n">ovf</span><span class="p">;</span>

	<span class="cm">/* It is possible on very rare occasions that the PMC has overflowed</span>
<span class="cm">	 * but the interrupt is yet to come.  Detect and fix this situation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">+=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_max_period</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">local64_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">local64_sub</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">new_raw_count</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Collect all HW events into the array event[].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">collect_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_count</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">evtype</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">current_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">pe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">group</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">max_count</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">event</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
		<span class="n">evtype</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">event_base</span><span class="p">;</span>
		<span class="n">current_idx</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMC_NO_INDEX</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">pe</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">max_count</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">event</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pe</span><span class="p">;</span>
			<span class="n">evtype</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">event_base</span><span class="p">;</span>
			<span class="n">current_idx</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMC_NO_INDEX</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * Check that a group of events can be simultaneously scheduled on to the PMU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alpha_check_constraints</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">**</span><span class="n">events</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">evtypes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_ev</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* No HW events is possible from hw_perf_group_sched_in(). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_ev</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n_ev</span> <span class="o">&gt;</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">num_pmcs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">check_constraints</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">evtypes</span><span class="p">,</span> <span class="n">n_ev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * If new events have been scheduled then update cpuc with the new</span>
<span class="cm"> * configuration.  This may involve shifting cycle counts from one PMC to</span>
<span class="cm"> * another.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">maybe_change_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_added</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Find counters that are moving to another PMC and update */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">pe</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">PMC_NO_INDEX</span> <span class="o">&amp;&amp;</span>
			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alpha_perf_event_update</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMC_NO_INDEX</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Assign to counters all unassigned events. */</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">pe</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">PMC_NO_INDEX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alpha_perf_event_set_period</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="n">hwc</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">))</span>
			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config_base</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* Schedule perf HW event on to PMU.</span>
<span class="cm"> *  - this function is called from outside this module via the pmu struct</span>
<span class="cm"> *    returned from perf event initialisation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alpha_pmu_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Sparc code has the IRQ disable first followed by the perf</span>
<span class="cm">	 * disable, however this can lead to an overflowed counter with the</span>
<span class="cm">	 * PMI disabled on rare occasions.  The alpha_perf_event_update()</span>
<span class="cm">	 * routine should detect this situation by noting a negative delta,</span>
<span class="cm">	 * nevertheless we disable the PMCs first to enable a potential</span>
<span class="cm">	 * final PMI to occur before we disable interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">irq_flags</span><span class="p">);</span>

	<span class="cm">/* Default to error to be returned */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="cm">/* Insert event on to PMU and if successful modify ret to valid return */</span>
	<span class="n">n0</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n0</span> <span class="o">&lt;</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">num_pmcs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">evtype</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">event_base</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMC_NO_INDEX</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha_check_constraints</span><span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">evtype</span><span class="p">,</span> <span class="n">n0</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_added</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_START</span><span class="p">))</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">PERF_HES_STOPPED</span><span class="p">;</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* Disable performance monitoring unit</span>
<span class="cm"> *  - this function is called from outside this module via the pmu struct</span>
<span class="cm"> *    returned from perf event initialisation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_pmu_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

			<span class="cm">/* Shift remaining entries down into the existing</span>
<span class="cm">			 * slot.</span>
<span class="cm">			 */</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">evtype</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">evtype</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="cm">/* Absorb the final count and turn off the event. */</span>
			<span class="n">alpha_perf_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hwc</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="n">idx</span><span class="p">);</span>
			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="o">--</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_pmu_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">alpha_perf_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hwc</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_pmu_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">PERF_HES_STOPPED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_UPDATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">alpha_perf_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hwc</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_DISABLE</span><span class="p">,</span> <span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">));</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_pmu_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_RELOAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">));</span>
		<span class="n">alpha_perf_event_set_period</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hwc</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span> <span class="o">|=</span> <span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_ENABLE</span><span class="p">,</span> <span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Check that CPU performance counters are supported.</span>
<span class="cm"> * - currently support EV67 and later CPUs.</span>
<span class="cm"> * - actually some later revisions of the EV6 have the same PMC model as the</span>
<span class="cm"> *     EV67 but we don&#39;t do suffiently deep CPU detection to detect them.</span>
<span class="cm"> *     Bad luck to the very few people who might have one, I guess.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">supported_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">percpu_struct</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cputype</span><span class="p">;</span>

	<span class="cm">/* Get cpu type from HW */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">percpu_struct</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hwrpb</span> <span class="o">+</span> <span class="n">hwrpb</span><span class="o">-&gt;</span><span class="n">processor_offset</span><span class="p">);</span>
	<span class="n">cputype</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="cm">/* Include all of EV67, EV68, EV7, EV79 and EV69 as supported. */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cputype</span> <span class="o">&gt;=</span> <span class="n">EV67_CPU</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cputype</span> <span class="o">&lt;=</span> <span class="n">EV69_CPU</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_perf_event_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing to be done! */</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">__hw_perf_event_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">evts</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">evtypes</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">idx_rubbish_bin</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* We only support a limited range of HARDWARE event types with one</span>
<span class="cm">	 * only programmable via a RAW event type.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PERF_TYPE_HARDWARE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">&gt;=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">max_events</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">event_map</span><span class="p">[</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PERF_TYPE_HW_CACHE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PERF_TYPE_RAW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The EV67 does not support mode exclusion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">exclude_kernel</span> <span class="o">||</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">exclude_user</span>
			<span class="o">||</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">exclude_hv</span> <span class="o">||</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">exclude_idle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We place the event type in event_base here and leave calculation</span>
<span class="cm">	 * of the codes to programme the PMU for alpha_pmu_enable() because</span>
<span class="cm">	 * it is only then we will know what HW events are actually</span>
<span class="cm">	 * scheduled on to the PMU.  At that point the code to programme the</span>
<span class="cm">	 * PMU is put into config_base and the PMC to use is placed into</span>
<span class="cm">	 * idx.  We initialise idx (below) to PMC_NO_INDEX to indicate that</span>
<span class="cm">	 * it is yet to be determined.</span>
<span class="cm">	 */</span>
	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">event_base</span> <span class="o">=</span> <span class="n">ev</span><span class="p">;</span>

	<span class="cm">/* Collect events in a group together suitable for calling</span>
<span class="cm">	 * alpha_check_constraints() to verify that the group as a whole can</span>
<span class="cm">	 * be scheduled on to the PMU.</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">!=</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">collect_events</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span>
				<span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">num_pmcs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">evts</span><span class="p">,</span> <span class="n">evtypes</span><span class="p">,</span> <span class="n">idx_rubbish_bin</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">evtypes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">event_base</span><span class="p">;</span>
	<span class="n">evts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alpha_check_constraints</span><span class="p">(</span><span class="n">evts</span><span class="p">,</span> <span class="n">evtypes</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Indicate that PMU config and idx are yet to be determined. */</span>
	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">config_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">PMC_NO_INDEX</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">hw_perf_event_destroy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Most architectures reserve the PMU for their use at this point.</span>
<span class="cm">	 * As there is no existing mechanism to arbitrate usage and there</span>
<span class="cm">	 * appears to be no other user of the Alpha PMU we just assume</span>
<span class="cm">	 * that we can just use it, hence a NO-OP here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Maybe an alpha_reserve_pmu() routine should be implemented but is</span>
<span class="cm">	 * anything else ever going to use it?</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_max_period</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">;</span>
		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Main entry point to initialise a HW performance event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alpha_pmu_event_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* does not support taken branch sampling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PERF_TYPE_RAW</span>:
	<span class="k">case</span> <span class="n">PERF_TYPE_HARDWARE</span>:
	<span class="k">case</span> <span class="n">PERF_TYPE_HW_CACHE</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha_pmu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Do the real initialisation work. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__hw_perf_event_init</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Main entry point - enable HW performance counters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_pmu_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Update cpuc with information from any new scheduled events. */</span>
		<span class="n">maybe_change_configuration</span><span class="p">(</span><span class="n">cpuc</span><span class="p">);</span>

		<span class="cm">/* Start counting the desired events. */</span>
		<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_LOGGING_OPTIONS</span><span class="p">,</span> <span class="n">EV67_PCTR_MODE_AGGREGATE</span><span class="p">);</span>
		<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_DESIRED_EVENTS</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">);</span>
		<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_ENABLE</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Main entry point - disable HW performance counters.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_pmu_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_DISABLE</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pmu</span> <span class="n">pmu</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pmu_enable</span>	<span class="o">=</span> <span class="n">alpha_pmu_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pmu_disable</span>	<span class="o">=</span> <span class="n">alpha_pmu_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">event_init</span>	<span class="o">=</span> <span class="n">alpha_pmu_event_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add</span>		<span class="o">=</span> <span class="n">alpha_pmu_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">del</span>		<span class="o">=</span> <span class="n">alpha_pmu_del</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">alpha_pmu_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">alpha_pmu_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">alpha_pmu_read</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Main entry point - don&#39;t know when this is called but it</span>
<span class="cm"> * obviously dumps debug info.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">perf_event_print_debug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pcr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pcr0</span><span class="p">,</span> <span class="n">pcr1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">supported_cpu</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">pcr</span> <span class="o">=</span> <span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pcr0</span> <span class="o">=</span> <span class="p">(</span><span class="n">pcr</span> <span class="o">&gt;&gt;</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_count_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_count_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">pcr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">pcr</span> <span class="o">&gt;&gt;</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_count_shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_count_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d: PCTR0[%06x] PCTR1[%06x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">pcr0</span><span class="p">,</span> <span class="n">pcr1</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Performance Monitoring Interrupt Service Routine called when a PMC</span>
<span class="cm"> * overflows.  The PMC that overflowed is passed in la_ptr.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_perf_event_irq_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">la_ptr</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">irq_pmi_count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="cm">/* Completely counting through the PMC&#39;s period to trigger a new PMC</span>
<span class="cm">	 * overflow interrupt while in this interrupt routine is utterly</span>
<span class="cm">	 * disastrous!  The EV6 and EV67 counters are sufficiently large to</span>
<span class="cm">	 * prevent this but to be really sure disable the PMCs.</span>
<span class="cm">	 */</span>
	<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_DISABLE</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span><span class="p">);</span>

	<span class="cm">/* la_ptr is the counter that overflowed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">la_ptr</span> <span class="o">&gt;=</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">num_pmcs</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This should never occur! */</span>
		<span class="n">irq_err_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;PMI: silly index %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">la_ptr</span><span class="p">);</span>
		<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_ENABLE</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">la_ptr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">current_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This can occur if the event is disabled right on a PMC overflow. */</span>
		<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_ENABLE</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This should never occur! */</span>
		<span class="n">irq_err_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;PMI: No event at index %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_ENABLE</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">alpha_perf_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hwc</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">alpha_pmu</span><span class="o">-&gt;</span><span class="n">pmc_max_period</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">perf_sample_data_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alpha_perf_event_set_period</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hwc</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_event_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Interrupts coming too quickly; &quot;throttle&quot; the</span>
<span class="cm">			 * counter, i.e., disable it for a little while.</span>
<span class="cm">			 */</span>
			<span class="n">alpha_pmu_stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">wrperfmon</span><span class="p">(</span><span class="n">PERFMON_CMD_ENABLE</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">idx_mask</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * Init call to initialise performance events at kernel startup.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_hw_perf_events</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Performance events: &quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">supported_cpu</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;No support for your CPU.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;Supported CPU type!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Override performance counter IRQ vector */</span>

	<span class="n">perf_irq</span> <span class="o">=</span> <span class="n">alpha_perf_event_irq_handler</span><span class="p">;</span>

	<span class="cm">/* And set up PMU specification */</span>
	<span class="n">alpha_pmu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ev67_pmu</span><span class="p">;</span>

	<span class="n">perf_pmu_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">PERF_TYPE_RAW</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">init_hw_perf_events</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
