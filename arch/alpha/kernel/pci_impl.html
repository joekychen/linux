<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › kernel › pci_impl.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pci_impl.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	linux/arch/alpha/kernel/pci_impl.h</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains declarations and inline functions for interfacing</span>
<span class="cm"> * with the PCI initialization routines.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">pci_dev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pci_controller</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pci_iommu_arena</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * We can&#39;t just blindly use 64K for machines with EISA busses; they</span>
<span class="cm"> * may also have PCI-PCI bridges present, and then we&#39;d configure the</span>
<span class="cm"> * bridge incorrectly.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, we start at 0x8000 or 0x9000, in hopes to get all devices&#39;</span>
<span class="cm"> * IO space areas allocated *before* 0xC000; this is because certain</span>
<span class="cm"> * BIOSes (Millennium for one) use PCI Config space &quot;mechanism #2&quot;</span>
<span class="cm"> * accesses to probe the bus. If a device&#39;s registers appear at 0xC000,</span>
<span class="cm"> * it may see an INx/OUTx at that address during BIOS emulation of the</span>
<span class="cm"> * VGA BIOS, and some cards, notably Adaptec 2940UW, take mortal offense.</span>
<span class="cm"> */</span>

<span class="cp">#define EISA_DEFAULT_IO_BASE	0x9000	</span><span class="cm">/* start above 8th slot */</span><span class="cp"></span>
<span class="cp">#define DEFAULT_IO_BASE		0x8000	</span><span class="cm">/* start at 8th slot */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * We try to make the DEFAULT_MEM_BASE addresses *always* have more than</span>
<span class="cm"> * a single bit set. This is so that devices like the broken Myrinet card</span>
<span class="cm"> * will always have a PCI memory address that will never match a IDSEL</span>
<span class="cm"> * address in PCI Config space, which can cause problems with early rev cards.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * An XL is AVANTI (APECS) family, *but* it has only 27 bits of ISA address</span>
<span class="cm"> * that get passed through the PCI&lt;-&gt;ISA bridge chip. Although this causes</span>
<span class="cm"> * us to set the PCI-&gt;Mem window bases lower than normal, we still allocate</span>
<span class="cm"> * PCI bus devices&#39; memory addresses *below* the low DMA mapping window,</span>
<span class="cm"> * and hope they fit below 64Mb (to avoid conflicts), and so that they can</span>
<span class="cm"> * be accessed via SPARSE space.</span>
<span class="cm"> *</span>
<span class="cm"> * We accept the risk that a broken Myrinet card will be put into a true XL</span>
<span class="cm"> * and thus can more easily run into the problem described below.</span>
<span class="cm"> */</span>
<span class="cp">#define XL_DEFAULT_MEM_BASE ((16+2)*1024*1024) </span><span class="cm">/* 16M to 64M-1 is avail */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * APECS and LCA have only 34 bits for physical addresses, thus limiting PCI</span>
<span class="cm"> * bus memory addresses for SPARSE access to be less than 128Mb.</span>
<span class="cm"> */</span>
<span class="cp">#define APECS_AND_LCA_DEFAULT_MEM_BASE ((16+2)*1024*1024)</span>

<span class="cm">/*</span>
<span class="cm"> * Because MCPCIA and T2 core logic support more bits for</span>
<span class="cm"> * physical addresses, they should allow an expanded range of SPARSE</span>
<span class="cm"> * memory addresses.  However, we do not use them all, in order to</span>
<span class="cm"> * avoid the HAE manipulation that would be needed.</span>
<span class="cm"> */</span>
<span class="cp">#define MCPCIA_DEFAULT_MEM_BASE ((32+2)*1024*1024)</span>
<span class="cp">#define T2_DEFAULT_MEM_BASE ((16+1)*1024*1024)</span>

<span class="cm">/*</span>
<span class="cm"> * Because CIA and PYXIS have more bits for physical addresses,</span>
<span class="cm"> * they support an expanded range of SPARSE memory addresses.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_MEM_BASE ((128+16)*1024*1024)</span>

<span class="cm">/* ??? Experimenting with no HAE for CIA.  */</span>
<span class="cp">#define CIA_DEFAULT_MEM_BASE ((32+2)*1024*1024)</span>

<span class="cp">#define IRONGATE_DEFAULT_MEM_BASE ((256*8-16)*1024*1024)</span>

<span class="cp">#define DEFAULT_AGP_APER_SIZE	(64*1024*1024)</span>

<span class="cm">/* </span>
<span class="cm"> * A small note about bridges and interrupts.  The DECchip 21050 (and</span>
<span class="cm"> * later) adheres to the PCI-PCI bridge specification.  This says that</span>
<span class="cm"> * the interrupts on the other side of a bridge are swizzled in the</span>
<span class="cm"> * following manner:</span>
<span class="cm"> *</span>
<span class="cm"> * Dev    Interrupt   Interrupt </span>
<span class="cm"> *        Pin on      Pin on </span>
<span class="cm"> *        Device      Connector</span>
<span class="cm"> *</span>
<span class="cm"> *   4    A           A</span>
<span class="cm"> *        B           B</span>
<span class="cm"> *        C           C</span>
<span class="cm"> *        D           D</span>
<span class="cm"> * </span>
<span class="cm"> *   5    A           B</span>
<span class="cm"> *        B           C</span>
<span class="cm"> *        C           D</span>
<span class="cm"> *        D           A</span>
<span class="cm"> *</span>
<span class="cm"> *   6    A           C</span>
<span class="cm"> *        B           D</span>
<span class="cm"> *        C           A</span>
<span class="cm"> *        D           B</span>
<span class="cm"> *</span>
<span class="cm"> *   7    A           D</span>
<span class="cm"> *        B           A</span>
<span class="cm"> *        C           B</span>
<span class="cm"> *        D           C</span>
<span class="cm"> *</span>
<span class="cm"> *   Where A = pin 1, B = pin 2 and so on and pin=0 = default = A.</span>
<span class="cm"> *   Thus, each swizzle is ((pin-1) + (device#-4)) % 4</span>
<span class="cm"> *</span>
<span class="cm"> *   pci_swizzle_interrupt_pin() swizzles for exactly one bridge.  The routine</span>
<span class="cm"> *   pci_common_swizzle() handles multiple bridges.  But there are a</span>
<span class="cm"> *   couple boards that do strange things.</span>
<span class="cm"> */</span>


<span class="cm">/* The following macro is used to implement the table-based irq mapping</span>
<span class="cm">   function for all single-bus Alphas.  */</span>

<span class="cp">#define COMMON_TABLE_LOOKUP						\</span>
<span class="cp">({ long _ctl_ = -1; 							\</span>
<span class="cp">   if (slot &gt;= min_idsel &amp;&amp; slot &lt;= max_idsel &amp;&amp; pin &lt; irqs_per_slot)	\</span>
<span class="cp">     _ctl_ = irq_tab[slot - min_idsel][pin];				\</span>
<span class="cp">   _ctl_; })</span>


<span class="cm">/* A PCI IOMMU allocation arena.  There are typically two of these</span>
<span class="cm">   regions per bus.  */</span>
<span class="cm">/* ??? The 8400 has a 32-byte pte entry, and the entire table apparently</span>
<span class="cm">   lives directly on the host bridge (no tlb?).  We don&#39;t support this</span>
<span class="cm">   machine, but if we ever did, we&#39;d need to parameterize all this quite</span>
<span class="cm">   a bit further.  Probably with per-bus operation tables.  */</span>

<span class="k">struct</span> <span class="n">pci_iommu_arena</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">;</span>
<span class="cp">#define IOMMU_INVALID_PTE 0x2 </span><span class="cm">/* 32:63 bits MBZ */</span><span class="cp"></span>
<span class="cp">#define IOMMU_RESERVED_PTE 0xface</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptes</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align_entry</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#if defined(CONFIG_ALPHA_SRM) &amp;&amp; \</span>
<span class="cp">    (defined(CONFIG_ALPHA_CIA) || defined(CONFIG_ALPHA_LCA))</span>
<span class="cp"># define NEED_SRM_SAVE_RESTORE</span>
<span class="cp">#else</span>
<span class="cp"># undef NEED_SRM_SAVE_RESTORE</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_ALPHA_GENERIC) || defined(NEED_SRM_SAVE_RESTORE)</span>
<span class="cp"># define ALPHA_RESTORE_SRM_SETUP</span>
<span class="cp">#else</span>
<span class="cp"># undef ALPHA_RESTORE_SRM_SETUP</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ALPHA_RESTORE_SRM_SETUP</span>
<span class="cm">/* Store PCI device configuration left by SRM here. */</span>
<span class="k">struct</span> <span class="n">pdev_srm_saved_conf</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pdev_srm_saved_conf</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_restore_srm_config</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define pdev_save_srm_config(dev)	do {} while (0)</span>
<span class="cp">#define pci_restore_srm_config()	do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/* The hose list.  */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose_head</span><span class="p">,</span> <span class="o">**</span><span class="n">hose_tail</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">pci_isa_hose</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alpha_agpgart_size</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">common_init_pci</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#define common_swizzle pci_common_swizzle</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">alloc_pci_controller</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">alloc_resource</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">iommu_arena_new_node</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="p">,</span>
					            <span class="n">dma_addr_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
					            <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">iommu_arena_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="p">,</span>
					       <span class="n">dma_addr_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">pci_io_names</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">pci_mem_names</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">pci_hae0_name</span><span class="p">[];</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size_for_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">iommu_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">iommu_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">iommu_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">iommu_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
