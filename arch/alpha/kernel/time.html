<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › kernel › time.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>time.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/alpha/kernel/time.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992, 1995, 1999, 2000  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains the PC-specific time handling details:</span>
<span class="cm"> * reading the RTC at bootup, etc..</span>
<span class="cm"> * 1994-07-02    Alan Modra</span>
<span class="cm"> *	fixed set_rtc_mmss, fixed time.year for &gt;= 2000, new mktime</span>
<span class="cm"> * 1995-03-26    Markus Kuhn</span>
<span class="cm"> *      fixed 500 ms bug at call to set_rtc_mmss, fixed DS12887</span>
<span class="cm"> *      precision CMOS clock update</span>
<span class="cm"> * 1997-09-10	Updated NTP code according to technical memorandum Jan &#39;96</span>
<span class="cm"> *		&quot;A Kernel Model for Precision Timekeeping&quot; by Dave Mills</span>
<span class="cm"> * 1997-01-09    Adrian Sun</span>
<span class="cm"> *      use interval timer if CONFIG_RTC=y</span>
<span class="cm"> * 1997-10-29    John Bowman (bowman@math.ualberta.ca)</span>
<span class="cm"> *      fixed tick loss calculation in timer_interrupt</span>
<span class="cm"> *      (round system clock to nearest tick instead of truncating)</span>
<span class="cm"> *      fixed algorithm in time_init for getting time from CMOS clock</span>
<span class="cm"> * 1999-04-16	Thorsten Kranzkowski (dl8bcu@gmx.net)</span>
<span class="cm"> *	fixed algorithm in do_gettimeofday() for calculating the precise time</span>
<span class="cm"> *	from processor cycle counter (now taking lost_ticks into account)</span>
<span class="cm"> * 2000-08-13	Jan-Benedict Glaw &lt;jbglaw@lug-owl.de&gt;</span>
<span class="cm"> * 	Fixed time_init to be aware of epoches != 1900. This prevents</span>
<span class="cm"> * 	booting up in 2048 for me;) Code is stolen from rtc.c.</span>
<span class="cm"> * 2003-06-03	R. Scott Bailey &lt;scott.bailey@eds.com&gt;</span>
<span class="cm"> *	Tighten sanity in time_init from 1% (10,000 PPM) to 250 PPM</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/param.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bcd.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/irq_work.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/hwrpb.h&gt;</span>
<span class="cp">#include &lt;asm/rtc.h&gt;</span>

<span class="cp">#include &lt;linux/mc146818rtc.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>

<span class="cp">#include &quot;proto.h&quot;</span>
<span class="cp">#include &quot;irq_impl.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">set_rtc_mmss</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">rtc_lock</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rtc_lock</span><span class="p">);</span>

<span class="cp">#define TICK_SIZE (tick_nsec / 1000)</span>

<span class="cm">/*</span>
<span class="cm"> * Shift amount by which scaled_ticks_per_cycle is scaled.  Shifting</span>
<span class="cm"> * by 48 gives us 16 bits for HZ while keeping the accuracy good even</span>
<span class="cm"> * for large CPU clock rates.</span>
<span class="cm"> */</span>
<span class="cp">#define FIX_SHIFT	48</span>

<span class="cm">/* lump static variables together for more efficient access: */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/* cycle counter last time it got invoked */</span>
	<span class="n">__u32</span> <span class="n">last_time</span><span class="p">;</span>
	<span class="cm">/* ticks/cycle * 2^48 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scaled_ticks_per_cycle</span><span class="p">;</span>
	<span class="cm">/* partial unused tick */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">partial_tick</span><span class="p">;</span>
<span class="p">}</span> <span class="n">state</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">est_cycle_freq</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IRQ_WORK</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">irq_work_pending</span><span class="p">);</span>

<span class="cp">#define set_irq_work_pending_flag()  __get_cpu_var(irq_work_pending) = 1</span>
<span class="cp">#define test_irq_work_pending()      __get_cpu_var(irq_work_pending)</span>
<span class="cp">#define clear_irq_work_pending()     __get_cpu_var(irq_work_pending) = 0</span>

<span class="kt">void</span> <span class="nf">arch_irq_work_raise</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_irq_work_pending_flag</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else  </span><span class="cm">/* CONFIG_IRQ_WORK */</span><span class="cp"></span>

<span class="cp">#define test_irq_work_pending()      0</span>
<span class="cp">#define clear_irq_work_pending()</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_IRQ_WORK */</span><span class="cp"></span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">rpcc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__u32</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;rpcc %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">update_persistent_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">set_rtc_mmss</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_persistent_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="n">mon</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">hour</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span><span class="p">,</span> <span class="n">epoch</span><span class="p">;</span>

	<span class="n">sec</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_SECONDS</span><span class="p">);</span>
	<span class="n">min</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_MINUTES</span><span class="p">);</span>
	<span class="n">hour</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_HOURS</span><span class="p">);</span>
	<span class="n">day</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_DAY_OF_MONTH</span><span class="p">);</span>
	<span class="n">mon</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_MONTH</span><span class="p">);</span>
	<span class="n">year</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_YEAR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">||</span> <span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">sec</span><span class="p">);</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">min</span><span class="p">);</span>
		<span class="n">hour</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">hour</span><span class="p">);</span>
		<span class="n">day</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">day</span><span class="p">);</span>
		<span class="n">mon</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">mon</span><span class="p">);</span>
		<span class="n">year</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">year</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* PC-like is standard; used for year &gt;= 70 */</span>
	<span class="n">epoch</span> <span class="o">=</span> <span class="mi">1900</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span>
		<span class="n">epoch</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">20</span> <span class="o">&amp;&amp;</span> <span class="n">year</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">)</span>
		<span class="cm">/* NT epoch */</span>
		<span class="n">epoch</span> <span class="o">=</span> <span class="mi">1980</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">48</span> <span class="o">&amp;&amp;</span> <span class="n">year</span> <span class="o">&lt;</span> <span class="mi">70</span><span class="p">)</span>
		<span class="cm">/* Digital UNIX epoch */</span>
		<span class="n">epoch</span> <span class="o">=</span> <span class="mi">1952</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Using epoch = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">epoch</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">year</span> <span class="o">+=</span> <span class="n">epoch</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1970</span><span class="p">)</span>
		<span class="n">year</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">mon</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">hour</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span><span class="p">);</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * timer_interrupt() needs to keep up the real-time clock,</span>
<span class="cm"> * as well as call the &quot;xtime_update()&quot; routine every clocktick</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="nf">timer_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">nticks</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_SMP</span>
	<span class="cm">/* Not SMP, do kernel PC profiling here.  */</span>
	<span class="n">profile_tick</span><span class="p">(</span><span class="n">CPU_PROFILING</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate how many ticks have passed since the last update,</span>
<span class="cm">	 * including any previous partial leftover.  Save any resulting</span>
<span class="cm">	 * fraction for the next pass.</span>
<span class="cm">	 */</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">rpcc</span><span class="p">();</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">state</span><span class="p">.</span><span class="n">last_time</span><span class="p">;</span>
	<span class="n">state</span><span class="p">.</span><span class="n">last_time</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">state</span><span class="p">.</span><span class="n">scaled_ticks_per_cycle</span> <span class="o">+</span> <span class="n">state</span><span class="p">.</span><span class="n">partial_tick</span><span class="p">;</span>
	<span class="n">state</span><span class="p">.</span><span class="n">partial_tick</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">FIX_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> 
	<span class="n">nticks</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="n">FIX_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nticks</span><span class="p">)</span>
		<span class="n">xtime_update</span><span class="p">(</span><span class="n">nticks</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_irq_work_pending</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">clear_irq_work_pending</span><span class="p">();</span>
		<span class="n">irq_work_run</span><span class="p">();</span>
	<span class="p">}</span>

<span class="cp">#ifndef CONFIG_SMP</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nticks</span><span class="o">--</span><span class="p">)</span>
		<span class="n">update_process_times</span><span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">get_irq_regs</span><span class="p">()));</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">common_init_rtc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">x</span><span class="p">;</span>

	<span class="cm">/* Reset periodic interrupt frequency.  */</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_FREQ_SELECT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
        <span class="cm">/* Test includes known working values on various platforms</span>
<span class="cm">           where 0x26 is wrong; we refuse to change those. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mh">0x26</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="mh">0x25</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="mh">0x19</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="mh">0x06</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Setting RTC_FREQ to 1024 Hz (%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="mh">0x26</span><span class="p">,</span> <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Turn on periodic interrupts.  */</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">RTC_PIE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Turning on RTC interrupts.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">x</span> <span class="o">|=</span> <span class="n">RTC_PIE</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RTC_AIE</span> <span class="o">|</span> <span class="n">RTC_UIE</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="mh">0x36</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">);</span>	<span class="cm">/* pit counter 0: system timer */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="mh">0xb6</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">);</span>	<span class="cm">/* pit counter 2: speaker */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x31</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x13</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">);</span>

	<span class="n">init_rtc_irq</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">common_get_rtc_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__get_rtc_time</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">common_set_rtc_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__set_rtc_time</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Validate a computed cycle counter result against the known bounds for</span>
<span class="cm">   the given processor core.  There&#39;s too much brokenness in the way of</span>
<span class="cm">   timing hardware for any one method to work everywhere.  :-(</span>

<span class="cm">   Return 0 if the result cannot be trusted, otherwise return the argument.  */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span>
<span class="nf">validate_cc_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">bounds</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cpu_hz</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">EV3_CPU</span><span class="p">]</span>    <span class="o">=</span> <span class="p">{</span>   <span class="mi">50000000</span><span class="p">,</span>  <span class="mi">200000000</span> <span class="p">},</span>	<span class="cm">/* guess */</span>
		<span class="p">[</span><span class="n">EV4_CPU</span><span class="p">]</span>    <span class="o">=</span> <span class="p">{</span>  <span class="mi">100000000</span><span class="p">,</span>  <span class="mi">300000000</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">LCA4_CPU</span><span class="p">]</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">100000000</span><span class="p">,</span>  <span class="mi">300000000</span> <span class="p">},</span>	<span class="cm">/* guess */</span>
		<span class="p">[</span><span class="n">EV45_CPU</span><span class="p">]</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">200000000</span><span class="p">,</span>  <span class="mi">300000000</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">EV5_CPU</span><span class="p">]</span>    <span class="o">=</span> <span class="p">{</span>  <span class="mi">250000000</span><span class="p">,</span>  <span class="mi">433000000</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">EV56_CPU</span><span class="p">]</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">333000000</span><span class="p">,</span>  <span class="mi">667000000</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">PCA56_CPU</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">400000000</span><span class="p">,</span>  <span class="mi">600000000</span> <span class="p">},</span>	<span class="cm">/* guess */</span>
		<span class="p">[</span><span class="n">PCA57_CPU</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">500000000</span><span class="p">,</span>  <span class="mi">600000000</span> <span class="p">},</span>	<span class="cm">/* guess */</span>
		<span class="p">[</span><span class="n">EV6_CPU</span><span class="p">]</span>    <span class="o">=</span> <span class="p">{</span>  <span class="mi">466000000</span><span class="p">,</span>  <span class="mi">600000000</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">EV67_CPU</span><span class="p">]</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">600000000</span><span class="p">,</span>  <span class="mi">750000000</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">EV68AL_CPU</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>  <span class="mi">750000000</span><span class="p">,</span>  <span class="mi">940000000</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">EV68CB_CPU</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1000000000</span><span class="p">,</span> <span class="mi">1333333333</span> <span class="p">},</span>
		<span class="cm">/* None of the following are shipping as of 2001-11-01.  */</span>
		<span class="p">[</span><span class="n">EV68CX_CPU</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1000000000</span><span class="p">,</span> <span class="mi">1700000000</span> <span class="p">},</span>	<span class="cm">/* guess */</span>
		<span class="p">[</span><span class="n">EV69_CPU</span><span class="p">]</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">1000000000</span><span class="p">,</span> <span class="mi">1700000000</span> <span class="p">},</span>	<span class="cm">/* guess */</span>
		<span class="p">[</span><span class="n">EV7_CPU</span><span class="p">]</span>    <span class="o">=</span> <span class="p">{</span>  <span class="mi">800000000</span><span class="p">,</span> <span class="mi">1400000000</span> <span class="p">},</span>	<span class="cm">/* guess */</span>
		<span class="p">[</span><span class="n">EV79_CPU</span><span class="p">]</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">1000000000</span><span class="p">,</span> <span class="mi">2000000000</span> <span class="p">},</span>	<span class="cm">/* guess */</span>
	<span class="p">};</span>

	<span class="cm">/* Allow for some drift in the crystal.  10MHz is more than enough.  */</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">deviation</span> <span class="o">=</span> <span class="mi">10000000</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">percpu_struct</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">percpu_struct</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">hwrpb</span> <span class="o">+</span> <span class="n">hwrpb</span><span class="o">-&gt;</span><span class="n">processor_offset</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>

	<span class="cm">/* If index out of bounds, no way to validate.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cpu_hz</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cc</span><span class="p">;</span>

	<span class="cm">/* If index contains no data, no way to validate.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_hz</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">max</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span> <span class="o">&lt;</span> <span class="n">cpu_hz</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">min</span> <span class="o">-</span> <span class="n">deviation</span>
	    <span class="o">||</span> <span class="n">cc</span> <span class="o">&gt;</span> <span class="n">cpu_hz</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">max</span> <span class="o">+</span> <span class="n">deviation</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Calibrate CPU clock using legacy 8254 timer/counter. Stolen from</span>
<span class="cm"> * arch/i386/time.c.</span>
<span class="cm"> */</span>

<span class="cp">#define CALIBRATE_LATCH	0xffff</span>
<span class="cp">#define TIMEOUT_COUNT	0x100000</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span>
<span class="nf">calibrate_cc_with_pit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cc</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the Gate high, disable speaker */</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x02</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now let&#39;s take care of CTC channel 2</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set the Gate high, program CTC channel 2 for mode 0,</span>
<span class="cm">	 * (interrupt on terminal count mode), binary count,</span>
<span class="cm">	 * load 5 * LATCH count, (LSB and MSB) to begin countdown.</span>
<span class="cm">	 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">);</span>		<span class="cm">/* binary, mode 0, LSB/MSB, Ch 2 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CALIBRATE_LATCH</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">);</span>	<span class="cm">/* LSB of count */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CALIBRATE_LATCH</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">);</span>	<span class="cm">/* MSB of count */</span>

	<span class="n">cc</span> <span class="o">=</span> <span class="n">rpcc</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">TIMEOUT_COUNT</span><span class="p">);</span>
	<span class="n">cc</span> <span class="o">=</span> <span class="n">rpcc</span><span class="p">()</span> <span class="o">-</span> <span class="n">cc</span><span class="p">;</span>

	<span class="cm">/* Error: ECTCNEVERSET or ECPUTOOFAST.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">count</span> <span class="o">==</span> <span class="n">TIMEOUT_COUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">cc</span> <span class="o">*</span> <span class="n">PIT_TICK_RATE</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">CALIBRATE_LATCH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The Linux interpretation of the CMOS clock register contents:</span>
<span class="cm">   When the Update-In-Progress (UIP) flag goes from 1 to 0, the</span>
<span class="cm">   RTC registers show the second which has precisely just started.</span>
<span class="cm">   Let&#39;s hope other operating systems interpret the RTC the same way.  */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span>
<span class="nf">rpcc_after_update_in_progress</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_FREQ_SELECT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RTC_UIP</span><span class="p">));</span>
	<span class="k">do</span> <span class="p">{</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_FREQ_SELECT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RTC_UIP</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rpcc</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_SMP</span>
<span class="cm">/* Until and unless we figure out how to get cpu cycle counters</span>
<span class="cm">   in sync and keep them there, we can&#39;t use the rpcc.  */</span>
<span class="k">static</span> <span class="n">cycle_t</span> <span class="nf">read_rpcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cycle_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_t</span><span class="p">)</span><span class="n">rpcc</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="n">clocksource_rpcc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>                   <span class="o">=</span> <span class="s">&quot;rpcc&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span>                 <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>                   <span class="o">=</span> <span class="n">read_rpcc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask</span>                   <span class="o">=</span> <span class="n">CLOCKSOURCE_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
	<span class="p">.</span><span class="n">flags</span>                  <span class="o">=</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">register_rpcc_clocksource</span><span class="p">(</span><span class="kt">long</span> <span class="n">cycle_freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clocksource_register_hz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_rpcc</span><span class="p">,</span> <span class="n">cycle_freq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">register_rpcc_clocksource</span><span class="p">(</span><span class="kt">long</span> <span class="n">cycle_freq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">time_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cycle_freq</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">diff</span><span class="p">;</span>

	<span class="cm">/* Calibrate CPU clock -- attempt #1.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">est_cycle_freq</span><span class="p">)</span>
		<span class="n">est_cycle_freq</span> <span class="o">=</span> <span class="n">validate_cc_value</span><span class="p">(</span><span class="n">calibrate_cc_with_pit</span><span class="p">());</span>

	<span class="n">cc1</span> <span class="o">=</span> <span class="n">rpcc</span><span class="p">();</span>

	<span class="cm">/* Calibrate CPU clock -- attempt #2.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">est_cycle_freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cc1</span> <span class="o">=</span> <span class="n">rpcc_after_update_in_progress</span><span class="p">();</span>
		<span class="n">cc2</span> <span class="o">=</span> <span class="n">rpcc_after_update_in_progress</span><span class="p">();</span>
		<span class="n">est_cycle_freq</span> <span class="o">=</span> <span class="n">validate_cc_value</span><span class="p">(</span><span class="n">cc2</span> <span class="o">-</span> <span class="n">cc1</span><span class="p">);</span>
		<span class="n">cc1</span> <span class="o">=</span> <span class="n">cc2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cycle_freq</span> <span class="o">=</span> <span class="n">hwrpb</span><span class="o">-&gt;</span><span class="n">cycle_freq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">est_cycle_freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the given value is within 250 PPM of what we calculated,</span>
<span class="cm">		   accept it.  Otherwise, use what we found.  */</span>
		<span class="n">tolerance</span> <span class="o">=</span> <span class="n">cycle_freq</span> <span class="o">/</span> <span class="mi">4000</span><span class="p">;</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="n">cycle_freq</span> <span class="o">-</span> <span class="n">est_cycle_freq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">diff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cycle_freq</span> <span class="o">=</span> <span class="n">est_cycle_freq</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;HWRPB cycle frequency bogus.  &quot;</span>
			       <span class="s">&quot;Estimated %lu Hz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cycle_freq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">est_cycle_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">validate_cc_value</span> <span class="p">(</span><span class="n">cycle_freq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;HWRPB cycle frequency bogus, &quot;</span>
		       <span class="s">&quot;and unable to estimate a proper value!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* From John Bowman &lt;bowman@math.ualberta.ca&gt;: allow the values</span>
<span class="cm">	   to settle, as the Update-In-Progress bit going low isn&#39;t good</span>
<span class="cm">	   enough on some hardware.  2ms is our guess; we haven&#39;t found </span>
<span class="cm">	   bogomips yet, but this is close on a 500Mhz box.  */</span>
	<span class="n">__delay</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">extern</span> <span class="kt">void</span> <span class="n">__you_loose</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
		<span class="n">__you_loose</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">register_rpcc_clocksource</span><span class="p">(</span><span class="n">cycle_freq</span><span class="p">);</span>

	<span class="n">state</span><span class="p">.</span><span class="n">last_time</span> <span class="o">=</span> <span class="n">cc1</span><span class="p">;</span>
	<span class="n">state</span><span class="p">.</span><span class="n">scaled_ticks_per_cycle</span>
		<span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">HZ</span> <span class="o">&lt;&lt;</span> <span class="n">FIX_SHIFT</span><span class="p">)</span> <span class="o">/</span> <span class="n">cycle_freq</span><span class="p">;</span>
	<span class="n">state</span><span class="p">.</span><span class="n">partial_tick</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>

	<span class="cm">/* Startup the timer source. */</span>
	<span class="n">alpha_mv</span><span class="p">.</span><span class="n">init_rtc</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In order to set the CMOS clock precisely, set_rtc_mmss has to be</span>
<span class="cm"> * called 500 ms after the second nowtime has started, because when</span>
<span class="cm"> * nowtime is written into the registers of the CMOS clock, it will</span>
<span class="cm"> * jump to the next second precisely 500 ms later. Check the Motorola</span>
<span class="cm"> * MC146818A or Dallas DS12887 data sheet for details.</span>
<span class="cm"> *</span>
<span class="cm"> * BUG: This routine does not handle hour overflow properly; it just</span>
<span class="cm"> *      sets the minutes. Usually you won&#39;t notice until after reboot!</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">set_rtc_mmss</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nowtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">real_seconds</span><span class="p">,</span> <span class="n">real_minutes</span><span class="p">,</span> <span class="n">cmos_minutes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">save_control</span><span class="p">,</span> <span class="n">save_freq_select</span><span class="p">;</span>

	<span class="cm">/* irq are locally disabled here */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="cm">/* Tell the clock it&#39;s being set */</span>
	<span class="n">save_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">CMOS_WRITE</span><span class="p">((</span><span class="n">save_control</span><span class="o">|</span><span class="n">RTC_SET</span><span class="p">),</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>

	<span class="cm">/* Stop and reset prescaler */</span>
	<span class="n">save_freq_select</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>
	<span class="n">CMOS_WRITE</span><span class="p">((</span><span class="n">save_freq_select</span><span class="o">|</span><span class="n">RTC_DIV_RESET2</span><span class="p">),</span> <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>

	<span class="n">cmos_minutes</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_MINUTES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">save_control</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">||</span> <span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span>
		<span class="n">cmos_minutes</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">cmos_minutes</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * since we&#39;re only adjusting minutes and seconds,</span>
<span class="cm">	 * don&#39;t interfere with hour overflow. This avoids</span>
<span class="cm">	 * messing with unknown time zones but requires your</span>
<span class="cm">	 * RTC not to be off by more than 15 minutes</span>
<span class="cm">	 */</span>
	<span class="n">real_seconds</span> <span class="o">=</span> <span class="n">nowtime</span> <span class="o">%</span> <span class="mi">60</span><span class="p">;</span>
	<span class="n">real_minutes</span> <span class="o">=</span> <span class="n">nowtime</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">abs</span><span class="p">(</span><span class="n">real_minutes</span> <span class="o">-</span> <span class="n">cmos_minutes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span><span class="o">/</span><span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* correct for half hour time zone */</span>
		<span class="n">real_minutes</span> <span class="o">+=</span> <span class="mi">30</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">real_minutes</span> <span class="o">%=</span> <span class="mi">60</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">real_minutes</span> <span class="o">-</span> <span class="n">cmos_minutes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">save_control</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">||</span> <span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">real_seconds</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">real_seconds</span><span class="p">);</span>
			<span class="n">real_minutes</span> <span class="o">=</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">real_minutes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">real_seconds</span><span class="p">,</span><span class="n">RTC_SECONDS</span><span class="p">);</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">real_minutes</span><span class="p">,</span><span class="n">RTC_MINUTES</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
		       <span class="s">&quot;set_rtc_mmss: can&#39;t update from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cmos_minutes</span><span class="p">,</span> <span class="n">real_minutes</span><span class="p">);</span>
 		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The following flags have to be released exactly in this order,</span>
<span class="cm">	 * otherwise the DS12887 (popular MC146818A clone with integrated</span>
<span class="cm">	 * battery and quartz) will not reset the oscillator and will not</span>
<span class="cm">	 * update precisely 500 ms later. You won&#39;t find this mentioned in</span>
<span class="cm">	 * the Dallas Semiconductor data sheets, but who believes data</span>
<span class="cm">	 * sheets anyway ...                           -- Markus Kuhn</span>
<span class="cm">	 */</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">save_control</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">save_freq_select</span><span class="p">,</span> <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
