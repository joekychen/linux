<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › kernel › core_irongate.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>core_irongate.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	linux/arch/alpha/kernel/core_irongate.c</span>
<span class="cm"> *</span>
<span class="cm"> * Based on code written by David A. Rusling (david.rusling@reo.mts.dec.com).</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright (C) 1999 Alpha Processor, Inc.,</span>
<span class="cm"> *		(David Daniel, Stig Telfer, Soohoon Lee)</span>
<span class="cm"> *</span>
<span class="cm"> * Code common to all IRONGATE core logic chips.</span>
<span class="cm"> */</span>

<span class="cp">#define __EXTERN_INLINE inline</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/core_irongate.h&gt;</span>
<span class="cp">#undef __EXTERN_INLINE</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>

<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/pci.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>

<span class="cp">#include &quot;proto.h&quot;</span>
<span class="cp">#include &quot;pci_impl.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * BIOS32-style PCI interface:</span>
<span class="cm"> */</span>

<span class="cp">#define DEBUG_CONFIG 0</span>

<span class="cp">#if DEBUG_CONFIG</span>
<span class="cp"># define DBG_CFG(args)	printk args</span>
<span class="cp">#else</span>
<span class="cp"># define DBG_CFG(args)</span>
<span class="cp">#endif</span>

<span class="n">igcsr32</span> <span class="o">*</span><span class="n">IronECC</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Given a bus, device, and function number, compute resulting</span>
<span class="cm"> * configuration space address accordingly.  It is therefore not safe</span>
<span class="cm"> * to have concurrent invocations to configuration space access</span>
<span class="cm"> * routines, but there really shouldn&#39;t be any need for this.</span>
<span class="cm"> *</span>
<span class="cm"> *	addr[31:24]		reserved</span>
<span class="cm"> *	addr[23:16]		bus number (8 bits = 128 possible buses)</span>
<span class="cm"> *	addr[15:11]		Device number (5 bits)</span>
<span class="cm"> *	addr[10: 8]		function number</span>
<span class="cm"> *	addr[ 7: 2]		register number</span>
<span class="cm"> *</span>
<span class="cm"> * For IRONGATE:</span>
<span class="cm"> *    if (bus = addr[23:16]) == 0</span>
<span class="cm"> *    then</span>
<span class="cm"> *	  type 0 config cycle:</span>
<span class="cm"> *	      addr_on_pci[31:11] = id selection for device = addr[15:11]</span>
<span class="cm"> *	      addr_on_pci[10: 2] = addr[10: 2] ???</span>
<span class="cm"> *	      addr_on_pci[ 1: 0] = 00</span>
<span class="cm"> *    else</span>
<span class="cm"> *	  type 1 config cycle (pass on with no decoding):</span>
<span class="cm"> *	      addr_on_pci[31:24] = 0</span>
<span class="cm"> *	      addr_on_pci[23: 2] = addr[23: 2]</span>
<span class="cm"> *	      addr_on_pci[ 1: 0] = 01</span>
<span class="cm"> *    fi</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *	The function number selects which function of a multi-function device</span>
<span class="cm"> *	(e.g., SCSI and Ethernet).</span>
<span class="cm"> *</span>
<span class="cm"> *	The register selects a DWORD (32 bit) register offset.	Hence it</span>
<span class="cm"> *	doesn&#39;t get shifted by 2 bits as we want to &quot;drop&quot; the bottom two</span>
<span class="cm"> *	bits.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mk_conf_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pbus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device_fn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pci_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bus</span> <span class="o">=</span> <span class="n">pbus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>

	<span class="n">DBG_CFG</span><span class="p">((</span><span class="s">&quot;mk_conf_addr(bus=%d ,device_fn=0x%x, where=0x%x, &quot;</span>
		 <span class="s">&quot;pci_addr=0x%p, type1=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">bus</span><span class="p">,</span> <span class="n">device_fn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">pci_addr</span><span class="p">,</span> <span class="n">type1</span><span class="p">));</span>

	<span class="o">*</span><span class="n">type1</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">device_fn</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">where</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">|=</span> <span class="n">IRONGATE_CONF</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pci_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">DBG_CFG</span><span class="p">((</span><span class="s">&quot;mk_conf_addr: returning pci_addr 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">irongate_read_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mk_conf_addr</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PCIBIOS_DEVICE_NOT_FOUND</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">__kernel_ldbu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">vucp</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">__kernel_ldwu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">vusp</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">vuip</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">irongate_write_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mk_conf_addr</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PCIBIOS_DEVICE_NOT_FOUND</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">__kernel_stb</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">vucp</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">__kernel_ldbu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">vucp</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">__kernel_stw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">vusp</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">__kernel_ldwu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">vusp</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="o">*</span><span class="p">(</span><span class="n">vuip</span><span class="p">)</span><span class="n">addr</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="o">*</span><span class="p">(</span><span class="n">vuip</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">irongate_pci_ops</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>		<span class="n">irongate_read_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>	<span class="n">irongate_write_config</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span>
<span class="nf">irongate_pci_clr_err</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nmi_ctl</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IRONGATE_jd</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">IRONGATE_jd</span> <span class="o">=</span> <span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">stat_cmd</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Iron stat_cmd %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">IRONGATE_jd</span><span class="p">);</span>
	<span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">stat_cmd</span> <span class="o">=</span> <span class="n">IRONGATE_jd</span><span class="p">;</span> <span class="cm">/* write again clears error bits */</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">IRONGATE_jd</span> <span class="o">=</span> <span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">stat_cmd</span><span class="p">;</span>  <span class="cm">/* re-read to force write */</span>

	<span class="n">IRONGATE_jd</span> <span class="o">=</span> <span class="o">*</span><span class="n">IronECC</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Iron ECC %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">IRONGATE_jd</span><span class="p">);</span>
	<span class="o">*</span><span class="n">IronECC</span> <span class="o">=</span> <span class="n">IRONGATE_jd</span><span class="p">;</span> <span class="cm">/* write again clears error bits */</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">IRONGATE_jd</span> <span class="o">=</span> <span class="o">*</span><span class="n">IronECC</span><span class="p">;</span>  <span class="cm">/* re-read to force write */</span>

	<span class="cm">/* Clear ALI NMI */</span>
        <span class="n">nmi_ctl</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x61</span><span class="p">);</span>
        <span class="n">nmi_ctl</span> <span class="o">|=</span> <span class="mh">0x0c</span><span class="p">;</span>
        <span class="n">outb</span><span class="p">(</span><span class="n">nmi_ctl</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">);</span>
        <span class="n">nmi_ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x0c</span><span class="p">;</span>
        <span class="n">outb</span><span class="p">(</span><span class="n">nmi_ctl</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">);</span>

	<span class="n">IRONGATE_jd</span> <span class="o">=</span> <span class="o">*</span><span class="n">IronECC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IRONGATE_jd</span> <span class="o">&amp;</span> <span class="mh">0x300</span><span class="p">)</span> <span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define IRONGATE_3GB 0xc0000000UL</span>

<span class="cm">/* On Albacore (aka UP1500) with 4Gb of RAM we have to reserve some</span>
<span class="cm">   memory for PCI. At this point we just reserve memory above 3Gb. Most</span>
<span class="cm">   of this memory will be freed after PCI setup is done. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">albacore_init_arch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memtop</span> <span class="o">=</span> <span class="n">max_low_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">memtop</span> <span class="o">+</span> <span class="mh">0x1000000UL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffffffUL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_struct</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pal_rev</span><span class="p">,</span> <span class="n">pal_var</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">percpu_struct</span><span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">hwrpb</span> <span class="o">+</span> <span class="n">hwrpb</span><span class="o">-&gt;</span><span class="n">processor_offset</span><span class="p">);</span>
	<span class="n">pal_rev</span> <span class="o">=</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pal_revision</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">pal_var</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpu</span><span class="o">-&gt;</span><span class="n">pal_revision</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="cm">/* Consoles earlier than A5.6-18 (OSF PALcode v1.62-2) set up</span>
<span class="cm">	   the CPU incorrectly (leave speculative stores enabled),</span>
<span class="cm">	   which causes memory corruption under certain conditions.</span>
<span class="cm">	   Issue a warning for such consoles. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alpha_using_srm</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pal_rev</span> <span class="o">&lt;</span> <span class="mh">0x13e</span> <span class="o">||</span>	<span class="p">(</span><span class="n">pal_rev</span> <span class="o">==</span> <span class="mh">0x13e</span> <span class="o">&amp;&amp;</span> <span class="n">pal_var</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;WARNING! Upgrade to SRM A5.6-19 &quot;</span>
				    <span class="s">&quot;or later</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_mem</span> <span class="o">&gt;</span> <span class="n">IRONGATE_3GB</span><span class="p">)</span>
		<span class="n">pci_mem</span> <span class="o">=</span> <span class="n">IRONGATE_3GB</span><span class="p">;</span>
	<span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">pci_mem</span> <span class="o">=</span> <span class="n">pci_mem</span><span class="p">;</span>
	<span class="n">alpha_mv</span><span class="p">.</span><span class="n">min_mem_address</span> <span class="o">=</span> <span class="n">pci_mem</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memtop</span> <span class="o">&gt;</span> <span class="n">pci_mem</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
		<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">initrd_start</span><span class="p">,</span> <span class="n">initrd_end</span><span class="p">;</span>
		<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">move_initrd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

		<span class="cm">/* Move the initrd out of the way. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">initrd_end</span> <span class="o">&amp;&amp;</span> <span class="n">__pa</span><span class="p">(</span><span class="n">initrd_end</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pci_mem</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>

			<span class="n">size</span> <span class="o">=</span> <span class="n">initrd_end</span> <span class="o">-</span> <span class="n">initrd_start</span><span class="p">;</span>
			<span class="n">free_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">initrd_start</span><span class="p">),</span>
					  <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">move_initrd</span><span class="p">(</span><span class="n">pci_mem</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;irongate_init_arch: initrd too big &quot;</span>
				       <span class="s">&quot;(%ldK)</span><span class="se">\n</span><span class="s">disabling initrd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">size</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">reserve_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">pci_mem</span><span class="p">,</span> <span class="n">memtop</span> <span class="o">-</span>
				<span class="n">pci_mem</span><span class="p">,</span> <span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;irongate_init_arch: temporarily reserving &quot;</span>
			<span class="s">&quot;region %08lx-%08lx for PCI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_mem</span><span class="p">,</span> <span class="n">memtop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">irongate_setup_agp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable the GART window. AGPGART doesn&#39;t work due to yet</span>
<span class="cm">	   unresolved memory coherency issues... */</span>
	<span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">agpva</span> <span class="o">=</span> <span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">agpva</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">;</span>
	<span class="n">alpha_agpgart_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">irongate_init_arch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">amd761</span> <span class="o">=</span> <span class="p">(</span><span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">dev_vendor</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x7006</span><span class="p">;</span>	<span class="cm">/* Albacore? */</span>

	<span class="n">IronECC</span> <span class="o">=</span> <span class="n">amd761</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">bacsr54_eccms761</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">dramms</span><span class="p">;</span>

	<span class="n">irongate_pci_clr_err</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amd761</span><span class="p">)</span>
		<span class="n">albacore_init_arch</span><span class="p">();</span>

	<span class="n">irongate_setup_agp</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create our single hose.</span>
<span class="cm">	 */</span>

	<span class="n">pci_isa_hose</span> <span class="o">=</span> <span class="n">hose</span> <span class="o">=</span> <span class="n">alloc_pci_controller</span><span class="p">();</span>
	<span class="n">hose</span><span class="o">-&gt;</span><span class="n">io_space</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ioport_resource</span><span class="p">;</span>
	<span class="n">hose</span><span class="o">-&gt;</span><span class="n">mem_space</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">;</span>
	<span class="n">hose</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This is for userland consumption.  For some reason, the 40-bit</span>
<span class="cm">	   PIO bias that we use in the kernel through KSEG didn&#39;t work for</span>
<span class="cm">	   the page table based user mappings.  So make sure we get the</span>
<span class="cm">	   43-bit PIO bias.  */</span>
	<span class="n">hose</span><span class="o">-&gt;</span><span class="n">sparse_mem_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hose</span><span class="o">-&gt;</span><span class="n">sparse_io_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hose</span><span class="o">-&gt;</span><span class="n">dense_mem_base</span>
	  <span class="o">=</span> <span class="p">(</span><span class="n">IRONGATE_MEM</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffUL</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x80000000000UL</span><span class="p">;</span>
	<span class="n">hose</span><span class="o">-&gt;</span><span class="n">dense_io_base</span>
	  <span class="o">=</span> <span class="p">(</span><span class="n">IRONGATE_IO</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffUL</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x80000000000UL</span><span class="p">;</span>

	<span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_isa</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_pci</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">__direct_map_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__direct_map_size</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IO map and AGP support</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/agp_backend.h&gt;</span>
<span class="cp">#include &lt;linux/agpgart.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>

<span class="cp">#define GET_PAGE_DIR_OFF(addr) (addr &gt;&gt; 22)</span>
<span class="cp">#define GET_PAGE_DIR_IDX(addr) (GET_PAGE_DIR_OFF(addr))</span>

<span class="cp">#define GET_GATT_OFF(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12) </span>
<span class="cp">#define GET_GATT(addr) (gatt_pages[GET_PAGE_DIR_IDX(addr)])</span>

<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span>
<span class="nf">irongate_ioremap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_struct</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">baddr</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">mmio_regs</span><span class="p">,</span> <span class="o">*</span><span class="n">gatt_pages</span><span class="p">,</span> <span class="o">*</span><span class="n">cur_gatt</span><span class="p">,</span> <span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gart_bus_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alpha_agpgart_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">IRONGATE_MEM</span><span class="p">);</span>

	<span class="n">gart_bus_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">bar0</span> <span class="o">&amp;</span>
			<span class="n">PCI_BASE_ADDRESS_MEM_MASK</span><span class="p">;</span> 

	<span class="cm">/* </span>
<span class="cm">	 * Check for within the AGP aperture...</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check the AGP area</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">gart_bus_addr</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> 
		    <span class="n">gart_bus_addr</span> <span class="o">+</span> <span class="n">alpha_agpgart_size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Not found - assume legacy ioremap</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">IRONGATE_MEM</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">mmio_regs</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">IRONGATE0</span><span class="o">-&gt;</span><span class="n">bar1</span> <span class="o">&amp;</span>
			<span class="n">PCI_BASE_ADDRESS_MEM_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">IRONGATE_MEM</span><span class="p">);</span>

	<span class="n">gatt_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">mmio_regs</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span> <span class="cm">/* FIXME */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Adjust the limits (mappings must be page aligned)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;AGP ioremap failed... addr not page aligned (0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">IRONGATE_MEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="o">-</span> <span class="n">addr</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	printk(&quot;irongate_ioremap(0x%lx, 0x%lx)\n&quot;, addr, size);</span>
<span class="c">	printk(&quot;irongate_ioremap:  gart_bus_addr  0x%lx\n&quot;, gart_bus_addr);</span>
<span class="c">	printk(&quot;irongate_ioremap:  gart_aper_size 0x%lx\n&quot;, gart_aper_size);</span>
<span class="c">	printk(&quot;irongate_ioremap:  mmio_regs      %p\n&quot;, mmio_regs);</span>
<span class="c">	printk(&quot;irongate_ioremap:  gatt_pages     %p\n&quot;, gatt_pages);</span>
<span class="c">	</span>
<span class="c">	for(baddr = addr; baddr &lt;= last; baddr += PAGE_SIZE)</span>
<span class="c">	{</span>
<span class="c">		cur_gatt = phys_to_virt(GET_GATT(baddr) &amp; ~1);</span>
<span class="c">		pte = cur_gatt[GET_GATT_OFF(baddr)] &amp; ~1;</span>
<span class="c">		printk(&quot;irongate_ioremap:  cur_gatt %p pte 0x%x\n&quot;,</span>
<span class="c">		       cur_gatt, pte);</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map it</span>
<span class="cm">	 */</span>
	<span class="n">area</span> <span class="o">=</span> <span class="n">get_vm_area</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">VM_IOREMAP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">area</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">baddr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span> 
	    <span class="n">baddr</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">;</span> 
	    <span class="n">baddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cur_gatt</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">GET_GATT</span><span class="p">(</span><span class="n">baddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">cur_gatt</span><span class="p">[</span><span class="n">GET_GATT_OFF</span><span class="p">(</span><span class="n">baddr</span><span class="p">)]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__alpha_remap_area_pages</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span>
					     <span class="n">pte</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;AGP ioremap: FAILED to map...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">flush_tlb_all</span><span class="p">();</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	printk(&quot;irongate_ioremap(0x%lx, 0x%lx) returning 0x%lx\n&quot;,</span>
<span class="c">	       addr, size, vaddr);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irongate_ioremap</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">irongate_iounmap</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">xaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(((</span><span class="kt">long</span><span class="p">)</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">41</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>	<span class="cm">/* kseg map, nothing to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vfree</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">PAGE_MASK</span> <span class="o">&amp;</span> <span class="n">addr</span><span class="p">));</span> 
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irongate_iounmap</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
