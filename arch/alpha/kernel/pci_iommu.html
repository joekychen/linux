<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › alpha › kernel › pci_iommu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pci_iommu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	linux/arch/alpha/kernel/pci_iommu.c</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/iommu-helper.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/hwrpb.h&gt;</span>

<span class="cp">#include &quot;proto.h&quot;</span>
<span class="cp">#include &quot;pci_impl.h&quot;</span>


<span class="cp">#define DEBUG_ALLOC 0</span>
<span class="cp">#if DEBUG_ALLOC &gt; 0</span>
<span class="cp"># define DBGA(args...)		printk(KERN_DEBUG args)</span>
<span class="cp">#else</span>
<span class="cp"># define DBGA(args...)</span>
<span class="cp">#endif</span>
<span class="cp">#if DEBUG_ALLOC &gt; 1</span>
<span class="cp"># define DBGA2(args...)		printk(KERN_DEBUG args)</span>
<span class="cp">#else</span>
<span class="cp"># define DBGA2(args...)</span>
<span class="cp">#endif</span>

<span class="cp">#define DEBUG_NODIRECT 0</span>

<span class="cp">#define ISA_DMA_MASK		0x00ffffff</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">mk_iommu_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the minimum of MAX or the first power of two larger</span>
<span class="cm">   than main memory.  */</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">size_for_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">max_low_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span> <span class="n">__init</span>
<span class="nf">iommu_arena_new_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">base</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">window_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">;</span>

	<span class="n">mem_size</span> <span class="o">=</span> <span class="n">window_size</span> <span class="o">/</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>

	<span class="cm">/* Note that the TLB lookup logic uses bitwise concatenation,</span>
<span class="cm">	   not addition, so the required arena alignment is based on</span>
<span class="cm">	   the size of the window.  Retain the align parameter so that</span>
<span class="cm">	   particular systems can over-align the arena.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">align</span> <span class="o">&lt;</span> <span class="n">mem_size</span><span class="p">)</span>
		<span class="n">align</span> <span class="o">=</span> <span class="n">mem_size</span><span class="p">;</span>


<span class="cp">#ifdef CONFIG_DISCONTIGMEM</span>

	<span class="n">arena</span> <span class="o">=</span> <span class="n">alloc_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arena</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">arena</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: couldn&#39;t allocate arena from node %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;    falling back to system-wide allocation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">arena</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arena</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span> <span class="o">=</span> <span class="n">__alloc_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: couldn&#39;t allocate arena ptes from node %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;    falling back to system-wide allocation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">mem_size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_DISCONTIGMEM */</span><span class="cp"></span>

	<span class="n">arena</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arena</span><span class="p">));</span>
	<span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">mem_size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_DISCONTIGMEM */</span><span class="cp"></span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">arena</span><span class="o">-&gt;</span><span class="n">hose</span> <span class="o">=</span> <span class="n">hose</span><span class="p">;</span>
	<span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">arena</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">window_size</span><span class="p">;</span>
	<span class="n">arena</span><span class="o">-&gt;</span><span class="n">next_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Align allocations to a multiple of a page size.  Not needed</span>
<span class="cm">	   unless there are chip bugs.  */</span>
	<span class="n">arena</span><span class="o">-&gt;</span><span class="n">align_entry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">arena</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span> <span class="n">__init</span>
<span class="nf">iommu_arena_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">base</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">window_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">iommu_arena_new_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hose</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be called with the arena lock held */</span>
<span class="k">static</span> <span class="kt">long</span>
<span class="nf">iommu_arena_find_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span>
		       <span class="kt">long</span> <span class="n">n</span><span class="p">,</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boundary_size</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">boundary_size</span> <span class="o">=</span> <span class="n">dma_get_seg_boundary</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">boundary_size</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">boundary_size</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Search forward for the first mask-aligned sequence of N free ptes */</span>
	<span class="n">ptes</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">;</span>
	<span class="n">nent</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">next_entry</span><span class="p">,</span> <span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">+</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">iommu_is_span_boundary</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">boundary_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ptes</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">])</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Reached the end.  Flush the TLB and restart</span>
<span class="cm">			 * the search from the beginning.</span>
<span class="cm">			*/</span>
			<span class="n">alpha_mv</span><span class="p">.</span><span class="n">mv_pci_tbi</span><span class="p">(</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">hose</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

			<span class="n">pass</span><span class="o">++</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Success. It&#39;s the responsibility of the caller to mark them</span>
<span class="cm">	   in use before releasing the lock */</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span>
<span class="nf">iommu_arena_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Search for N empty ptes */</span>
	<span class="n">ptes</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">align_entry</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">iommu_arena_find_pages</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Success.  Mark them all in use, ie not zero and invalid</span>
<span class="cm">	   for the iommu tlb that could load them from under us.</span>
<span class="cm">	   The chip specific bits will fill this in with something</span>
<span class="cm">	   kosher when we return.  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">ptes</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">IOMMU_INVALID_PTE</span><span class="p">;</span>

	<span class="n">arena</span><span class="o">-&gt;</span><span class="n">next_entry</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iommu_arena_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * True if the machine supports DAC addressing, and DEV can</span>
<span class="cm"> * make use of it given MASK.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_dac_dma_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dac_offset</span> <span class="o">=</span> <span class="n">alpha_mv</span><span class="p">.</span><span class="n">pci_dac_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* If this is not set, the machine doesn&#39;t support DAC at all.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The device has to be able to address our DAC bit.  */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dac_offset</span> <span class="o">&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dac_offset</span><span class="p">)</span>
		<span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If both conditions above are met, we are fine. */</span>
	<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;pci_dac_dma_supported %s from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ok</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ok</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Map a single buffer of the indicated size for PCI DMA in streaming</span>
<span class="cm">   mode.  The 32-bit PCI bus mastering address to use is returned.</span>
<span class="cm">   Once the device is given the dma address, the device owns this memory</span>
<span class="cm">   until either pci_unmap_single or pci_dma_sync_single is performed.  */</span>

<span class="k">static</span> <span class="n">dma_addr_t</span>
<span class="nf">pci_map_single_1</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">dac_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">sysdata</span> <span class="o">:</span> <span class="n">pci_isa_hose</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">max_dma</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">:</span> <span class="n">ISA_DMA_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">npages</span><span class="p">,</span> <span class="n">dma_ofs</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">paddr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">cpu_addr</span><span class="p">);</span>

<span class="cp">#if !DEBUG_NODIRECT</span>
	<span class="cm">/* First check to see if we can use the direct map window.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="n">__direct_map_base</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">max_dma</span>
	    <span class="o">&amp;&amp;</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">__direct_map_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">__direct_map_base</span><span class="p">;</span>

		<span class="n">DBGA2</span><span class="p">(</span><span class="s">&quot;pci_map_single: [%p,%zx] -&gt; direct %llx from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Next, use DAC if selected earlier.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">alpha_mv</span><span class="p">.</span><span class="n">pci_dac_offset</span><span class="p">;</span>

		<span class="n">DBGA2</span><span class="p">(</span><span class="s">&quot;pci_map_single: [%p,%zx] -&gt; DAC %llx from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the machine doesn&#39;t define a pci_tbi routine, we have to</span>
<span class="cm">	   assume it doesn&#39;t support sg mapping, and, since we tried to</span>
<span class="cm">	   use direct_map above, it now must be considered an error. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">alpha_mv</span><span class="p">.</span><span class="n">mv_pci_tbi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;pci_map_single: no HW sg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_pci</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arena</span> <span class="o">||</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">+</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">max_dma</span><span class="p">)</span>
		<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_isa</span><span class="p">;</span>

	<span class="n">npages</span> <span class="o">=</span> <span class="n">iommu_num_pages</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/* Force allocation to 64KB boundary for ISA bridges. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span> <span class="o">==</span> <span class="n">isa_bridge</span><span class="p">)</span>
		<span class="n">align</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">dma_ofs</span> <span class="o">=</span> <span class="n">iommu_arena_alloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_ofs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;pci_map_single failed: &quot;</span>
		       <span class="s">&quot;could not allocate dma page tables</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">paddr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">dma_ofs</span><span class="p">]</span> <span class="o">=</span> <span class="n">mk_iommu_pte</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">+</span> <span class="n">dma_ofs</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="n">DBGA2</span><span class="p">(</span><span class="s">&quot;pci_map_single: [%p,%zx] np %ld -&gt; sg %llx from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper for generic DMA-mapping functions. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="nf">alpha_gendev_to_pci</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Assume that non-PCI devices asking for DMA are either ISA or EISA,</span>
<span class="cm">	   BUG() otherwise. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">isa_bridge</span><span class="p">);</span>

	<span class="cm">/* Assume non-busmaster ISA DMA when dma_mask is not set (the ISA</span>
<span class="cm">	   bridge is bus master then). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">||</span> <span class="o">!*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">isa_bridge</span><span class="p">;</span>

	<span class="cm">/* For EISA bus masters, return isa_bridge (it might have smaller</span>
<span class="cm">	   dma_mask due to wiring limitations). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">&gt;=</span> <span class="n">isa_bridge</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">isa_bridge</span><span class="p">;</span>

	<span class="cm">/* This assumes ISA bus master with dma_mask 0xffffff. */</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">alpha_pci_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">alpha_gendev_to_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dac_allowed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">PCI_DMA_NONE</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">dac_allowed</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pci_dac_dma_supported</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> 
	<span class="k">return</span> <span class="n">pci_map_single_1</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> 
				<span class="n">size</span><span class="p">,</span> <span class="n">dac_allowed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Unmap a single streaming mode DMA translation.  The DMA_ADDR and</span>
<span class="cm">   SIZE must match what was provided for in a previous pci_map_single</span>
<span class="cm">   call.  All other usages are undefined.  After this call, reads by</span>
<span class="cm">   the cpu to the buffer are guaranteed to see whatever the device</span>
<span class="cm">   wrote there.  */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_pci_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">alpha_gendev_to_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">sysdata</span> <span class="o">:</span> <span class="n">pci_isa_hose</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">dma_ofs</span><span class="p">,</span> <span class="n">npages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">PCI_DMA_NONE</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_addr</span> <span class="o">&gt;=</span> <span class="n">__direct_map_base</span>
	    <span class="o">&amp;&amp;</span> <span class="n">dma_addr</span> <span class="o">&lt;</span> <span class="n">__direct_map_base</span> <span class="o">+</span> <span class="n">__direct_map_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Nothing to do.  */</span>

		<span class="n">DBGA2</span><span class="p">(</span><span class="s">&quot;pci_unmap_single: direct [%llx,%zx] from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">dma_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_addr</span> <span class="o">&gt;</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBGA2</span><span class="p">(</span><span class="s">&quot;pci64_unmap_single: DAC [%llx,%zx] from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">dma_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_pci</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arena</span> <span class="o">||</span> <span class="n">dma_addr</span> <span class="o">&lt;</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">)</span>
		<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_isa</span><span class="p">;</span>

	<span class="n">dma_ofs</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr</span> <span class="o">-</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_ofs</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">&gt;=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Bogus pci_unmap_single: dma_addr %llx &quot;</span>
		       <span class="s">&quot; base %llx size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dma_addr</span><span class="p">,</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">,</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">npages</span> <span class="o">=</span> <span class="n">iommu_num_pages</span><span class="p">(</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">iommu_arena_free</span><span class="p">(</span><span class="n">arena</span><span class="p">,</span> <span class="n">dma_ofs</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>

        <span class="cm">/* If we&#39;re freeing ptes above the `next_entry&#39; pointer (they</span>
<span class="cm">           may have snuck back into the TLB since the last wrap flush),</span>
<span class="cm">           we need to flush the TLB before reallocating the latter.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_ofs</span> <span class="o">&gt;=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">next_entry</span><span class="p">)</span>
		<span class="n">alpha_mv</span><span class="p">.</span><span class="n">mv_pci_tbi</span><span class="p">(</span><span class="n">hose</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">dma_addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">DBGA2</span><span class="p">(</span><span class="s">&quot;pci_unmap_single: sg [%llx,%zx] np %ld from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">dma_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Allocate and map kernel buffer using consistent mode DMA for PCI</span>
<span class="cm">   device.  Returns non-NULL cpu-view pointer to the buffer if</span>
<span class="cm">   successful and sets *DMA_ADDRP to the pci side dma address as well,</span>
<span class="cm">   else DMA_ADDRP is undefined.  */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alpha_pci_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				      <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_addrp</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">alpha_gendev_to_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="n">gfp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GFP_DMA</span><span class="p">;</span>

<span class="nl">try_again:</span>
	<span class="n">cpu_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">cpu_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;pci_alloc_consistent: &quot;</span>
		       <span class="s">&quot;get_free_pages failed from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="cm">/* ??? Really atomic allocation?  Otherwise we could play</span>
<span class="cm">		   with vmalloc and sg if we can&#39;t find contiguous memory.  */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="o">*</span><span class="n">dma_addrp</span> <span class="o">=</span> <span class="n">pci_map_single_1</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_addrp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alpha_mv</span><span class="p">.</span><span class="n">mv_pci_tbi</span> <span class="o">||</span> <span class="p">(</span><span class="n">gfp</span> <span class="o">&amp;</span> <span class="n">GFP_DMA</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* The address doesn&#39;t fit required mask and we</span>
<span class="cm">		   do not have iommu. Try again with GFP_DMA. */</span>
		<span class="n">gfp</span> <span class="o">|=</span> <span class="n">GFP_DMA</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DBGA2</span><span class="p">(</span><span class="s">&quot;pci_alloc_consistent: %zx -&gt; [%p,%llx] from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">size</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">dma_addrp</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">cpu_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free and unmap a consistent DMA buffer.  CPU_ADDR and DMA_ADDR must</span>
<span class="cm">   be values that were returned from pci_alloc_consistent.  SIZE must</span>
<span class="cm">   be the same as what as passed into pci_alloc_consistent.</span>
<span class="cm">   References to the memory and mappings associated with CPU_ADDR or</span>
<span class="cm">   DMA_ADDR past this call are illegal.  */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_pci_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">alpha_gendev_to_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>

	<span class="n">DBGA2</span><span class="p">(</span><span class="s">&quot;pci_free_consistent: [%llx,%zx] from %pf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">dma_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Classify the elements of the scatterlist.  Write dma_address</span>
<span class="cm">   of each element with:</span>
<span class="cm">	0   : Followers all physically adjacent.</span>
<span class="cm">	1   : Followers all virtually adjacent.</span>
<span class="cm">	-1  : Not leader, physically adjacent to previous.</span>
<span class="cm">	-2  : Not leader, virtually adjacent to previous.</span>
<span class="cm">   Write dma_length of each leader with the combined lengths of</span>
<span class="cm">   the mergable followers.  */</span>

<span class="cp">#define SG_ENT_VIRT_ADDRESS(SG) (sg_virt((SG)))</span>
<span class="cp">#define SG_ENT_PHYS_ADDRESS(SG) __pa(SG_ENT_VIRT_ADDRESS(SG))</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sg_classify</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span>
	    <span class="kt">int</span> <span class="n">virt_ok</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_paddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">leader</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">leader_flag</span><span class="p">,</span> <span class="n">leader_length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_seg_size</span><span class="p">;</span>

	<span class="n">leader</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="n">leader_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">leader_length</span> <span class="o">=</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="n">next_paddr</span> <span class="o">=</span> <span class="n">SG_ENT_PHYS_ADDRESS</span><span class="p">(</span><span class="n">leader</span><span class="p">)</span> <span class="o">+</span> <span class="n">leader_length</span><span class="p">;</span>

	<span class="cm">/* we will not marge sg without device. */</span>
	<span class="n">max_seg_size</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">dma_get_max_seg_size</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">++</span><span class="n">sg</span><span class="p">;</span> <span class="n">sg</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">SG_ENT_PHYS_ADDRESS</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">leader_length</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">max_seg_size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">new_segment</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next_paddr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">leader_length</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">next_paddr</span> <span class="o">|</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">virt_ok</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
			<span class="n">leader_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">leader_length</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="nl">new_segment:</span>
			<span class="n">leader</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">leader_flag</span><span class="p">;</span>
			<span class="n">leader</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">leader_length</span><span class="p">;</span>
			<span class="n">leader</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
			<span class="n">leader_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">leader_length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">next_paddr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leader</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">leader_flag</span><span class="p">;</span>
	<span class="n">leader</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">leader_length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Given a scatterlist leader, choose an allocation method and fill</span>
<span class="cm">   in the blanks.  */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">leader</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span>
	<span class="n">dma_addr_t</span> <span class="n">max_dma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dac_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span> <span class="o">=</span> <span class="n">SG_ENT_PHYS_ADDRESS</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">dma_length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">npages</span><span class="p">,</span> <span class="n">dma_ofs</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#if !DEBUG_NODIRECT</span>
	<span class="cm">/* If everything is physically contiguous, and the addresses</span>
<span class="cm">	   fall into the direct-map window, use it.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">==</span> <span class="mi">0</span>
	    <span class="o">&amp;&amp;</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="n">__direct_map_base</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">max_dma</span>
	    <span class="o">&amp;&amp;</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">__direct_map_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">__direct_map_base</span><span class="p">;</span>
		<span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;    sg_fill: [%p,%lx] -&gt; direct %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">__va</span><span class="p">(</span><span class="n">paddr</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* If physically contiguous and DAC is available, use it.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dac_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">alpha_mv</span><span class="p">.</span><span class="n">pci_dac_offset</span><span class="p">;</span>
		<span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;    sg_fill: [%p,%lx] -&gt; DAC %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">__va</span><span class="p">(</span><span class="n">paddr</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Otherwise, we&#39;ll use the iommu to make the pages virtually</span>
<span class="cm">	   contiguous.  */</span>

	<span class="n">paddr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">npages</span> <span class="o">=</span> <span class="n">iommu_num_pages</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">dma_ofs</span> <span class="o">=</span> <span class="n">iommu_arena_alloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_ofs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we attempted a direct map above but failed, die.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Otherwise, break up the remaining virtually contiguous</span>
<span class="cm">		   hunks into individual direct maps and retry.  */</span>
		<span class="n">sg_classify</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">leader</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">sg_fill</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">leader</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">max_dma</span><span class="p">,</span> <span class="n">dac_allowed</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">+</span> <span class="n">dma_ofs</span><span class="o">*</span><span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;    sg_fill: [%p,%lx] -&gt; sg %llx np %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">__va</span><span class="p">(</span><span class="n">paddr</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>

	<span class="cm">/* All virtually contiguous.  We need to find the length of each</span>
<span class="cm">	   physically contiguous subsegment to fill in the ptes.  */</span>
	<span class="n">ptes</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">[</span><span class="n">dma_ofs</span><span class="p">];</span>
	<span class="n">sg</span> <span class="o">=</span> <span class="n">leader</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
<span class="cp">#if DEBUG_ALLOC &gt; 0</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">last_sg</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">paddr</span> <span class="o">=</span> <span class="n">SG_ENT_PHYS_ADDRESS</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">sg</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">dma_address</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
			<span class="n">sg</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">npages</span> <span class="o">=</span> <span class="n">iommu_num_pages</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">paddr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="o">*</span><span class="n">ptes</span><span class="o">++</span> <span class="o">=</span> <span class="n">mk_iommu_pte</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>

<span class="cp">#if DEBUG_ALLOC &gt; 0</span>
		<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;    (%ld) [%p,%x] np %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">last_sg</span> <span class="o">-</span> <span class="n">leader</span><span class="p">,</span> <span class="n">SG_ENT_VIRT_ADDRESS</span><span class="p">(</span><span class="n">last_sg</span><span class="p">),</span>
		     <span class="n">last_sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">last_sg</span> <span class="o">&lt;=</span> <span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;        (%ld) [%p,%x] cont</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">last_sg</span> <span class="o">-</span> <span class="n">leader</span><span class="p">,</span> <span class="n">SG_ENT_VIRT_ADDRESS</span><span class="p">(</span><span class="n">last_sg</span><span class="p">),</span>
			     <span class="n">last_sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">sg</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alpha_pci_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">alpha_gendev_to_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span> <span class="o">*</span><span class="n">out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">max_dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dac_allowed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">PCI_DMA_NONE</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">dac_allowed</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">pci_dac_dma_supported</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Fast path single entry scatterlists.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nents</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span>
		  <span class="o">=</span> <span class="n">pci_map_single_1</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">SG_ENT_VIRT_ADDRESS</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span>
				     <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">dac_allowed</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">sg</span> <span class="o">+</span> <span class="n">nents</span><span class="p">;</span>

	<span class="cm">/* First, prepare information about the entries.  */</span>
	<span class="n">sg_classify</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">alpha_mv</span><span class="p">.</span><span class="n">mv_pci_tbi</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Second, figure out where we&#39;re going to map things.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alpha_mv</span><span class="p">.</span><span class="n">mv_pci_tbi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hose</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">sysdata</span> <span class="o">:</span> <span class="n">pci_isa_hose</span><span class="p">;</span>
		<span class="n">max_dma</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">:</span> <span class="n">ISA_DMA_MASK</span><span class="p">;</span>
		<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_pci</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arena</span> <span class="o">||</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">+</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">max_dma</span><span class="p">)</span>
			<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_isa</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">max_dma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">arena</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hose</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Third, iterate over the scatterlist leaders and allocate</span>
<span class="cm">	   dma space as needed.  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">out</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span> <span class="n">sg</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg_fill</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">max_dma</span><span class="p">,</span> <span class="n">dac_allowed</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">out</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark the end of the list for pci_unmap_sg.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">out</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">-</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;pci_map_sg failed: no entries?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;pci_map_sg: %ld entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">out</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

 <span class="nl">error:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;pci_map_sg failed: &quot;</span>
	       <span class="s">&quot;could not allocate dma page tables</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Some allocation failed while mapping the scatterlist</span>
<span class="cm">	   entries.  Unmap them now.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
		<span class="n">pci_unmap_sg</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">out</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unmap a set of streaming mode DMA translations.  Again, cpu read</span>
<span class="cm">   rules concerning calls here are the same as for pci_unmap_single()</span>
<span class="cm">   above.  */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">alpha_pci_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">alpha_gendev_to_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">max_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">fbeg</span><span class="p">,</span> <span class="n">fend</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">PCI_DMA_NONE</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">alpha_mv</span><span class="p">.</span><span class="n">mv_pci_tbi</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hose</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">sysdata</span> <span class="o">:</span> <span class="n">pci_isa_hose</span><span class="p">;</span>
	<span class="n">max_dma</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">:</span> <span class="n">ISA_DMA_MASK</span><span class="p">;</span>
	<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_pci</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arena</span> <span class="o">||</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">+</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">max_dma</span><span class="p">)</span>
		<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_isa</span><span class="p">;</span>

	<span class="n">fbeg</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">end</span> <span class="o">=</span> <span class="n">sg</span> <span class="o">+</span> <span class="n">nents</span><span class="p">;</span> <span class="n">sg</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">npages</span><span class="p">,</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="n">dma_addr_t</span> <span class="n">tend</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_length</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* It&#39;s a DAC address -- nothing to do.  */</span>
			<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;    (%ld) DAC [%llx,%zx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">sg</span> <span class="o">-</span> <span class="n">end</span> <span class="o">+</span> <span class="n">nents</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">__direct_map_base</span>
		    <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">__direct_map_base</span> <span class="o">+</span> <span class="n">__direct_map_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Nothing to do.  */</span>
			<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;    (%ld) direct [%llx,%zx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">sg</span> <span class="o">-</span> <span class="n">end</span> <span class="o">+</span> <span class="n">nents</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;    (%ld) sg [%llx,%zx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">sg</span> <span class="o">-</span> <span class="n">end</span> <span class="o">+</span> <span class="n">nents</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

		<span class="n">npages</span> <span class="o">=</span> <span class="n">iommu_num_pages</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">iommu_arena_free</span><span class="p">(</span><span class="n">arena</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>

		<span class="n">tend</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fbeg</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span> <span class="n">fbeg</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fend</span> <span class="o">&lt;</span> <span class="n">tend</span><span class="p">)</span> <span class="n">fend</span> <span class="o">=</span> <span class="n">tend</span><span class="p">;</span>
	<span class="p">}</span>

        <span class="cm">/* If we&#39;re freeing ptes above the `next_entry&#39; pointer (they</span>
<span class="cm">           may have snuck back into the TLB since the last wrap flush),</span>
<span class="cm">           we need to flush the TLB before reallocating the latter.  */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fend</span> <span class="o">-</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span> <span class="o">&gt;=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">next_entry</span><span class="p">)</span>
		<span class="n">alpha_mv</span><span class="p">.</span><span class="n">mv_pci_tbi</span><span class="p">(</span><span class="n">hose</span><span class="p">,</span> <span class="n">fbeg</span><span class="p">,</span> <span class="n">fend</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">DBGA</span><span class="p">(</span><span class="s">&quot;pci_unmap_sg: %ld entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nents</span> <span class="o">-</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">sg</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Return whether the given PCI device DMA address mask can be</span>
<span class="cm">   supported properly.  */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alpha_pci_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">alpha_gendev_to_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">;</span>

	<span class="cm">/* If there exists a direct map, and the mask fits either</span>
<span class="cm">	   the entire direct mapped space or the total system memory as</span>
<span class="cm">	   shifted by the map base */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__direct_map_size</span> <span class="o">!=</span> <span class="mi">0</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">__direct_map_base</span> <span class="o">+</span> <span class="n">__direct_map_size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">mask</span> <span class="o">||</span>
		<span class="n">__direct_map_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_low_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Check that we have a scatter-gather arena that fits.  */</span>
	<span class="n">hose</span> <span class="o">=</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">sysdata</span> <span class="o">:</span> <span class="n">pci_isa_hose</span><span class="p">;</span>
	<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_isa</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arena</span> <span class="o">&amp;&amp;</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">+</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">arena</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">sg_pci</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arena</span> <span class="o">&amp;&amp;</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">+</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* As last resort try ZONE_DMA.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__direct_map_base</span> <span class="o">&amp;&amp;</span> <span class="n">MAX_DMA_ADDRESS</span> <span class="o">-</span> <span class="n">IDENT_ADDR</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * AGP GART extensions to the IOMMU</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">iommu_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pg_count</span><span class="p">,</span> <span class="kt">long</span> <span class="n">align_mask</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arena</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Search for N empty ptes.  */</span>
	<span class="n">ptes</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">iommu_arena_find_pages</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">pg_count</span><span class="p">,</span> <span class="n">align_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Success.  Mark them all reserved (ie not zero and invalid)</span>
<span class="cm">	   for the iommu tlb that could load them from under us.</span>
<span class="cm">	   They will be filled in with valid bits by _bind() */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pg_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">ptes</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">IOMMU_RESERVED_PTE</span><span class="p">;</span>

	<span class="n">arena</span><span class="o">-&gt;</span><span class="n">next_entry</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">pg_count</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> 
<span class="nf">iommu_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pg_start</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pg_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arena</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ptes</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">;</span>

	<span class="cm">/* Make sure they&#39;re all reserved first... */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">pg_start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pg_start</span> <span class="o">+</span> <span class="n">pg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IOMMU_RESERVED_PTE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">iommu_arena_free</span><span class="p">(</span><span class="n">arena</span><span class="p">,</span> <span class="n">pg_start</span><span class="p">,</span> <span class="n">pg_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">iommu_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pg_start</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pg_count</span><span class="p">,</span> 
	   <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arena</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ptes</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">pg_start</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pg_start</span> <span class="o">+</span> <span class="n">pg_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IOMMU_RESERVED_PTE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
		
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pg_start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ptes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mk_iommu_pte</span><span class="p">(</span><span class="n">page_to_phys</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arena</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">iommu_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_iommu_arena</span> <span class="o">*</span><span class="n">arena</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pg_start</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pg_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arena</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">ptes</span> <span class="o">+</span> <span class="n">pg_start</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">IOMMU_RESERVED_PTE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alpha_pci_mapping_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alpha_pci_set_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">pci_dma_supported</span><span class="p">(</span><span class="n">alpha_gendev_to_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="n">alpha_pci_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc</span>			<span class="o">=</span> <span class="n">alpha_pci_alloc_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span>			<span class="o">=</span> <span class="n">alpha_pci_free_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_page</span>		<span class="o">=</span> <span class="n">alpha_pci_map_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_page</span>		<span class="o">=</span> <span class="n">alpha_pci_unmap_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span>			<span class="o">=</span> <span class="n">alpha_pci_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span>		<span class="o">=</span> <span class="n">alpha_pci_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mapping_error</span>		<span class="o">=</span> <span class="n">alpha_pci_mapping_error</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_supported</span>		<span class="o">=</span> <span class="n">alpha_pci_supported</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_dma_mask</span>		<span class="o">=</span> <span class="n">alpha_pci_set_mask</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="o">*</span><span class="n">dma_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">alpha_pci_ops</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dma_ops</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
