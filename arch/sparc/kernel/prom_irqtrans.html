<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › kernel › prom_irqtrans.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>prom_irqtrans.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>

<span class="cp">#include &lt;asm/oplib.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/upa.h&gt;</span>

<span class="cp">#include &quot;prom.h&quot;</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="cm">/* PSYCHO interrupt mapping support. */</span>
<span class="cp">#define PSYCHO_IMAP_A_SLOT0	0x0c00UL</span>
<span class="cp">#define PSYCHO_IMAP_B_SLOT0	0x0c20UL</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">psycho_pcislot_imap_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span> <span class="o">=</span>  <span class="p">(</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="mh">0x0c</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PSYCHO_IMAP_A_SLOT0</span> <span class="o">+</span> <span class="p">(</span><span class="n">slot</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">PSYCHO_IMAP_B_SLOT0</span> <span class="o">+</span> <span class="p">(</span><span class="n">slot</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define PSYCHO_OBIO_IMAP_BASE	0x1000UL</span>

<span class="cp">#define PSYCHO_ONBOARD_IRQ_BASE		0x20</span>
<span class="cp">#define psycho_onboard_imap_offset(__ino) \</span>
<span class="cp">	(PSYCHO_OBIO_IMAP_BASE + (((__ino) &amp; 0x1f) &lt;&lt; 3))</span>

<span class="cp">#define PSYCHO_ICLR_A_SLOT0	0x1400UL</span>
<span class="cp">#define PSYCHO_ICLR_SCSI	0x1800UL</span>

<span class="cp">#define psycho_iclr_offset(ino)					      \</span>
<span class="cp">	((ino &amp; 0x20) ? (PSYCHO_ICLR_SCSI + (((ino) &amp; 0x1f) &lt;&lt; 3)) :  \</span>
<span class="cp">			(PSYCHO_ICLR_A_SLOT0 + (((ino) &amp; 0x1f)&lt;&lt;3)))</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">psycho_irq_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">controller_regs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imap</span><span class="p">,</span> <span class="n">iclr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imap_off</span><span class="p">,</span> <span class="n">iclr_off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inofixup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ino</span> <span class="o">&amp;=</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">PSYCHO_ONBOARD_IRQ_BASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* PCI slot */</span>
		<span class="n">imap_off</span> <span class="o">=</span> <span class="n">psycho_pcislot_imap_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Onboard device */</span>
		<span class="n">imap_off</span> <span class="o">=</span> <span class="n">psycho_onboard_imap_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Now build the IRQ bucket. */</span>
	<span class="n">imap</span> <span class="o">=</span> <span class="n">controller_regs</span> <span class="o">+</span> <span class="n">imap_off</span><span class="p">;</span>

	<span class="n">iclr_off</span> <span class="o">=</span> <span class="n">psycho_iclr_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">iclr</span> <span class="o">=</span> <span class="n">controller_regs</span> <span class="o">+</span> <span class="n">iclr_off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">inofixup</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">build_irq</span><span class="p">(</span><span class="n">inofixup</span><span class="p">,</span> <span class="n">iclr</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">psycho_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_irq_controller</span><span class="p">));</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">irq_build</span> <span class="o">=</span> <span class="n">psycho_irq_build</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define sabre_read(__reg) \</span>
<span class="cp">({	u64 __ret; \</span>
<span class="cp">	__asm__ __volatile__(&quot;ldxa [%1] %2, %0&quot; \</span>
<span class="cp">			     : &quot;=r&quot; (__ret) \</span>
<span class="cp">			     : &quot;r&quot; (__reg), &quot;i&quot; (ASI_PHYS_BYPASS_EC_E) \</span>
<span class="cp">			     : &quot;memory&quot;); \</span>
<span class="cp">	__ret; \</span>
<span class="cp">})</span>

<span class="k">struct</span> <span class="n">sabre_irq_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">controller_regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_first_busno</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define SABRE_CONFIGSPACE	0x001000000UL</span>
<span class="cp">#define SABRE_WRSYNC		0x1c20UL</span>

<span class="cp">#define SABRE_CONFIG_BASE(CONFIG_SPACE)	\</span>
<span class="cp">	(CONFIG_SPACE | (1UL &lt;&lt; 24))</span>
<span class="cp">#define SABRE_CONFIG_ENCODE(BUS, DEVFN, REG)	\</span>
<span class="cp">	(((unsigned long)(BUS)   &lt;&lt; 16) |	\</span>
<span class="cp">	 ((unsigned long)(DEVFN) &lt;&lt; 8)  |	\</span>
<span class="cp">	 ((unsigned long)(REG)))</span>

<span class="cm">/* When a device lives behind a bridge deeper in the PCI bus topology</span>
<span class="cm"> * than APB, a special sequence must run to make sure all pending DMA</span>
<span class="cm"> * transfers at the time of IRQ delivery are visible in the coherency</span>
<span class="cm"> * domain by the cpu.  This sequence is to perform a read on the far</span>
<span class="cm"> * side of the non-APB bridge, then perform a read of Sabre&#39;s DMA</span>
<span class="cm"> * write-sync register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sabre_wsync_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_arg1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_arg2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">phys_hi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_arg1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sabre_irq_data</span> <span class="o">*</span><span class="n">irq_data</span> <span class="o">=</span> <span class="n">_arg2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">controller_regs</span> <span class="o">=</span> <span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">controller_regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sync_reg</span> <span class="o">=</span> <span class="n">controller_regs</span> <span class="o">+</span> <span class="n">SABRE_WRSYNC</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">config_space</span> <span class="o">=</span> <span class="n">controller_regs</span> <span class="o">+</span> <span class="n">SABRE_CONFIGSPACE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">_unused</span><span class="p">;</span>

	<span class="n">config_space</span> <span class="o">=</span> <span class="n">SABRE_CONFIG_BASE</span><span class="p">(</span><span class="n">config_space</span><span class="p">);</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="p">(</span><span class="n">phys_hi</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">devfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">phys_hi</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">config_space</span> <span class="o">|=</span> <span class="n">SABRE_CONFIG_ENCODE</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;membar #Sync</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;lduha [%1] %2, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;membar #Sync&quot;</span>
			     <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">_unused</span><span class="p">)</span>
			     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">config_space</span><span class="p">),</span>
			       <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_PHYS_BYPASS_EC_E_L</span><span class="p">)</span>
			     <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

	<span class="n">sabre_read</span><span class="p">(</span><span class="n">sync_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SABRE_IMAP_A_SLOT0	0x0c00UL</span>
<span class="cp">#define SABRE_IMAP_B_SLOT0	0x0c20UL</span>
<span class="cp">#define SABRE_ICLR_A_SLOT0	0x1400UL</span>
<span class="cp">#define SABRE_ICLR_B_SLOT0	0x1480UL</span>
<span class="cp">#define SABRE_ICLR_SCSI		0x1800UL</span>
<span class="cp">#define SABRE_ICLR_ETH		0x1808UL</span>
<span class="cp">#define SABRE_ICLR_BPP		0x1810UL</span>
<span class="cp">#define SABRE_ICLR_AU_REC	0x1818UL</span>
<span class="cp">#define SABRE_ICLR_AU_PLAY	0x1820UL</span>
<span class="cp">#define SABRE_ICLR_PFAIL	0x1828UL</span>
<span class="cp">#define SABRE_ICLR_KMS		0x1830UL</span>
<span class="cp">#define SABRE_ICLR_FLPY		0x1838UL</span>
<span class="cp">#define SABRE_ICLR_SHW		0x1840UL</span>
<span class="cp">#define SABRE_ICLR_KBD		0x1848UL</span>
<span class="cp">#define SABRE_ICLR_MS		0x1850UL</span>
<span class="cp">#define SABRE_ICLR_SER		0x1858UL</span>
<span class="cp">#define SABRE_ICLR_UE		0x1870UL</span>
<span class="cp">#define SABRE_ICLR_CE		0x1878UL</span>
<span class="cp">#define SABRE_ICLR_PCIERR	0x1880UL</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sabre_pcislot_imap_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span> <span class="o">=</span>  <span class="p">(</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="mh">0x0c</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SABRE_IMAP_A_SLOT0</span> <span class="o">+</span> <span class="p">(</span><span class="n">slot</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">SABRE_IMAP_B_SLOT0</span> <span class="o">+</span> <span class="p">(</span><span class="n">slot</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SABRE_OBIO_IMAP_BASE	0x1000UL</span>
<span class="cp">#define SABRE_ONBOARD_IRQ_BASE	0x20</span>
<span class="cp">#define sabre_onboard_imap_offset(__ino) \</span>
<span class="cp">	(SABRE_OBIO_IMAP_BASE + (((__ino) &amp; 0x1f) &lt;&lt; 3))</span>

<span class="cp">#define sabre_iclr_offset(ino)					      \</span>
<span class="cp">	((ino &amp; 0x20) ? (SABRE_ICLR_SCSI + (((ino) &amp; 0x1f) &lt;&lt; 3)) :  \</span>
<span class="cp">			(SABRE_ICLR_A_SLOT0 + (((ino) &amp; 0x1f)&lt;&lt;3)))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sabre_device_needs_wsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">parent_model</span><span class="p">,</span> <span class="o">*</span><span class="n">parent_compat</span><span class="p">;</span>

	<span class="cm">/* This traversal up towards the root is meant to</span>
<span class="cm">	 * handle two cases:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) non-PCI bus sitting under PCI, such as &#39;ebus&#39;</span>
<span class="cm">	 * 2) the PCI controller interrupts themselves, which</span>
<span class="cm">	 *    will use the sabre_irq_build but do not need</span>
<span class="cm">	 *    the DMA synchronization handling</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;pci&quot;</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">parent_model</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span>
				       <span class="s">&quot;model&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent_model</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parent_model</span><span class="p">,</span> <span class="s">&quot;SUNW,sabre&quot;</span><span class="p">)</span> <span class="o">||</span>
	     <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parent_model</span><span class="p">,</span> <span class="s">&quot;SUNW,simba&quot;</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">parent_compat</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span>
					<span class="s">&quot;compatible&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent_compat</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parent_compat</span><span class="p">,</span> <span class="s">&quot;pci108e,a000&quot;</span><span class="p">)</span> <span class="o">||</span>
	     <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parent_compat</span><span class="p">,</span> <span class="s">&quot;pci108e,a001&quot;</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sabre_irq_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sabre_irq_data</span> <span class="o">*</span><span class="n">irq_data</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">controller_regs</span> <span class="o">=</span> <span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">controller_regs</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom_pci_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imap</span><span class="p">,</span> <span class="n">iclr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imap_off</span><span class="p">,</span> <span class="n">iclr_off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inofixup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">ino</span> <span class="o">&amp;=</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">SABRE_ONBOARD_IRQ_BASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* PCI slot */</span>
		<span class="n">imap_off</span> <span class="o">=</span> <span class="n">sabre_pcislot_imap_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* onboard device */</span>
		<span class="n">imap_off</span> <span class="o">=</span> <span class="n">sabre_onboard_imap_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Now build the IRQ bucket. */</span>
	<span class="n">imap</span> <span class="o">=</span> <span class="n">controller_regs</span> <span class="o">+</span> <span class="n">imap_off</span><span class="p">;</span>

	<span class="n">iclr_off</span> <span class="o">=</span> <span class="n">sabre_iclr_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">iclr</span> <span class="o">=</span> <span class="n">controller_regs</span> <span class="o">+</span> <span class="n">iclr_off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">inofixup</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">build_irq</span><span class="p">(</span><span class="n">inofixup</span><span class="p">,</span> <span class="n">iclr</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>

	<span class="cm">/* If the parent device is a PCI&lt;-&gt;PCI bridge other than</span>
<span class="cm">	 * APB, we have to install a pre-handler to ensure that</span>
<span class="cm">	 * all pending DMA is drained before the interrupt handler</span>
<span class="cm">	 * is run.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="n">sabre_device_needs_wsync</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">irq_install_pre_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span>
					<span class="n">sabre_wsync_handler</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">phys_hi</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">irq_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sabre_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sabre_irq_data</span> <span class="o">*</span><span class="n">irq_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">busrange</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_irq_controller</span><span class="p">));</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">irq_build</span> <span class="o">=</span> <span class="n">sabre_irq_build</span><span class="p">;</span>

	<span class="n">irq_data</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sabre_irq_data</span><span class="p">));</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">controller_regs</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>

	<span class="n">busrange</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;bus-range&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">pci_first_busno</span> <span class="o">=</span> <span class="n">busrange</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">irq_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* SCHIZO interrupt mapping support.  Unlike Psycho, for this controller the</span>
<span class="cm"> * imap/iclr registers are per-PBM.</span>
<span class="cm"> */</span>
<span class="cp">#define SCHIZO_IMAP_BASE	0x1000UL</span>
<span class="cp">#define SCHIZO_ICLR_BASE	0x1400UL</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">schizo_imap_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SCHIZO_IMAP_BASE</span> <span class="o">+</span> <span class="p">(</span><span class="n">ino</span> <span class="o">*</span> <span class="mi">8UL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">schizo_iclr_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SCHIZO_ICLR_BASE</span> <span class="o">+</span> <span class="p">(</span><span class="n">ino</span> <span class="o">*</span> <span class="mi">8UL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">schizo_ino_to_iclr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbm_regs</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">return</span> <span class="n">pbm_regs</span> <span class="o">+</span> <span class="n">schizo_iclr_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">schizo_ino_to_imap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbm_regs</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pbm_regs</span> <span class="o">+</span> <span class="n">schizo_imap_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define schizo_read(__reg) \</span>
<span class="cp">({	u64 __ret; \</span>
<span class="cp">	__asm__ __volatile__(&quot;ldxa [%1] %2, %0&quot; \</span>
<span class="cp">			     : &quot;=r&quot; (__ret) \</span>
<span class="cp">			     : &quot;r&quot; (__reg), &quot;i&quot; (ASI_PHYS_BYPASS_EC_E) \</span>
<span class="cp">			     : &quot;memory&quot;); \</span>
<span class="cp">	__ret; \</span>
<span class="cp">})</span>
<span class="cp">#define schizo_write(__reg, __val) \</span>
<span class="cp">	__asm__ __volatile__(&quot;stxa %0, [%1] %2&quot; \</span>
<span class="cp">			     : </span><span class="cm">/* no outputs */</span><span class="cp"> \</span>
<span class="cp">			     : &quot;r&quot; (__val), &quot;r&quot; (__reg), \</span>
<span class="cp">			       &quot;i&quot; (ASI_PHYS_BYPASS_EC_E) \</span>
<span class="cp">			     : &quot;memory&quot;)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tomatillo_wsync_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_arg1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_arg2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sync_reg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_arg2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="n">IMAP_INO</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>

	<span class="n">schizo_write</span><span class="p">(</span><span class="n">sync_reg</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">schizo_read</span><span class="p">(</span><span class="n">sync_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;tomatillo_wsync_handler: DMA won&#39;t sync [%llx:%llx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">val</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_arg1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cacheline</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>
			<span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">64</span><span class="p">)));</span>

		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;rd %%fprs, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
				     <span class="s">&quot;or %0, %4, %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
				     <span class="s">&quot;wr %1, 0x0, %%fprs</span><span class="se">\n\t</span><span class="s">&quot;</span>
				     <span class="s">&quot;stda %%f0, [%5] %6</span><span class="se">\n\t</span><span class="s">&quot;</span>
				     <span class="s">&quot;wr %0, 0x0, %%fprs</span><span class="se">\n\t</span><span class="s">&quot;</span>
				     <span class="s">&quot;membar #Sync&quot;</span>
				     <span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
				     <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">),</span>
				     <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">FPRS_FEF</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">cacheline</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				     <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_BLK_COMMIT_P</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">schizo_irq_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbm_regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sync_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">portid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_version</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">schizo_irq_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">schizo_irq_data</span> <span class="o">*</span><span class="n">irq_data</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbm_regs</span> <span class="o">=</span> <span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">pbm_regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imap</span><span class="p">,</span> <span class="n">iclr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ign_fixup</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_tomatillo</span><span class="p">;</span>

	<span class="n">ino</span> <span class="o">&amp;=</span> <span class="mh">0x3f</span><span class="p">;</span>

	<span class="cm">/* Now build the IRQ bucket. */</span>
	<span class="n">imap</span> <span class="o">=</span> <span class="n">schizo_ino_to_imap</span><span class="p">(</span><span class="n">pbm_regs</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">iclr</span> <span class="o">=</span> <span class="n">schizo_ino_to_iclr</span><span class="p">(</span><span class="n">pbm_regs</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>

	<span class="cm">/* On Schizo, no inofixup occurs.  This is because each</span>
<span class="cm">	 * INO has it&#39;s own IMAP register.  On Psycho and Sabre</span>
<span class="cm">	 * there is only one IMAP register for each PCI slot even</span>
<span class="cm">	 * though four different INOs can be generated by each</span>
<span class="cm">	 * PCI slot.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But, for JBUS variants (essentially, Tomatillo), we have</span>
<span class="cm">	 * to fixup the lowest bit of the interrupt group number.</span>
<span class="cm">	 */</span>
	<span class="n">ign_fixup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">is_tomatillo</span> <span class="o">=</span> <span class="p">(</span><span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">sync_reg</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_tomatillo</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">portid</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">ign_fixup</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">build_irq</span><span class="p">(</span><span class="n">ign_fixup</span><span class="p">,</span> <span class="n">iclr</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_tomatillo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq_install_pre_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span>
					<span class="n">tomatillo_wsync_handler</span><span class="p">,</span>
					<span class="p">((</span><span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">?</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">sync_reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">__schizo_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">is_tomatillo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">schizo_irq_data</span> <span class="o">*</span><span class="n">irq_data</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_irq_controller</span><span class="p">));</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">irq_build</span> <span class="o">=</span> <span class="n">schizo_irq_build</span><span class="p">;</span>

	<span class="n">irq_data</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">schizo_irq_data</span><span class="p">));</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">irq_data</span><span class="p">;</span>

	<span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">pbm_regs</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_tomatillo</span><span class="p">)</span>
		<span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">sync_reg</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">+</span> <span class="mh">0x1a18UL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">sync_reg</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">portid</span> <span class="o">=</span> <span class="n">of_getintprop_default</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;portid&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">=</span> <span class="n">of_getintprop_default</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;version#&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">schizo_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__schizo_irq_trans_init</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">tomatillo_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__schizo_irq_trans_init</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">pci_sun4v_irq_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devino</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">devhandle</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sun4v_build_irq</span><span class="p">(</span><span class="n">devhandle</span><span class="p">,</span> <span class="n">devino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">pci_sun4v_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_irq_controller</span><span class="p">));</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">irq_build</span> <span class="o">=</span> <span class="n">pci_sun4v_irq_build</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
		<span class="p">((</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32UL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">fire_irq_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbm_regs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">portid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FIRE_IMAP_BASE	0x001000</span>
<span class="cp">#define FIRE_ICLR_BASE	0x001400</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">fire_imap_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">FIRE_IMAP_BASE</span> <span class="o">+</span> <span class="p">(</span><span class="n">ino</span> <span class="o">*</span> <span class="mi">8UL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">fire_iclr_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">FIRE_ICLR_BASE</span> <span class="o">+</span> <span class="p">(</span><span class="n">ino</span> <span class="o">*</span> <span class="mi">8UL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">fire_ino_to_iclr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbm_regs</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pbm_regs</span> <span class="o">+</span> <span class="n">fire_iclr_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">fire_ino_to_imap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbm_regs</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pbm_regs</span> <span class="o">+</span> <span class="n">fire_imap_offset</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fire_irq_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fire_irq_data</span> <span class="o">*</span><span class="n">irq_data</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbm_regs</span> <span class="o">=</span> <span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">pbm_regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imap</span><span class="p">,</span> <span class="n">iclr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">int_ctrlr</span><span class="p">;</span>

	<span class="n">ino</span> <span class="o">&amp;=</span> <span class="mh">0x3f</span><span class="p">;</span>

	<span class="cm">/* Now build the IRQ bucket. */</span>
	<span class="n">imap</span> <span class="o">=</span> <span class="n">fire_ino_to_imap</span><span class="p">(</span><span class="n">pbm_regs</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">iclr</span> <span class="o">=</span> <span class="n">fire_ino_to_iclr</span><span class="p">(</span><span class="n">pbm_regs</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>

	<span class="cm">/* Set the interrupt controller number.  */</span>
	<span class="n">int_ctrlr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">upa_writeq</span><span class="p">(</span><span class="n">int_ctrlr</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>

	<span class="cm">/* The interrupt map registers do not have an INO field</span>
<span class="cm">	 * like other chips do.  They return zero in the INO</span>
<span class="cm">	 * field, and the interrupt controller number is controlled</span>
<span class="cm">	 * in bits 6 to 9.  So in order for build_irq() to get</span>
<span class="cm">	 * the INO right we pass it in as part of the fixup</span>
<span class="cm">	 * which will get added to the map register zero value</span>
<span class="cm">	 * read by build_irq().</span>
<span class="cm">	 */</span>
	<span class="n">ino</span> <span class="o">|=</span> <span class="p">(</span><span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">portid</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">ino</span> <span class="o">-=</span> <span class="n">int_ctrlr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">build_irq</span><span class="p">(</span><span class="n">ino</span><span class="p">,</span> <span class="n">iclr</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">fire_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fire_irq_data</span> <span class="o">*</span><span class="n">irq_data</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_irq_controller</span><span class="p">));</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">irq_build</span> <span class="o">=</span> <span class="n">fire_irq_build</span><span class="p">;</span>

	<span class="n">irq_data</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fire_irq_data</span><span class="p">));</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">irq_data</span><span class="p">;</span>

	<span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">pbm_regs</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
	<span class="n">irq_data</span><span class="o">-&gt;</span><span class="n">portid</span> <span class="o">=</span> <span class="n">of_getintprop_default</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;portid&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SBUS</span>
<span class="cm">/* INO number to IMAP register offset for SYSIO external IRQ&#39;s.</span>
<span class="cm"> * This should conform to both Sunfire/Wildfire server and Fusion</span>
<span class="cm"> * desktop designs.</span>
<span class="cm"> */</span>
<span class="cp">#define SYSIO_IMAP_SLOT0	0x2c00UL</span>
<span class="cp">#define SYSIO_IMAP_SLOT1	0x2c08UL</span>
<span class="cp">#define SYSIO_IMAP_SLOT2	0x2c10UL</span>
<span class="cp">#define SYSIO_IMAP_SLOT3	0x2c18UL</span>
<span class="cp">#define SYSIO_IMAP_SCSI		0x3000UL</span>
<span class="cp">#define SYSIO_IMAP_ETH		0x3008UL</span>
<span class="cp">#define SYSIO_IMAP_BPP		0x3010UL</span>
<span class="cp">#define SYSIO_IMAP_AUDIO	0x3018UL</span>
<span class="cp">#define SYSIO_IMAP_PFAIL	0x3020UL</span>
<span class="cp">#define SYSIO_IMAP_KMS		0x3028UL</span>
<span class="cp">#define SYSIO_IMAP_FLPY		0x3030UL</span>
<span class="cp">#define SYSIO_IMAP_SHW		0x3038UL</span>
<span class="cp">#define SYSIO_IMAP_KBD		0x3040UL</span>
<span class="cp">#define SYSIO_IMAP_MS		0x3048UL</span>
<span class="cp">#define SYSIO_IMAP_SER		0x3050UL</span>
<span class="cp">#define SYSIO_IMAP_TIM0		0x3060UL</span>
<span class="cp">#define SYSIO_IMAP_TIM1		0x3068UL</span>
<span class="cp">#define SYSIO_IMAP_UE		0x3070UL</span>
<span class="cp">#define SYSIO_IMAP_CE		0x3078UL</span>
<span class="cp">#define SYSIO_IMAP_SBERR	0x3080UL</span>
<span class="cp">#define SYSIO_IMAP_PMGMT	0x3088UL</span>
<span class="cp">#define SYSIO_IMAP_GFX		0x3090UL</span>
<span class="cp">#define SYSIO_IMAP_EUPA		0x3098UL</span>

<span class="cp">#define bogon     ((unsigned long) -1)</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysio_irq_offsets</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* SBUS Slot 0 --&gt; 3, level 1 --&gt; 7 */</span>
	<span class="n">SYSIO_IMAP_SLOT0</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT0</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT0</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT0</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SLOT0</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT0</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT0</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT0</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SLOT1</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT1</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT1</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT1</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SLOT1</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT1</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT1</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT1</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SLOT2</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT2</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT2</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT2</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SLOT2</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT2</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT2</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT2</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SLOT3</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT3</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT3</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT3</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SLOT3</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT3</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT3</span><span class="p">,</span> <span class="n">SYSIO_IMAP_SLOT3</span><span class="p">,</span>

	<span class="cm">/* Onboard devices (not relevant/used on SunFire). */</span>
	<span class="n">SYSIO_IMAP_SCSI</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_ETH</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_BPP</span><span class="p">,</span>
	<span class="n">bogon</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_AUDIO</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_PFAIL</span><span class="p">,</span>
	<span class="n">bogon</span><span class="p">,</span>
	<span class="n">bogon</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_KMS</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_FLPY</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SHW</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_KBD</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_MS</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SER</span><span class="p">,</span>
	<span class="n">bogon</span><span class="p">,</span>
	<span class="n">bogon</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_TIM0</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_TIM1</span><span class="p">,</span>
	<span class="n">bogon</span><span class="p">,</span>
	<span class="n">bogon</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_UE</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_CE</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_SBERR</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_PMGMT</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_GFX</span><span class="p">,</span>
	<span class="n">SYSIO_IMAP_EUPA</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#undef bogon</span>

<span class="cp">#define NUM_SYSIO_OFFSETS ARRAY_SIZE(sysio_irq_offsets)</span>

<span class="cm">/* Convert Interrupt Mapping register pointer to associated</span>
<span class="cm"> * Interrupt Clear register pointer, SYSIO specific version.</span>
<span class="cm"> */</span>
<span class="cp">#define SYSIO_ICLR_UNUSED0	0x3400UL</span>
<span class="cp">#define SYSIO_ICLR_SLOT0	0x3408UL</span>
<span class="cp">#define SYSIO_ICLR_SLOT1	0x3448UL</span>
<span class="cp">#define SYSIO_ICLR_SLOT2	0x3488UL</span>
<span class="cp">#define SYSIO_ICLR_SLOT3	0x34c8UL</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sysio_imap_to_iclr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">SYSIO_ICLR_UNUSED0</span> <span class="o">-</span> <span class="n">SYSIO_IMAP_SLOT0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">imap</span> <span class="o">+</span> <span class="n">diff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sbus_of_build_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imap</span><span class="p">,</span> <span class="n">iclr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sbus_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sbus_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ino</span> <span class="o">&amp;=</span> <span class="mh">0x3f</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="p">)</span>
		<span class="n">sbus_slot</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">which_io</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="mh">0x20</span><span class="p">)</span>
		<span class="n">ino</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sbus_slot</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">imap</span> <span class="o">=</span> <span class="n">sysio_irq_offsets</span><span class="p">[</span><span class="n">ino</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">imap</span> <span class="o">==</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;get_irq_translations: Bad SYSIO INO[%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">ino</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">imap</span> <span class="o">+=</span> <span class="n">reg_base</span><span class="p">;</span>

	<span class="cm">/* SYSIO inconsistency.  For external SLOTS, we have to select</span>
<span class="cm">	 * the right ICLR register based upon the lower SBUS irq level</span>
<span class="cm">	 * bits.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iclr</span> <span class="o">=</span> <span class="n">sysio_imap_to_iclr</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sbus_level</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">sbus_slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">iclr</span> <span class="o">=</span> <span class="n">reg_base</span> <span class="o">+</span> <span class="n">SYSIO_ICLR_SLOT0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">iclr</span> <span class="o">=</span> <span class="n">reg_base</span> <span class="o">+</span> <span class="n">SYSIO_ICLR_SLOT1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">iclr</span> <span class="o">=</span> <span class="n">reg_base</span> <span class="o">+</span> <span class="n">SYSIO_ICLR_SLOT2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">iclr</span> <span class="o">=</span> <span class="n">reg_base</span> <span class="o">+</span> <span class="n">SYSIO_ICLR_SLOT3</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">iclr</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sbus_level</span> <span class="o">-</span> <span class="mi">1UL</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8UL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">build_irq</span><span class="p">(</span><span class="n">sbus_level</span><span class="p">,</span> <span class="n">iclr</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sbus_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_irq_controller</span><span class="p">));</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">irq_build</span> <span class="o">=</span> <span class="n">sbus_of_build_irq</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SBUS */</span><span class="cp"></span>


<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">central_build_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">central_dp</span> <span class="o">=</span> <span class="n">_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">central_op</span> <span class="o">=</span> <span class="n">of_find_device_by_node</span><span class="p">(</span><span class="n">central_dp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imap</span><span class="p">,</span> <span class="n">iclr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eeprom&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">central_op</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;zs&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">central_op</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;clock-board&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">central_op</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ino</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">imap</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="mh">0x00UL</span><span class="p">;</span>
	<span class="n">iclr</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="mh">0x10UL</span><span class="p">;</span>

	<span class="cm">/* Set the INO state to idle, and disable.  */</span>
	<span class="n">upa_writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iclr</span><span class="p">);</span>
	<span class="n">upa_readl</span><span class="p">(</span><span class="n">iclr</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">upa_readl</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x80000000</span><span class="p">;</span>
	<span class="n">upa_writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">build_irq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iclr</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">central_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_irq_controller</span><span class="p">));</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">irq_build</span> <span class="o">=</span> <span class="n">central_build_irq</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">dp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">irq_trans</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_trans</span> <span class="n">__initdata</span> <span class="n">pci_irq_trans_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;SUNW,sabre&quot;</span><span class="p">,</span> <span class="n">sabre_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;pci108e,a000&quot;</span><span class="p">,</span> <span class="n">sabre_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;pci108e,a001&quot;</span><span class="p">,</span> <span class="n">sabre_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SUNW,psycho&quot;</span><span class="p">,</span> <span class="n">psycho_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;pci108e,8000&quot;</span><span class="p">,</span> <span class="n">psycho_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SUNW,schizo&quot;</span><span class="p">,</span> <span class="n">schizo_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;pci108e,8001&quot;</span><span class="p">,</span> <span class="n">schizo_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SUNW,schizo+&quot;</span><span class="p">,</span> <span class="n">schizo_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;pci108e,8002&quot;</span><span class="p">,</span> <span class="n">schizo_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SUNW,tomatillo&quot;</span><span class="p">,</span> <span class="n">tomatillo_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;pci108e,a801&quot;</span><span class="p">,</span> <span class="n">tomatillo_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SUNW,sun4v-pci&quot;</span><span class="p">,</span> <span class="n">pci_sun4v_irq_trans_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;pciex108e,80f0&quot;</span><span class="p">,</span> <span class="n">fire_irq_trans_init</span> <span class="p">},</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sun4v_vdev_irq_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devino</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="n">_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">devhandle</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sun4v_build_irq</span><span class="p">(</span><span class="n">devhandle</span><span class="p">,</span> <span class="n">devino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sun4v_vdev_irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span> <span class="o">=</span> <span class="n">prom_early_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_irq_controller</span><span class="p">));</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">irq_build</span> <span class="o">=</span> <span class="n">sun4v_vdev_irq_build</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">irq_trans</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
		<span class="p">((</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32UL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">irq_trans_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="n">model</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;model&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">model</span><span class="p">)</span>
		<span class="n">model</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;compatible&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pci_irq_trans_table</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">irq_trans</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci_irq_trans_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SBUS</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;sbus&quot;</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;sbi&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sbus_irq_trans_init</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;fhc&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;central&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">central_irq_trans_init</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;virtual-devices&quot;</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;niu&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sun4v_vdev_irq_trans_init</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
