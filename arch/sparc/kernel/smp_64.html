<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › kernel › smp_64.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smp_64.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* smp.c: Sparc64 SMP support.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1997, 2007, 2008 David S. Miller (davem@davemloft.net)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/head.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/cpudata.h&gt;</span>
<span class="cp">#include &lt;asm/hvtramp.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/timer.h&gt;</span>

<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/oplib.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/starfire.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/mdesc.h&gt;</span>
<span class="cp">#include &lt;asm/ldc.h&gt;</span>
<span class="cp">#include &lt;asm/hypervisor.h&gt;</span>
<span class="cp">#include &lt;asm/pcr.h&gt;</span>

<span class="cp">#include &quot;cpumap.h&quot;</span>

<span class="kt">int</span> <span class="n">sparc64_multi_core</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_t</span><span class="p">,</span> <span class="n">cpu_sibling_map</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_MASK_NONE</span><span class="p">;</span>
<span class="n">cpumask_t</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__read_mostly</span> <span class="o">=</span>
	<span class="p">{</span> <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">NR_CPUS</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CPU_MASK_NONE</span> <span class="p">};</span>

<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_core_map</span><span class="p">);</span>

<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">smp_commenced_mask</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">smp_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;State:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;CPU%d:</span><span class="se">\t\t</span><span class="s">online</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_bogo</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			   <span class="s">&quot;Cpu%dClkTck</span><span class="se">\t</span><span class="s">: %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">i</span><span class="p">,</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">clock_tick</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">setup_sparc64_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">callin_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">smp_callin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpuid</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>

	<span class="n">__local_per_cpu_offset</span> <span class="o">=</span> <span class="n">__per_cpu_offset</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="n">sun4v_ktsb_register</span><span class="p">();</span>

	<span class="n">__flush_tlb_all</span><span class="p">();</span>

	<span class="n">setup_sparc64_timer</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cheetah_pcache_forced_on</span><span class="p">)</span>
		<span class="n">cheetah_enable_pcache</span><span class="p">();</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">callin_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;membar #Sync</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;flush  %%g6&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear this or we will die instantly when we</span>
<span class="cm">	 * schedule back to this idler...</span>
<span class="cm">	 */</span>
	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">new_child</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Attach to the address space of init_task. */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>

	<span class="cm">/* inform the notifiers about the new cpu */</span>
	<span class="n">notify_cpu_starting</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_commenced_mask</span><span class="p">))</span>
		<span class="n">rmb</span><span class="p">();</span>

	<span class="n">ipi_call_lock_irq</span><span class="p">();</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpuid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">ipi_call_unlock_irq</span><span class="p">();</span>

	<span class="cm">/* idle thread is expected to have preempt disabled */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cpu_panic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU[%d]: Returns from cpu_idle!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SMP bolixed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This tick register synchronization scheme is taken entirely from</span>
<span class="cm"> * the ia64 port, see arch/ia64/kernel/smpboot.c for details and credit.</span>
<span class="cm"> *</span>
<span class="cm"> * The only change I&#39;ve made is to rework it so that the master</span>
<span class="cm"> * initiates the synchonization instead of the slave. -DaveM</span>
<span class="cm"> */</span>

<span class="cp">#define MASTER	0</span>
<span class="cp">#define SLAVE	(SMP_CACHE_BYTES/sizeof(unsigned long))</span>

<span class="cp">#define NUM_ROUNDS	64	</span><span class="cm">/* magic value */</span><span class="cp"></span>
<span class="cp">#define NUM_ITERS	5	</span><span class="cm">/* likewise */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">itc_sync_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">go</span><span class="p">[</span><span class="n">SLAVE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="cp">#define DEBUG_TICK_SYNC	0</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">get_delta</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">best_t0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">best_t1</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="n">best_tm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tcenter</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">tm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ITERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t0</span> <span class="o">=</span> <span class="n">tick_ops</span><span class="o">-&gt;</span><span class="n">get_tick</span><span class="p">();</span>
		<span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">membar_safe</span><span class="p">(</span><span class="s">&quot;#StoreLoad&quot;</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tm</span> <span class="o">=</span> <span class="n">go</span><span class="p">[</span><span class="n">SLAVE</span><span class="p">]))</span>
			<span class="n">rmb</span><span class="p">();</span>
		<span class="n">go</span><span class="p">[</span><span class="n">SLAVE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">t1</span> <span class="o">=</span> <span class="n">tick_ops</span><span class="o">-&gt;</span><span class="n">get_tick</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span> <span class="o">&lt;</span> <span class="n">best_t1</span> <span class="o">-</span> <span class="n">best_t0</span><span class="p">)</span>
			<span class="n">best_t0</span> <span class="o">=</span> <span class="n">t0</span><span class="p">,</span> <span class="n">best_t1</span> <span class="o">=</span> <span class="n">t1</span><span class="p">,</span> <span class="n">best_tm</span> <span class="o">=</span> <span class="n">tm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="n">best_t1</span> <span class="o">-</span> <span class="n">best_t0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">best_tm</span> <span class="o">-</span> <span class="n">best_t0</span><span class="p">;</span>

	<span class="cm">/* average best_t0 and best_t1 without overflow: */</span>
	<span class="n">tcenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_t0</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">best_t1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">best_t0</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">best_t1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">tcenter</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tcenter</span> <span class="o">-</span> <span class="n">best_tm</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_synchronize_tick_client</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">adjust_latency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="n">master_time_stamp</span><span class="p">;</span>
<span class="cp">#if DEBUG_TICK_SYNC</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">rt</span><span class="p">;</span>	<span class="cm">/* roundtrip time */</span>
		<span class="kt">long</span> <span class="n">master</span><span class="p">;</span>	<span class="cm">/* master&#39;s timestamp */</span>
		<span class="kt">long</span> <span class="n">diff</span><span class="p">;</span>	<span class="cm">/* difference between midpoint and master&#39;s timestamp */</span>
		<span class="kt">long</span> <span class="n">lat</span><span class="p">;</span>	<span class="cm">/* estimate of itc adjustment latency */</span>
	<span class="p">}</span> <span class="n">t</span><span class="p">[</span><span class="n">NUM_ROUNDS</span><span class="p">];</span>
<span class="cp">#endif</span>

	<span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">])</span>
		<span class="n">rmb</span><span class="p">();</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ROUNDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">get_delta</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master_time_stamp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* let&#39;s lock on to this... */</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">adjust_latency</span> <span class="o">+=</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span>
					<span class="n">adj</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span> <span class="o">+</span> <span class="n">adjust_latency</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">adj</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span>

				<span class="n">tick_ops</span><span class="o">-&gt;</span><span class="n">add_tick</span><span class="p">(</span><span class="n">adj</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#if DEBUG_TICK_SYNC</span>
			<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
			<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">master</span> <span class="o">=</span> <span class="n">master_time_stamp</span><span class="p">;</span>
			<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">diff</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lat</span> <span class="o">=</span> <span class="n">adjust_latency</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

<span class="cp">#if DEBUG_TICK_SYNC</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ROUNDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;rt=%5ld master=%5ld diff=%5ld adjlat=%5ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rt</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">master</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">diff</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lat</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU %d: synchronized TICK with master CPU &quot;</span>
	       <span class="s">&quot;(last diff %ld cycles, maxerr %lu cycles)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">delta</span><span class="p">,</span> <span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_start_sync_tick_client</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_synchronize_one_tick</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">smp_start_sync_tick_client</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* wait for client to be ready */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">])</span>
		<span class="n">rmb</span><span class="p">();</span>

	<span class="cm">/* now let the client proceed into his loop */</span>
	<span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">membar_safe</span><span class="p">(</span><span class="s">&quot;#StoreLoad&quot;</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">itc_sync_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ROUNDS</span><span class="o">*</span><span class="n">NUM_ITERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">])</span>
				<span class="n">rmb</span><span class="p">();</span>
			<span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="n">go</span><span class="p">[</span><span class="n">SLAVE</span><span class="p">]</span> <span class="o">=</span> <span class="n">tick_ops</span><span class="o">-&gt;</span><span class="n">get_tick</span><span class="p">();</span>
			<span class="n">membar_safe</span><span class="p">(</span><span class="s">&quot;#StoreLoad&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">itc_sync_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_SUN_LDOMS) &amp;&amp; defined(CONFIG_HOTPLUG_CPU)</span>
<span class="cm">/* XXX Put this in some common place. XXX */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kimage_addr_to_ra</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kern_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">ldom_startcpu_cpuid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thread_reg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">descrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sparc64_ttable_tl0</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kern_locked_tte_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hvtramp_descr</span> <span class="o">*</span><span class="n">hdesc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trampoline_ra</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trap_per_cpu</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tte_vaddr</span><span class="p">,</span> <span class="n">tte_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hv_err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hdesc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdesc</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvtramp_mapping</span><span class="p">)</span> <span class="o">*</span>
			 <span class="n">num_kernel_image_mappings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdesc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ldom_startcpu_cpuid: Cannot allocate &quot;</span>
		       <span class="s">&quot;hvtramp_descr.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">descrp</span> <span class="o">=</span> <span class="n">hdesc</span><span class="p">;</span>

	<span class="n">hdesc</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">hdesc</span><span class="o">-&gt;</span><span class="n">num_mappings</span> <span class="o">=</span> <span class="n">num_kernel_image_mappings</span><span class="p">;</span>

	<span class="n">tb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trap_block</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="n">hdesc</span><span class="o">-&gt;</span><span class="n">fault_info_va</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">fault_info</span><span class="p">;</span>
	<span class="n">hdesc</span><span class="o">-&gt;</span><span class="n">fault_info_pa</span> <span class="o">=</span> <span class="n">kimage_addr_to_ra</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">fault_info</span><span class="p">);</span>

	<span class="n">hdesc</span><span class="o">-&gt;</span><span class="n">thread_reg</span> <span class="o">=</span> <span class="n">thread_reg</span><span class="p">;</span>

	<span class="n">tte_vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">KERNBASE</span><span class="p">;</span>
	<span class="n">tte_data</span> <span class="o">=</span> <span class="n">kern_locked_tte_data</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdesc</span><span class="o">-&gt;</span><span class="n">num_mappings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hdesc</span><span class="o">-&gt;</span><span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">tte_vaddr</span><span class="p">;</span>
		<span class="n">hdesc</span><span class="o">-&gt;</span><span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tte</span>   <span class="o">=</span> <span class="n">tte_data</span><span class="p">;</span>
		<span class="n">tte_vaddr</span> <span class="o">+=</span> <span class="mh">0x400000</span><span class="p">;</span>
		<span class="n">tte_data</span>  <span class="o">+=</span> <span class="mh">0x400000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trampoline_ra</span> <span class="o">=</span> <span class="n">kimage_addr_to_ra</span><span class="p">(</span><span class="n">hv_cpu_startup</span><span class="p">);</span>

	<span class="n">hv_err</span> <span class="o">=</span> <span class="n">sun4v_cpu_start</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">trampoline_ra</span><span class="p">,</span>
				 <span class="n">kimage_addr_to_ra</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sparc64_ttable_tl0</span><span class="p">),</span>
				 <span class="n">__pa</span><span class="p">(</span><span class="n">hdesc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hv_err</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ldom_startcpu_cpuid: sun4v_cpu_start() &quot;</span>
		       <span class="s">&quot;gives error %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hv_err</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sparc64_cpu_startup</span><span class="p">;</span>

<span class="cm">/* The OBP cpu startup callback truncates the 3rd arg cookie to</span>
<span class="cm"> * 32-bits (I think) so to be safe we have it read the pointer</span>
<span class="cm"> * contained here so we work on &gt;4GB machines. -DaveM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">cpu_new_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">smp_boot_one_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span> <span class="o">=</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">sparc64_cpu_startup</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span> <span class="o">=</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">cpu_new_thread</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">descr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">callin_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_new_thread</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_SUN_LDOMS) &amp;&amp; defined(CONFIG_HOTPLUG_CPU)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ldom_domaining_enabled</span><span class="p">)</span>
			<span class="n">ldom_startcpu_cpuid</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span>
					    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cpu_new_thread</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">descr</span><span class="p">);</span>
		<span class="k">else</span>
<span class="cp">#endif</span>
			<span class="n">prom_startcpu_cpuid</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">of_find_node_by_cpuid</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="n">prom_startcpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">phandle</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">50000</span><span class="p">;</span> <span class="n">timeout</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">callin_flag</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">callin_flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Processor %d is stuck.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpu_new_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">descr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spitfire_xcall_helper</span><span class="p">(</span><span class="n">u64</span> <span class="n">data0</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data1</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data2</span><span class="p">,</span> <span class="n">u64</span> <span class="n">pstate</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">result</span><span class="p">,</span> <span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stuck</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_is_starfire</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* map to real upaid */</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="p">(((</span><span class="n">cpu</span> <span class="o">&amp;</span> <span class="mh">0x3c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">cpu</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">cpu</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x70</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="cm">/* Ok, this is the real Spitfire Errata #54.</span>
<span class="cm">	 * One must read back from a UDB internal register</span>
<span class="cm">	 * after writes to the UDB interrupt dispatch, but</span>
<span class="cm">	 * before the membar Sync for that write.</span>
<span class="cm">	 * So we use the high UDB control register (ASI 0x7f,</span>
<span class="cm">	 * ADDR 0x20) for the dummy read. -DaveM</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;wrpr	%1, %2, %%pstate</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;stxa	%4, [%0] %3</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;stxa	%5, [%0+%8] %3</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;add	%0, %8, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;stxa	%6, [%0+%8] %3</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;membar	#Sync</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;stxa	%%g0, [%7] %3</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;membar	#Sync</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;mov	0x20, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;ldxa	[%%g1] 0x7f, %%g0</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="s">&quot;membar	#Sync&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">PSTATE_IE</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_INTR_W</span><span class="p">),</span>
	  <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">data0</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">data1</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">data2</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">target</span><span class="p">),</span>
	  <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="mh">0x10</span><span class="p">),</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="o">:</span> <span class="s">&quot;g1&quot;</span><span class="p">);</span>

	<span class="cm">/* NOTE: PSTATE_IE is still clear. */</span>
	<span class="n">stuck</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;ldxa [%%g0] %1, %0&quot;</span>
			<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="o">:</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_INTR_DISPATCH_STAT</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;wrpr %0, 0x0, %%pstate&quot;</span>
					     <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">stuck</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stuck</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">);</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;wrpr %0, 0x0, %%pstate&quot;</span>
			     <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stuck</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU[%d]: mondo stuckage result[%016llx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spitfire_xcall_deliver</span><span class="p">(</span><span class="k">struct</span> <span class="n">trap_per_cpu</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">mondo</span><span class="p">,</span> <span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">cpu_list</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pstate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;rdpr %%pstate, %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">));</span>
	<span class="n">cpu_list</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_list_pa</span><span class="p">);</span>
	<span class="n">mondo</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_mondo_block_pa</span><span class="p">);</span>
	<span class="n">data0</span> <span class="o">=</span> <span class="n">mondo</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">data1</span> <span class="o">=</span> <span class="n">mondo</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">data2</span> <span class="o">=</span> <span class="n">mondo</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spitfire_xcall_helper</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">pstate</span><span class="p">,</span> <span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* Cheetah now allows to send the whole 64-bytes of data in the interrupt</span>
<span class="cm"> * packet, but we have no use for that.  However we do take advantage of</span>
<span class="cm"> * the new pipelining feature (ie. dispatch to multiple cpus simultaneously).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cheetah_xcall_deliver</span><span class="p">(</span><span class="k">struct</span> <span class="n">trap_per_cpu</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nack_busy_id</span><span class="p">,</span> <span class="n">is_jbus</span><span class="p">,</span> <span class="n">need_more</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">mondo</span><span class="p">,</span> <span class="n">pstate</span><span class="p">,</span> <span class="n">ver</span><span class="p">,</span> <span class="n">busy_mask</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">cpu_list</span><span class="p">;</span>

	<span class="n">cpu_list</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_list_pa</span><span class="p">);</span>
	<span class="n">mondo</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_mondo_block_pa</span><span class="p">);</span>

	<span class="cm">/* Unfortunately, someone at Sun had the brilliant idea to make the</span>
<span class="cm">	 * busy/nack fields hard-coded by ITID number for this Ultra-III</span>
<span class="cm">	 * derivative processor.</span>
<span class="cm">	 */</span>
	<span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;rdpr %%ver, %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">ver</span><span class="p">));</span>
	<span class="n">is_jbus</span> <span class="o">=</span> <span class="p">((</span><span class="n">ver</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">==</span> <span class="n">__JALAPENO_ID</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">ver</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">==</span> <span class="n">__SERRANO_ID</span><span class="p">);</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;rdpr %%pstate, %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">));</span>

<span class="nl">retry:</span>
	<span class="n">need_more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;wrpr %0, %1, %%pstate</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">PSTATE_IE</span><span class="p">));</span>

	<span class="cm">/* Setup the dispatch data registers. */</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;stxa	%0, [%3] %6</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;stxa	%1, [%4] %6</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;stxa	%2, [%5] %6</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;membar	#Sync</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="o">:</span> <span class="cm">/* no outputs */</span>
			     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">mondo</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">mondo</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">mondo</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
			       <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="mh">0x40</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="mh">0x50</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="mh">0x60</span><span class="p">),</span>
			       <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_INTR_W</span><span class="p">));</span>

	<span class="n">nack_busy_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">busy_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">target</span><span class="p">,</span> <span class="n">nr</span><span class="p">;</span>

			<span class="n">nr</span> <span class="o">=</span> <span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x70</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_jbus</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">busy_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">target</span> <span class="o">|=</span> <span class="p">(</span><span class="n">nack_busy_id</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
				<span class="n">busy_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1UL</span> <span class="o">&lt;&lt;</span>
					      <span class="p">(</span><span class="n">nack_busy_id</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
				<span class="s">&quot;stxa	%%g0, [%0] %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
				<span class="s">&quot;membar	#Sync</span><span class="se">\n\t</span><span class="s">&quot;</span>
				<span class="o">:</span> <span class="cm">/* no outputs */</span>
				<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_INTR_W</span><span class="p">));</span>
			<span class="n">nack_busy_id</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nack_busy_id</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">need_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Now, poll for completion. */</span>
	<span class="p">{</span>
		<span class="n">u64</span> <span class="n">dispatch_stat</span><span class="p">,</span> <span class="n">nack_mask</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">stuck</span><span class="p">;</span>

		<span class="n">stuck</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">*</span> <span class="n">nack_busy_id</span><span class="p">;</span>
		<span class="n">nack_mask</span> <span class="o">=</span> <span class="n">busy_mask</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;ldxa	[%%g0] %1, %0&quot;</span>
					     <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dispatch_stat</span><span class="p">)</span>
					     <span class="o">:</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_INTR_DISPATCH_STAT</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dispatch_stat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">busy_mask</span> <span class="o">|</span> <span class="n">nack_mask</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;wrpr %0, 0x0, %%pstate&quot;</span>
						     <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">need_more</span><span class="p">))</span> <span class="p">{</span>
					<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
							<span class="k">continue</span><span class="p">;</span>
						<span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
						<span class="n">this_cnt</span><span class="o">++</span><span class="p">;</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">this_cnt</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span>
							<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">stuck</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dispatch_stat</span> <span class="o">&amp;</span> <span class="n">busy_mask</span><span class="p">);</span>

		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;wrpr %0, 0x0, %%pstate&quot;</span>
				     <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dispatch_stat</span> <span class="o">&amp;</span> <span class="n">busy_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Busy bits will not clear, continue instead</span>
<span class="cm">			 * of freezing up on this cpu.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU[%d]: mondo stuckage result[%016llx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">dispatch_stat</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_busy_nack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Delay some random time with interrupts enabled</span>
<span class="cm">			 * to prevent deadlock.</span>
<span class="cm">			 */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nack_busy_id</span><span class="p">);</span>

			<span class="cm">/* Clear out the mask bits for cpus which did not</span>
<span class="cm">			 * NACK us.</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u64</span> <span class="n">check_mask</span><span class="p">,</span> <span class="n">nr</span><span class="p">;</span>

				<span class="n">nr</span> <span class="o">=</span> <span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">is_jbus</span><span class="p">)</span>
					<span class="n">check_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x2UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nr</span><span class="p">));</span>
				<span class="k">else</span>
					<span class="n">check_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x2UL</span> <span class="o">&lt;&lt;</span>
						      <span class="n">this_busy_nack</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">dispatch_stat</span> <span class="o">&amp;</span> <span class="n">check_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
				<span class="n">this_busy_nack</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">this_busy_nack</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Multi-cpu list version.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hypervisor_xcall_deliver</span><span class="p">(</span><span class="k">struct</span> <span class="n">trap_per_cpu</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="n">prev_sent</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">saw_cpu_error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">cpu_list</span><span class="p">;</span>

	<span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">cpu_list</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_list_pa</span><span class="p">);</span>

	<span class="n">saw_cpu_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">prev_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">forward_progress</span><span class="p">,</span> <span class="n">n_sent</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">sun4v_cpu_mondo_send</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span>
					      <span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_list_pa</span><span class="p">,</span>
					      <span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_mondo_block_pa</span><span class="p">);</span>

		<span class="cm">/* HV_EOK means all cpus received the xcall, we&#39;re done.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">HV_EOK</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* First, see if we made any forward progress.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The hypervisor indicates successful sends by setting</span>
<span class="cm">		 * cpu list entries to the value 0xffff.</span>
<span class="cm">		 */</span>
		<span class="n">n_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">))</span>
				<span class="n">n_sent</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">forward_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_sent</span> <span class="o">&gt;</span> <span class="n">prev_sent</span><span class="p">)</span>
			<span class="n">forward_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">prev_sent</span> <span class="o">=</span> <span class="n">n_sent</span><span class="p">;</span>

		<span class="cm">/* If we get a HV_ECPUERROR, then one or more of the cpus</span>
<span class="cm">		 * in the list are in error state.  Use the cpu_state()</span>
<span class="cm">		 * hypervisor call to find out which cpus are in error state.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">HV_ECPUERROR</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">long</span> <span class="n">err</span><span class="p">;</span>
				<span class="n">u16</span> <span class="n">cpu</span><span class="p">;</span>

				<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">err</span> <span class="o">=</span> <span class="n">sun4v_cpu_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">HV_CPU_STATE_ERROR</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">saw_cpu_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
					<span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">HV_EWOULDBLOCK</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fatal_mondo_error</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t bother rewriting the CPU list, just leave the</span>
<span class="cm">		 * 0xffff and non-0xffff entries in there and the</span>
<span class="cm">		 * hypervisor will do the right thing.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Only advance timeout state if we didn&#39;t make any</span>
<span class="cm">		 * forward progress.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">forward_progress</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">fatal_mondo_timeout</span><span class="p">;</span>

			<span class="cm">/* Delay a little bit to let other cpus catch up</span>
<span class="cm">			 * on their cpu mondo queue work.</span>
<span class="cm">			 */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">saw_cpu_error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fatal_mondo_cpu_error</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">fatal_mondo_cpu_error:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;CPU[%d]: SUN4V mondo cpu error, some target cpus &quot;</span>
	       <span class="s">&quot;(including %d) were in error state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">this_cpu</span><span class="p">,</span> <span class="n">saw_cpu_error</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">fatal_mondo_timeout:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;CPU[%d]: SUN4V mondo timeout, no forward &quot;</span>
	       <span class="s">&quot; progress after %d retries.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">this_cpu</span><span class="p">,</span> <span class="n">retries</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">dump_cpu_list_and_out</span><span class="p">;</span>

<span class="nl">fatal_mondo_error:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;CPU[%d]: Unexpected SUN4V mondo error %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">this_cpu</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;CPU[%d]: Args were cnt(%d) cpulist_pa(%lx) &quot;</span>
	       <span class="s">&quot;mondo_block_pa(%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">this_cpu</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_list_pa</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_mondo_block_pa</span><span class="p">);</span>

<span class="nl">dump_cpu_list_and_out:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;CPU[%d]: CPU list [ &quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%u &quot;</span><span class="p">,</span> <span class="n">cpu_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">xcall_deliver_impl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">trap_per_cpu</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xcall_deliver</span><span class="p">(</span><span class="n">u64</span> <span class="n">data0</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data1</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data2</span><span class="p">,</span> <span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trap_per_cpu</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">cpu_list</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">mondo</span><span class="p">;</span>

	<span class="cm">/* We have to do this whole thing with interrupts fully disabled.</span>
<span class="cm">	 * Otherwise if we send an xcall from interrupt context it will</span>
<span class="cm">	 * corrupt both our mondo block and cpu list state.</span>
<span class="cm">	 *</span>
<span class="cm">	 * One consequence of this is that we cannot use timeout mechanisms</span>
<span class="cm">	 * that depend upon interrupts being delivered locally.  So, for</span>
<span class="cm">	 * example, we cannot sample jiffies and expect it to advance.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Fortunately, udelay() uses %stick/%tick so we can use that.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">tb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trap_block</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">];</span>

	<span class="n">mondo</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_mondo_block_pa</span><span class="p">);</span>
	<span class="n">mondo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data0</span><span class="p">;</span>
	<span class="n">mondo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data1</span><span class="p">;</span>
	<span class="n">mondo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">data2</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">cpu_list</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_list_pa</span><span class="p">);</span>

	<span class="cm">/* Setup the initial cpu list.  */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">this_cpu</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cpu_list</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
		<span class="n">xcall_deliver_impl</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send cross call to all processors mentioned in MASK_P</span>
<span class="cm"> * except self.  Really, there are only two cases currently,</span>
<span class="cm"> * &quot;cpu_online_mask&quot; and &quot;mm_cpumask(mm)&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_cross_call_masked</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data1</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data2</span><span class="p">,</span> <span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">data0</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">ctx</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">func</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">));</span>

	<span class="n">xcall_deliver</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send cross call to all processors except self. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_cross_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data1</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_cross_call_masked</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_sync_tick</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_start_sync_tick_client</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xcall_deliver</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">xcall_sync_tick</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		      <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_call_function</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">arch_send_call_function_ipi_mask</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xcall_deliver</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">xcall_call_function</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_call_function_single</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">arch_send_call_function_single_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xcall_deliver</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">xcall_call_function_single</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		      <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__irq_entry</span> <span class="nf">smp_call_function_client</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_softint</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">irq</span><span class="p">);</span>
	<span class="n">generic_smp_call_function_interrupt</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__irq_entry</span> <span class="nf">smp_call_function_single_client</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_softint</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">irq</span><span class="p">);</span>
	<span class="n">generic_smp_call_function_single_interrupt</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tsb_sync</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trap_per_cpu</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trap_block</span><span class="p">[</span><span class="n">raw_smp_processor_id</span><span class="p">()];</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

	<span class="cm">/* It is not valid to test &quot;current-&gt;active_mm == mm&quot; here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The value of &quot;current&quot; is not changed atomically with</span>
<span class="cm">	 * switch_mm().  But that&#39;s OK, we just need to check the</span>
<span class="cm">	 * current cpu&#39;s trap block PGD physical address.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">pgd_paddr</span> <span class="o">==</span> <span class="n">__pa</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">))</span>
		<span class="n">tsb_context_switch</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_tsb_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_call_function_many</span><span class="p">(</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span> <span class="n">tsb_sync</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_flush_tlb_mm</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_flush_tlb_pending</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_flush_tlb_kernel_range</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_fetch_glob_regs</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_receive_signal</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_new_mmu_context_version</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_KGDB</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_kgdb_capture</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DCACHE_ALIASING_POSSIBLE</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_flush_dcache_page_cheetah</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_flush_dcache_page_spitfire</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_DCFLUSH</span>
<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">dcpage_flushes</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">dcpage_flushes_xcall</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__local_flush_dcache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DCACHE_ALIASING_POSSIBLE</span>
	<span class="n">__flush_dcache_page</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
			    <span class="p">((</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span>
		<span class="n">__flush_icache_page</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_flush_dcache_page_impl</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">this_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_DCFLUSH</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcpage_flushes</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">this_cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">this_cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__local_flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">pg_addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">u64</span> <span class="n">data0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">xcall_flush_dcache_page_spitfire</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">data0</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah</span> <span class="o">||</span> <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DCACHE_ALIASING_POSSIBLE</span>
			<span class="n">data0</span> <span class="o">=</span>	<span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">xcall_flush_dcache_page_cheetah</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xcall_deliver</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pg_addr</span><span class="p">),</span>
				      <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">pg_addr</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_DEBUG_DCFLUSH</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcpage_flushes_xcall</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_dcache_page_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pg_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">data0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_DEBUG_DCFLUSH</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcpage_flushes</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">data0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pg_addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data0</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">xcall_flush_dcache_page_spitfire</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">data0</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah</span> <span class="o">||</span> <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DCACHE_ALIASING_POSSIBLE</span>
		<span class="n">data0</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">xcall_flush_dcache_page_cheetah</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xcall_deliver</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pg_addr</span><span class="p">),</span>
			      <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">pg_addr</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_DCFLUSH</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcpage_flushes_xcall</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">__local_flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__irq_entry</span> <span class="nf">smp_new_mmu_context_version_client</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">clear_softint</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* See if we need to allocate a new TLB context because</span>
<span class="cm">	 * the version of the one we are using is now out of date.</span>
<span class="cm">	 */</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span> <span class="o">||</span> <span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">CTX_VALID</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">)))</span>
		<span class="n">get_new_mmu_context</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">load_secondary_context</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">__flush_tlb_mm</span><span class="p">(</span><span class="n">CTX_HWBITS</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">),</span>
		       <span class="n">SECONDARY_CONTEXT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_new_mmu_context_version</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_cross_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xcall_new_mmu_context_version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_KGDB</span>
<span class="kt">void</span> <span class="nf">kgdb_roundup_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_cross_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xcall_kgdb_capture</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">smp_fetch_global_regs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_cross_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xcall_fetch_glob_regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* We know that the window frames of the user have been flushed</span>
<span class="cm"> * to the stack before we get here because all callers of us</span>
<span class="cm"> * are flush_tlb_*() routines, and these run after flush_cache_*()</span>
<span class="cm"> * which performs the flushw.</span>
<span class="cm"> *</span>
<span class="cm"> * The SMP TLB coherency scheme we use works as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) mm-&gt;cpu_vm_mask is a bit mask of which cpus an address</span>
<span class="cm"> *    space has (potentially) executed on, this is the heuristic</span>
<span class="cm"> *    we use to avoid doing cross calls.</span>
<span class="cm"> *</span>
<span class="cm"> *    Also, for flushing from kswapd and also for clones, we</span>
<span class="cm"> *    use cpu_vm_mask as the list of cpus to make run the TLB.</span>
<span class="cm"> *</span>
<span class="cm"> * 2) TLB context numbers are shared globally across all processors</span>
<span class="cm"> *    in the system, this allows us to play several games to avoid</span>
<span class="cm"> *    cross calls.</span>
<span class="cm"> *</span>
<span class="cm"> *    One invariant is that when a cpu switches to a process, and</span>
<span class="cm"> *    that processes tsk-&gt;active_mm-&gt;cpu_vm_mask does not have the</span>
<span class="cm"> *    current cpu&#39;s bit set, that tlb context is flushed locally.</span>
<span class="cm"> *</span>
<span class="cm"> *    If the address space is non-shared (ie. mm-&gt;count == 1) we avoid</span>
<span class="cm"> *    cross calls when we want to flush the currently running process&#39;s</span>
<span class="cm"> *    tlb state.  This is done by clearing all cpu bits except the current</span>
<span class="cm"> *    processor&#39;s in current-&gt;mm-&gt;cpu_vm_mask and performing the</span>
<span class="cm"> *    flush locally only.  This will force any subsequent cpus which run</span>
<span class="cm"> *    this task to flush the context from the local tlb if the process</span>
<span class="cm"> *    migrates to another cpu (again).</span>
<span class="cm"> *</span>
<span class="cm"> * 3) For shared address spaces (threads) and swapping we bite the</span>
<span class="cm"> *    bullet for most cases and perform the cross call (but only to</span>
<span class="cm"> *    the cpus listed in cpu_vm_mask).</span>
<span class="cm"> *</span>
<span class="cm"> *    The performance gain from &quot;optimizing&quot; away the cross call for threads is</span>
<span class="cm"> *    questionable (in theory the big win for threads is the massive sharing of</span>
<span class="cm"> *    address space state across processors).</span>
<span class="cm"> */</span>

<span class="cm">/* This currently is only used by the hugetlb arch pre-fault</span>
<span class="cm"> * hook on UltraSPARC-III+ and later when changing the pagesize</span>
<span class="cm"> * bits of the context register for an address space.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">smp_flush_tlb_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">CTX_HWBITS</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">local_flush_and_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smp_cross_call_masked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xcall_flush_tlb_mm</span><span class="p">,</span>
			      <span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>

<span class="nl">local_flush_and_out:</span>
	<span class="n">__flush_tlb_mm</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SECONDARY_CONTEXT</span><span class="p">);</span>

	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_flush_tlb_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vaddrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">CTX_HWBITS</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">smp_cross_call_masked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xcall_flush_tlb_pending</span><span class="p">,</span>
				      <span class="n">ctx</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vaddrs</span><span class="p">,</span>
				      <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>

	<span class="n">__flush_tlb_pending</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">vaddrs</span><span class="p">);</span>

	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_flush_tlb_kernel_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">start</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">end</span>    <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_cross_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xcall_flush_tlb_kernel_range</span><span class="p">,</span>
			       <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

		<span class="n">__flush_tlb_kernel_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* CPU capture. */</span>
<span class="cm">/* #define CAPTURE_DEBUG */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xcall_capture</span><span class="p">;</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">smp_capture_depth</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">smp_capture_registry</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">penguins_are_doing_time</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">smp_capture</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">atomic_add_ret</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_capture_depth</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ncpus</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">();</span>

<span class="cp">#ifdef CAPTURE_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU[%d]: Sending penguins to jail...&quot;</span><span class="p">,</span>
		       <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="cp">#endif</span>
		<span class="n">penguins_are_doing_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_capture_registry</span><span class="p">);</span>
		<span class="n">smp_cross_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xcall_capture</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_capture_registry</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ncpus</span><span class="p">)</span>
			<span class="n">rmb</span><span class="p">();</span>
<span class="cp">#ifdef CAPTURE_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_release</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_capture_depth</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef CAPTURE_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU[%d]: Giving pardon to &quot;</span>
		       <span class="s">&quot;imprisoned penguins</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="cp">#endif</span>
		<span class="n">penguins_are_doing_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">membar_safe</span><span class="p">(</span><span class="s">&quot;#StoreLoad&quot;</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_capture_registry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Imprisoned penguins run with %pil == PIL_NORMAL_MAX, but PSTATE_IE</span>
<span class="cm"> * set, so they can service tlb flush xcalls...</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_world</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__irq_entry</span> <span class="nf">smp_penguin_jailcell</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_softint</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">irq</span><span class="p">);</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;flushw&quot;</span><span class="p">);</span>
	<span class="n">prom_world</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_capture_registry</span><span class="p">);</span>
	<span class="n">membar_safe</span><span class="p">(</span><span class="s">&quot;#StoreLoad&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">penguins_are_doing_time</span><span class="p">)</span>
		<span class="n">rmb</span><span class="p">();</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_capture_registry</span><span class="p">);</span>
	<span class="n">prom_world</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* /proc/profile writes can call this, don&#39;t __init it please. */</span>
<span class="kt">int</span> <span class="nf">setup_profiling_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">multiplier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_prepare_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">smp_prepare_boot_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_setup_processor_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span>
		<span class="n">xcall_deliver_impl</span> <span class="o">=</span> <span class="n">spitfire_xcall_deliver</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah</span> <span class="o">||</span> <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span><span class="p">)</span>
		<span class="n">xcall_deliver_impl</span> <span class="o">=</span> <span class="n">cheetah_xcall_deliver</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">xcall_deliver_impl</span> <span class="o">=</span> <span class="n">hypervisor_xcall_deliver</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">smp_fill_in_sib_core_maps</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

		<span class="n">cpumask_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_core_map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">core_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_core_map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">core_id</span> <span class="o">==</span>
			    <span class="n">cpu_data</span><span class="p">(</span><span class="n">j</span><span class="p">).</span><span class="n">core_id</span><span class="p">)</span>
				<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_core_map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

		<span class="n">cpumask_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">proc_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">proc_id</span> <span class="o">==</span>
			    <span class="n">cpu_data</span><span class="p">(</span><span class="n">j</span><span class="p">).</span><span class="n">proc_id</span><span class="p">)</span>
				<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">__cpu_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tidle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">smp_boot_one_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tidle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_commenced_mask</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="n">mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* On SUN4V, writes to %tick and %stick are</span>
<span class="cm">			 * not allowed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">!=</span> <span class="n">hypervisor</span><span class="p">)</span>
				<span class="n">smp_synchronize_one_tick</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="kt">void</span> <span class="nf">cpu_play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pstate</span><span class="p">;</span>

	<span class="n">idle_task_exit</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">trap_per_cpu</span> <span class="o">*</span><span class="n">tb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trap_block</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

		<span class="n">sun4v_cpu_qconf</span><span class="p">(</span><span class="n">HV_CPU_QUEUE_CPU_MONDO</span><span class="p">,</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">cpu_mondo_pa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sun4v_cpu_qconf</span><span class="p">(</span><span class="n">HV_CPU_QUEUE_DEVICE_MONDO</span><span class="p">,</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">dev_mondo_pa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sun4v_cpu_qconf</span><span class="p">(</span><span class="n">HV_CPU_QUEUE_RES_ERROR</span><span class="p">,</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">resum_mondo_pa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sun4v_cpu_qconf</span><span class="p">(</span><span class="n">HV_CPU_QUEUE_NONRES_ERROR</span><span class="p">,</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">nonresum_mondo_pa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_commenced_mask</span><span class="p">);</span>
	<span class="n">membar_safe</span><span class="p">(</span><span class="s">&quot;#Sync&quot;</span><span class="p">);</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;rdpr	%%pstate, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;wrpr	%0, %1, %%pstate&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">PSTATE_IE</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">barrier</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">cpuinfo_sparc</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_core_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_core_map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_core_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>

	<span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">core_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">proc_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="cm">/* Make sure no interrupts point to this cpu.  */</span>
	<span class="n">fixup_irqs</span><span class="p">();</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="n">ipi_call_lock</span><span class="p">();</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">ipi_call_unlock</span><span class="p">();</span>

	<span class="n">cpu_map_rebuild</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_commenced_mask</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_commenced_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;CPU %u didn&#39;t die...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_SUN_LDOMS)</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hv_err</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">hv_err</span> <span class="o">=</span> <span class="n">sun4v_cpu_stop</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hv_err</span> <span class="o">==</span> <span class="n">HV_EOK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sun4v_cpu_stop() fails err=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">hv_err</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_cpus_done</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pcr_arch_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_send_reschedule</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xcall_deliver</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">xcall_receive_signal</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		      <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__irq_entry</span> <span class="nf">smp_receive_signal_client</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_softint</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">irq</span><span class="p">);</span>
	<span class="n">scheduler_ipi</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* This is a nop because we capture all other cpus</span>
<span class="cm"> * anyways when making the PROM active.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">smp_send_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_alloc_bootmem - NUMA friendly alloc_bootmem wrapper for percpu</span>
<span class="cm"> * @cpu: cpu to allocate for</span>
<span class="cm"> * @size: size allocation in bytes</span>
<span class="cm"> * @align: alignment</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate @size bytes aligned at @align for cpu @cpu.  This wrapper</span>
<span class="cm"> * does the right thing for NUMA regardless of the current</span>
<span class="cm"> * configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to the allocated area on success, NULL on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">pcpu_alloc_bootmem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">MAX_DMA_ADDRESS</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NEED_MULTIPLE_NODES</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;cpu %d has no node %d or node-local memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cpu</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;per cpu data for cpu%d %lu bytes at %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">cpu</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">__alloc_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">),</span>
					   <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;per cpu data for cpu%d %lu bytes on node%d at &quot;</span>
			 <span class="s">&quot;%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">pcpu_free_bootmem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_bootmem</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pcpu_cpu_distance</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">from</span><span class="p">)</span> <span class="o">==</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">to</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">LOCAL_DISTANCE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">REMOTE_DISTANCE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">pcpu_populate_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

		<span class="n">new</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">pud_populate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

		<span class="n">new</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">pmd_populate_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_per_cpu_areas</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcpu_chosen_fc</span> <span class="o">!=</span> <span class="n">PCPU_FC_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pcpu_embed_first_chunk</span><span class="p">(</span><span class="n">PERCPU_MODULE_RESERVE</span><span class="p">,</span>
					    <span class="n">PERCPU_DYNAMIC_RESERVE</span><span class="p">,</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
					    <span class="n">pcpu_cpu_distance</span><span class="p">,</span>
					    <span class="n">pcpu_alloc_bootmem</span><span class="p">,</span>
					    <span class="n">pcpu_free_bootmem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;PERCPU: %s allocator failed (%d), &quot;</span>
				   <span class="s">&quot;falling back to page size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">pcpu_fc_names</span><span class="p">[</span><span class="n">pcpu_chosen_fc</span><span class="p">],</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pcpu_page_first_chunk</span><span class="p">(</span><span class="n">PERCPU_MODULE_RESERVE</span><span class="p">,</span>
					   <span class="n">pcpu_alloc_bootmem</span><span class="p">,</span>
					   <span class="n">pcpu_free_bootmem</span><span class="p">,</span>
					   <span class="n">pcpu_populate_pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;cannot initialize percpu area (err=%d)&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pcpu_base_addr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__per_cpu_start</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">__per_cpu_offset</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">+</span> <span class="n">pcpu_unit_offsets</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="cm">/* Setup %g5 for the boot cpu.  */</span>
	<span class="n">__local_per_cpu_offset</span> <span class="o">=</span> <span class="n">__per_cpu_offset</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="n">of_fill_in_cpu_data</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="n">mdesc_fill_in_cpu_data</span><span class="p">(</span><span class="n">cpu_all_mask</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
