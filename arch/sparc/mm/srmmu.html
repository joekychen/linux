<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › mm › srmmu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>srmmu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * srmmu.c:  SRMMU specific routines for memory management.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995 David S. Miller  (davem@caip.rutgers.edu)</span>
<span class="cm"> * Copyright (C) 1995,2002 Pete Zaitcev (zaitcev@yahoo.com)</span>
<span class="cm"> * Copyright (C) 1996 Eddie C. Dost    (ecd@skynet.be)</span>
<span class="cm"> * Copyright (C) 1997,1998 Jakub Jelinek (jj@sunsite.mff.cuni.cz)</span>
<span class="cm"> * Copyright (C) 1999,2000 Anton Blanchard (anton@samba.org)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;asm/bitext.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/vaddrs.h&gt;</span>
<span class="cp">#include &lt;asm/traps.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/mbus.h&gt;</span>
<span class="cp">#include &lt;asm/cache.h&gt;</span>
<span class="cp">#include &lt;asm/oplib.h&gt;</span>
<span class="cp">#include &lt;asm/asi.h&gt;</span>
<span class="cp">#include &lt;asm/msi.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/io-unit.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>

<span class="cm">/* Now the cpu specific definitions. */</span>
<span class="cp">#include &lt;asm/viking.h&gt;</span>
<span class="cp">#include &lt;asm/mxcc.h&gt;</span>
<span class="cp">#include &lt;asm/ross.h&gt;</span>
<span class="cp">#include &lt;asm/tsunami.h&gt;</span>
<span class="cp">#include &lt;asm/swift.h&gt;</span>
<span class="cp">#include &lt;asm/turbosparc.h&gt;</span>
<span class="cp">#include &lt;asm/leon.h&gt;</span>

<span class="cp">#include &quot;srmmu.h&quot;</span>

<span class="k">enum</span> <span class="n">mbus_module</span> <span class="n">srmmu_modtype</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hwbug_bitmask</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">vac_cache_size</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">vac_line_size</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ctx_list</span> <span class="o">*</span><span class="n">ctx_list_pool</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ctx_list</span> <span class="n">ctx_free</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ctx_list</span> <span class="n">ctx_used</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">sparc_iomap</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_valid_pfn</span><span class="p">;</span>

<span class="k">static</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">srmmu_swapper_pg_dir</span><span class="p">;</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="o">*</span><span class="n">sparc32_cachetlb_ops</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="o">*</span><span class="n">local_ops</span><span class="p">;</span>

<span class="cp">#define FLUSH_BEGIN(mm)</span>
<span class="cp">#define FLUSH_END</span>
<span class="cp">#else</span>
<span class="cp">#define FLUSH_BEGIN(mm) if ((mm)-&gt;context != NO_CONTEXT) {</span>
<span class="cp">#define FLUSH_END	}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">flush_page_for_dma_global</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">srmmu_name</span><span class="p">;</span>

<span class="n">ctxd_t</span> <span class="o">*</span><span class="n">srmmu_ctx_table_phys</span><span class="p">;</span>
<span class="k">static</span> <span class="n">ctxd_t</span> <span class="o">*</span><span class="n">srmmu_context_table</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">viking_mxcc_present</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">srmmu_context_spinlock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">is_hypersparc</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">srmmu_cache_pagetables</span><span class="p">;</span>

<span class="cm">/* these will be initialized in srmmu_nocache_calcsize() */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">srmmu_nocache_size</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">srmmu_nocache_end</span><span class="p">;</span>

<span class="cm">/* 1 bit &lt;=&gt; 256 bytes of nocache &lt;=&gt; 64 PTEs */</span>
<span class="cp">#define SRMMU_NOCACHE_BITMAP_SHIFT (PAGE_SHIFT - 4)</span>

<span class="cm">/* The context table is a nocache user with the biggest alignment needs. */</span>
<span class="cp">#define SRMMU_NOCACHE_ALIGN_MAX (sizeof(ctxd_t)*SRMMU_MAX_CONTEXTS)</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">srmmu_nocache_pool</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">srmmu_nocache_bitmap</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bit_map</span> <span class="n">srmmu_nocache_map</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">srmmu_pmd_none</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFF</span><span class="p">);</span> <span class="p">}</span>

<span class="cm">/* XXX should we hyper_flush_whole_icache here - Anton */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">srmmu_ctxd_set</span><span class="p">(</span><span class="n">ctxd_t</span> <span class="o">*</span><span class="n">ctxp</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span><span class="p">)</span>
<span class="p">{</span> <span class="n">set_pte</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ctxp</span><span class="p">,</span> <span class="p">(</span><span class="n">SRMMU_ET_PTD</span> <span class="o">|</span> <span class="p">(</span><span class="n">__nocache_pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pgdp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)));</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">pmd_set</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptp</span><span class="p">;</span>	<span class="cm">/* Physical address, shifted right by 4 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ptp</span> <span class="o">=</span> <span class="n">__nocache_pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptep</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="o">/</span><span class="n">SRMMU_REAL_PTRS_PER_PTE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_pte</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pmdp</span><span class="o">-&gt;</span><span class="n">pmdv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SRMMU_ET_PTD</span> <span class="o">|</span> <span class="n">ptp</span><span class="p">);</span>
		<span class="n">ptp</span> <span class="o">+=</span> <span class="p">(</span><span class="n">SRMMU_REAL_PTRS_PER_PTE</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pmd_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptp</span><span class="p">;</span>	<span class="cm">/* Physical address, shifted right by 4 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ptp</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>	<span class="cm">/* watch for overflow */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="o">/</span><span class="n">SRMMU_REAL_PTRS_PER_PTE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_pte</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pmdp</span><span class="o">-&gt;</span><span class="n">pmdv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SRMMU_ET_PTD</span> <span class="o">|</span> <span class="n">ptp</span><span class="p">);</span>
		<span class="n">ptp</span> <span class="o">+=</span> <span class="p">(</span><span class="n">SRMMU_REAL_PTRS_PER_PTE</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Find an entry in the third-level page table.. */</span> 
<span class="n">pte_t</span> <span class="o">*</span><span class="nf">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">__nocache_va</span><span class="p">((</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">pmdv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">SRMMU_PTD_PMASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pte</span> <span class="o">+</span>
	    <span class="p">((</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTRS_PER_PTE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * size: bytes to allocate in the nocache area.</span>
<span class="cm"> * align: bytes, number to align at.</span>
<span class="cm"> * Returns the virtual address of the allocated area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__srmmu_get_nocache</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Size 0x%x too small for nocache request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Size 0x%x unaligned int nocache request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">align</span> <span class="o">&gt;</span> <span class="n">SRMMU_NOCACHE_ALIGN_MAX</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">bit_map_string_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_nocache_map</span><span class="p">,</span>
		       			<span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">,</span>
					<span class="n">align</span> <span class="o">&gt;&gt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;srmmu: out of nocache %d: %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">srmmu_nocache_size</span><span class="p">,</span>
		    <span class="n">srmmu_nocache_map</span><span class="p">.</span><span class="n">used</span> <span class="o">&lt;&lt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">SRMMU_NOCACHE_VADDR</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">srmmu_get_nocache</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">__srmmu_get_nocache</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">srmmu_free_nocache</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">SRMMU_NOCACHE_VADDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Vaddr %lx is smaller than nocache base 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">vaddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">SRMMU_NOCACHE_VADDR</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span><span class="o">+</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">srmmu_nocache_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Vaddr %lx is bigger than nocache end 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">vaddr</span><span class="p">,</span> <span class="n">srmmu_nocache_end</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Size 0x%x is not a power of 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Size 0x%x is too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Vaddr %lx is not aligned to size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">-</span> <span class="n">SRMMU_NOCACHE_VADDR</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">;</span>

	<span class="n">bit_map_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_nocache_map</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">srmmu_early_allocate_ptable_skeleton</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">probe_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>	<span class="cm">/* in fault.c */</span>

<span class="cm">/*</span>
<span class="cm"> * Reserve nocache dynamically proportionally to the amount of</span>
<span class="cm"> * system RAM. -- Tomas Szepe &lt;szepe@pinerecords.com&gt;, June 2002</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">srmmu_nocache_calcsize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysmemavail</span> <span class="o">=</span> <span class="n">probe_memory</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">srmmu_nocache_npages</span><span class="p">;</span>

	<span class="n">srmmu_nocache_npages</span> <span class="o">=</span>
		<span class="n">sysmemavail</span> <span class="o">/</span> <span class="n">SRMMU_NOCACHE_ALCRATIO</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">256</span><span class="p">;</span>

 <span class="cm">/* P3 XXX The 4x overuse: corroborated by /proc/meminfo. */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>if (srmmu<em>nocache</em>npages &lt; 256) srmmu<em>nocache</em>npages = 256;</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">srmmu_nocache_npages</span> <span class="o">&lt;</span> <span class="n">SRMMU_MIN_NOCACHE_PAGES</span><span class="p">)</span>
		<span class="n">srmmu_nocache_npages</span> <span class="o">=</span> <span class="n">SRMMU_MIN_NOCACHE_PAGES</span><span class="p">;</span>

	<span class="cm">/* anything above 1280 blows up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srmmu_nocache_npages</span> <span class="o">&gt;</span> <span class="n">SRMMU_MAX_NOCACHE_PAGES</span><span class="p">)</span>
		<span class="n">srmmu_nocache_npages</span> <span class="o">=</span> <span class="n">SRMMU_MAX_NOCACHE_PAGES</span><span class="p">;</span>

	<span class="n">srmmu_nocache_size</span> <span class="o">=</span> <span class="n">srmmu_nocache_npages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">srmmu_nocache_end</span> <span class="o">=</span> <span class="n">SRMMU_NOCACHE_VADDR</span> <span class="o">+</span> <span class="n">srmmu_nocache_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">srmmu_nocache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitmap_bits</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pteval</span><span class="p">;</span>

	<span class="n">bitmap_bits</span> <span class="o">=</span> <span class="n">srmmu_nocache_size</span> <span class="o">&gt;&gt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">;</span>

	<span class="n">srmmu_nocache_pool</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">srmmu_nocache_size</span><span class="p">,</span>
		<span class="n">SRMMU_NOCACHE_ALIGN_MAX</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">srmmu_nocache_pool</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">srmmu_nocache_size</span><span class="p">);</span>

	<span class="n">srmmu_nocache_bitmap</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">bitmap_bits</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
	<span class="n">bit_map_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_nocache_map</span><span class="p">,</span> <span class="n">srmmu_nocache_bitmap</span><span class="p">,</span> <span class="n">bitmap_bits</span><span class="p">);</span>

	<span class="n">srmmu_swapper_pg_dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__srmmu_get_nocache</span><span class="p">(</span><span class="n">SRMMU_PGD_TABLE_SIZE</span><span class="p">,</span> <span class="n">SRMMU_PGD_TABLE_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">srmmu_swapper_pg_dir</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SRMMU_PGD_TABLE_SIZE</span><span class="p">);</span>
	<span class="n">init_mm</span><span class="p">.</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">srmmu_swapper_pg_dir</span><span class="p">;</span>

	<span class="n">srmmu_early_allocate_ptable_skeleton</span><span class="p">(</span><span class="n">SRMMU_NOCACHE_VADDR</span><span class="p">,</span> <span class="n">srmmu_nocache_end</span><span class="p">);</span>

	<span class="n">paddr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">srmmu_nocache_pool</span><span class="p">);</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">SRMMU_NOCACHE_VADDR</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">srmmu_nocache_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pgd</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">);</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pmd</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">);</span>

		<span class="n">pteval</span> <span class="o">=</span> <span class="p">((</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">SRMMU_ET_PTE</span> <span class="o">|</span> <span class="n">SRMMU_PRIV</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">srmmu_cache_pagetables</span><span class="p">)</span>
			<span class="n">pteval</span> <span class="o">|=</span> <span class="n">SRMMU_CACHE</span><span class="p">;</span>

		<span class="n">set_pte</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pte</span><span class="p">),</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pteval</span><span class="p">));</span>

		<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">paddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flush_cache_all</span><span class="p">();</span>
	<span class="n">flush_tlb_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">pgd_t</span> <span class="o">*</span><span class="nf">get_pgd_fast</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__srmmu_get_nocache</span><span class="p">(</span><span class="n">SRMMU_PGD_TABLE_SIZE</span><span class="p">,</span> <span class="n">SRMMU_PGD_TABLE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">init</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">USER_PTRS_PER_PGD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pgd_t</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pgd</span> <span class="o">+</span> <span class="n">USER_PTRS_PER_PGD</span><span class="p">,</span> <span class="n">init</span> <span class="o">+</span> <span class="n">USER_PTRS_PER_PGD</span><span class="p">,</span>
						<span class="p">(</span><span class="n">PTRS_PER_PGD</span> <span class="o">-</span> <span class="n">USER_PTRS_PER_PGD</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pgd_t</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pgd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hardware needs alignment to 256 only, but we align to whole page size</span>
<span class="cm"> * to reduce fragmentation problems due to the buddy principle.</span>
<span class="cm"> * XXX Provide actual fragmentation statistics in /proc.</span>
<span class="cm"> *</span>
<span class="cm"> * Alignments up to the page size are the same for physical and virtual</span>
<span class="cm"> * addresses of the nocache area.</span>
<span class="cm"> */</span>
<span class="n">pgtable_t</span> <span class="nf">pte_alloc_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pte_alloc_one_kernel</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span> <span class="n">__nocache_pa</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span> <span class="p">);</span>
	<span class="n">pgtable_page_ctor</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pte_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgtable_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p</span><span class="p">;</span>

	<span class="n">pgtable_page_dtor</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>	<span class="cm">/* Cached address (for test) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>	<span class="cm">/* Physical address */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__nocache_va</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>	<span class="cm">/* Nocached virtual */</span>
	<span class="n">srmmu_free_nocache</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PTE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">alloc_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">old_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctx_list</span> <span class="o">*</span><span class="n">ctxp</span><span class="p">;</span>

	<span class="n">ctxp</span> <span class="o">=</span> <span class="n">ctx_free</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ctxp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ctx_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remove_from_ctx_list</span><span class="p">(</span><span class="n">ctxp</span><span class="p">);</span>
		<span class="n">add_to_used_ctxlist</span><span class="p">(</span><span class="n">ctxp</span><span class="p">);</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">ctxp</span><span class="o">-&gt;</span><span class="n">ctx_number</span><span class="p">;</span>
		<span class="n">ctxp</span><span class="o">-&gt;</span><span class="n">ctx_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ctxp</span> <span class="o">=</span> <span class="n">ctx_used</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ctxp</span><span class="o">-&gt;</span><span class="n">ctx_mm</span> <span class="o">==</span> <span class="n">old_mm</span><span class="p">)</span>
		<span class="n">ctxp</span> <span class="o">=</span> <span class="n">ctxp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ctxp</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ctx_used</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;out of mmu contexts&quot;</span><span class="p">);</span>
	<span class="n">flush_cache_mm</span><span class="p">(</span><span class="n">ctxp</span><span class="o">-&gt;</span><span class="n">ctx_mm</span><span class="p">);</span>
	<span class="n">flush_tlb_mm</span><span class="p">(</span><span class="n">ctxp</span><span class="o">-&gt;</span><span class="n">ctx_mm</span><span class="p">);</span>
	<span class="n">remove_from_ctx_list</span><span class="p">(</span><span class="n">ctxp</span><span class="p">);</span>
	<span class="n">add_to_used_ctxlist</span><span class="p">(</span><span class="n">ctxp</span><span class="p">);</span>
	<span class="n">ctxp</span><span class="o">-&gt;</span><span class="n">ctx_mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">NO_CONTEXT</span><span class="p">;</span>
	<span class="n">ctxp</span><span class="o">-&gt;</span><span class="n">ctx_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">ctxp</span><span class="o">-&gt;</span><span class="n">ctx_number</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_context</span><span class="p">(</span><span class="kt">int</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctx_list</span> <span class="o">*</span><span class="n">ctx_old</span><span class="p">;</span>

	<span class="n">ctx_old</span> <span class="o">=</span> <span class="n">ctx_list_pool</span> <span class="o">+</span> <span class="n">context</span><span class="p">;</span>
	<span class="n">remove_from_ctx_list</span><span class="p">(</span><span class="n">ctx_old</span><span class="p">);</span>
	<span class="n">add_to_free_ctxlist</span><span class="p">(</span><span class="n">ctx_old</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">switch_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">old_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">==</span> <span class="n">NO_CONTEXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_context_spinlock</span><span class="p">);</span>
		<span class="n">alloc_context</span><span class="p">(</span><span class="n">old_mm</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_context_spinlock</span><span class="p">);</span>
		<span class="n">srmmu_ctxd_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_context_table</span><span class="p">[</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">],</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sparc_cpu_model</span> <span class="o">==</span> <span class="n">sparc_leon</span><span class="p">)</span>
		<span class="n">leon_switch_mm</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_hypersparc</span><span class="p">)</span>
		<span class="n">hyper_flush_whole_icache</span><span class="p">();</span>

	<span class="n">srmmu_set_context</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Low level IO area allocation on the SRMMU. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">srmmu_mapioaddr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physaddr</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">virt_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">physaddr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">pgdp</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">virt_addr</span><span class="p">);</span>
	<span class="n">pmdp</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span> <span class="n">virt_addr</span><span class="p">);</span>
	<span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">virt_addr</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">physaddr</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">SRMMU_ET_PTE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * I need to test whether this is consistent over all</span>
<span class="cm">	 * sun4m&#39;s.  The bus_type represents the upper 4 bits of</span>
<span class="cm">	 * 36-bit physical address on the I/O space lines...</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">bus_type</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">SRMMU_PRIV</span><span class="p">;</span>
	<span class="n">__flush_page_to_ram</span><span class="p">(</span><span class="n">virt_addr</span><span class="p">);</span>
	<span class="n">set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">srmmu_mapiorange</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xpa</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xva</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">srmmu_mapioaddr</span><span class="p">(</span><span class="n">xpa</span><span class="p">,</span> <span class="n">xva</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
		<span class="n">xva</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">xpa</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">flush_tlb_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">srmmu_unmapioaddr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">virt_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

	<span class="n">pgdp</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">virt_addr</span><span class="p">);</span>
	<span class="n">pmdp</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span> <span class="n">virt_addr</span><span class="p">);</span>
	<span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">virt_addr</span><span class="p">);</span>

	<span class="cm">/* No need to flush uncacheable page. */</span>
	<span class="n">__pte_clear</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">srmmu_unmapiorange</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">virt_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">srmmu_unmapioaddr</span><span class="p">(</span><span class="n">virt_addr</span><span class="p">);</span>
		<span class="n">virt_addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">flush_tlb_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* tsunami.S */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_cache_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_cache_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_cache_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_page_to_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_page_for_dma</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_sig_insns</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insn_addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_tlb_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_tlb_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_flush_tlb_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tsunami_setup_blockops</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* swift.S */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_cache_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_cache_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_cache_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_page_to_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_page_for_dma</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_sig_insns</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insn_addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_tlb_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_tlb_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swift_flush_tlb_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c">  /* P3: deadwood to debug precise flushes on Swift. */</span>
<span class="c">void swift_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)</span>
<span class="c">{</span>
<span class="c">	int cctx, ctx1;</span>

<span class="c">	page &amp;= PAGE_MASK;</span>
<span class="c">	if ((ctx1 = vma-&gt;vm_mm-&gt;context) != -1) {</span>
<span class="c">		cctx = srmmu_get_context();</span>
<span class="c">/* Is context # ever different from current context? P3 */</span>
<span class="c">		if (cctx != ctx1) {</span>
<span class="c">			printk(&quot;flush ctx %02x curr %02x\n&quot;, ctx1, cctx);</span>
<span class="c">			srmmu_set_context(ctx1);</span>
<span class="c">			swift_flush_page(page);</span>
<span class="c">			__asm__ __volatile__(&quot;sta %%g0, [%0] %1\n\t&quot; : :</span>
<span class="c">					&quot;r&quot; (page), &quot;i&quot; (ASI_M_FLUSH_PROBE));</span>
<span class="c">			srmmu_set_context(cctx);</span>
<span class="c">		} else {</span>
<span class="c">			 /* Rm. prot. bits from virt. c. */</span>
<span class="c">			/* swift_flush_cache_all(); */</span>
<span class="c">			/* swift_flush_cache_page(vma, page); */</span>
<span class="c">			swift_flush_page(page);</span>

<span class="c">			__asm__ __volatile__(&quot;sta %%g0, [%0] %1\n\t&quot; : :</span>
<span class="c">				&quot;r&quot; (page), &quot;i&quot; (ASI_M_FLUSH_PROBE));</span>
<span class="c">			/* same as above: srmmu_flush_tlb_page() */</span>
<span class="c">		}</span>
<span class="c">	}</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The following are all MBUS based SRMMU modules, and therefore could</span>
<span class="cm"> * be found in a multiprocessor configuration.  On the whole, these</span>
<span class="cm"> * chips seems to be much more touchy about DVMA and page tables</span>
<span class="cm"> * with respect to cache coherency.</span>
<span class="cm"> */</span>

<span class="cm">/* viking.S */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_cache_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_cache_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_cache_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_page_to_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_page_for_dma</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_sig_insns</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_mxcc_flush_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_tlb_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_tlb_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">viking_flush_tlb_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sun4dsmp_flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sun4dsmp_flush_tlb_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sun4dsmp_flush_tlb_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sun4dsmp_flush_tlb_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>

<span class="cm">/* hypersparc.S */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_cache_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_cache_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_cache_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_page_to_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_page_for_dma</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_sig_insns</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insn_addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_tlb_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_tlb_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_flush_tlb_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hypersparc_setup_blockops</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: All of this startup code assumes the low 16mb (approx.) of</span>
<span class="cm"> *       kernel mappings are done with one single contiguous chunk of</span>
<span class="cm"> *       ram.  On small ram machines (classics mainly) we only get</span>
<span class="cm"> *       around 8mb mapped for us.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_pgtable_allocfail</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;inherit_prom_mappings: Cannot alloc kernel %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">prom_halt</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">srmmu_early_allocate_ptable_skeleton</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgdp</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pgdp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pmdp</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">__srmmu_get_nocache</span><span class="p">(</span>
			    <span class="n">SRMMU_PMD_TABLE_SIZE</span><span class="p">,</span> <span class="n">SRMMU_PMD_TABLE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmdp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">early_pgtable_allocfail</span><span class="p">(</span><span class="s">&quot;pmd&quot;</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pmdp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SRMMU_PMD_TABLE_SIZE</span><span class="p">);</span>
			<span class="n">pgd_set</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pgdp</span><span class="p">),</span> <span class="n">pmdp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pmdp</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pgdp</span><span class="p">),</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">srmmu_pmd_none</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pmdp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ptep</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__srmmu_get_nocache</span><span class="p">(</span><span class="n">PTE_SIZE</span><span class="p">,</span> <span class="n">PTE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ptep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">early_pgtable_allocfail</span><span class="p">(</span><span class="s">&quot;pte&quot;</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">ptep</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PTE_SIZE</span><span class="p">);</span>
			<span class="n">pmd_set</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pmdp</span><span class="p">),</span> <span class="n">ptep</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mh">0xffffffffUL</span> <span class="o">-</span> <span class="n">PMD_SIZE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PMD_MASK</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">srmmu_allocate_ptable_skeleton</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
						  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgdp</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgdp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pmdp</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__srmmu_get_nocache</span><span class="p">(</span><span class="n">SRMMU_PMD_TABLE_SIZE</span><span class="p">,</span> <span class="n">SRMMU_PMD_TABLE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmdp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">early_pgtable_allocfail</span><span class="p">(</span><span class="s">&quot;pmd&quot;</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SRMMU_PMD_TABLE_SIZE</span><span class="p">);</span>
			<span class="n">pgd_set</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span> <span class="n">pmdp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pmdp</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">srmmu_pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmdp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ptep</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">__srmmu_get_nocache</span><span class="p">(</span><span class="n">PTE_SIZE</span><span class="p">,</span>
							     <span class="n">PTE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ptep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">early_pgtable_allocfail</span><span class="p">(</span><span class="s">&quot;pte&quot;</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PTE_SIZE</span><span class="p">);</span>
			<span class="n">pmd_set</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mh">0xffffffffUL</span> <span class="o">-</span> <span class="n">PMD_SIZE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PMD_MASK</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* These flush types are not available on all chips... */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">srmmu_probe</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sparc_cpu_model</span> <span class="o">!=</span> <span class="n">sparc_leon</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">vaddr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;lda [%1] %2, %0</span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="o">:</span>
				     <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="o">:</span>
				     <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">|</span> <span class="mh">0x400</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_M_FLUSH_PROBE</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">leon_swprobe</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is much cleaner than poking around physical address space</span>
<span class="cm"> * looking at the prom&#39;s page table directly which is what most</span>
<span class="cm"> * other OS&#39;s do.  Yuck... this is much better.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">srmmu_inherit_prom_mappings</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">what</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* 0 = normal-pte, 1 = pmd-level pte, 2 = pgd-level pte */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prompte</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* probably wrap around */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="mh">0xfef00000</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">KADB_DEBUGGER_BEGVM</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">prompte</span> <span class="o">=</span> <span class="n">srmmu_probe</span><span class="p">(</span><span class="n">start</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
    
		<span class="cm">/* A red snapper, see what it really is. */</span>
		<span class="n">what</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SRMMU_REAL_PMD_MASK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">srmmu_probe</span><span class="p">((</span><span class="n">start</span><span class="o">-</span><span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="n">SRMMU_REAL_PMD_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="n">prompte</span><span class="p">)</span>
				<span class="n">what</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
    
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SRMMU_PGDIR_MASK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">srmmu_probe</span><span class="p">((</span><span class="n">start</span><span class="o">-</span><span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="n">SRMMU_PGDIR_SIZE</span><span class="p">)</span> <span class="o">==</span>
			   <span class="n">prompte</span><span class="p">)</span>
				<span class="n">what</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
    
		<span class="n">pgdp</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">what</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pgdp</span><span class="p">)</span> <span class="o">=</span> <span class="n">__pgd</span><span class="p">(</span><span class="n">prompte</span><span class="p">);</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="n">SRMMU_PGDIR_SIZE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pgdp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pmdp</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__srmmu_get_nocache</span><span class="p">(</span><span class="n">SRMMU_PMD_TABLE_SIZE</span><span class="p">,</span> <span class="n">SRMMU_PMD_TABLE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmdp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">early_pgtable_allocfail</span><span class="p">(</span><span class="s">&quot;pmd&quot;</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pmdp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SRMMU_PMD_TABLE_SIZE</span><span class="p">);</span>
			<span class="n">pgd_set</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pgdp</span><span class="p">),</span> <span class="n">pmdp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pmdp</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pgdp</span><span class="p">),</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">srmmu_pmd_none</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pmdp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ptep</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">__srmmu_get_nocache</span><span class="p">(</span><span class="n">PTE_SIZE</span><span class="p">,</span>
							     <span class="n">PTE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ptep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">early_pgtable_allocfail</span><span class="p">(</span><span class="s">&quot;pte&quot;</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">ptep</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PTE_SIZE</span><span class="p">);</span>
			<span class="n">pmd_set</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pmdp</span><span class="p">),</span> <span class="n">ptep</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">what</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We bend the rule where all 16 PTPs in a pmd_t point</span>
<span class="cm">			 * inside the same PTE page, and we leak a perfectly</span>
<span class="cm">			 * good hardware PTE piece. Alternatives seem worse.</span>
<span class="cm">			 */</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>	<span class="cm">/* Index of HW PMD in soft cluster */</span>
			<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PMD_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmdp</span><span class="o">-&gt;</span><span class="n">pmdv</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">=</span> <span class="n">prompte</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="n">SRMMU_REAL_PMD_SIZE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pmdp</span><span class="p">),</span> <span class="n">start</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">ptep</span><span class="p">)</span> <span class="o">=</span> <span class="n">__pte</span><span class="p">(</span><span class="n">prompte</span><span class="p">);</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define KERNEL_PTE(page_shifted) ((page_shifted)|SRMMU_CACHE|SRMMU_PRIV|SRMMU_VALID)</span>

<span class="cm">/* Create a third-level SRMMU 16MB page mapping. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_large_mapping</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">big_pte</span><span class="p">;</span>

	<span class="n">big_pte</span> <span class="o">=</span> <span class="n">KERNEL_PTE</span><span class="p">(</span><span class="n">phys_base</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="n">pgdp</span><span class="p">)</span> <span class="o">=</span> <span class="n">__pgd</span><span class="p">(</span><span class="n">big_pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Map sp_bank entry SP_ENTRY, starting at virtual address VBASE. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">map_spbank</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vbase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sp_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp_banks</span><span class="p">[</span><span class="n">sp_entry</span><span class="p">].</span><span class="n">base_addr</span> <span class="o">&amp;</span> <span class="n">SRMMU_PGDIR_MASK</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">vbase</span> <span class="o">&amp;</span> <span class="n">SRMMU_PGDIR_MASK</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vend</span> <span class="o">=</span> <span class="n">SRMMU_PGDIR_ALIGN</span><span class="p">(</span><span class="n">vbase</span> <span class="o">+</span> <span class="n">sp_banks</span><span class="p">[</span><span class="n">sp_entry</span><span class="p">].</span><span class="n">num_bytes</span><span class="p">);</span>
	<span class="cm">/* Map &quot;low&quot; memory only */</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_vaddr</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_vaddr</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">SRMMU_MAXMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vstart</span> <span class="o">&lt;</span> <span class="n">min_vaddr</span> <span class="o">||</span> <span class="n">vstart</span> <span class="o">&gt;=</span> <span class="n">max_vaddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vstart</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">vend</span> <span class="o">&gt;</span> <span class="n">max_vaddr</span> <span class="o">||</span> <span class="n">vend</span> <span class="o">&lt;</span> <span class="n">min_vaddr</span><span class="p">)</span>
		<span class="n">vend</span> <span class="o">=</span> <span class="n">max_vaddr</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">vstart</span> <span class="o">&lt;</span> <span class="n">vend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_large_mapping</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">pstart</span><span class="p">);</span>
		<span class="n">vstart</span> <span class="o">+=</span> <span class="n">SRMMU_PGDIR_SIZE</span><span class="p">;</span> <span class="n">pstart</span> <span class="o">+=</span> <span class="n">SRMMU_PGDIR_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">vstart</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">map_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phys_base</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_large_mapping</span><span class="p">(</span><span class="n">PAGE_OFFSET</span><span class="p">,</span> <span class="n">phys_base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sp_banks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num_bytes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map_spbank</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">sp_banks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base_addr</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Paging initialization on the Sparc Reference MMU. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sparc_context_init</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">poke_srmmu</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__cpuinitdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bootmem_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pages_avail</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">srmmu_paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">phandle</span> <span class="n">cpunode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">node_str</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_avail</span><span class="p">;</span>

	<span class="n">sparc_iomap</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">SUN4M_IOBASE_VADDR</span><span class="p">;</span>	<span class="cm">/* 16MB of IOSPACE on all sun4m&#39;s. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sparc_cpu_model</span> <span class="o">==</span> <span class="n">sun4d</span><span class="p">)</span>
		<span class="n">num_contexts</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span> <span class="cm">/* We know it is Viking */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Find the number of contexts on the srmmu. */</span>
		<span class="n">cpunode</span> <span class="o">=</span> <span class="n">prom_getchild</span><span class="p">(</span><span class="n">prom_root_node</span><span class="p">);</span>
		<span class="n">num_contexts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">cpunode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prom_getstring</span><span class="p">(</span><span class="n">cpunode</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="n">node_str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node_str</span><span class="p">));</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">node_str</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">num_contexts</span> <span class="o">=</span> <span class="n">prom_getintdefault</span><span class="p">(</span><span class="n">cpunode</span><span class="p">,</span> <span class="s">&quot;mmu-nctx&quot;</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cpunode</span> <span class="o">=</span> <span class="n">prom_getsibling</span><span class="p">(</span><span class="n">cpunode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">num_contexts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;Something wrong, can&#39;t find cpu node in paging_init.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">pages_avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">last_valid_pfn</span> <span class="o">=</span> <span class="n">bootmem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pages_avail</span><span class="p">);</span>

	<span class="n">srmmu_nocache_calcsize</span><span class="p">();</span>
	<span class="n">srmmu_nocache_init</span><span class="p">();</span>
        <span class="n">srmmu_inherit_prom_mappings</span><span class="p">(</span><span class="mh">0xfe400000</span><span class="p">,(</span><span class="n">LINUX_OPPROM_ENDVM</span><span class="o">-</span><span class="n">PAGE_SIZE</span><span class="p">));</span>
	<span class="n">map_kernel</span><span class="p">();</span>

	<span class="cm">/* ctx table has to be physically aligned to its size */</span>
	<span class="n">srmmu_context_table</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctxd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__srmmu_get_nocache</span><span class="p">(</span><span class="n">num_contexts</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctxd_t</span><span class="p">),</span> <span class="n">num_contexts</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctxd_t</span><span class="p">));</span>
	<span class="n">srmmu_ctx_table_phys</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctxd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">srmmu_context_table</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_contexts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">srmmu_ctxd_set</span><span class="p">((</span><span class="n">ctxd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__nocache_fix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_context_table</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">srmmu_swapper_pg_dir</span><span class="p">);</span>

	<span class="n">flush_cache_all</span><span class="p">();</span>
	<span class="n">srmmu_set_ctable_ptr</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">srmmu_ctx_table_phys</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* Stop from hanging here... */</span>
	<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_all</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="n">flush_tlb_all</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">poke_srmmu</span><span class="p">();</span>

	<span class="n">srmmu_allocate_ptable_skeleton</span><span class="p">(</span><span class="n">sparc_iomap</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">IOBASE_END</span><span class="p">);</span>
	<span class="n">srmmu_allocate_ptable_skeleton</span><span class="p">(</span><span class="n">DVMA_VADDR</span><span class="p">,</span> <span class="n">DVMA_END</span><span class="p">);</span>

	<span class="n">srmmu_allocate_ptable_skeleton</span><span class="p">(</span>
		<span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">__end_of_fixed_addresses</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">FIXADDR_TOP</span><span class="p">);</span>
	<span class="n">srmmu_allocate_ptable_skeleton</span><span class="p">(</span><span class="n">PKMAP_BASE</span><span class="p">,</span> <span class="n">PKMAP_END</span><span class="p">);</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">PKMAP_BASE</span><span class="p">);</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">PKMAP_BASE</span><span class="p">);</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">PKMAP_BASE</span><span class="p">);</span>
	<span class="n">pkmap_page_table</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>

	<span class="n">flush_cache_all</span><span class="p">();</span>
	<span class="n">flush_tlb_all</span><span class="p">();</span>

	<span class="n">sparc_context_init</span><span class="p">(</span><span class="n">num_contexts</span><span class="p">);</span>

	<span class="n">kmap_init</span><span class="p">();</span>

	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zones_size</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zholes_size</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">znum</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">znum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">znum</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">znum</span><span class="o">++</span><span class="p">)</span>
			<span class="n">zones_size</span><span class="p">[</span><span class="n">znum</span><span class="p">]</span> <span class="o">=</span> <span class="n">zholes_size</span><span class="p">[</span><span class="n">znum</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">npages</span> <span class="o">=</span> <span class="n">max_low_pfn</span> <span class="o">-</span> <span class="n">pfn_base</span><span class="p">;</span>

		<span class="n">zones_size</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">]</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
		<span class="n">zholes_size</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">]</span> <span class="o">=</span> <span class="n">npages</span> <span class="o">-</span> <span class="n">pages_avail</span><span class="p">;</span>

		<span class="n">npages</span> <span class="o">=</span> <span class="n">highend_pfn</span> <span class="o">-</span> <span class="n">max_low_pfn</span><span class="p">;</span>
		<span class="n">zones_size</span><span class="p">[</span><span class="n">ZONE_HIGHMEM</span><span class="p">]</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
		<span class="n">zholes_size</span><span class="p">[</span><span class="n">ZONE_HIGHMEM</span><span class="p">]</span> <span class="o">=</span> <span class="n">npages</span> <span class="o">-</span> <span class="n">calc_highpages</span><span class="p">();</span>

		<span class="n">free_area_init_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zones_size</span><span class="p">,</span> <span class="n">pfn_base</span><span class="p">,</span> <span class="n">zholes_size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mmu_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> 
		   <span class="s">&quot;MMU type</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;contexts</span><span class="se">\t</span><span class="s">: %d</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;nocache total</span><span class="se">\t</span><span class="s">: %ld</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;nocache used</span><span class="se">\t</span><span class="s">: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">srmmu_name</span><span class="p">,</span>
		   <span class="n">num_contexts</span><span class="p">,</span>
		   <span class="n">srmmu_nocache_size</span><span class="p">,</span>
		   <span class="n">srmmu_nocache_map</span><span class="p">.</span><span class="n">used</span> <span class="o">&lt;&lt;</span> <span class="n">SRMMU_NOCACHE_BITMAP_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">destroy_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">!=</span> <span class="n">NO_CONTEXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_cache_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">srmmu_ctxd_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_context_table</span><span class="p">[</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">],</span> <span class="n">srmmu_swapper_pg_dir</span><span class="p">);</span>
		<span class="n">flush_tlb_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_context_spinlock</span><span class="p">);</span>
		<span class="n">free_context</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srmmu_context_spinlock</span><span class="p">);</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">NO_CONTEXT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Init various srmmu chip types. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">srmmu_is_bad</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;Could not determine SRMMU chip type.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">prom_halt</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_vac_layout</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phandle</span> <span class="n">nd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cache_lines</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">node_str</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_line_size</span> <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">nd</span> <span class="o">=</span> <span class="n">prom_getchild</span><span class="p">(</span><span class="n">prom_root_node</span><span class="p">);</span>
	<span class="k">while</span><span class="p">((</span><span class="n">nd</span> <span class="o">=</span> <span class="n">prom_getsibling</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_getstring</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="n">node_str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node_str</span><span class="p">));</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">node_str</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vac_line_size</span> <span class="o">=</span> <span class="n">prom_getint</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="s">&quot;cache-line-size&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vac_line_size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;can&#39;t determine cache-line-size, &quot;</span>
					    <span class="s">&quot;halting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">prom_halt</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">cache_lines</span> <span class="o">=</span> <span class="n">prom_getint</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="s">&quot;cache-nlines&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache_lines</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;can&#39;t determine cache-nlines, halting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">prom_halt</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="n">vac_cache_size</span> <span class="o">=</span> <span class="n">cache_lines</span> <span class="o">*</span> <span class="n">vac_line_size</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
			<span class="k">if</span><span class="p">(</span><span class="n">vac_cache_size</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">)</span>
				<span class="n">max_size</span> <span class="o">=</span> <span class="n">vac_cache_size</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">vac_line_size</span> <span class="o">&lt;</span> <span class="n">min_line_size</span><span class="p">)</span>
				<span class="n">min_line_size</span> <span class="o">=</span> <span class="n">vac_line_size</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>FIXME: cpus not contiguous!!</p></td><td class="code"><div class="highlight"><pre>			<span class="n">cpu</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
<span class="cp">#else</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;No CPU nodes found, halting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">vac_cache_size</span> <span class="o">=</span> <span class="n">max_size</span><span class="p">;</span>
	<span class="n">vac_line_size</span> <span class="o">=</span> <span class="n">min_line_size</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SRMMU: Using VAC size of %d bytes, line size %d bytes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">vac_cache_size</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">vac_line_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">poke_hypersparc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clear</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mreg</span> <span class="o">=</span> <span class="n">srmmu_get_mmureg</span><span class="p">();</span>

	<span class="n">hyper_flush_unconditional_combined</span><span class="p">();</span>

	<span class="n">mreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HYPERSPARC_CWENABLE</span><span class="p">);</span>
	<span class="n">mreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">HYPERSPARC_CENABLE</span> <span class="o">|</span> <span class="n">HYPERSPARC_WBENABLE</span><span class="p">);</span>
	<span class="n">mreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">HYPERSPARC_CMODE</span><span class="p">);</span>

	<span class="n">srmmu_set_mmureg</span><span class="p">(</span><span class="n">mreg</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"> /* XXX I think this is bad news... -DaveM */</span>
<span class="c">	hyper_clear_all_tags();</span>
<span class="cp">#endif</span>

	<span class="n">put_ross_icr</span><span class="p">(</span><span class="n">HYPERSPARC_ICCR_FTD</span> <span class="o">|</span> <span class="n">HYPERSPARC_ICCR_ICE</span><span class="p">);</span>
	<span class="n">hyper_flush_whole_icache</span><span class="p">();</span>
	<span class="n">clear</span> <span class="o">=</span> <span class="n">srmmu_get_faddr</span><span class="p">();</span>
	<span class="n">clear</span> <span class="o">=</span> <span class="n">srmmu_get_fstatus</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="n">hypersparc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cache_all</span>	<span class="o">=</span> <span class="n">hypersparc_flush_cache_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_mm</span>	<span class="o">=</span> <span class="n">hypersparc_flush_cache_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_page</span>	<span class="o">=</span> <span class="n">hypersparc_flush_cache_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_range</span>	<span class="o">=</span> <span class="n">hypersparc_flush_cache_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_all</span>	<span class="o">=</span> <span class="n">hypersparc_flush_tlb_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_mm</span>		<span class="o">=</span> <span class="n">hypersparc_flush_tlb_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_page</span>	<span class="o">=</span> <span class="n">hypersparc_flush_tlb_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_range</span>	<span class="o">=</span> <span class="n">hypersparc_flush_tlb_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_to_ram</span>	<span class="o">=</span> <span class="n">hypersparc_flush_page_to_ram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sig_insns</span>	<span class="o">=</span> <span class="n">hypersparc_flush_sig_insns</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_for_dma</span>	<span class="o">=</span> <span class="n">hypersparc_flush_page_for_dma</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_hypersparc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">srmmu_name</span> <span class="o">=</span> <span class="s">&quot;ROSS HyperSparc&quot;</span><span class="p">;</span>
	<span class="n">srmmu_modtype</span> <span class="o">=</span> <span class="n">HyperSparc</span><span class="p">;</span>

	<span class="n">init_vac_layout</span><span class="p">();</span>

	<span class="n">is_hypersparc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sparc32_cachetlb_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hypersparc_ops</span><span class="p">;</span>

	<span class="n">poke_srmmu</span> <span class="o">=</span> <span class="n">poke_hypersparc</span><span class="p">;</span>

	<span class="n">hypersparc_setup_blockops</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">poke_swift</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mreg</span><span class="p">;</span>

	<span class="cm">/* Clear any crap from the cache or else... */</span>
	<span class="n">swift_flush_cache_all</span><span class="p">();</span>

	<span class="cm">/* Enable I &amp; D caches */</span>
	<span class="n">mreg</span> <span class="o">=</span> <span class="n">srmmu_get_mmureg</span><span class="p">();</span>
	<span class="n">mreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SWIFT_IE</span> <span class="o">|</span> <span class="n">SWIFT_DE</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The Swift branch folding logic is completely broken.  At</span>
<span class="cm">	 * trap time, if things are just right, if can mistakenly</span>
<span class="cm">	 * think that a trap is coming from kernel mode when in fact</span>
<span class="cm">	 * it is coming from user mode (it mis-executes the branch in</span>
<span class="cm">	 * the trap code).  So you see things like crashme completely</span>
<span class="cm">	 * hosing your machine which is completely unacceptable.  Turn</span>
<span class="cm">	 * this shit off... nice job Fujitsu.</span>
<span class="cm">	 */</span>
	<span class="n">mreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SWIFT_BF</span><span class="p">);</span>
	<span class="n">srmmu_set_mmureg</span><span class="p">(</span><span class="n">mreg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="n">swift_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cache_all</span>	<span class="o">=</span> <span class="n">swift_flush_cache_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_mm</span>	<span class="o">=</span> <span class="n">swift_flush_cache_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_page</span>	<span class="o">=</span> <span class="n">swift_flush_cache_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_range</span>	<span class="o">=</span> <span class="n">swift_flush_cache_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_all</span>	<span class="o">=</span> <span class="n">swift_flush_tlb_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_mm</span>		<span class="o">=</span> <span class="n">swift_flush_tlb_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_page</span>	<span class="o">=</span> <span class="n">swift_flush_tlb_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_range</span>	<span class="o">=</span> <span class="n">swift_flush_tlb_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_to_ram</span>	<span class="o">=</span> <span class="n">swift_flush_page_to_ram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sig_insns</span>	<span class="o">=</span> <span class="n">swift_flush_sig_insns</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_for_dma</span>	<span class="o">=</span> <span class="n">swift_flush_page_for_dma</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define SWIFT_MASKID_ADDR  0x10003018</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_swift</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">swift_rev</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;lda [%1] %2, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;srl %0, 0x18, %0</span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="o">:</span>
			     <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">swift_rev</span><span class="p">)</span> <span class="o">:</span>
			     <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">SWIFT_MASKID_ADDR</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_M_BYPASS</span><span class="p">));</span>
	<span class="n">srmmu_name</span> <span class="o">=</span> <span class="s">&quot;Fujitsu Swift&quot;</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">swift_rev</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x11</span>:
	<span class="k">case</span> <span class="mh">0x20</span>:
	<span class="k">case</span> <span class="mh">0x23</span>:
	<span class="k">case</span> <span class="mh">0x30</span>:
		<span class="n">srmmu_modtype</span> <span class="o">=</span> <span class="n">Swift_lots_o_bugs</span><span class="p">;</span>
		<span class="n">hwbug_bitmask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">HWBUG_KERN_ACCBROKEN</span> <span class="o">|</span> <span class="n">HWBUG_KERN_CBITBROKEN</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Gee george, I wonder why Sun is so hush hush about</span>
<span class="cm">		 * this hardware bug... really braindamage stuff going</span>
<span class="cm">		 * on here.  However I think we can find a way to avoid</span>
<span class="cm">		 * all of the workaround overhead under Linux.  Basically,</span>
<span class="cm">		 * any page fault can cause kernel pages to become user</span>
<span class="cm">		 * accessible (the mmu gets confused and clears some of</span>
<span class="cm">		 * the ACC bits in kernel ptes).  Aha, sounds pretty</span>
<span class="cm">		 * horrible eh?  But wait, after extensive testing it appears</span>
<span class="cm">		 * that if you use pgd_t level large kernel pte&#39;s (like the</span>
<span class="cm">		 * 4MB pages on the Pentium) the bug does not get tripped</span>
<span class="cm">		 * at all.  This avoids almost all of the major overhead.</span>
<span class="cm">		 * Welcome to a world where your vendor tells you to,</span>
<span class="cm">		 * &quot;apply this kernel patch&quot; instead of &quot;sorry for the</span>
<span class="cm">		 * broken hardware, send it back and we&#39;ll give you</span>
<span class="cm">		 * properly functioning parts&quot;</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x25</span>:
	<span class="k">case</span> <span class="mh">0x31</span>:
		<span class="n">srmmu_modtype</span> <span class="o">=</span> <span class="n">Swift_bad_c</span><span class="p">;</span>
		<span class="n">hwbug_bitmask</span> <span class="o">|=</span> <span class="n">HWBUG_KERN_CBITBROKEN</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * You see Sun allude to this hardware bug but never</span>
<span class="cm">		 * admit things directly, they&#39;ll say things like,</span>
<span class="cm">		 * &quot;the Swift chip cache problems&quot; or similar.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">srmmu_modtype</span> <span class="o">=</span> <span class="n">Swift_ok</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sparc32_cachetlb_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">swift_ops</span><span class="p">;</span>
	<span class="n">flush_page_for_dma_global</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Are you now convinced that the Swift is one of the</span>
<span class="cm">	 * biggest VLSI abortions of all time?  Bravo Fujitsu!</span>
<span class="cm">	 * Fujitsu, the !#?!%$&#39;d up processor people.  I bet if</span>
<span class="cm">	 * you examined the microcode of the Swift you&#39;d find</span>
<span class="cm">	 * XXX&#39;s all over the place.</span>
<span class="cm">	 */</span>
	<span class="n">poke_srmmu</span> <span class="o">=</span> <span class="n">poke_swift</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_cache_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flush_user_windows</span><span class="p">();</span>
	<span class="n">turbosparc_idflash_clear</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_cache_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FLUSH_BEGIN</span><span class="p">(</span><span class="n">mm</span><span class="p">)</span>
	<span class="n">flush_user_windows</span><span class="p">();</span>
	<span class="n">turbosparc_idflash_clear</span><span class="p">();</span>
	<span class="n">FLUSH_END</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_cache_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FLUSH_BEGIN</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">)</span>
	<span class="n">flush_user_windows</span><span class="p">();</span>
	<span class="n">turbosparc_idflash_clear</span><span class="p">();</span>
	<span class="n">FLUSH_END</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FLUSH_BEGIN</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">)</span>
	<span class="n">flush_user_windows</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">)</span>
		<span class="n">turbosparc_flush_icache</span><span class="p">();</span>
	<span class="n">turbosparc_flush_dcache</span><span class="p">();</span>
	<span class="n">FLUSH_END</span>
<span class="p">}</span>

<span class="cm">/* TurboSparc is copy-back, if we turn it on, but this does not work. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_page_to_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef TURBOSPARC_WRITEBACK</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clear</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srmmu_probe</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">turbosparc_flush_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">clear</span> <span class="o">=</span> <span class="n">srmmu_get_fstatus</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_sig_insns</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insn_addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_page_for_dma</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">turbosparc_flush_dcache</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">srmmu_flush_whole_tlb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_tlb_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FLUSH_BEGIN</span><span class="p">(</span><span class="n">mm</span><span class="p">)</span>
	<span class="n">srmmu_flush_whole_tlb</span><span class="p">();</span>
	<span class="n">FLUSH_END</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_tlb_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FLUSH_BEGIN</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">)</span>
	<span class="n">srmmu_flush_whole_tlb</span><span class="p">();</span>
	<span class="n">FLUSH_END</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">turbosparc_flush_tlb_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">FLUSH_BEGIN</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">)</span>
	<span class="n">srmmu_flush_whole_tlb</span><span class="p">();</span>
	<span class="n">FLUSH_END</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">poke_turbosparc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mreg</span> <span class="o">=</span> <span class="n">srmmu_get_mmureg</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ccreg</span><span class="p">;</span>

	<span class="cm">/* Clear any crap from the cache or else... */</span>
	<span class="n">turbosparc_flush_cache_all</span><span class="p">();</span>
	<span class="n">mreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TURBOSPARC_ICENABLE</span> <span class="o">|</span> <span class="n">TURBOSPARC_DCENABLE</span><span class="p">);</span> <span class="cm">/* Temporarily disable I &amp; D caches */</span>
	<span class="n">mreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TURBOSPARC_PCENABLE</span><span class="p">);</span>		<span class="cm">/* Don&#39;t check parity */</span>
	<span class="n">srmmu_set_mmureg</span><span class="p">(</span><span class="n">mreg</span><span class="p">);</span>
	
	<span class="n">ccreg</span> <span class="o">=</span> <span class="n">turbosparc_get_ccreg</span><span class="p">();</span>

<span class="cp">#ifdef TURBOSPARC_WRITEBACK</span>
	<span class="n">ccreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TURBOSPARC_SNENABLE</span><span class="p">);</span>		<span class="cm">/* Do DVMA snooping in Dcache */</span>
	<span class="n">ccreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TURBOSPARC_uS2</span> <span class="o">|</span> <span class="n">TURBOSPARC_WTENABLE</span><span class="p">);</span>
			<span class="cm">/* Write-back D-cache, emulate VLSI</span>
<span class="cm">			 * abortion number three, not number one */</span>
<span class="cp">#else</span>
	<span class="cm">/* For now let&#39;s play safe, optimize later */</span>
	<span class="n">ccreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TURBOSPARC_SNENABLE</span> <span class="o">|</span> <span class="n">TURBOSPARC_WTENABLE</span><span class="p">);</span>
			<span class="cm">/* Do DVMA snooping in Dcache, Write-thru D-cache */</span>
	<span class="n">ccreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TURBOSPARC_uS2</span><span class="p">);</span>
			<span class="cm">/* Emulate VLSI abortion number three, not number one */</span>
<span class="cp">#endif</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ccreg</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* No SE cache */</span>
	<span class="k">case</span> <span class="mi">7</span>: <span class="cm">/* Test mode */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ccreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TURBOSPARC_SCENABLE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">turbosparc_set_ccreg</span> <span class="p">(</span><span class="n">ccreg</span><span class="p">);</span>

	<span class="n">mreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TURBOSPARC_ICENABLE</span> <span class="o">|</span> <span class="n">TURBOSPARC_DCENABLE</span><span class="p">);</span> <span class="cm">/* I &amp; D caches on */</span>
	<span class="n">mreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TURBOSPARC_ICSNOOP</span><span class="p">);</span>		<span class="cm">/* Icache snooping on */</span>
	<span class="n">srmmu_set_mmureg</span><span class="p">(</span><span class="n">mreg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="n">turbosparc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cache_all</span>	<span class="o">=</span> <span class="n">turbosparc_flush_cache_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_mm</span>	<span class="o">=</span> <span class="n">turbosparc_flush_cache_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_page</span>	<span class="o">=</span> <span class="n">turbosparc_flush_cache_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_range</span>	<span class="o">=</span> <span class="n">turbosparc_flush_cache_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_all</span>	<span class="o">=</span> <span class="n">turbosparc_flush_tlb_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_mm</span>		<span class="o">=</span> <span class="n">turbosparc_flush_tlb_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_page</span>	<span class="o">=</span> <span class="n">turbosparc_flush_tlb_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_range</span>	<span class="o">=</span> <span class="n">turbosparc_flush_tlb_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_to_ram</span>	<span class="o">=</span> <span class="n">turbosparc_flush_page_to_ram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sig_insns</span>	<span class="o">=</span> <span class="n">turbosparc_flush_sig_insns</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_for_dma</span>	<span class="o">=</span> <span class="n">turbosparc_flush_page_for_dma</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_turbosparc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">srmmu_name</span> <span class="o">=</span> <span class="s">&quot;Fujitsu TurboSparc&quot;</span><span class="p">;</span>
	<span class="n">srmmu_modtype</span> <span class="o">=</span> <span class="n">TurboSparc</span><span class="p">;</span>
	<span class="n">sparc32_cachetlb_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">turbosparc_ops</span><span class="p">;</span>
	<span class="n">poke_srmmu</span> <span class="o">=</span> <span class="n">poke_turbosparc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">poke_tsunami</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mreg</span> <span class="o">=</span> <span class="n">srmmu_get_mmureg</span><span class="p">();</span>

	<span class="n">tsunami_flush_icache</span><span class="p">();</span>
	<span class="n">tsunami_flush_dcache</span><span class="p">();</span>
	<span class="n">mreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TSUNAMI_ITD</span><span class="p">;</span>
	<span class="n">mreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TSUNAMI_IENAB</span> <span class="o">|</span> <span class="n">TSUNAMI_DENAB</span><span class="p">);</span>
	<span class="n">srmmu_set_mmureg</span><span class="p">(</span><span class="n">mreg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="n">tsunami_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cache_all</span>	<span class="o">=</span> <span class="n">tsunami_flush_cache_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_mm</span>	<span class="o">=</span> <span class="n">tsunami_flush_cache_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_page</span>	<span class="o">=</span> <span class="n">tsunami_flush_cache_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_range</span>	<span class="o">=</span> <span class="n">tsunami_flush_cache_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_all</span>	<span class="o">=</span> <span class="n">tsunami_flush_tlb_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_mm</span>		<span class="o">=</span> <span class="n">tsunami_flush_tlb_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_page</span>	<span class="o">=</span> <span class="n">tsunami_flush_tlb_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_range</span>	<span class="o">=</span> <span class="n">tsunami_flush_tlb_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_to_ram</span>	<span class="o">=</span> <span class="n">tsunami_flush_page_to_ram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sig_insns</span>	<span class="o">=</span> <span class="n">tsunami_flush_sig_insns</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_for_dma</span>	<span class="o">=</span> <span class="n">tsunami_flush_page_for_dma</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_tsunami</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Tsunami&#39;s pretty sane, Sun and TI actually got it</span>
<span class="cm">	 * somewhat right this time.  Fujitsu should have</span>
<span class="cm">	 * taken some lessons from them.</span>
<span class="cm">	 */</span>

	<span class="n">srmmu_name</span> <span class="o">=</span> <span class="s">&quot;TI Tsunami&quot;</span><span class="p">;</span>
	<span class="n">srmmu_modtype</span> <span class="o">=</span> <span class="n">Tsunami</span><span class="p">;</span>
	<span class="n">sparc32_cachetlb_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tsunami_ops</span><span class="p">;</span>
	<span class="n">poke_srmmu</span> <span class="o">=</span> <span class="n">poke_tsunami</span><span class="p">;</span>

	<span class="n">tsunami_setup_blockops</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">poke_viking</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mreg</span> <span class="o">=</span> <span class="n">srmmu_get_mmureg</span><span class="p">();</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">smp_catch</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">viking_mxcc_present</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mxcc_control</span> <span class="o">=</span> <span class="n">mxcc_get_creg</span><span class="p">();</span>

		<span class="n">mxcc_control</span> <span class="o">|=</span> <span class="p">(</span><span class="n">MXCC_CTL_ECE</span> <span class="o">|</span> <span class="n">MXCC_CTL_PRE</span> <span class="o">|</span> <span class="n">MXCC_CTL_MCE</span><span class="p">);</span>
		<span class="n">mxcc_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MXCC_CTL_RRC</span><span class="p">);</span>
		<span class="n">mxcc_set_creg</span><span class="p">(</span><span class="n">mxcc_control</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t need memory parity checks.</span>
<span class="cm">		 * XXX This is a mess, have to dig out later. ecd.</span>
<span class="cm">		viking_mxcc_turn_off_parity(&amp;mreg, &amp;mxcc_control);</span>
<span class="cm">		 */</span>

		<span class="cm">/* We do cache ptables on MXCC. */</span>
		<span class="n">mreg</span> <span class="o">|=</span> <span class="n">VIKING_TCENABLE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bpreg</span><span class="p">;</span>

		<span class="n">mreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">VIKING_TCENABLE</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">smp_catch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Must disable mixed-cmd mode here for other cpu&#39;s. */</span>
			<span class="n">bpreg</span> <span class="o">=</span> <span class="n">viking_get_bpreg</span><span class="p">();</span>
			<span class="n">bpreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">VIKING_ACTION_MIX</span><span class="p">);</span>
			<span class="n">viking_set_bpreg</span><span class="p">(</span><span class="n">bpreg</span><span class="p">);</span>

			<span class="cm">/* Just in case PROM does something funny. */</span>
			<span class="n">msi_set_sync</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mreg</span> <span class="o">|=</span> <span class="n">VIKING_SPENABLE</span><span class="p">;</span>
	<span class="n">mreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">VIKING_ICENABLE</span> <span class="o">|</span> <span class="n">VIKING_DCENABLE</span><span class="p">);</span>
	<span class="n">mreg</span> <span class="o">|=</span> <span class="n">VIKING_SBENABLE</span><span class="p">;</span>
	<span class="n">mreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">VIKING_ACENABLE</span><span class="p">);</span>
	<span class="n">srmmu_set_mmureg</span><span class="p">(</span><span class="n">mreg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="n">viking_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cache_all</span>	<span class="o">=</span> <span class="n">viking_flush_cache_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_mm</span>	<span class="o">=</span> <span class="n">viking_flush_cache_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_page</span>	<span class="o">=</span> <span class="n">viking_flush_cache_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_range</span>	<span class="o">=</span> <span class="n">viking_flush_cache_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_all</span>	<span class="o">=</span> <span class="n">viking_flush_tlb_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_mm</span>		<span class="o">=</span> <span class="n">viking_flush_tlb_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_page</span>	<span class="o">=</span> <span class="n">viking_flush_tlb_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_range</span>	<span class="o">=</span> <span class="n">viking_flush_tlb_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_to_ram</span>	<span class="o">=</span> <span class="n">viking_flush_page_to_ram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sig_insns</span>	<span class="o">=</span> <span class="n">viking_flush_sig_insns</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_for_dma</span>	<span class="o">=</span> <span class="n">viking_flush_page_for_dma</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/* On sun4d the cpu broadcasts local TLB flushes, so we can just</span>
<span class="cm"> * perform the local TLB flush and all the other cpus will see it.</span>
<span class="cm"> * But, unfortunately, there is a bug in the sun4d XBUS backplane</span>
<span class="cm"> * that requires that we add some synchronization to these flushes.</span>
<span class="cm"> *</span>
<span class="cm"> * The bug is that the fifo which keeps track of all the pending TLB</span>
<span class="cm"> * broadcasts in the system is an entry or two too small, so if we</span>
<span class="cm"> * have too many going at once we&#39;ll overflow that fifo and lose a TLB</span>
<span class="cm"> * flush resulting in corruption.</span>
<span class="cm"> *</span>
<span class="cm"> * Our workaround is to take a global spinlock around the TLB flushes,</span>
<span class="cm"> * which guarentees we won&#39;t ever have too many pending.  It&#39;s a big</span>
<span class="cm"> * hammer, but a semaphore like system to make sure we only have N TLB</span>
<span class="cm"> * flushes going at once will require SMP locking anyways so there&#39;s</span>
<span class="cm"> * no real value in trying any harder than this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="n">viking_sun4d_smp_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cache_all</span>	<span class="o">=</span> <span class="n">viking_flush_cache_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_mm</span>	<span class="o">=</span> <span class="n">viking_flush_cache_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_page</span>	<span class="o">=</span> <span class="n">viking_flush_cache_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_range</span>	<span class="o">=</span> <span class="n">viking_flush_cache_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_all</span>	<span class="o">=</span> <span class="n">sun4dsmp_flush_tlb_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_mm</span>		<span class="o">=</span> <span class="n">sun4dsmp_flush_tlb_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_page</span>	<span class="o">=</span> <span class="n">sun4dsmp_flush_tlb_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_range</span>	<span class="o">=</span> <span class="n">sun4dsmp_flush_tlb_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_to_ram</span>	<span class="o">=</span> <span class="n">viking_flush_page_to_ram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sig_insns</span>	<span class="o">=</span> <span class="n">viking_flush_sig_insns</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_for_dma</span>	<span class="o">=</span> <span class="n">viking_flush_page_for_dma</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_viking</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mreg</span> <span class="o">=</span> <span class="n">srmmu_get_mmureg</span><span class="p">();</span>

	<span class="cm">/* Ahhh, the viking.  SRMMU VLSI abortion number two... */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mreg</span> <span class="o">&amp;</span> <span class="n">VIKING_MMODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">srmmu_name</span> <span class="o">=</span> <span class="s">&quot;TI Viking&quot;</span><span class="p">;</span>
		<span class="n">viking_mxcc_present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">msi_set_sync</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need this to make sure old viking takes no hits</span>
<span class="cm">		 * on it&#39;s cache for dma snoops to workaround the</span>
<span class="cm">		 * &quot;load from non-cacheable memory&quot; interrupt bug.</span>
<span class="cm">		 * This is only necessary because of the new way in</span>
<span class="cm">		 * which we use the IOMMU.</span>
<span class="cm">		 */</span>
		<span class="n">viking_ops</span><span class="p">.</span><span class="n">page_for_dma</span> <span class="o">=</span> <span class="n">viking_flush_page</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="n">viking_sun4d_smp_ops</span><span class="p">.</span><span class="n">page_for_dma</span> <span class="o">=</span> <span class="n">viking_flush_page</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">flush_page_for_dma_global</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">srmmu_name</span> <span class="o">=</span> <span class="s">&quot;TI Viking/MXCC&quot;</span><span class="p">;</span>
		<span class="n">viking_mxcc_present</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">srmmu_cache_pagetables</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sparc32_cachetlb_ops</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="o">*</span><span class="p">)</span>
		<span class="o">&amp;</span><span class="n">viking_ops</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sparc_cpu_model</span> <span class="o">==</span> <span class="n">sun4d</span><span class="p">)</span>
		<span class="n">sparc32_cachetlb_ops</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="o">*</span><span class="p">)</span>
			<span class="o">&amp;</span><span class="n">viking_sun4d_smp_ops</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">poke_srmmu</span> <span class="o">=</span> <span class="n">poke_viking</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Probe for the srmmu chip version. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">get_srmmu_type</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mreg</span><span class="p">,</span> <span class="n">psr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mod_typ</span><span class="p">,</span> <span class="n">mod_rev</span><span class="p">,</span> <span class="n">psr_typ</span><span class="p">,</span> <span class="n">psr_vers</span><span class="p">;</span>

	<span class="n">srmmu_modtype</span> <span class="o">=</span> <span class="n">SRMMU_INVAL_MOD</span><span class="p">;</span>
	<span class="n">hwbug_bitmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mreg</span> <span class="o">=</span> <span class="n">srmmu_get_mmureg</span><span class="p">();</span> <span class="n">psr</span> <span class="o">=</span> <span class="n">get_psr</span><span class="p">();</span>
	<span class="n">mod_typ</span> <span class="o">=</span> <span class="p">(</span><span class="n">mreg</span> <span class="o">&amp;</span> <span class="mh">0xf0000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">;</span>
	<span class="n">mod_rev</span> <span class="o">=</span> <span class="p">(</span><span class="n">mreg</span> <span class="o">&amp;</span> <span class="mh">0x0f000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">psr_typ</span> <span class="o">=</span> <span class="p">(</span><span class="n">psr</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">psr_vers</span> <span class="o">=</span> <span class="p">(</span><span class="n">psr</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="cm">/* First, check for sparc-leon. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sparc_cpu_model</span> <span class="o">==</span> <span class="n">sparc_leon</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_leon</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Second, check for HyperSparc or Cypress. */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mod_typ</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">mod_rev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">7</span>:
			<span class="cm">/* UP or MP Hypersparc */</span>
			<span class="n">init_hypersparc</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">case</span> <span class="mi">10</span>:
		<span class="k">case</span> <span class="mi">11</span>:
		<span class="k">case</span> <span class="mi">12</span>:
		<span class="k">case</span> <span class="mi">13</span>:
		<span class="k">case</span> <span class="mi">14</span>:
		<span class="k">case</span> <span class="mi">15</span>:
		<span class="nl">default:</span>
			<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;Sparc-Linux Cypress support does not longer exit.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">prom_halt</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * Now Fujitsu TurboSparc. It might happen that it is</span>
<span class="cm">	 * in Swift emulation mode, so we will check later...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psr_typ</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">psr_vers</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_turbosparc</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Next check for Fujitsu Swift. */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">psr_typ</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">psr_vers</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phandle</span> <span class="n">cpunode</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">node_str</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

		<span class="cm">/* Look if it is not a TurboSparc emulating Swift... */</span>
		<span class="n">cpunode</span> <span class="o">=</span> <span class="n">prom_getchild</span><span class="p">(</span><span class="n">prom_root_node</span><span class="p">);</span>
		<span class="k">while</span><span class="p">((</span><span class="n">cpunode</span> <span class="o">=</span> <span class="n">prom_getsibling</span><span class="p">(</span><span class="n">cpunode</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prom_getstring</span><span class="p">(</span><span class="n">cpunode</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="n">node_str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node_str</span><span class="p">));</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">node_str</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prom_getintdefault</span><span class="p">(</span><span class="n">cpunode</span><span class="p">,</span> <span class="s">&quot;psr-implementation&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="n">prom_getintdefault</span><span class="p">(</span><span class="n">cpunode</span><span class="p">,</span> <span class="s">&quot;psr-version&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">init_turbosparc</span><span class="p">();</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		
		<span class="n">init_swift</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now the Viking family of srmmu. */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">psr_typ</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span>
	   <span class="p">((</span><span class="n">psr_vers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">psr_vers</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod_typ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod_rev</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">init_viking</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Finally the Tsunami. */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">psr_typ</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">psr_vers</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod_typ</span> <span class="o">||</span> <span class="n">mod_rev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">init_tsunami</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Oh well */</span>
	<span class="n">srmmu_is_bad</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/* Local cross-calls. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_page_for_dma</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xc1</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">page_for_dma</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">page_for_dma</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_cache_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xc0</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_all</span><span class="p">);</span>
	<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xc0</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_all</span><span class="p">);</span>
	<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_cache_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">!=</span> <span class="n">NO_CONTEXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_t</span> <span class="n">cpu_mask</span><span class="p">;</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">))</span>
			<span class="n">xc1</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_mm</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">mm</span><span class="p">);</span>
		<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_tlb_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">!=</span> <span class="n">NO_CONTEXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_t</span> <span class="n">cpu_mask</span><span class="p">;</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xc1</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_mm</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">mm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">)</span>
				<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span>
					     <span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()));</span>
		<span class="p">}</span>
		<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_cache_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">!=</span> <span class="n">NO_CONTEXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_t</span> <span class="n">cpu_mask</span><span class="p">;</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">))</span>
			<span class="n">xc3</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_range</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_tlb_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">!=</span> <span class="n">NO_CONTEXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_t</span> <span class="n">cpu_mask</span><span class="p">;</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">))</span>
			<span class="n">xc3</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_range</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">!=</span> <span class="n">NO_CONTEXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_t</span> <span class="n">cpu_mask</span><span class="p">;</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">))</span>
			<span class="n">xc2</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_page</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_tlb_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">!=</span> <span class="n">NO_CONTEXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_t</span> <span class="n">cpu_mask</span><span class="p">;</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">))</span>
			<span class="n">xc2</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_page</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_page_to_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Current theory is that those who call this are the one&#39;s</span>
<span class="cm">	 * who have just dirtied their cache with the pages contents</span>
<span class="cm">	 * in kernel space, therefore we only run this on local cpu.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX This experiment failed, research further... -DaveM</span>
<span class="cm">	 */</span>
<span class="cp">#if 1</span>
	<span class="n">xc1</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">page_to_ram</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">page_to_ram</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_flush_sig_insns</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insn_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_t</span> <span class="n">cpu_mask</span><span class="p">;</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_mask</span><span class="p">))</span>
		<span class="n">xc2</span><span class="p">((</span><span class="n">smpfunc_t</span><span class="p">)</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">sig_insns</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">mm</span><span class="p">,</span> <span class="n">insn_addr</span><span class="p">);</span>
	<span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">sig_insns</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">insn_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="n">smp_cachetlb_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cache_all</span>	<span class="o">=</span> <span class="n">smp_flush_cache_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_mm</span>	<span class="o">=</span> <span class="n">smp_flush_cache_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_page</span>	<span class="o">=</span> <span class="n">smp_flush_cache_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cache_range</span>	<span class="o">=</span> <span class="n">smp_flush_cache_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_all</span>	<span class="o">=</span> <span class="n">smp_flush_tlb_all</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_mm</span>		<span class="o">=</span> <span class="n">smp_flush_tlb_mm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_page</span>	<span class="o">=</span> <span class="n">smp_flush_tlb_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlb_range</span>	<span class="o">=</span> <span class="n">smp_flush_tlb_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_to_ram</span>	<span class="o">=</span> <span class="n">smp_flush_page_to_ram</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sig_insns</span>	<span class="o">=</span> <span class="n">smp_flush_sig_insns</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_for_dma</span>	<span class="o">=</span> <span class="n">smp_flush_page_for_dma</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* Load up routines and constants for sun4m and sun4d mmu */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">load_mmu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">ld_mmu_iommu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">ld_mmu_iounit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* Functions */</span>
	<span class="n">get_srmmu_type</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* El switcheroo... */</span>
	<span class="n">local_ops</span> <span class="o">=</span> <span class="n">sparc32_cachetlb_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sparc_cpu_model</span> <span class="o">==</span> <span class="n">sun4d</span> <span class="o">||</span> <span class="n">sparc_cpu_model</span> <span class="o">==</span> <span class="n">sparc_leon</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">tlb_all</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_all</span><span class="p">;</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">tlb_mm</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_mm</span><span class="p">;</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">tlb_range</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_range</span><span class="p">;</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">tlb_page</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">tlb_page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">poke_srmmu</span> <span class="o">==</span> <span class="n">poke_viking</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Avoid unnecessary cross calls. */</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">cache_all</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_all</span><span class="p">;</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">cache_mm</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_mm</span><span class="p">;</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">cache_range</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_range</span><span class="p">;</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">cache_page</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">cache_page</span><span class="p">;</span>

		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">page_to_ram</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">page_to_ram</span><span class="p">;</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">sig_insns</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">sig_insns</span><span class="p">;</span>
		<span class="n">smp_cachetlb_ops</span><span class="p">.</span><span class="n">page_for_dma</span> <span class="o">=</span> <span class="n">local_ops</span><span class="o">-&gt;</span><span class="n">page_for_dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* It really is const after this point. */</span>
	<span class="n">sparc32_cachetlb_ops</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_cachetlb_ops</span> <span class="o">*</span><span class="p">)</span>
		<span class="o">&amp;</span><span class="n">smp_cachetlb_ops</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sparc_cpu_model</span> <span class="o">==</span> <span class="n">sun4d</span><span class="p">)</span>
		<span class="n">ld_mmu_iounit</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">ld_mmu_iommu</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sparc_cpu_model</span> <span class="o">==</span> <span class="n">sun4d</span><span class="p">)</span>
		<span class="n">sun4d_init_smp</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sparc_cpu_model</span> <span class="o">==</span> <span class="n">sparc_leon</span><span class="p">)</span>
		<span class="n">leon_init_smp</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">sun4m_init_smp</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
