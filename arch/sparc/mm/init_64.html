<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › mm › init_64.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>init_64.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  arch/sparc64/mm/init.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1996-1999 David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> *  Copyright (C) 1997-1999 Jakub Jelinek (jj@sunsite.mff.cuni.cz)</span>
<span class="cm"> */</span>
 
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/poison.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/sort.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;asm/head.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/oplib.h&gt;</span>
<span class="cp">#include &lt;asm/iommu.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/starfire.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/spitfire.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/tsb.h&gt;</span>
<span class="cp">#include &lt;asm/hypervisor.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/mdesc.h&gt;</span>
<span class="cp">#include &lt;asm/cpudata.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>

<span class="cp">#include &quot;init_64.h&quot;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* A bitmap, one bit for every 256MB of physical memory.  If the bit</span>
<span class="cm"> * is clear, we should use a 4MB page (via kern_linear_pte_xor[0]) else</span>
<span class="cm"> * if set we should use a 256MB page (via kern_linear_pte_xor[1]).</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kpte_linear_bitmap</span><span class="p">[</span><span class="n">KPTE_BITMAP_BYTES</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)];</span>

<span class="cp">#ifndef CONFIG_DEBUG_PAGEALLOC</span>
<span class="cm">/* A special kernel TSB for 4MB and 256MB linear mappings.</span>
<span class="cm"> * Space is allocated for this right after the trap table</span>
<span class="cm"> * in arch/sparc64/kernel/head.S</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tsb</span> <span class="n">swapper_4m_tsb</span><span class="p">[</span><span class="n">KERNEL_TSB4M_NENTRIES</span><span class="p">];</span>
<span class="cp">#endif</span>

<span class="cp">#define MAX_BANKS	32</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="n">pavail</span><span class="p">[</span><span class="n">MAX_BANKS</span><span class="p">]</span> <span class="n">__devinitdata</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pavail_ents</span> <span class="n">__devinitdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmp_p64</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">read_obp_memory</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="o">*</span><span class="n">num_ents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phandle</span> <span class="n">node</span> <span class="o">=</span> <span class="n">prom_finddevice</span><span class="p">(</span><span class="s">&quot;/memory&quot;</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">prop_size</span> <span class="o">=</span> <span class="n">prom_getproplen</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">property</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ents</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ents</span> <span class="o">=</span> <span class="n">prop_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_prom64_registers</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ents</span> <span class="o">&gt;</span> <span class="n">MAX_BANKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;The machine has more %s property entries than &quot;</span>
			    <span class="s">&quot;this kernel can support (%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">property</span><span class="p">,</span> <span class="n">MAX_BANKS</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">prom_getproperty</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">property</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="p">,</span> <span class="n">prop_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t get %s property from /memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Sanitize what we got from the firmware, by page aligning</span>
<span class="cm">	 * everything.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_base</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>

			<span class="n">size</span> <span class="o">-=</span> <span class="n">new_base</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0L</span><span class="p">)</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
			<span class="n">base</span> <span class="o">=</span> <span class="n">new_base</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0UL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If it is empty, simply get rid of it.</span>
<span class="cm">			 * This simplifies the logic of the other</span>
<span class="cm">			 * functions that process these arrays.</span>
<span class="cm">			 */</span>
			<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
				<span class="p">(</span><span class="n">ents</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
			<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="n">ents</span><span class="o">--</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">num_ents</span> <span class="o">=</span> <span class="n">ents</span><span class="p">;</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">ents</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_prom64_registers</span><span class="p">),</span>
	     <span class="n">cmp_p64</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sparc64_valid_addr_bitmap</span><span class="p">[</span><span class="n">VALID_ADDR_BITMAP_BYTES</span> <span class="o">/</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)];</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sparc64_valid_addr_bitmap</span><span class="p">);</span>

<span class="cm">/* Kernel physical address base and size in bytes.  */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kern_base</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kern_size</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* Initial ramdisk setup */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sparc_ramdisk_image64</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sparc_ramdisk_image</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sparc_ramdisk_size</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">mem_map_zero</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mem_map_zero</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sparc64_highest_unlocked_tlb_ent</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sparc64_kern_pri_context</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sparc64_kern_pri_nuc_bits</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sparc64_kern_sec_context</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">num_kernel_image_mappings</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_DCFLUSH</span>
<span class="n">atomic_t</span> <span class="n">dcpage_flushes</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="n">atomic_t</span> <span class="n">dcpage_flushes_xcall</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_dcache_page_impl</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_DCFLUSH</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcpage_flushes</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DCACHE_ALIASING_POSSIBLE</span>
	<span class="n">__flush_dcache_page</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
			    <span class="p">((</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span>
		<span class="n">__flush_icache_page</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#define PG_dcache_dirty		PG_arch_1</span>
<span class="cp">#define PG_dcache_cpu_shift	32UL</span>
<span class="cp">#define PG_dcache_cpu_mask	\</span>
<span class="cp">	((1UL&lt;&lt;ilog2(roundup_pow_of_two(NR_CPUS)))-1UL)</span>

<span class="cp">#define dcache_dirty_cpu(page) \</span>
<span class="cp">	(((page)-&gt;flags &gt;&gt; PG_dcache_cpu_shift) &amp; PG_dcache_cpu_mask)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_dcache_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">this_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">non_cpu_bits</span><span class="p">;</span>

	<span class="n">non_cpu_bits</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">PG_dcache_cpu_mask</span> <span class="o">&lt;&lt;</span> <span class="n">PG_dcache_cpu_shift</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">PG_dcache_cpu_shift</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">PG_dcache_dirty</span><span class="p">);</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;1:</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;ldx	[%2], %%g7</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;and	%%g7, %1, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;or	%%g1, %0, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;casx	[%2], %%g7, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;cmp	%%g7, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;bne,pn	%%xcc, 1b</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot; nop&quot;</span>
			     <span class="o">:</span> <span class="cm">/* no outputs */</span>
			     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">non_cpu_bits</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
			     <span class="o">:</span> <span class="s">&quot;g1&quot;</span><span class="p">,</span> <span class="s">&quot;g7&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_dcache_dirty_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">PG_dcache_dirty</span><span class="p">);</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;! test_and_clear_dcache_dirty</span><span class="se">\n</span><span class="s">&quot;</span>
			     <span class="s">&quot;1:</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;ldx	[%2], %%g7</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;srlx	%%g7, %4, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;and	%%g1, %3, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;cmp	%%g1, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;bne,pn	%%icc, 2f</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot; andn	%%g7, %1, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;casx	[%2], %%g7, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;cmp	%%g7, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;bne,pn	%%xcc, 1b</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot; nop</span><span class="se">\n</span><span class="s">&quot;</span>
			     <span class="s">&quot;2:&quot;</span>
			     <span class="o">:</span> <span class="cm">/* no outputs */</span>
			     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">),</span>
			       <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">PG_dcache_cpu_mask</span><span class="p">),</span>
			       <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">PG_dcache_cpu_shift</span><span class="p">)</span>
			     <span class="o">:</span> <span class="s">&quot;g1&quot;</span><span class="p">,</span> <span class="s">&quot;g7&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tsb_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsb</span> <span class="o">*</span><span class="n">ent</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tsb_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span> <span class="o">||</span> <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="n">tsb_addr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">tsb_addr</span><span class="p">);</span>

	<span class="n">__tsb_insert</span><span class="p">(</span><span class="n">tsb_addr</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_PAGE_ALL_SZ_BITS</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_PAGE_SZBITS</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_dcache</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pg_flags</span><span class="p">;</span>

		<span class="n">pg_flags</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pg_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">PG_dcache_dirty</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">((</span><span class="n">pg_flags</span> <span class="o">&gt;&gt;</span> <span class="n">PG_dcache_cpu_shift</span><span class="p">)</span> <span class="o">&amp;</span>
				   <span class="n">PG_dcache_cpu_mask</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

			<span class="cm">/* This is just to optimize away some function calls</span>
<span class="cm">			 * in the SMP case.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">this_cpu</span><span class="p">)</span>
				<span class="n">flush_dcache_page_impl</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">smp_flush_dcache_page_impl</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

			<span class="n">clear_dcache_dirty_cpu</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

			<span class="n">put_cpu</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">update_mmu_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tsb</span> <span class="o">*</span><span class="n">tsb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tag</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tsb_index</span><span class="p">,</span> <span class="n">tsb_hash_shift</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">!=</span> <span class="n">hypervisor</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
			<span class="n">flush_dcache</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>

	<span class="n">tsb_index</span> <span class="o">=</span> <span class="n">MM_TSB_BASE</span><span class="p">;</span>
	<span class="n">tsb_hash_shift</span> <span class="o">=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">tsb_block</span><span class="p">[</span><span class="n">MM_TSB_HUGE</span><span class="p">].</span><span class="n">tsb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SZALL_4V</span><span class="p">)</span> <span class="o">==</span> <span class="n">_PAGE_SZHUGE_4V</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">tlb_type</span> <span class="o">!=</span> <span class="n">hypervisor</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SZALL_4U</span><span class="p">)</span> <span class="o">==</span> <span class="n">_PAGE_SZHUGE_4U</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tsb_index</span> <span class="o">=</span> <span class="n">MM_TSB_HUGE</span><span class="p">;</span>
			<span class="n">tsb_hash_shift</span> <span class="o">=</span> <span class="n">HPAGE_SHIFT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">tsb</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">tsb_block</span><span class="p">[</span><span class="n">tsb_index</span><span class="p">].</span><span class="n">tsb</span><span class="p">;</span>
	<span class="n">tsb</span> <span class="o">+=</span> <span class="p">((</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">tsb_hash_shift</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">tsb_block</span><span class="p">[</span><span class="n">tsb_index</span><span class="p">].</span><span class="n">tsb_nentries</span> <span class="o">-</span> <span class="mi">1UL</span><span class="p">));</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">22UL</span><span class="p">);</span>
	<span class="n">tsb_insert</span><span class="p">(</span><span class="n">tsb</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_dcache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Do not bother with the expensive D-cache flush if it</span>
<span class="cm">	 * is merely the zero page.  The &#39;bigcore&#39; testcase in GDB</span>
<span class="cm">	 * causes this case to run millions of times.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">ZERO_PAGE</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">this_cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mapping_mapped</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">PG_dcache_dirty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">dirty_cpu</span> <span class="o">=</span> <span class="n">dcache_dirty_cpu</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dirty_cpu</span> <span class="o">==</span> <span class="n">this_cpu</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">smp_flush_dcache_page_impl</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">dirty_cpu</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">set_dcache_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We could delay the flush for the !page_mapping</span>
<span class="cm">		 * case too.  But that case is for exec env/arg</span>
<span class="cm">		 * pages and those are %99 certainly going to get</span>
<span class="cm">		 * faulted into the tlb (and thus flushed) anyways.</span>
<span class="cm">		 */</span>
		<span class="n">flush_dcache_page_impl</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_dcache_page</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">flush_icache_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Cheetah and Hypervisor platform cpus have coherent I-cache. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kaddr</span><span class="p">;</span>

		<span class="cm">/* This code only runs on Spitfire cpus so this is</span>
<span class="cm">		 * why we can assume _PAGE_PADDR_4U.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">kaddr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">kaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_PAGE_PADDR_4U</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">kaddr</span> <span class="o">&gt;=</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span>
				<span class="n">paddr</span> <span class="o">=</span> <span class="n">kaddr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
				<span class="n">pud_t</span> <span class="o">*</span><span class="n">pudp</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">);</span>
				<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pudp</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">);</span>
				<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">);</span>

				<span class="n">paddr</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__flush_icache_page</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_icache_range</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">mmu_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MMU Type</span><span class="se">\t</span><span class="s">: Cheetah</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MMU Type</span><span class="se">\t</span><span class="s">: Cheetah+</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MMU Type</span><span class="se">\t</span><span class="s">: Spitfire</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MMU Type</span><span class="se">\t</span><span class="s">: Hypervisor (sun4v)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MMU Type</span><span class="se">\t</span><span class="s">: ???</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_DCFLUSH</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DCPageFlushes</span><span class="se">\t</span><span class="s">: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcpage_flushes</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DCPageFlushesXC</span><span class="se">\t</span><span class="s">: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcpage_flushes_xcall</span><span class="p">));</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_DCFLUSH */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">linux_prom_translation</span> <span class="n">prom_trans</span><span class="p">[</span><span class="mi">512</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prom_trans_ents</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kern_locked_tte_data</span><span class="p">;</span>

<span class="cm">/* The obp translations are saved based on 8k pagesize, since obp can</span>
<span class="cm"> * use a mixture of pagesizes. Misses to the LOW_OBP_ADDRESS -&gt;</span>
<span class="cm"> * HI_OBP_ADDRESS range are handled in ktlb.S.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">in_obp_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&gt;=</span> <span class="n">LOW_OBP_ADDRESS</span> <span class="o">&amp;&amp;</span>
		<span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">HI_OBP_ADDRESS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmp_ptrans</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom_translation</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Read OBP translations property into &#39;prom_trans[]&#39;.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">read_obp_translations</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">ents</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">prom_finddevice</span><span class="p">(</span><span class="s">&quot;/virtual-memory&quot;</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">prom_getproplen</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;translations&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;prom_mappings: Couldn&#39;t get size.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prom_trans</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;prom_mappings: Size %Zd is too big.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">prom_getproperty</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;translations&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">prom_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="n">prom_trans</span><span class="p">)))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;prom_mappings: Couldn&#39;t get property.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_prom_translation</span><span class="p">);</span>

	<span class="n">ents</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">prom_trans</span><span class="p">,</span> <span class="n">ents</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_prom_translation</span><span class="p">),</span>
	     <span class="n">cmp_ptrans</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Now kick out all the non-OBP entries.  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_obp_range</span><span class="p">(</span><span class="n">prom_trans</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">first</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_obp_range</span><span class="p">(</span><span class="n">prom_trans</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">linux_prom_translation</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prom_trans</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">first</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">linux_prom_translation</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prom_trans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">linux_prom_translation</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prom_trans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="mh">0x0UL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prom_trans_ents</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear diag TTE bits. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prom_trans_ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">prom_trans</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x0003fe0000000000UL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Force execute bit on.  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prom_trans_ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">prom_trans</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span> <span class="o">?</span>
				       <span class="n">_PAGE_EXEC_4V</span> <span class="o">:</span> <span class="n">_PAGE_EXEC_4U</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">hypervisor_tlb_lock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">sun4v_mmu_map_perm_addr</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">mmu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;hypervisor_tlb_lock[%lx:%lx:%lx:%lx]: &quot;</span>
			    <span class="s">&quot;errors with %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">mmu</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kern_large_tte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">remap_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_page</span><span class="p">,</span> <span class="n">tte_vaddr</span><span class="p">,</span> <span class="n">tte_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">tlb_ent</span> <span class="o">=</span> <span class="n">sparc64_highest_locked_tlbent</span><span class="p">();</span>

	<span class="n">tte_vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">KERNBASE</span><span class="p">;</span>
	<span class="n">phys_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">prom_boot_mapping_phys_low</span> <span class="o">&gt;&gt;</span> <span class="mi">22UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">22UL</span><span class="p">;</span>
	<span class="n">tte_data</span> <span class="o">=</span> <span class="n">kern_large_tte</span><span class="p">(</span><span class="n">phys_page</span><span class="p">);</span>

	<span class="n">kern_locked_tte_data</span> <span class="o">=</span> <span class="n">tte_data</span><span class="p">;</span>

	<span class="cm">/* Now lock us into the TLBs via Hypervisor or OBP. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_kernel_image_mappings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hypervisor_tlb_lock</span><span class="p">(</span><span class="n">tte_vaddr</span><span class="p">,</span> <span class="n">tte_data</span><span class="p">,</span> <span class="n">HV_MMU_DMMU</span><span class="p">);</span>
			<span class="n">hypervisor_tlb_lock</span><span class="p">(</span><span class="n">tte_vaddr</span><span class="p">,</span> <span class="n">tte_data</span><span class="p">,</span> <span class="n">HV_MMU_IMMU</span><span class="p">);</span>
			<span class="n">tte_vaddr</span> <span class="o">+=</span> <span class="mh">0x400000</span><span class="p">;</span>
			<span class="n">tte_data</span> <span class="o">+=</span> <span class="mh">0x400000</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_kernel_image_mappings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prom_dtlb_load</span><span class="p">(</span><span class="n">tlb_ent</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">tte_data</span><span class="p">,</span> <span class="n">tte_vaddr</span><span class="p">);</span>
			<span class="n">prom_itlb_load</span><span class="p">(</span><span class="n">tlb_ent</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">tte_data</span><span class="p">,</span> <span class="n">tte_vaddr</span><span class="p">);</span>
			<span class="n">tte_vaddr</span> <span class="o">+=</span> <span class="mh">0x400000</span><span class="p">;</span>
			<span class="n">tte_data</span> <span class="o">+=</span> <span class="mh">0x400000</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sparc64_highest_unlocked_tlb_ent</span> <span class="o">=</span> <span class="n">tlb_ent</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sparc64_kern_pri_context</span> <span class="o">=</span> <span class="p">(</span><span class="n">CTX_CHEETAH_PLUS_CTX0</span> <span class="o">|</span>
					    <span class="n">CTX_CHEETAH_PLUS_NUC</span><span class="p">);</span>
		<span class="n">sparc64_kern_pri_nuc_bits</span> <span class="o">=</span> <span class="n">CTX_CHEETAH_PLUS_NUC</span><span class="p">;</span>
		<span class="n">sparc64_kern_sec_context</span> <span class="o">=</span> <span class="n">CTX_CHEETAH_PLUS_CTX0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">inherit_prom_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Now fixup OBP&#39;s idea about where we really are mapped. */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Remapping the kernel... &quot;</span><span class="p">);</span>
	<span class="n">remap_kernel</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">prom_world</span><span class="p">(</span><span class="kt">int</span> <span class="n">enter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enter</span><span class="p">)</span>
		<span class="n">set_fs</span><span class="p">((</span><span class="n">mm_segment_t</span><span class="p">)</span> <span class="p">{</span> <span class="n">get_thread_current_ds</span><span class="p">()</span> <span class="p">});</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;flushw&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__flush_dcache_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">va</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">va</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">va</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spitfire_put_dcache_tag</span><span class="p">(</span><span class="n">va</span> <span class="o">&amp;</span> <span class="mh">0x3fe0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">512</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah</span> <span class="o">||</span> <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">va</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">va</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">va</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span>
			<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;stxa %%g0, [%0] %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
					     <span class="s">&quot;membar #Sync&quot;</span>
					     <span class="o">:</span> <span class="cm">/* no outputs */</span>
					     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">va</span><span class="p">),</span>
					       <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_DCACHE_INVALIDATE</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__flush_dcache_range</span><span class="p">);</span>

<span class="cm">/* get_new_mmu_context() uses &quot;cache + 1&quot;.  */</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ctx_alloc_lock</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tlb_context_cache</span> <span class="o">=</span> <span class="n">CTX_FIRST_VERSION</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#define MAX_CTX_NR	(1UL &lt;&lt; CTX_NR_BITS)</span>
<span class="cp">#define CTX_BMAP_SLOTS	BITS_TO_LONGS(MAX_CTX_NR)</span>
<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">mmu_context_bmap</span><span class="p">,</span> <span class="n">MAX_CTX_NR</span><span class="p">);</span>

<span class="cm">/* Caller does TLB context flushing on local CPU if necessary.</span>
<span class="cm"> * The caller also ensures that CTX_VALID(mm-&gt;context) is false.</span>
<span class="cm"> *</span>
<span class="cm"> * We must be careful about boundary cases so that we never</span>
<span class="cm"> * let the user have CTX 0 (nucleus) or we ever use a CTX</span>
<span class="cm"> * version of zero (and thus NO_CONTEXT would not be caught</span>
<span class="cm"> * by version mis-match tests in mmu_context.h).</span>
<span class="cm"> *</span>
<span class="cm"> * Always invoked with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">get_new_mmu_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">new_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_pgsz_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_version</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_alloc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">orig_pgsz_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">sparc64_ctx_val</span> <span class="o">&amp;</span> <span class="n">CTX_PGSZ_MASK</span><span class="p">);</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="p">(</span><span class="n">tlb_context_cache</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CTX_NR_MASK</span><span class="p">;</span>
	<span class="n">new_ctx</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">mmu_context_bmap</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CTX_NR_BITS</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">new_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_ctx</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CTX_NR_BITS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_ctx</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">mmu_context_bmap</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_ctx</span> <span class="o">&gt;=</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">new_ctx</span> <span class="o">=</span> <span class="p">(</span><span class="n">tlb_context_cache</span> <span class="o">&amp;</span> <span class="n">CTX_VERSION_MASK</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">CTX_FIRST_VERSION</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_ctx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">new_ctx</span> <span class="o">=</span> <span class="n">CTX_FIRST_VERSION</span><span class="p">;</span>

			<span class="cm">/* Don&#39;t call memset, for 16 entries that&#39;s just</span>
<span class="cm">			 * plain silly...</span>
<span class="cm">			 */</span>
			<span class="n">mmu_context_bmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">mmu_context_bmap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">mmu_context_bmap</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">mmu_context_bmap</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CTX_BMAP_SLOTS</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mmu_context_bmap</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">mmu_context_bmap</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">mmu_context_bmap</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">mmu_context_bmap</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">new_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mmu_context_bmap</span><span class="p">[</span><span class="n">new_ctx</span><span class="o">&gt;&gt;</span><span class="mi">6</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">new_ctx</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">));</span>
	<span class="n">new_ctx</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tlb_context_cache</span> <span class="o">&amp;</span> <span class="n">CTX_VERSION_MASK</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">tlb_context_cache</span> <span class="o">=</span> <span class="n">new_ctx</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">sparc64_ctx_val</span> <span class="o">=</span> <span class="n">new_ctx</span> <span class="o">|</span> <span class="n">orig_pgsz_bits</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_alloc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">new_version</span><span class="p">))</span>
		<span class="n">smp_new_mmu_context_version</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">numa_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">numa_debug</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_numa</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">))</span>
		<span class="n">numa_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;debug&quot;</span><span class="p">))</span>
		<span class="n">numa_debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;numa&quot;</span><span class="p">,</span> <span class="n">early_numa</span><span class="p">);</span>

<span class="cp">#define numadbg(f, a...) \</span>
<span class="cp">do {	if (numa_debug) \</span>
<span class="cp">		printk(KERN_INFO f, ## a); \</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">find_ramdisk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_base</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sparc_ramdisk_image</span> <span class="o">||</span> <span class="n">sparc_ramdisk_image64</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ramdisk_image</span><span class="p">;</span>

		<span class="cm">/* Older versions of the bootloader only supported a</span>
<span class="cm">		 * 32-bit physical address for the ramdisk image</span>
<span class="cm">		 * location, stored at sparc_ramdisk_image.  Newer</span>
<span class="cm">		 * SILO versions set sparc_ramdisk_image to zero and</span>
<span class="cm">		 * provide a full 64-bit physical address at</span>
<span class="cm">		 * sparc_ramdisk_image64.</span>
<span class="cm">		 */</span>
		<span class="n">ramdisk_image</span> <span class="o">=</span> <span class="n">sparc_ramdisk_image</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ramdisk_image</span><span class="p">)</span>
			<span class="n">ramdisk_image</span> <span class="o">=</span> <span class="n">sparc_ramdisk_image64</span><span class="p">;</span>

		<span class="cm">/* Another bootloader quirk.  The bootloader normalizes</span>
<span class="cm">		 * the physical address to KERNBASE, so we have to</span>
<span class="cm">		 * factor that back out and add in the lowest valid</span>
<span class="cm">		 * physical page address to get the true physical address.</span>
<span class="cm">		 */</span>
		<span class="n">ramdisk_image</span> <span class="o">-=</span> <span class="n">KERNBASE</span><span class="p">;</span>
		<span class="n">ramdisk_image</span> <span class="o">+=</span> <span class="n">phys_base</span><span class="p">;</span>

		<span class="n">numadbg</span><span class="p">(</span><span class="s">&quot;Found ramdisk at physical address 0x%lx, size %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ramdisk_image</span><span class="p">,</span> <span class="n">sparc_ramdisk_size</span><span class="p">);</span>

		<span class="n">initrd_start</span> <span class="o">=</span> <span class="n">ramdisk_image</span><span class="p">;</span>
		<span class="n">initrd_end</span> <span class="o">=</span> <span class="n">ramdisk_image</span> <span class="o">+</span> <span class="n">sparc_ramdisk_size</span><span class="p">;</span>

		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">initrd_start</span><span class="p">,</span> <span class="n">sparc_ramdisk_size</span><span class="p">);</span>

		<span class="n">initrd_start</span> <span class="o">+=</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>
		<span class="n">initrd_end</span> <span class="o">+=</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">node_mem_mask</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">node_mem_mask</span> <span class="n">node_masks</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_node_masks</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">numa_cpu_lookup_table</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="n">cpumask_t</span> <span class="n">numa_cpumask_lookup_table</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_NEED_MULTIPLE_NODES</span>

<span class="k">struct</span> <span class="n">mdesc_mblock</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">base</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">size</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">offset</span><span class="p">;</span> <span class="cm">/* RA-to-PA */</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mdesc_mblock</span> <span class="o">*</span><span class="n">mblocks</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_mblocks</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ra_to_pa</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_mblocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mdesc_mblock</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mblocks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&amp;&amp;</span>
		    <span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">ra_to_pa</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_node_masks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">node_mem_mask</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_masks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">memblock_nid_range</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">nid</span> <span class="o">=</span> <span class="n">find_node</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">find_node</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="o">*</span><span class="n">nid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* This must be invoked after performing all of the necessary</span>
<span class="cm"> * memblock_set_node() calls for &#39;nid&#39;.  We need to be able to get</span>
<span class="cm"> * correct data from get_pfn_range_for_nid().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">allocate_node_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NEED_MULTIPLE_NODES</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>

	<span class="n">paddr</span> <span class="o">=</span> <span class="n">memblock_alloc_try_nid</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pglist_data</span><span class="p">),</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;Cannot allocate pglist_data for nid[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pglist_data</span><span class="p">));</span>

	<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>

	<span class="n">get_pfn_range_for_nid</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">=</span> <span class="n">start_pfn</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span> <span class="o">=</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_node_masks_nonnuma</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">numadbg</span><span class="p">(</span><span class="s">&quot;Initializing tables for non-numa.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">node_masks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="n">node_masks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">num_node_masks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">numa_cpu_lookup_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpumask_setall</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numa_cpumask_lookup_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NEED_MULTIPLE_NODES</span>
<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">node_data</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">numa_cpu_lookup_table</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">numa_cpumask_lookup_table</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">node_data</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">mdesc_mlgroup</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">node</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">latency</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">match</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">mask</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mdesc_mlgroup</span> <span class="o">*</span><span class="n">mlgroups</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_mlgroups</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_pio_for_cfg_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">mdesc_handle</span> <span class="o">*</span><span class="n">md</span><span class="p">,</span> <span class="n">u64</span> <span class="n">pio</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">cfg_handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">arc</span><span class="p">;</span>

	<span class="n">mdesc_for_each_arc</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">pio</span><span class="p">,</span> <span class="n">MDESC_ARC_TYPE_FWD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">target</span> <span class="o">=</span> <span class="n">mdesc_arc_target</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">arc</span><span class="p">);</span>
		<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">mdesc_get_property</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
					 <span class="s">&quot;cfg-handle&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">val</span> <span class="o">==</span> <span class="n">cfg_handle</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_arcs_for_cfg_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">mdesc_handle</span> <span class="o">*</span><span class="n">md</span><span class="p">,</span> <span class="n">u64</span> <span class="n">grp</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">cfg_handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">arc</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">best_latency</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">candidate</span> <span class="o">=</span> <span class="n">MDESC_NODE_NULL</span><span class="p">;</span>
	<span class="n">mdesc_for_each_arc</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">grp</span><span class="p">,</span> <span class="n">MDESC_ARC_TYPE_FWD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">target</span> <span class="o">=</span> <span class="n">mdesc_arc_target</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">arc</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">mdesc_node_name</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
		<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;pio-latency-group&quot;</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">mdesc_get_property</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s">&quot;latency&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">best_latency</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">candidate</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
			<span class="n">best_latency</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">candidate</span> <span class="o">==</span> <span class="n">MDESC_NODE_NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">scan_pio_for_cfg_handle</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">cfg_handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">of_node_to_nid</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mdesc_handle</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg_handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">nid</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">grp</span><span class="p">;</span>

	<span class="cm">/* This is the right thing to do on currently supported</span>
<span class="cm">	 * SUN4U NUMA platforms as well, as the PCI controller does</span>
<span class="cm">	 * not sit behind any particular memory controller.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mlgroups</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">cfg_handle</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32UL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">;</span>

	<span class="n">md</span> <span class="o">=</span> <span class="n">mdesc_grab</span><span class="p">();</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mdesc_for_each_node_by_name</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">grp</span><span class="p">,</span> <span class="s">&quot;group&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scan_arcs_for_cfg_handle</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">grp</span><span class="p">,</span> <span class="n">cfg_handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mdesc_release</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">add_node_ranges</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_end</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

			<span class="n">this_end</span> <span class="o">=</span> <span class="n">memblock_nid_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">);</span>

			<span class="n">numadbg</span><span class="p">(</span><span class="s">&quot;Setting memblock NUMA node nid[%d] &quot;</span>
				<span class="s">&quot;start[%lx] end[%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">this_end</span><span class="p">);</span>

			<span class="n">memblock_set_node</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">this_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">this_end</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">grab_mlgroups</span><span class="p">(</span><span class="k">struct</span> <span class="n">mdesc_handle</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">mdesc_for_each_node_by_name</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;memory-latency-group&quot;</span><span class="p">)</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">paddr</span> <span class="o">=</span> <span class="n">memblock_alloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mdesc_mlgroup</span><span class="p">),</span>
			  <span class="n">SMP_CACHE_BYTES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mlgroups</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
	<span class="n">num_mlgroups</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mdesc_for_each_node_by_name</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;memory-latency-group&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mdesc_mlgroup</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mlgroups</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">];</span>
		<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>

		<span class="n">m</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">mdesc_get_property</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;latency&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">latency</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">mdesc_get_property</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;address-match&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">mdesc_get_property</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;address-mask&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>

		<span class="n">numadbg</span><span class="p">(</span><span class="s">&quot;MLGROUP[%d]: node[%llx] latency[%llx] &quot;</span>
			<span class="s">&quot;match[%llx] mask[%llx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">latency</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">grab_mblocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">mdesc_handle</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">mdesc_for_each_node_by_name</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;mblock&quot;</span><span class="p">)</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">paddr</span> <span class="o">=</span> <span class="n">memblock_alloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mdesc_mblock</span><span class="p">),</span>
			  <span class="n">SMP_CACHE_BYTES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mblocks</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
	<span class="n">num_mblocks</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mdesc_for_each_node_by_name</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;mblock&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mdesc_mblock</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mblocks</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">];</span>
		<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">mdesc_get_property</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;base&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">mdesc_get_property</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;size&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">mdesc_get_property</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
					 <span class="s">&quot;address-congruence-offset&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>

		<span class="n">numadbg</span><span class="p">(</span><span class="s">&quot;MBLOCK[%d]: base[%llx] size[%llx] offset[%llx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">numa_parse_mdesc_group_cpus</span><span class="p">(</span><span class="k">struct</span> <span class="n">mdesc_handle</span> <span class="o">*</span><span class="n">md</span><span class="p">,</span>
					       <span class="n">u64</span> <span class="n">grp</span><span class="p">,</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">arc</span><span class="p">;</span>

	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">mdesc_for_each_arc</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">grp</span><span class="p">,</span> <span class="n">MDESC_ARC_TYPE_BACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">target</span> <span class="o">=</span> <span class="n">mdesc_arc_target</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">arc</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">mdesc_node_name</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
		<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">mdesc_get_property</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mdesc_mlgroup</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">find_mlgroup</span><span class="p">(</span><span class="n">u64</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_mlgroups</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mdesc_mlgroup</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mlgroups</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">m</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_attach_mlgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mdesc_handle</span> <span class="o">*</span><span class="n">md</span><span class="p">,</span> <span class="n">u64</span> <span class="n">grp</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mdesc_mlgroup</span> <span class="o">*</span><span class="n">candidate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">arc</span><span class="p">,</span> <span class="n">best_latency</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_mem_mask</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">mdesc_for_each_arc</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">grp</span><span class="p">,</span> <span class="n">MDESC_ARC_TYPE_FWD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">target</span> <span class="o">=</span> <span class="n">mdesc_arc_target</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">arc</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">mdesc_mlgroup</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">find_mlgroup</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">latency</span> <span class="o">&lt;</span> <span class="n">best_latency</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">candidate</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
			<span class="n">best_latency</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">latency</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">candidate</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_node_masks</span> <span class="o">!=</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Inconsistent NUMA state, &quot;</span>
		       <span class="s">&quot;index[%d] != num_node_masks[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">index</span><span class="p">,</span> <span class="n">num_node_masks</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_masks</span><span class="p">[</span><span class="n">num_node_masks</span><span class="o">++</span><span class="p">];</span>

	<span class="n">n</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">;</span>

	<span class="n">numadbg</span><span class="p">(</span><span class="s">&quot;NUMA NODE[%d]: mask[%lx] val[%lx] (latency[%llx])</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">candidate</span><span class="o">-&gt;</span><span class="n">latency</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_parse_mdesc_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">mdesc_handle</span> <span class="o">*</span><span class="n">md</span><span class="p">,</span> <span class="n">u64</span> <span class="n">grp</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">numa_parse_mdesc_group_cpus</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">grp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">)</span>
		<span class="n">numa_cpu_lookup_table</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numa_cpumask_lookup_table</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numa_debug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NUMA GROUP[%d]: cpus [ &quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">numa_attach_mlgroup</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">grp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_parse_mdesc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mdesc_handle</span> <span class="o">*</span><span class="n">md</span> <span class="o">=</span> <span class="n">mdesc_grab</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">mdesc_node_by_name</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">MDESC_NODE_NULL</span><span class="p">,</span> <span class="s">&quot;latency-groups&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">MDESC_NODE_NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mdesc_release</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">grab_mblocks</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">grab_mlgroups</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mdesc_for_each_node_by_name</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;group&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">numa_parse_mdesc_group</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">add_node_ranges</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_node_masks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">allocate_node_data</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">node_set_online</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mdesc_release</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_parse_jbus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* NUMA node id is encoded in bits 36 and higher, and there is</span>
<span class="cm">	 * a 1-to-1 mapping from CPU ID to NUMA node ID.</span>
<span class="cm">	 */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">numa_cpu_lookup_table</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numa_cpumask_lookup_table</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="n">node_masks</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">36UL</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1UL</span><span class="p">);</span>
		<span class="n">node_masks</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">&lt;&lt;</span> <span class="mi">36UL</span><span class="p">;</span>

		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">num_node_masks</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">add_node_ranges</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">num_node_masks</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">allocate_node_data</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
		<span class="n">node_set_online</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">numa_parse_sun4u</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah</span> <span class="o">||</span> <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ver</span><span class="p">;</span>

		<span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;rdpr %%ver, %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">ver</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ver</span> <span class="o">&gt;&gt;</span> <span class="mi">32UL</span><span class="p">)</span> <span class="o">==</span> <span class="n">__JALAPENO_ID</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">ver</span> <span class="o">&gt;&gt;</span> <span class="mi">32UL</span><span class="p">)</span> <span class="o">==</span> <span class="n">__SERRANO_ID</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">numa_parse_jbus</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">bootmem_init_numa</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">numadbg</span><span class="p">(</span><span class="s">&quot;bootmem_init_numa()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numa_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">numa_parse_mdesc</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">numa_parse_sun4u</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bootmem_init_numa</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">bootmem_init_nonnuma</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">top_of_ram</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_ram</span> <span class="o">=</span> <span class="n">memblock_phys_mem_size</span><span class="p">();</span>

	<span class="n">numadbg</span><span class="p">(</span><span class="s">&quot;bootmem_init_nonnuma()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Top of RAM: 0x%lx, Total RAM: 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">top_of_ram</span><span class="p">,</span> <span class="n">total_ram</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Memory hole size: %ldMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">top_of_ram</span> <span class="o">-</span> <span class="n">total_ram</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>

	<span class="n">init_node_masks_nonnuma</span><span class="p">();</span>
	<span class="n">memblock_set_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">ULLONG_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">allocate_node_data</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">node_set_online</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">bootmem_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">;</span>

	<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
	<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">phys_base</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bootmem_init_numa</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bootmem_init_nonnuma</span><span class="p">();</span>

	<span class="cm">/* Dump memblock with node info. */</span>
	<span class="n">memblock_dump_all</span><span class="p">();</span>

	<span class="cm">/* XXX cpu notifier XXX */</span>

	<span class="n">sparse_memory_present_with_active_regions</span><span class="p">(</span><span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="n">sparse_init</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">end_pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="n">pall</span><span class="p">[</span><span class="n">MAX_BANKS</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pall_ents</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__ref</span> <span class="nf">kernel_map_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pstart</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pend</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vstart</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">pstart</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vend</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">pend</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alloc_bytes</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vstart</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">vend</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;kernel_map: Unaligned physmem[%lx:%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">vstart</span><span class="p">,</span> <span class="n">vend</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">vstart</span> <span class="o">&lt;</span> <span class="n">vend</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_end</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vstart</span><span class="p">);</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">vstart</span><span class="p">);</span>
		<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

		<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">vstart</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pmd_t</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

			<span class="n">new</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="n">alloc_bytes</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">pud_populate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">vstart</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pte_t</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

			<span class="n">new</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="n">alloc_bytes</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">pmd_populate_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vstart</span><span class="p">);</span>
		<span class="n">this_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">vstart</span> <span class="o">+</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PMD_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this_end</span> <span class="o">&gt;</span> <span class="n">vend</span><span class="p">)</span>
			<span class="n">this_end</span> <span class="o">=</span> <span class="n">vend</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">vstart</span> <span class="o">&lt;</span> <span class="n">this_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">));</span>

			<span class="n">vstart</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">paddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">alloc_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kvmap_linear_patch</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_PAGEALLOC */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">mark_kpte_bitmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shift_256MB</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask_256MB</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">shift_256MB</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1UL</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size_256MB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">shift_256MB</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">remains</span><span class="p">;</span>

		<span class="n">remains</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remains</span> <span class="o">&lt;</span> <span class="n">size_256MB</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="n">mask_256MB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size_256MB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask_256MB</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">remains</span> <span class="o">&gt;=</span> <span class="n">size_256MB</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">shift_256MB</span><span class="p">;</span>

			<span class="n">__set_bit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">kpte_linear_bitmap</span><span class="p">);</span>

			<span class="n">start</span> <span class="o">+=</span> <span class="n">size_256MB</span><span class="p">;</span>
			<span class="n">remains</span> <span class="o">-=</span> <span class="n">size_256MB</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_kpte_bitmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pall_ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_start</span><span class="p">,</span> <span class="n">phys_end</span><span class="p">;</span>

		<span class="n">phys_start</span> <span class="o">=</span> <span class="n">pall</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
		<span class="n">phys_end</span> <span class="o">=</span> <span class="n">phys_start</span> <span class="o">+</span> <span class="n">pall</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span><span class="p">;</span>

		<span class="n">mark_kpte_bitmap</span><span class="p">(</span><span class="n">phys_start</span><span class="p">,</span> <span class="n">phys_end</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">kernel_physical_mapping_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">mem_alloced</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pall_ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_start</span><span class="p">,</span> <span class="n">phys_end</span><span class="p">;</span>

		<span class="n">phys_start</span> <span class="o">=</span> <span class="n">pall</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
		<span class="n">phys_end</span> <span class="o">=</span> <span class="n">phys_start</span> <span class="o">+</span> <span class="n">pall</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span><span class="p">;</span>

		<span class="n">mem_alloced</span> <span class="o">+=</span> <span class="n">kernel_map_range</span><span class="p">(</span><span class="n">phys_start</span><span class="p">,</span> <span class="n">phys_end</span><span class="p">,</span>
						<span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Allocated %ld bytes for kernel page tables.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">mem_alloced</span><span class="p">);</span>

	<span class="n">kvmap_linear_patch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01000000</span><span class="p">;</span> <span class="cm">/* nop */</span>
	<span class="n">flushi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvmap_linear_patch</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">__flush_tlb_all</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
<span class="kt">void</span> <span class="nf">kernel_map_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_start</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_end</span> <span class="o">=</span> <span class="n">phys_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">numpages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">kernel_map_range</span><span class="p">(</span><span class="n">phys_start</span><span class="p">,</span> <span class="n">phys_end</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">enable</span> <span class="o">?</span> <span class="n">PAGE_KERNEL</span> <span class="o">:</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span>

	<span class="n">flush_tsb_kernel_range</span><span class="p">(</span><span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">phys_start</span><span class="p">,</span>
			       <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">phys_end</span><span class="p">);</span>

	<span class="cm">/* we should perform an IPI and flush all tlbs,</span>
<span class="cm">	 * but that can deadlock-&gt;flush only current cpu.</span>
<span class="cm">	 */</span>
	<span class="n">__flush_tlb_kernel_range</span><span class="p">(</span><span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">phys_start</span><span class="p">,</span>
				 <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">phys_end</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">find_ecache_flush_span</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pavail_ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">tsb_phys_patch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsb_ldquad_phys_patch_entry</span> <span class="o">*</span><span class="n">pquad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tsb_phys_patch_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">pquad</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__tsb_ldquad_phys_patch</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pquad</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">__tsb_ldquad_phys_patch_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">pquad</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">pquad</span><span class="o">-&gt;</span><span class="n">sun4v_insn</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">pquad</span><span class="o">-&gt;</span><span class="n">sun4u_insn</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;flush	%0&quot;</span>
				     <span class="o">:</span> <span class="cm">/* no outputs */</span>
				     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">));</span>

		<span class="n">pquad</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__tsb_phys_patch</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">__tsb_phys_patch_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>

		<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">insn</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;flush	%0&quot;</span>
				     <span class="o">:</span> <span class="cm">/* no outputs */</span>
				     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">));</span>

		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Don&#39;t mark as init, we give this to the Hypervisor.  */</span>
<span class="cp">#ifndef CONFIG_DEBUG_PAGEALLOC</span>
<span class="cp">#define NUM_KTSB_DESCR	2</span>
<span class="cp">#else</span>
<span class="cp">#define NUM_KTSB_DESCR	1</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hv_tsb_descr</span> <span class="n">ktsb_descr</span><span class="p">[</span><span class="n">NUM_KTSB_DESCR</span><span class="p">];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tsb</span> <span class="n">swapper_tsb</span><span class="p">[</span><span class="n">KERNEL_TSB_NENTRIES</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">patch_one_ktsb_phys</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pa</span> <span class="o">&gt;&gt;=</span> <span class="n">KTSB_PHYS_SHIFT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ia</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">start</span><span class="p">;</span>

		<span class="n">ia</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3fffff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">pa</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;flush	%0&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">ia</span><span class="p">));</span>

		<span class="n">ia</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3ff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">pa</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">);</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;flush	%0&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">ia</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

		<span class="n">start</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ktsb_phys_patch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__swapper_tsb_phys_patch</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__swapper_tsb_phys_patch_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ktsb_pa</span><span class="p">;</span>

	<span class="n">ktsb_pa</span> <span class="o">=</span> <span class="n">kern_base</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">swapper_tsb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">);</span>
	<span class="n">patch_one_ktsb_phys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__swapper_tsb_phys_patch</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">__swapper_tsb_phys_patch_end</span><span class="p">,</span> <span class="n">ktsb_pa</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__swapper_4m_tsb_phys_patch</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__swapper_4m_tsb_phys_patch_end</span><span class="p">;</span>
	<span class="n">ktsb_pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">kern_base</span> <span class="o">+</span>
		   <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">swapper_4m_tsb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">));</span>
	<span class="n">patch_one_ktsb_phys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__swapper_4m_tsb_phys_patch</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">__swapper_4m_tsb_phys_patch_end</span><span class="p">,</span> <span class="n">ktsb_pa</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sun4v_ktsb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ktsb_pa</span><span class="p">;</span>

	<span class="cm">/* First KTSB for PAGE_SIZE mappings.  */</span>
	<span class="n">ktsb_pa</span> <span class="o">=</span> <span class="n">kern_base</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">swapper_tsb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span>:
	<span class="nl">default:</span>
		<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pgsz_idx</span> <span class="o">=</span> <span class="n">HV_PGSZ_IDX_8K</span><span class="p">;</span>
		<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pgsz_mask</span> <span class="o">=</span> <span class="n">HV_PGSZ_MASK_8K</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>:
		<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pgsz_idx</span> <span class="o">=</span> <span class="n">HV_PGSZ_IDX_64K</span><span class="p">;</span>
		<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pgsz_mask</span> <span class="o">=</span> <span class="n">HV_PGSZ_MASK_64K</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span>:
		<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pgsz_idx</span> <span class="o">=</span> <span class="n">HV_PGSZ_IDX_512K</span><span class="p">;</span>
		<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pgsz_mask</span> <span class="o">=</span> <span class="n">HV_PGSZ_MASK_512K</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>:
		<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pgsz_idx</span> <span class="o">=</span> <span class="n">HV_PGSZ_IDX_4MB</span><span class="p">;</span>
		<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pgsz_mask</span> <span class="o">=</span> <span class="n">HV_PGSZ_MASK_4MB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">assoc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">num_ttes</span> <span class="o">=</span> <span class="n">KERNEL_TSB_NENTRIES</span><span class="p">;</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ctx_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tsb_base</span> <span class="o">=</span> <span class="n">ktsb_pa</span><span class="p">;</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">resv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="cm">/* Second KTSB for 4MB/256MB mappings.  */</span>
	<span class="n">ktsb_pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">kern_base</span> <span class="o">+</span>
		   <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">swapper_4m_tsb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">));</span>

	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">pgsz_idx</span> <span class="o">=</span> <span class="n">HV_PGSZ_IDX_4MB</span><span class="p">;</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">pgsz_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">HV_PGSZ_MASK_4MB</span> <span class="o">|</span>
				   <span class="n">HV_PGSZ_MASK_256MB</span><span class="p">);</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">assoc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">num_ttes</span> <span class="o">=</span> <span class="n">KERNEL_TSB4M_NENTRIES</span><span class="p">;</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ctx_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tsb_base</span> <span class="o">=</span> <span class="n">ktsb_pa</span><span class="p">;</span>
	<span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">resv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">sun4v_ktsb_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pa</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pa</span> <span class="o">=</span> <span class="n">kern_base</span> <span class="o">+</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ktsb_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sun4v_mmu_tsb_ctx0</span><span class="p">(</span><span class="n">NUM_KTSB_DESCR</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;hypervisor_mmu_tsb_ctx0[%lx]: &quot;</span>
			    <span class="s">&quot;errors with %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* paging_init() sets up the page tables */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_valid_pfn</span><span class="p">;</span>
<span class="n">pgd_t</span> <span class="n">swapper_pg_dir</span><span class="p">[</span><span class="mi">2048</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sun4u_pgprot_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sun4v_pgprot_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">phys_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">real_end</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/* These build time checkes make sure that the dcache_dirty_cpu()</span>
<span class="cm">	 * page-&gt;flags usage will work.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When a page gets marked as dcache-dirty, we store the</span>
<span class="cm">	 * cpu number starting at bit 32 in the page-&gt;flags.  Also,</span>
<span class="cm">	 * functions like clear_dcache_dirty_cpu use the cpu mask</span>
<span class="cm">	 * in 13-bit signed-immediate instruction fields.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Page flags must not reach into upper 32 bits that are used</span>
<span class="cm">	 * for the cpu number</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">NR_PAGEFLAGS</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The bit fields placed in the high range must not reach below</span>
<span class="cm">	 * the 32 bit boundary. Otherwise we cannot place the cpu field</span>
<span class="cm">	 * at the 32 bit boundary.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SECTIONS_WIDTH</span> <span class="o">+</span> <span class="n">NODES_WIDTH</span> <span class="o">+</span> <span class="n">ZONES_WIDTH</span> <span class="o">+</span>
		<span class="n">ilog2</span><span class="p">(</span><span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">NR_CPUS</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">NR_CPUS</span> <span class="o">&gt;</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">kern_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">prom_boot_mapping_phys_low</span> <span class="o">&gt;&gt;</span> <span class="mi">22UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">22UL</span><span class="p">;</span>
	<span class="n">kern_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_end</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">KERNBASE</span><span class="p">;</span>

	<span class="cm">/* Invalidate both kernel TSBs.  */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">swapper_tsb</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">swapper_tsb</span><span class="p">));</span>
<span class="cp">#ifndef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">swapper_4m_tsb</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">swapper_4m_tsb</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="n">sun4v_pgprot_init</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">sun4u_pgprot_init</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span> <span class="o">||</span>
	    <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tsb_phys_patch</span><span class="p">();</span>
		<span class="n">ktsb_phys_patch</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sun4v_patch_tlb_handlers</span><span class="p">();</span>
		<span class="n">sun4v_ktsb_init</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Find available physical memory...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Read it twice in order to work around a bug in openfirmware.</span>
<span class="cm">	 * The call to grab this table itself can cause openfirmware to</span>
<span class="cm">	 * allocate memory, which in turn can take away some space from</span>
<span class="cm">	 * the list of available memory.  Reading it twice makes sure</span>
<span class="cm">	 * we really do get the final value.</span>
<span class="cm">	 */</span>
	<span class="n">read_obp_translations</span><span class="p">();</span>
	<span class="n">read_obp_memory</span><span class="p">(</span><span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pall</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pall_ents</span><span class="p">);</span>
	<span class="n">read_obp_memory</span><span class="p">(</span><span class="s">&quot;available&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavail</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pavail_ents</span><span class="p">);</span>
	<span class="n">read_obp_memory</span><span class="p">(</span><span class="s">&quot;available&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavail</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pavail_ents</span><span class="p">);</span>

	<span class="n">phys_base</span> <span class="o">=</span> <span class="mh">0xffffffffffffffffUL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pavail_ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phys_base</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">phys_base</span><span class="p">,</span> <span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">);</span>
		<span class="n">memblock_add</span><span class="p">(</span><span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">kern_base</span><span class="p">,</span> <span class="n">kern_size</span><span class="p">);</span>

	<span class="n">find_ramdisk</span><span class="p">(</span><span class="n">phys_base</span><span class="p">);</span>

	<span class="n">memblock_enforce_memory_limit</span><span class="p">(</span><span class="n">cmdline_memory_size</span><span class="p">);</span>

	<span class="n">memblock_allow_resize</span><span class="p">();</span>
	<span class="n">memblock_dump_all</span><span class="p">();</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mmu_context_bmap</span><span class="p">);</span>

	<span class="n">shift</span> <span class="o">=</span> <span class="n">kern_base</span> <span class="o">+</span> <span class="n">PAGE_OFFSET</span> <span class="o">-</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">KERNBASE</span><span class="p">);</span>

	<span class="n">real_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_end</span><span class="p">;</span>
	<span class="n">num_kernel_image_mappings</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">real_end</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Kernel: Using %d locked TLB entries for main kernel image.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">num_kernel_image_mappings</span><span class="p">);</span>

	<span class="cm">/* Set kernel pgd to upper alias so physical page computations</span>
<span class="cm">	 * work.</span>
<span class="cm">	 */</span>
	<span class="n">init_mm</span><span class="p">.</span><span class="n">pgd</span> <span class="o">+=</span> <span class="p">((</span><span class="n">shift</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pgd_t</span><span class="p">)));</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="n">swapper_low_pmd_dir</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">swapper_low_pmd_dir</span><span class="p">));</span>

	<span class="cm">/* Now can init the kernel/bad page tables. */</span>
	<span class="n">pud_set</span><span class="p">(</span><span class="n">pud_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapper_pg_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">swapper_low_pmd_dir</span> <span class="o">+</span> <span class="p">(</span><span class="n">shift</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pgd_t</span><span class="p">)));</span>
	
	<span class="n">inherit_prom_mappings</span><span class="p">();</span>
	
	<span class="n">init_kpte_bitmap</span><span class="p">();</span>

	<span class="cm">/* Ok, we can use our TLB miss and window trap handlers safely.  */</span>
	<span class="n">setup_tba</span><span class="p">();</span>

	<span class="n">__flush_tlb_all</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="n">sun4v_ktsb_register</span><span class="p">();</span>

	<span class="n">prom_build_devicetree</span><span class="p">();</span>
	<span class="n">of_populate_present_mask</span><span class="p">();</span>
<span class="cp">#ifndef CONFIG_SMP</span>
	<span class="n">of_fill_in_cpu_data</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sun4v_mdesc_init</span><span class="p">();</span>
		<span class="n">mdesc_populate_present_mask</span><span class="p">(</span><span class="n">cpu_all_mask</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_SMP</span>
		<span class="n">mdesc_fill_in_cpu_data</span><span class="p">(</span><span class="n">cpu_all_mask</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* Setup bootmem... */</span>
	<span class="n">last_valid_pfn</span> <span class="o">=</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">bootmem_init</span><span class="p">(</span><span class="n">phys_base</span><span class="p">);</span>

	<span class="cm">/* Once the OF device tree and MDESC have been setup, we know</span>
<span class="cm">	 * the list of possible cpus.  Therefore we can allocate the</span>
<span class="cm">	 * IRQ stacks.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="n">softirq_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__alloc_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">),</span>
							<span class="n">THREAD_SIZE</span><span class="p">,</span>
							<span class="n">THREAD_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">hardirq_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__alloc_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">),</span>
							<span class="n">THREAD_SIZE</span><span class="p">,</span>
							<span class="n">THREAD_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kernel_physical_mapping_init</span><span class="p">();</span>

	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">));</span>

		<span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>

		<span class="n">free_area_init_nodes</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Booting Linux...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">page_in_phys_avail</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">paddr</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pavail_ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">paddr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;=</span> <span class="n">kern_base</span> <span class="o">&amp;&amp;</span> <span class="n">paddr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">kern_base</span> <span class="o">+</span> <span class="n">kern_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">initrd_start</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">paddr</span> <span class="o">&lt;</span> <span class="n">__pa</span><span class="p">(</span><span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">initrd_end</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">linux_prom64_registers</span> <span class="n">pavail_rescan</span><span class="p">[</span><span class="n">MAX_BANKS</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pavail_rescan_ents</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="cm">/* Certain OBP calls, such as fetching &quot;available&quot; properties, can</span>
<span class="cm"> * claim physical memory.  So, along with initializing the valid</span>
<span class="cm"> * address bitmap, what we do here is refetch the physical available</span>
<span class="cm"> * memory list again, and make sure it provides at least as much</span>
<span class="cm"> * memory as &#39;pavail&#39; does.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_valid_addr_bitmap_from_pavail</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">read_obp_memory</span><span class="p">(</span><span class="s">&quot;available&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavail_rescan</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pavail_rescan_ents</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pavail_ents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_start</span><span class="p">,</span> <span class="n">old_end</span><span class="p">;</span>

		<span class="n">old_start</span> <span class="o">=</span> <span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
		<span class="n">old_end</span> <span class="o">=</span> <span class="n">old_start</span> <span class="o">+</span> <span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">old_start</span> <span class="o">&lt;</span> <span class="n">old_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">pavail_rescan_ents</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_start</span><span class="p">,</span> <span class="n">new_end</span><span class="p">;</span>

				<span class="n">new_start</span> <span class="o">=</span> <span class="n">pavail_rescan</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">;</span>
				<span class="n">new_end</span> <span class="o">=</span> <span class="n">new_start</span> <span class="o">+</span>
					<span class="n">pavail_rescan</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">reg_size</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">new_start</span> <span class="o">&lt;=</span> <span class="n">old_start</span> <span class="o">&amp;&amp;</span>
				    <span class="n">new_end</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">old_start</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">set_bit</span><span class="p">(</span><span class="n">old_start</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">do_next_page</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;mem_init: Lost memory in pavail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;mem_init: OLD start[%lx] size[%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span>
				    <span class="n">pavail</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span><span class="p">);</span>
			<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;mem_init: NEW start[%lx] size[%lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">pavail_rescan</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span>
				    <span class="n">pavail_rescan</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg_size</span><span class="p">);</span>
			<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;mem_init: Cannot continue, aborting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">prom_halt</span><span class="p">();</span>

		<span class="nl">do_next_page:</span>
			<span class="n">old_start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">patch_tlb_miss_handler_bitmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_addr_bitmap_insn</span><span class="p">[];</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_addr_bitmap_patch</span><span class="p">[];</span>

	<span class="n">valid_addr_bitmap_insn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_addr_bitmap_patch</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">valid_addr_bitmap_insn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_addr_bitmap_patch</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">flushi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">valid_addr_bitmap_insn</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">mem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">codepages</span><span class="p">,</span> <span class="n">datapages</span><span class="p">,</span> <span class="n">initpages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">kern_base</span><span class="p">;</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">kern_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">,</span> <span class="n">sparc64_valid_addr_bitmap</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">setup_valid_addr_bitmap_from_pavail</span><span class="p">(</span><span class="n">sparc64_valid_addr_bitmap</span><span class="p">);</span>
	<span class="n">patch_tlb_miss_handler_bitmap</span><span class="p">();</span>

	<span class="n">high_memory</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">last_valid_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NEED_MULTIPLE_NODES</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">totalram_pages</span> <span class="o">+=</span>
					<span class="n">free_all_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_low_memory_core_early</span><span class="p">(</span><span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">totalram_pages</span> <span class="o">=</span> <span class="n">free_all_bootmem</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* We subtract one to account for the mem_map_zero page</span>
<span class="cm">	 * allocated below.</span>
<span class="cm">	 */</span>
	<span class="n">totalram_pages</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">num_physpages</span> <span class="o">=</span> <span class="n">totalram_pages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the zero page, mark it reserved, so that page count</span>
<span class="cm">	 * is not manipulated when freeing the page from user ptes.</span>
<span class="cm">	 */</span>
	<span class="n">mem_map_zero</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_map_zero</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prom_printf</span><span class="p">(</span><span class="s">&quot;paging_init: Cannot alloc zero page.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">prom_halt</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">SetPageReserved</span><span class="p">(</span><span class="n">mem_map_zero</span><span class="p">);</span>

	<span class="n">codepages</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_etext</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_start</span><span class="p">));</span>
	<span class="n">codepages</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">codepages</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">datapages</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_edata</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_etext</span><span class="p">));</span>
	<span class="n">datapages</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">datapages</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">initpages</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__init_end</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__init_begin</span><span class="p">));</span>
	<span class="n">initpages</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">initpages</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Memory: %luk available (%ldk kernel code, %ldk data, %ldk init) [%016lx,%016lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">nr_free_pages</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
	       <span class="n">codepages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
	       <span class="n">datapages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span> 
	       <span class="n">initpages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span> 
	       <span class="n">PAGE_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="n">last_valid_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah</span> <span class="o">||</span> <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span><span class="p">)</span>
		<span class="n">cheetah_ecache_flush_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_initmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">initend</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* If the physical memory maps were trimmed by kernel command</span>
<span class="cm">	 * line options, don&#39;t even try freeing this initmem stuff up.</span>
<span class="cm">	 * The kernel image could have been in the trimmed out region</span>
<span class="cm">	 * and if so the freeing below will free invalid page structs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmdline_memory_size</span><span class="p">)</span>
		<span class="n">do_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The init section is aligned to 8k in vmlinux.lds. Page align for &gt;8k pagesizes.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">__init_begin</span><span class="p">));</span>
	<span class="n">initend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">__init_end</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">initend</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">kern_base</span><span class="p">))</span> <span class="o">-</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">KERNBASE</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">POISON_FREE_INITMEM</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">do_free</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

			<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">init_page_count</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">__free_page</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">num_physpages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">totalram_pages</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="kt">void</span> <span class="nf">free_initrd_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;Freeing initrd memory: %ldk freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>

		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">num_physpages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">totalram_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define _PAGE_CACHE_4U	(_PAGE_CP_4U | _PAGE_CV_4U)</span>
<span class="cp">#define _PAGE_CACHE_4V	(_PAGE_CP_4V | _PAGE_CV_4V)</span>
<span class="cp">#define __DIRTY_BITS_4U	 (_PAGE_MODIFIED_4U | _PAGE_WRITE_4U | _PAGE_W_4U)</span>
<span class="cp">#define __DIRTY_BITS_4V	 (_PAGE_MODIFIED_4V | _PAGE_WRITE_4V | _PAGE_W_4V)</span>
<span class="cp">#define __ACCESS_BITS_4U (_PAGE_ACCESSED_4U | _PAGE_READ_4U | _PAGE_R)</span>
<span class="cp">#define __ACCESS_BITS_4V (_PAGE_ACCESSED_4V | _PAGE_READ_4V | _PAGE_R)</span>

<span class="n">pgprot_t</span> <span class="n">PAGE_KERNEL</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">);</span>

<span class="n">pgprot_t</span> <span class="n">PAGE_KERNEL_LOCKED</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">pgprot_t</span> <span class="n">PAGE_COPY</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="n">pgprot_t</span> <span class="n">PAGE_SHARED</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">PAGE_SHARED</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pg_iobits</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_PAGE_IE</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">_PAGE_IE</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_PAGE_E</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">_PAGE_E</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_PAGE_CACHE</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">_PAGE_CACHE</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SPARSEMEM_VMEMMAP</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vmemmap_table</span><span class="p">[</span><span class="n">VMEMMAP_SIZE</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">__meminit</span> <span class="nf">vmemmap_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vstart</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">nr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">vstart</span> <span class="o">-</span> <span class="n">VMEMMAP_BASE</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">vend</span> <span class="o">-</span> <span class="n">VMEMMAP_BASE</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">phys_start</span> <span class="o">&amp;</span> <span class="n">VMEMMAP_CHUNK_MASK</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">VMEMMAP_ALIGN</span><span class="p">(</span><span class="n">phys_end</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte_base</span><span class="p">;</span>

	<span class="n">pte_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZ4MB_4U</span> <span class="o">|</span>
		    <span class="n">_PAGE_CP_4U</span> <span class="o">|</span> <span class="n">_PAGE_CV_4U</span> <span class="o">|</span>
		    <span class="n">_PAGE_P_4U</span> <span class="o">|</span> <span class="n">_PAGE_W_4U</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="n">pte_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZ4MB_4V</span> <span class="o">|</span>
			    <span class="n">_PAGE_CP_4V</span> <span class="o">|</span> <span class="n">_PAGE_CV_4V</span> <span class="o">|</span>
			    <span class="n">_PAGE_P_4V</span> <span class="o">|</span> <span class="n">_PAGE_W_4V</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">VMEMMAP_CHUNK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vmem_pp</span> <span class="o">=</span>
			<span class="n">vmemmap_table</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">VMEMMAP_CHUNK_SHIFT</span><span class="p">);</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">vmem_pp</span> <span class="o">&amp;</span> <span class="n">_PAGE_VALID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">block</span> <span class="o">=</span> <span class="n">vmemmap_alloc_block</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="o">*</span><span class="n">vmem_pp</span> <span class="o">=</span> <span class="n">pte_base</span> <span class="o">|</span> <span class="n">__pa</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;[%p-%p] page_structs=%lu &quot;</span>
			       <span class="s">&quot;node=%d entry=%lu/%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span>
			       <span class="n">node</span><span class="p">,</span>
			       <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">VMEMMAP_CHUNK_SHIFT</span><span class="p">,</span>
			       <span class="n">VMEMMAP_SIZE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPARSEMEM_VMEMMAP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prot_init_common</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_none</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_shared</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_copy</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_readonly</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_exec_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PAGE_COPY</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_copy</span><span class="p">);</span>
	<span class="n">PAGE_SHARED</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_shared</span><span class="p">);</span>

	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_none</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x1</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_readonly</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">page_exec_bit</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_copy</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">page_exec_bit</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x3</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_copy</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">page_exec_bit</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x4</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_readonly</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x5</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_readonly</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x6</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_copy</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x7</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_copy</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x8</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_none</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0x9</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_readonly</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">page_exec_bit</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0xa</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_shared</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">page_exec_bit</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0xb</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_shared</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">page_exec_bit</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0xc</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_readonly</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0xd</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_readonly</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0xe</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_shared</span><span class="p">);</span>
	<span class="n">protection_map</span><span class="p">[</span><span class="mh">0xf</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">page_shared</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sun4u_pgprot_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_none</span><span class="p">,</span> <span class="n">page_shared</span><span class="p">,</span> <span class="n">page_copy</span><span class="p">,</span> <span class="n">page_readonly</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_exec_bit</span><span class="p">;</span>

	<span class="n">PAGE_KERNEL</span> <span class="o">=</span> <span class="n">__pgprot</span> <span class="p">(</span><span class="n">_PAGE_PRESENT_4U</span> <span class="o">|</span> <span class="n">_PAGE_VALID</span> <span class="o">|</span>
				<span class="n">_PAGE_CACHE_4U</span> <span class="o">|</span> <span class="n">_PAGE_P_4U</span> <span class="o">|</span>
				<span class="n">__ACCESS_BITS_4U</span> <span class="o">|</span> <span class="n">__DIRTY_BITS_4U</span> <span class="o">|</span>
				<span class="n">_PAGE_EXEC_4U</span><span class="p">);</span>
	<span class="n">PAGE_KERNEL_LOCKED</span> <span class="o">=</span> <span class="n">__pgprot</span> <span class="p">(</span><span class="n">_PAGE_PRESENT_4U</span> <span class="o">|</span> <span class="n">_PAGE_VALID</span> <span class="o">|</span>
				       <span class="n">_PAGE_CACHE_4U</span> <span class="o">|</span> <span class="n">_PAGE_P_4U</span> <span class="o">|</span>
				       <span class="n">__ACCESS_BITS_4U</span> <span class="o">|</span> <span class="n">__DIRTY_BITS_4U</span> <span class="o">|</span>
				       <span class="n">_PAGE_EXEC_4U</span> <span class="o">|</span> <span class="n">_PAGE_L_4U</span><span class="p">);</span>

	<span class="n">_PAGE_IE</span> <span class="o">=</span> <span class="n">_PAGE_IE_4U</span><span class="p">;</span>
	<span class="n">_PAGE_E</span> <span class="o">=</span> <span class="n">_PAGE_E_4U</span><span class="p">;</span>
	<span class="n">_PAGE_CACHE</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_4U</span><span class="p">;</span>

	<span class="n">pg_iobits</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT_4U</span> <span class="o">|</span> <span class="n">__DIRTY_BITS_4U</span> <span class="o">|</span>
		     <span class="n">__ACCESS_BITS_4U</span> <span class="o">|</span> <span class="n">_PAGE_E_4U</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZBITS_4U</span><span class="p">)</span> <span class="o">^</span>
		<span class="mh">0xfffff80000000000UL</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZ4MB_4U</span><span class="p">)</span> <span class="o">^</span>
		<span class="mh">0xfffff80000000000UL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">_PAGE_CP_4U</span> <span class="o">|</span> <span class="n">_PAGE_CV_4U</span> <span class="o">|</span>
				   <span class="n">_PAGE_P_4U</span> <span class="o">|</span> <span class="n">_PAGE_W_4U</span><span class="p">);</span>

	<span class="cm">/* XXX Should use 256MB on Panther. XXX */</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">_PAGE_SZBITS</span> <span class="o">=</span> <span class="n">_PAGE_SZBITS_4U</span><span class="p">;</span>
	<span class="n">_PAGE_ALL_SZ_BITS</span> <span class="o">=</span>  <span class="p">(</span><span class="n">_PAGE_SZ4MB_4U</span> <span class="o">|</span> <span class="n">_PAGE_SZ512K_4U</span> <span class="o">|</span>
			      <span class="n">_PAGE_SZ64K_4U</span> <span class="o">|</span> <span class="n">_PAGE_SZ8K_4U</span> <span class="o">|</span>
			      <span class="n">_PAGE_SZ32MB_4U</span> <span class="o">|</span> <span class="n">_PAGE_SZ256MB_4U</span><span class="p">);</span>


	<span class="n">page_none</span> <span class="o">=</span> <span class="n">_PAGE_PRESENT_4U</span> <span class="o">|</span> <span class="n">_PAGE_ACCESSED_4U</span> <span class="o">|</span> <span class="n">_PAGE_CACHE_4U</span><span class="p">;</span>
	<span class="n">page_shared</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT_4U</span> <span class="o">|</span> <span class="n">_PAGE_CACHE_4U</span> <span class="o">|</span>
		       <span class="n">__ACCESS_BITS_4U</span> <span class="o">|</span> <span class="n">_PAGE_WRITE_4U</span> <span class="o">|</span> <span class="n">_PAGE_EXEC_4U</span><span class="p">);</span>
	<span class="n">page_copy</span>   <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT_4U</span> <span class="o">|</span> <span class="n">_PAGE_CACHE_4U</span> <span class="o">|</span>
		       <span class="n">__ACCESS_BITS_4U</span> <span class="o">|</span> <span class="n">_PAGE_EXEC_4U</span><span class="p">);</span>
	<span class="n">page_readonly</span>   <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT_4U</span> <span class="o">|</span> <span class="n">_PAGE_CACHE_4U</span> <span class="o">|</span>
			   <span class="n">__ACCESS_BITS_4U</span> <span class="o">|</span> <span class="n">_PAGE_EXEC_4U</span><span class="p">);</span>

	<span class="n">page_exec_bit</span> <span class="o">=</span> <span class="n">_PAGE_EXEC_4U</span><span class="p">;</span>

	<span class="n">prot_init_common</span><span class="p">(</span><span class="n">page_none</span><span class="p">,</span> <span class="n">page_shared</span><span class="p">,</span> <span class="n">page_copy</span><span class="p">,</span> <span class="n">page_readonly</span><span class="p">,</span>
			 <span class="n">page_exec_bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sun4v_pgprot_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_none</span><span class="p">,</span> <span class="n">page_shared</span><span class="p">,</span> <span class="n">page_copy</span><span class="p">,</span> <span class="n">page_readonly</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_exec_bit</span><span class="p">;</span>

	<span class="n">PAGE_KERNEL</span> <span class="o">=</span> <span class="n">__pgprot</span> <span class="p">(</span><span class="n">_PAGE_PRESENT_4V</span> <span class="o">|</span> <span class="n">_PAGE_VALID</span> <span class="o">|</span>
				<span class="n">_PAGE_CACHE_4V</span> <span class="o">|</span> <span class="n">_PAGE_P_4V</span> <span class="o">|</span>
				<span class="n">__ACCESS_BITS_4V</span> <span class="o">|</span> <span class="n">__DIRTY_BITS_4V</span> <span class="o">|</span>
				<span class="n">_PAGE_EXEC_4V</span><span class="p">);</span>
	<span class="n">PAGE_KERNEL_LOCKED</span> <span class="o">=</span> <span class="n">PAGE_KERNEL</span><span class="p">;</span>

	<span class="n">_PAGE_IE</span> <span class="o">=</span> <span class="n">_PAGE_IE_4V</span><span class="p">;</span>
	<span class="n">_PAGE_E</span> <span class="o">=</span> <span class="n">_PAGE_E_4V</span><span class="p">;</span>
	<span class="n">_PAGE_CACHE</span> <span class="o">=</span> <span class="n">_PAGE_CACHE_4V</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZBITS_4V</span><span class="p">)</span> <span class="o">^</span>
		<span class="mh">0xfffff80000000000UL</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZ4MB_4V</span><span class="p">)</span> <span class="o">^</span>
		<span class="mh">0xfffff80000000000UL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">_PAGE_CP_4V</span> <span class="o">|</span> <span class="n">_PAGE_CV_4V</span> <span class="o">|</span>
				   <span class="n">_PAGE_P_4V</span> <span class="o">|</span> <span class="n">_PAGE_W_4V</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZBITS_4V</span><span class="p">)</span> <span class="o">^</span>
		<span class="mh">0xfffff80000000000UL</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZ256MB_4V</span><span class="p">)</span> <span class="o">^</span>
		<span class="mh">0xfffff80000000000UL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">kern_linear_pte_xor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">_PAGE_CP_4V</span> <span class="o">|</span> <span class="n">_PAGE_CV_4V</span> <span class="o">|</span>
				   <span class="n">_PAGE_P_4V</span> <span class="o">|</span> <span class="n">_PAGE_W_4V</span><span class="p">);</span>

	<span class="n">pg_iobits</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT_4V</span> <span class="o">|</span> <span class="n">__DIRTY_BITS_4V</span> <span class="o">|</span>
		     <span class="n">__ACCESS_BITS_4V</span> <span class="o">|</span> <span class="n">_PAGE_E_4V</span><span class="p">);</span>

	<span class="n">_PAGE_SZBITS</span> <span class="o">=</span> <span class="n">_PAGE_SZBITS_4V</span><span class="p">;</span>
	<span class="n">_PAGE_ALL_SZ_BITS</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_SZ16GB_4V</span> <span class="o">|</span> <span class="n">_PAGE_SZ2GB_4V</span> <span class="o">|</span>
			     <span class="n">_PAGE_SZ256MB_4V</span> <span class="o">|</span> <span class="n">_PAGE_SZ32MB_4V</span> <span class="o">|</span>
			     <span class="n">_PAGE_SZ4MB_4V</span> <span class="o">|</span> <span class="n">_PAGE_SZ512K_4V</span> <span class="o">|</span>
			     <span class="n">_PAGE_SZ64K_4V</span> <span class="o">|</span> <span class="n">_PAGE_SZ8K_4V</span><span class="p">);</span>

	<span class="n">page_none</span> <span class="o">=</span> <span class="n">_PAGE_PRESENT_4V</span> <span class="o">|</span> <span class="n">_PAGE_ACCESSED_4V</span> <span class="o">|</span> <span class="n">_PAGE_CACHE_4V</span><span class="p">;</span>
	<span class="n">page_shared</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT_4V</span> <span class="o">|</span> <span class="n">_PAGE_CACHE_4V</span> <span class="o">|</span>
		       <span class="n">__ACCESS_BITS_4V</span> <span class="o">|</span> <span class="n">_PAGE_WRITE_4V</span> <span class="o">|</span> <span class="n">_PAGE_EXEC_4V</span><span class="p">);</span>
	<span class="n">page_copy</span>   <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT_4V</span> <span class="o">|</span> <span class="n">_PAGE_CACHE_4V</span> <span class="o">|</span>
		       <span class="n">__ACCESS_BITS_4V</span> <span class="o">|</span> <span class="n">_PAGE_EXEC_4V</span><span class="p">);</span>
	<span class="n">page_readonly</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_PRESENT_4V</span> <span class="o">|</span> <span class="n">_PAGE_CACHE_4V</span> <span class="o">|</span>
			 <span class="n">__ACCESS_BITS_4V</span> <span class="o">|</span> <span class="n">_PAGE_EXEC_4V</span><span class="p">);</span>

	<span class="n">page_exec_bit</span> <span class="o">=</span> <span class="n">_PAGE_EXEC_4V</span><span class="p">;</span>

	<span class="n">prot_init_common</span><span class="p">(</span><span class="n">page_none</span><span class="p">,</span> <span class="n">page_shared</span><span class="p">,</span> <span class="n">page_copy</span><span class="p">,</span> <span class="n">page_readonly</span><span class="p">,</span>
			 <span class="n">page_exec_bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pte_sz_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span>:
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">_PAGE_SZ8K_4V</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>:
			<span class="k">return</span> <span class="n">_PAGE_SZ64K_4V</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span>:
			<span class="k">return</span> <span class="n">_PAGE_SZ512K_4V</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>:
			<span class="k">return</span> <span class="n">_PAGE_SZ4MB_4V</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span>:
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">_PAGE_SZ8K_4U</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>:
			<span class="k">return</span> <span class="n">_PAGE_SZ64K_4U</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span>:
			<span class="k">return</span> <span class="n">_PAGE_SZ512K_4U</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>:
			<span class="k">return</span> <span class="n">_PAGE_SZ4MB_4U</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">pte_t</span> <span class="nf">mk_pte_io</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">space</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>

	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span>  <span class="o">=</span> <span class="n">page</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">prot</span><span class="p">));</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">space</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">pte_sz_bits</span><span class="p">(</span><span class="n">page_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kern_large_tte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZ4MB_4U</span> <span class="o">|</span>
	       <span class="n">_PAGE_CP_4U</span> <span class="o">|</span> <span class="n">_PAGE_CV_4U</span> <span class="o">|</span> <span class="n">_PAGE_P_4U</span> <span class="o">|</span>
	       <span class="n">_PAGE_EXEC_4U</span> <span class="o">|</span> <span class="n">_PAGE_L_4U</span> <span class="o">|</span> <span class="n">_PAGE_W_4U</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_SZ4MB_4V</span> <span class="o">|</span>
		       <span class="n">_PAGE_CP_4V</span> <span class="o">|</span> <span class="n">_PAGE_CV_4V</span> <span class="o">|</span> <span class="n">_PAGE_P_4V</span> <span class="o">|</span>
		       <span class="n">_PAGE_EXEC_4V</span> <span class="o">|</span> <span class="n">_PAGE_W_4V</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">val</span> <span class="o">|</span> <span class="n">paddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If not locked, zap it. */</span>
<span class="kt">void</span> <span class="nf">__flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pstate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;flushw</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;rdpr	%%pstate, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;wrpr	%0, %1, %%pstate&quot;</span>
			     <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">)</span>
			     <span class="o">:</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">PSTATE_IE</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">hypervisor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sun4v_mmu_demap_all</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Spitfire Errata #32 workaround */</span>
			<span class="cm">/* NOTE: Always runs on spitfire, so no</span>
<span class="cm">			 *       cheetah+ page size encodings.</span>
<span class="cm">			 */</span>
			<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;stxa	%0, [%1] %2</span><span class="se">\n\t</span><span class="s">&quot;</span>
					     <span class="s">&quot;flush	%%g6&quot;</span>
					     <span class="o">:</span> <span class="cm">/* No outputs */</span>
					     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="mi">0</span><span class="p">),</span>
					     <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">PRIMARY_CONTEXT</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_DMMU</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spitfire_get_dtlb_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_L_4U</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;stxa %%g0, [%0] %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
						     <span class="s">&quot;membar #Sync&quot;</span>
						     <span class="o">:</span> <span class="cm">/* no outputs */</span>
						     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">TLB_TAG_ACCESS</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_DMMU</span><span class="p">));</span>
				<span class="n">spitfire_put_dtlb_data</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x0UL</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Spitfire Errata #32 workaround */</span>
			<span class="cm">/* NOTE: Always runs on spitfire, so no</span>
<span class="cm">			 *       cheetah+ page size encodings.</span>
<span class="cm">			 */</span>
			<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;stxa	%0, [%1] %2</span><span class="se">\n\t</span><span class="s">&quot;</span>
					     <span class="s">&quot;flush	%%g6&quot;</span>
					     <span class="o">:</span> <span class="cm">/* No outputs */</span>
					     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="mi">0</span><span class="p">),</span>
					     <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">PRIMARY_CONTEXT</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_DMMU</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spitfire_get_itlb_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_L_4U</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;stxa %%g0, [%0] %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
						     <span class="s">&quot;membar #Sync&quot;</span>
						     <span class="o">:</span> <span class="cm">/* no outputs */</span>
						     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">TLB_TAG_ACCESS</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_IMMU</span><span class="p">));</span>
				<span class="n">spitfire_put_itlb_data</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x0UL</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah</span> <span class="o">||</span> <span class="n">tlb_type</span> <span class="o">==</span> <span class="n">cheetah_plus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cheetah_flush_dtlb_all</span><span class="p">();</span>
		<span class="n">cheetah_flush_itlb_all</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;wrpr	%0, 0, %%pstate&quot;</span>
			     <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pstate</span><span class="p">));</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
