<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › net › bpf_jit_comp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bpf_jit_comp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/moduleloader.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/filter.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>

<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>

<span class="cp">#include &quot;bpf_jit.h&quot;</span>

<span class="kt">int</span> <span class="n">bpf_jit_enable</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_simm13</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">value</span> <span class="o">+</span> <span class="mh">0x1000</span> <span class="o">&lt;</span> <span class="mh">0x2000</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bpf_flush_icache</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start_</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end_</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SPARC64</span>
	<span class="cm">/* Cheetah&#39;s I-cache is fully coherent.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlb_type</span> <span class="o">==</span> <span class="n">spitfire</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">start_</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">end_</span><span class="p">;</span>

		<span class="n">start</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">7UL</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">7UL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7UL</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flushi</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#define SEEN_DATAREF 1 </span><span class="cm">/* might call external helpers */</span><span class="cp"></span>
<span class="cp">#define SEEN_XREG    2 </span><span class="cm">/* ebx is used */</span><span class="cp"></span>
<span class="cp">#define SEEN_MEM     4 </span><span class="cm">/* use mem[] for temporary storage */</span><span class="cp"></span>

<span class="cp">#define S13(X)		((X) &amp; 0x1fff)</span>
<span class="cp">#define IMMED		0x00002000</span>
<span class="cp">#define RD(X)		((X) &lt;&lt; 25)</span>
<span class="cp">#define RS1(X)		((X) &lt;&lt; 14)</span>
<span class="cp">#define RS2(X)		((X))</span>
<span class="cp">#define OP(X)		((X) &lt;&lt; 30)</span>
<span class="cp">#define OP2(X)		((X) &lt;&lt; 22)</span>
<span class="cp">#define OP3(X)		((X) &lt;&lt; 19)</span>
<span class="cp">#define COND(X)		((X) &lt;&lt; 25)</span>
<span class="cp">#define F1(X)		OP(X)</span>
<span class="cp">#define F2(X, Y)	(OP(X) | OP2(Y))</span>
<span class="cp">#define F3(X, Y)	(OP(X) | OP3(Y))</span>

<span class="cp">#define CONDN		COND(0x0)</span>
<span class="cp">#define CONDE		COND(0x1)</span>
<span class="cp">#define CONDLE		COND(0x2)</span>
<span class="cp">#define CONDL		COND(0x3)</span>
<span class="cp">#define CONDLEU		COND(0x4)</span>
<span class="cp">#define CONDCS		COND(0x5)</span>
<span class="cp">#define CONDNEG		COND(0x6)</span>
<span class="cp">#define CONDVC		COND(0x7)</span>
<span class="cp">#define CONDA		COND(0x8)</span>
<span class="cp">#define CONDNE		COND(0x9)</span>
<span class="cp">#define CONDG		COND(0xa)</span>
<span class="cp">#define CONDGE		COND(0xb)</span>
<span class="cp">#define CONDGU		COND(0xc)</span>
<span class="cp">#define CONDCC		COND(0xd)</span>
<span class="cp">#define CONDPOS		COND(0xe)</span>
<span class="cp">#define CONDVS		COND(0xf)</span>

<span class="cp">#define CONDGEU		CONDCC</span>
<span class="cp">#define CONDLU		CONDCS</span>

<span class="cp">#define WDISP22(X)	(((X) &gt;&gt; 2) &amp; 0x3fffff)</span>

<span class="cp">#define BA		(F2(0, 2) | CONDA)</span>
<span class="cp">#define BGU		(F2(0, 2) | CONDGU)</span>
<span class="cp">#define BLEU		(F2(0, 2) | CONDLEU)</span>
<span class="cp">#define BGEU		(F2(0, 2) | CONDGEU)</span>
<span class="cp">#define BLU		(F2(0, 2) | CONDLU)</span>
<span class="cp">#define BE		(F2(0, 2) | CONDE)</span>
<span class="cp">#define BNE		(F2(0, 2) | CONDNE)</span>

<span class="cp">#ifdef CONFIG_SPARC64</span>
<span class="cp">#define BNE_PTR		(F2(0, 1) | CONDNE | (2 &lt;&lt; 20))</span>
<span class="cp">#else</span>
<span class="cp">#define BNE_PTR		BNE</span>
<span class="cp">#endif</span>

<span class="cp">#define SETHI(K, REG)	\</span>
<span class="cp">	(F2(0, 0x4) | RD(REG) | (((K) &gt;&gt; 10) &amp; 0x3fffff))</span>
<span class="cp">#define OR_LO(K, REG)	\</span>
<span class="cp">	(F3(2, 0x02) | IMMED | RS1(REG) | ((K) &amp; 0x3ff) | RD(REG))</span>

<span class="cp">#define ADD		F3(2, 0x00)</span>
<span class="cp">#define AND		F3(2, 0x01)</span>
<span class="cp">#define ANDCC		F3(2, 0x11)</span>
<span class="cp">#define OR		F3(2, 0x02)</span>
<span class="cp">#define SUB		F3(2, 0x04)</span>
<span class="cp">#define SUBCC		F3(2, 0x14)</span>
<span class="cp">#define MUL		F3(2, 0x0a)	</span><span class="cm">/* umul */</span><span class="cp"></span>
<span class="cp">#define DIV		F3(2, 0x0e)	</span><span class="cm">/* udiv */</span><span class="cp"></span>
<span class="cp">#define SLL		F3(2, 0x25)</span>
<span class="cp">#define SRL		F3(2, 0x26)</span>
<span class="cp">#define JMPL		F3(2, 0x38)</span>
<span class="cp">#define CALL		F1(1)</span>
<span class="cp">#define BR		F2(0, 0x01)</span>
<span class="cp">#define RD_Y		F3(2, 0x28)</span>
<span class="cp">#define WR_Y		F3(2, 0x30)</span>

<span class="cp">#define LD32		F3(3, 0x00)</span>
<span class="cp">#define LD8		F3(3, 0x01)</span>
<span class="cp">#define LD16		F3(3, 0x02)</span>
<span class="cp">#define LD64		F3(3, 0x0b)</span>
<span class="cp">#define ST32		F3(3, 0x04)</span>

<span class="cp">#ifdef CONFIG_SPARC64</span>
<span class="cp">#define LDPTR		LD64</span>
<span class="cp">#define BASE_STACKFRAME	176</span>
<span class="cp">#else</span>
<span class="cp">#define LDPTR		LD32</span>
<span class="cp">#define BASE_STACKFRAME	96</span>
<span class="cp">#endif</span>

<span class="cp">#define LD32I		(LD32 | IMMED)</span>
<span class="cp">#define LD8I		(LD8 | IMMED)</span>
<span class="cp">#define LD16I		(LD16 | IMMED)</span>
<span class="cp">#define LD64I		(LD64 | IMMED)</span>
<span class="cp">#define LDPTRI		(LDPTR | IMMED)</span>
<span class="cp">#define ST32I		(ST32 | IMMED)</span>

<span class="cp">#define emit_nop()		\</span>
<span class="cp">do {				\</span>
<span class="cp">	*prog++ = SETHI(0, G0);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_neg()					\</span>
<span class="cp">do {	</span><span class="cm">/* sub %g0, r_A, r_A */</span><span class="cp">				\</span>
<span class="cp">	*prog++ = SUB | RS1(G0) | RS2(r_A) | RD(r_A);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_reg_move(FROM, TO)				\</span>
<span class="cp">do {	</span><span class="cm">/* or %g0, FROM, TO */</span><span class="cp">				\</span>
<span class="cp">	*prog++ = OR | RS1(G0) | RS2(FROM) | RD(TO);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_clear(REG)					\</span>
<span class="cp">do {	</span><span class="cm">/* or %g0, %g0, REG */</span><span class="cp">				\</span>
<span class="cp">	*prog++ = OR | RS1(G0) | RS2(G0) | RD(REG);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_set_const(K, REG)					\</span>
<span class="cp">do {	</span><span class="cm">/* sethi %hi(K), REG */</span><span class="cp">					\</span>
<span class="cp">	*prog++ = SETHI(K, REG);				\</span>
<span class="cp">	</span><span class="cm">/* or REG, %lo(K), REG */</span><span class="cp">				\</span>
<span class="cp">	*prog++ = OR_LO(K, REG);				\</span>
<span class="cp">} while (0)</span>

	<span class="cm">/* Emit</span>
<span class="cm">	 *</span>
<span class="cm">	 *	OP	r_A, r_X, r_A</span>
<span class="cm">	 */</span>
<span class="cp">#define emit_alu_X(OPCODE)					\</span>
<span class="cp">do {								\</span>
<span class="cp">	seen |= SEEN_XREG;					\</span>
<span class="cp">	*prog++ = OPCODE | RS1(r_A) | RS2(r_X) | RD(r_A);	\</span>
<span class="cp">} while (0)</span>

	<span class="cm">/* Emit either:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	OP	r_A, K, r_A</span>
<span class="cm">	 *</span>
<span class="cm">	 * or</span>
<span class="cm">	 *</span>
<span class="cm">	 *	sethi	%hi(K), r_TMP</span>
<span class="cm">	 *	or	r_TMP, %lo(K), r_TMP</span>
<span class="cm">	 *	OP	r_A, r_TMP, r_A</span>
<span class="cm">	 *</span>
<span class="cm">	 * depending upon whether K fits in a signed 13-bit</span>
<span class="cm">	 * immediate instruction field.  Emit nothing if K</span>
<span class="cm">	 * is zero.</span>
<span class="cm">	 */</span>
<span class="cp">#define emit_alu_K(OPCODE, K)					\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (K) {						\</span>
<span class="cp">		unsigned int _insn = OPCODE;			\</span>
<span class="cp">		_insn |= RS1(r_A) | RD(r_A);			\</span>
<span class="cp">		if (is_simm13(K)) {				\</span>
<span class="cp">			*prog++ = _insn | IMMED | S13(K);	\</span>
<span class="cp">		} else {					\</span>
<span class="cp">			emit_set_const(K, r_TMP);		\</span>
<span class="cp">			*prog++ = _insn | RS2(r_TMP);		\</span>
<span class="cp">		}						\</span>
<span class="cp">	}							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_loadimm(K, DEST)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (is_simm13(K)) {						\</span>
<span class="cp">		</span><span class="cm">/* or %g0, K, DEST */</span><span class="cp">					\</span>
<span class="cp">		*prog++ = OR | IMMED | RS1(G0) | S13(K) | RD(DEST);	\</span>
<span class="cp">	} else {							\</span>
<span class="cp">		emit_set_const(K, DEST);				\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_loadptr(BASE, STRUCT, FIELD, DEST)				\</span>
<span class="cp">do {	unsigned int _off = offsetof(STRUCT, FIELD);			\</span>
<span class="cp">	BUILD_BUG_ON(FIELD_SIZEOF(STRUCT, FIELD) != sizeof(void *));	\</span>
<span class="cp">	*prog++ = LDPTRI | RS1(BASE) | S13(_off) | RD(DEST);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_load32(BASE, STRUCT, FIELD, DEST)				\</span>
<span class="cp">do {	unsigned int _off = offsetof(STRUCT, FIELD);			\</span>
<span class="cp">	BUILD_BUG_ON(FIELD_SIZEOF(STRUCT, FIELD) != sizeof(u32));	\</span>
<span class="cp">	*prog++ = LD32I | RS1(BASE) | S13(_off) | RD(DEST);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_load16(BASE, STRUCT, FIELD, DEST)				\</span>
<span class="cp">do {	unsigned int _off = offsetof(STRUCT, FIELD);			\</span>
<span class="cp">	BUILD_BUG_ON(FIELD_SIZEOF(STRUCT, FIELD) != sizeof(u16));	\</span>
<span class="cp">	*prog++ = LD16I | RS1(BASE) | S13(_off) | RD(DEST);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define __emit_load8(BASE, STRUCT, FIELD, DEST)				\</span>
<span class="cp">do {	unsigned int _off = offsetof(STRUCT, FIELD);			\</span>
<span class="cp">	*prog++ = LD8I | RS1(BASE) | S13(_off) | RD(DEST);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_load8(BASE, STRUCT, FIELD, DEST)				\</span>
<span class="cp">do {	BUILD_BUG_ON(FIELD_SIZEOF(STRUCT, FIELD) != sizeof(u8));	\</span>
<span class="cp">	__emit_load8(BASE, STRUCT, FIELD, DEST);			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_ldmem(OFF, DEST)					\</span>
<span class="cp">do {	*prog++ = LD32I | RS1(FP) | S13(-(OFF)) | RD(DEST);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_stmem(OFF, SRC)					\</span>
<span class="cp">do {	*prog++ = LD32I | RS1(FP) | S13(-(OFF)) | RD(SRC);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#ifdef CONFIG_SPARC64</span>
<span class="cp">#define emit_load_cpu(REG)						\</span>
<span class="cp">	emit_load16(G6, struct thread_info, cpu, REG)</span>
<span class="cp">#else</span>
<span class="cp">#define emit_load_cpu(REG)						\</span>
<span class="cp">	emit_load32(G6, struct thread_info, cpu, REG)</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="cp">#define emit_load_cpu(REG)	emit_clear(REG)</span>
<span class="cp">#endif</span>

<span class="cp">#define emit_skb_loadptr(FIELD, DEST) \</span>
<span class="cp">	emit_loadptr(r_SKB, struct sk_buff, FIELD, DEST)</span>
<span class="cp">#define emit_skb_load32(FIELD, DEST) \</span>
<span class="cp">	emit_load32(r_SKB, struct sk_buff, FIELD, DEST)</span>
<span class="cp">#define emit_skb_load16(FIELD, DEST) \</span>
<span class="cp">	emit_load16(r_SKB, struct sk_buff, FIELD, DEST)</span>
<span class="cp">#define __emit_skb_load8(FIELD, DEST) \</span>
<span class="cp">	__emit_load8(r_SKB, struct sk_buff, FIELD, DEST)</span>
<span class="cp">#define emit_skb_load8(FIELD, DEST) \</span>
<span class="cp">	emit_load8(r_SKB, struct sk_buff, FIELD, DEST)</span>

<span class="cp">#define emit_jmpl(BASE, IMM_OFF, LREG) \</span>
<span class="cp">	*prog++ = (JMPL | IMMED | RS1(BASE) | S13(IMM_OFF) | RD(LREG))</span>

<span class="cp">#define emit_call(FUNC)					\</span>
<span class="cp">do {	void *_here = image + addrs[i] - 8;		\</span>
<span class="cp">	unsigned int _off = (void *)(FUNC) - _here;	\</span>
<span class="cp">	*prog++ = CALL | (((_off) &gt;&gt; 2) &amp; 0x3fffffff);	\</span>
<span class="cp">	emit_nop();					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_branch(BR_OPC, DEST)			\</span>
<span class="cp">do {	unsigned int _here = addrs[i] - 8;		\</span>
<span class="cp">	*prog++ = BR_OPC | WDISP22((DEST) - _here);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_branch_off(BR_OPC, OFF)			\</span>
<span class="cp">do {	*prog++ = BR_OPC | WDISP22(OFF);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define emit_jump(DEST)		emit_branch(BA, DEST)</span>

<span class="cp">#define emit_read_y(REG)	*prog++ = RD_Y | RD(REG)</span>
<span class="cp">#define emit_write_y(REG)	*prog++ = WR_Y | IMMED | RS1(REG) | S13(0)</span>

<span class="cp">#define emit_cmp(R1, R2) \</span>
<span class="cp">	*prog++ = (SUBCC | RS1(R1) | RS2(R2) | RD(G0))</span>

<span class="cp">#define emit_cmpi(R1, IMM) \</span>
<span class="cp">	*prog++ = (SUBCC | IMMED | RS1(R1) | S13(IMM) | RD(G0));</span>

<span class="cp">#define emit_btst(R1, R2) \</span>
<span class="cp">	*prog++ = (ANDCC | RS1(R1) | RS2(R2) | RD(G0))</span>

<span class="cp">#define emit_btsti(R1, IMM) \</span>
<span class="cp">	*prog++ = (ANDCC | IMMED | RS1(R1) | S13(IMM) | RD(G0));</span>

<span class="cp">#define emit_sub(R1, R2, R3) \</span>
<span class="cp">	*prog++ = (SUB | RS1(R1) | RS2(R2) | RD(R3))</span>

<span class="cp">#define emit_subi(R1, IMM, R3) \</span>
<span class="cp">	*prog++ = (SUB | IMMED | RS1(R1) | S13(IMM) | RD(R3))</span>

<span class="cp">#define emit_add(R1, R2, R3) \</span>
<span class="cp">	*prog++ = (ADD | RS1(R1) | RS2(R2) | RD(R3))</span>

<span class="cp">#define emit_addi(R1, IMM, R3) \</span>
<span class="cp">	*prog++ = (ADD | IMMED | RS1(R1) | S13(IMM) | RD(R3))</span>

<span class="cp">#define emit_alloc_stack(SZ) \</span>
<span class="cp">	*prog++ = (SUB | IMMED | RS1(SP) | S13(SZ) | RD(SP))</span>

<span class="cp">#define emit_release_stack(SZ) \</span>
<span class="cp">	*prog++ = (ADD | IMMED | RS1(SP) | S13(SZ) | RD(SP))</span>

<span class="cm">/* A note about branch offset calculations.  The addrs[] array,</span>
<span class="cm"> * indexed by BPF instruction, records the address after all the</span>
<span class="cm"> * sparc instructions emitted for that BPF instruction.</span>
<span class="cm"> *</span>
<span class="cm"> * The most common case is to emit a branch at the end of such</span>
<span class="cm"> * a code sequence.  So this would be two instructions, the</span>
<span class="cm"> * branch and it&#39;s delay slot.</span>
<span class="cm"> *</span>
<span class="cm"> * Therefore by default the branch emitters calculate the branch</span>
<span class="cm"> * offset field as:</span>
<span class="cm"> *</span>
<span class="cm"> *	destination - (addrs[i] - 8)</span>
<span class="cm"> *</span>
<span class="cm"> * This &quot;addrs[i] - 8&quot; is the address of the branch itself or</span>
<span class="cm"> * what &quot;.&quot; would be in assembler notation.  The &quot;8&quot; part is</span>
<span class="cm"> * how we take into consideration the branch and it&#39;s delay</span>
<span class="cm"> * slot mentioned above.</span>
<span class="cm"> *</span>
<span class="cm"> * Sometimes we need to emit a branch earlier in the code</span>
<span class="cm"> * sequence.  And in these situations we adjust &quot;destination&quot;</span>
<span class="cm"> * to accomodate this difference.  For example, if we needed</span>
<span class="cm"> * to emit a branch (and it&#39;s delay slot) right before the</span>
<span class="cm"> * final instruction emitted for a BPF opcode, we&#39;d use</span>
<span class="cm"> * &quot;destination + 4&quot; instead of just plain &quot;destination&quot; above.</span>
<span class="cm"> *</span>
<span class="cm"> * This is why you see all of these funny emit_branch() and</span>
<span class="cm"> * emit_jump() calls with adjusted offsets.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">bpf_jit_compile</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cleanup_addr</span><span class="p">,</span> <span class="n">proglen</span><span class="p">,</span> <span class="n">oldproglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="o">*</span><span class="n">prog</span><span class="p">,</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pass</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sock_filter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">flen</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">pc_ret0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addrs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">image</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bpf_jit_enable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">addrs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">flen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addrs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Before first pass, make a rough estimation of addrs[]</span>
<span class="cm">	 * each bpf instruction is translated to less than 64 bytes</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">proglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">flen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proglen</span> <span class="o">+=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">proglen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cleanup_addr</span> <span class="o">=</span> <span class="n">proglen</span><span class="p">;</span> <span class="cm">/* epilogue address */</span>
	<span class="n">image</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pass</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">pass</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">seen_or_pass0</span> <span class="o">=</span> <span class="p">(</span><span class="n">pass</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">SEEN_XREG</span> <span class="o">|</span> <span class="n">SEEN_DATAREF</span> <span class="o">|</span> <span class="n">SEEN_MEM</span><span class="p">)</span> <span class="o">:</span> <span class="n">seen</span><span class="p">;</span>

		<span class="cm">/* no prologue/epilogue for trivial filters (RET something) */</span>
		<span class="n">proglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">prog</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

		<span class="cm">/* Prologue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seen_or_pass0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seen_or_pass0</span> <span class="o">&amp;</span> <span class="n">SEEN_MEM</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">BASE_STACKFRAME</span><span class="p">;</span>
				<span class="n">sz</span> <span class="o">+=</span> <span class="n">BPF_MEMWORDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
				<span class="n">emit_alloc_stack</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Make sure we dont leek kernel memory. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seen_or_pass0</span> <span class="o">&amp;</span> <span class="n">SEEN_XREG</span><span class="p">)</span>
				<span class="n">emit_clear</span><span class="p">(</span><span class="n">r_X</span><span class="p">);</span>

			<span class="cm">/* If this filter needs to access skb data,</span>
<span class="cm">			 * load %o4 and %o5 with:</span>
<span class="cm">			 *  %o4 = skb-&gt;len - skb-&gt;data_len</span>
<span class="cm">			 *  %o5 = skb-&gt;data</span>
<span class="cm">			 * And also back up %o7 into r_saved_O7 so we can</span>
<span class="cm">			 * invoke the stubs using &#39;call&#39;.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seen_or_pass0</span> <span class="o">&amp;</span> <span class="n">SEEN_DATAREF</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">emit_load32</span><span class="p">(</span><span class="n">r_SKB</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">r_HEADLEN</span><span class="p">);</span>
				<span class="n">emit_load32</span><span class="p">(</span><span class="n">r_SKB</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">r_TMP</span><span class="p">);</span>
				<span class="n">emit_sub</span><span class="p">(</span><span class="n">r_HEADLEN</span><span class="p">,</span> <span class="n">r_TMP</span><span class="p">,</span> <span class="n">r_HEADLEN</span><span class="p">);</span>
				<span class="n">emit_loadptr</span><span class="p">(</span><span class="n">r_SKB</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">r_SKB_DATA</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">emit_reg_move</span><span class="p">(</span><span class="n">O7</span><span class="p">,</span> <span class="n">r_saved_O7</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BPF_S_RET_K</span>:
		<span class="k">case</span> <span class="n">BPF_S_LD_W_LEN</span>:
		<span class="k">case</span> <span class="n">BPF_S_ANC_PROTOCOL</span>:
		<span class="k">case</span> <span class="n">BPF_S_ANC_PKTTYPE</span>:
		<span class="k">case</span> <span class="n">BPF_S_ANC_IFINDEX</span>:
		<span class="k">case</span> <span class="n">BPF_S_ANC_MARK</span>:
		<span class="k">case</span> <span class="n">BPF_S_ANC_RXHASH</span>:
		<span class="k">case</span> <span class="n">BPF_S_ANC_CPU</span>:
		<span class="k">case</span> <span class="n">BPF_S_ANC_QUEUE</span>:
		<span class="k">case</span> <span class="n">BPF_S_LD_W_ABS</span>:
		<span class="k">case</span> <span class="n">BPF_S_LD_H_ABS</span>:
		<span class="k">case</span> <span class="n">BPF_S_LD_B_ABS</span>:
			<span class="cm">/* The first instruction sets the A register (or is</span>
<span class="cm">			 * a &quot;RET &#39;constant&#39;&quot;)</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* Make sure we dont leak kernel information to the</span>
<span class="cm">			 * user.</span>
<span class="cm">			 */</span>
			<span class="n">emit_clear</span><span class="p">(</span><span class="n">r_A</span><span class="p">);</span> <span class="cm">/* A = 0 */</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">flen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">k</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t_offset</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_offset</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">t_op</span><span class="p">,</span> <span class="n">f_op</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">ilen</span><span class="p">;</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_ADD_X</span>:	<span class="cm">/* A += X; */</span>
				<span class="n">emit_alu_X</span><span class="p">(</span><span class="n">ADD</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_ADD_K</span>:	<span class="cm">/* A += K; */</span>
				<span class="n">emit_alu_K</span><span class="p">(</span><span class="n">ADD</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_SUB_X</span>:	<span class="cm">/* A -= X; */</span>
				<span class="n">emit_alu_X</span><span class="p">(</span><span class="n">SUB</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_SUB_K</span>:	<span class="cm">/* A -= K */</span>
				<span class="n">emit_alu_K</span><span class="p">(</span><span class="n">SUB</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_AND_X</span>:	<span class="cm">/* A &amp;= X */</span>
				<span class="n">emit_alu_X</span><span class="p">(</span><span class="n">AND</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_AND_K</span>:	<span class="cm">/* A &amp;= K */</span>
				<span class="n">emit_alu_K</span><span class="p">(</span><span class="n">AND</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_OR_X</span>:	<span class="cm">/* A |= X */</span>
				<span class="n">emit_alu_X</span><span class="p">(</span><span class="n">OR</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_OR_K</span>:	<span class="cm">/* A |= K */</span>
				<span class="n">emit_alu_K</span><span class="p">(</span><span class="n">OR</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_LSH_X</span>:	<span class="cm">/* A &lt;&lt;= X */</span>
				<span class="n">emit_alu_X</span><span class="p">(</span><span class="n">SLL</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_LSH_K</span>:	<span class="cm">/* A &lt;&lt;= K */</span>
				<span class="n">emit_alu_K</span><span class="p">(</span><span class="n">SLL</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_RSH_X</span>:	<span class="cm">/* A &gt;&gt;= X */</span>
				<span class="n">emit_alu_X</span><span class="p">(</span><span class="n">SRL</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_RSH_K</span>:	<span class="cm">/* A &gt;&gt;= K */</span>
				<span class="n">emit_alu_K</span><span class="p">(</span><span class="n">SRL</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_MUL_X</span>:	<span class="cm">/* A *= X; */</span>
				<span class="n">emit_alu_X</span><span class="p">(</span><span class="n">MUL</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_MUL_K</span>:	<span class="cm">/* A *= K */</span>
				<span class="n">emit_alu_K</span><span class="p">(</span><span class="n">MUL</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_DIV_K</span>:	<span class="cm">/* A /= K */</span>
				<span class="n">emit_alu_K</span><span class="p">(</span><span class="n">MUL</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="n">emit_read_y</span><span class="p">(</span><span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_DIV_X</span>:	<span class="cm">/* A /= X; */</span>
				<span class="n">emit_cmpi</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pc_ret0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">t_offset</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">[</span><span class="n">pc_ret0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="cp">#ifdef CONFIG_SPARC32</span>
					<span class="n">emit_branch</span><span class="p">(</span><span class="n">BE</span><span class="p">,</span> <span class="n">t_offset</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>
<span class="cp">#else</span>
					<span class="n">emit_branch</span><span class="p">(</span><span class="n">BE</span><span class="p">,</span> <span class="n">t_offset</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
<span class="cp">#endif</span>
					<span class="n">emit_nop</span><span class="p">();</span> <span class="cm">/* delay slot */</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">emit_branch_off</span><span class="p">(</span><span class="n">BNE</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
					<span class="n">emit_nop</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_SPARC32</span>
					<span class="n">emit_jump</span><span class="p">(</span><span class="n">cleanup_addr</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>
<span class="cp">#else</span>
					<span class="n">emit_jump</span><span class="p">(</span><span class="n">cleanup_addr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
<span class="cp">#endif</span>
					<span class="n">emit_clear</span><span class="p">(</span><span class="n">r_A</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">emit_write_y</span><span class="p">(</span><span class="n">G0</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SPARC32</span>
				<span class="cm">/* The Sparc v8 architecture requires</span>
<span class="cm">				 * three instructions between a %y</span>
<span class="cm">				 * register write and the first use.</span>
<span class="cm">				 */</span>
				<span class="n">emit_nop</span><span class="p">();</span>
				<span class="n">emit_nop</span><span class="p">();</span>
				<span class="n">emit_nop</span><span class="p">();</span>
<span class="cp">#endif</span>
				<span class="n">emit_alu_X</span><span class="p">(</span><span class="n">DIV</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ALU_NEG</span>:
				<span class="n">emit_neg</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_RET_K</span>:
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">K</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pc_ret0</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
						<span class="n">pc_ret0</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="n">emit_clear</span><span class="p">(</span><span class="n">r_A</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">emit_loadimm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/* Fallthrough */</span>
			<span class="k">case</span> <span class="n">BPF_S_RET_A</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">seen_or_pass0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">flen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">emit_jump</span><span class="p">(</span><span class="n">cleanup_addr</span><span class="p">);</span>
						<span class="n">emit_nop</span><span class="p">();</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">seen_or_pass0</span> <span class="o">&amp;</span> <span class="n">SEEN_MEM</span><span class="p">)</span> <span class="p">{</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">BASE_STACKFRAME</span><span class="p">;</span>
						<span class="n">sz</span> <span class="o">+=</span> <span class="n">BPF_MEMWORDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
						<span class="n">emit_release_stack</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="cm">/* jmpl %r_saved_O7 + 8, %g0 */</span>
				<span class="n">emit_jmpl</span><span class="p">(</span><span class="n">r_saved_O7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">G0</span><span class="p">);</span>
				<span class="n">emit_reg_move</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">O0</span><span class="p">);</span> <span class="cm">/* delay slot */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_MISC_TAX</span>:
				<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="n">emit_reg_move</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_MISC_TXA</span>:
				<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="n">emit_reg_move</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ANC_CPU</span>:
				<span class="n">emit_load_cpu</span><span class="p">(</span><span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ANC_PROTOCOL</span>:
				<span class="n">emit_skb_load16</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">				/* GCC won&#39;t let us take the address of</span>
<span class="c">				 * a bit field even though we very much</span>
<span class="c">				 * know what we are doing here.</span>
<span class="c">				 */</span>
<span class="c">			case BPF_S_ANC_PKTTYPE:</span>
<span class="c">				__emit_skb_load8(pkt_type, r_A);</span>
<span class="c">				emit_alu_K(SRL, 5);</span>
<span class="c">				break;</span>
<span class="cp">#endif</span>
			<span class="k">case</span> <span class="n">BPF_S_ANC_IFINDEX</span>:
				<span class="n">emit_skb_loadptr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="n">emit_cmpi</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">emit_branch</span><span class="p">(</span><span class="n">BNE_PTR</span><span class="p">,</span> <span class="n">cleanup_addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
				<span class="n">emit_nop</span><span class="p">();</span>
				<span class="n">emit_load32</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ANC_MARK</span>:
				<span class="n">emit_skb_load32</span><span class="p">(</span><span class="n">mark</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ANC_QUEUE</span>:
				<span class="n">emit_skb_load16</span><span class="p">(</span><span class="n">queue_mapping</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ANC_HATYPE</span>:
				<span class="n">emit_skb_loadptr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="n">emit_cmpi</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">emit_branch</span><span class="p">(</span><span class="n">BNE_PTR</span><span class="p">,</span> <span class="n">cleanup_addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
				<span class="n">emit_nop</span><span class="p">();</span>
				<span class="n">emit_load16</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ANC_RXHASH</span>:
				<span class="n">emit_skb_load32</span><span class="p">(</span><span class="n">rxhash</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">BPF_S_LD_IMM</span>:
				<span class="n">emit_loadimm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_LDX_IMM</span>:
				<span class="n">emit_loadimm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_LD_MEM</span>:
				<span class="n">emit_ldmem</span><span class="p">(</span><span class="n">K</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_LDX_MEM</span>:
				<span class="n">emit_ldmem</span><span class="p">(</span><span class="n">K</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_ST</span>:
				<span class="n">emit_stmem</span><span class="p">(</span><span class="n">K</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_STX</span>:
				<span class="n">emit_stmem</span><span class="p">(</span><span class="n">K</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

<span class="cp">#define CHOOSE_LOAD_FUNC(K, func) \</span>
<span class="cp">	((int)K &lt; 0 ? ((int)K &gt;= SKF_LL_OFF ? func##_negative_offset : func) : func##_positive_offset)</span>

			<span class="k">case</span> <span class="n">BPF_S_LD_W_ABS</span>:
				<span class="n">func</span> <span class="o">=</span> <span class="n">CHOOSE_LOAD_FUNC</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">bpf_jit_load_word</span><span class="p">);</span>
<span class="nl">common_load:</span>			<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_DATAREF</span><span class="p">;</span>
				<span class="n">emit_loadimm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">r_OFF</span><span class="p">);</span>
				<span class="n">emit_call</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_LD_H_ABS</span>:
				<span class="n">func</span> <span class="o">=</span> <span class="n">CHOOSE_LOAD_FUNC</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">bpf_jit_load_half</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">common_load</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_LD_B_ABS</span>:
				<span class="n">func</span> <span class="o">=</span> <span class="n">CHOOSE_LOAD_FUNC</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">bpf_jit_load_byte</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">common_load</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_LDX_B_MSH</span>:
				<span class="n">func</span> <span class="o">=</span> <span class="n">CHOOSE_LOAD_FUNC</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">bpf_jit_load_byte_msh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">common_load</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_LD_W_IND</span>:
				<span class="n">func</span> <span class="o">=</span> <span class="n">bpf_jit_load_word</span><span class="p">;</span>
<span class="nl">common_load_ind:</span>		<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_DATAREF</span> <span class="o">|</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_simm13</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">emit_addi</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">r_OFF</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">emit_loadimm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">r_TMP</span><span class="p">);</span>
						<span class="n">emit_add</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="n">r_TMP</span><span class="p">,</span> <span class="n">r_OFF</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">emit_reg_move</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="n">r_OFF</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">emit_call</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_LD_H_IND</span>:
				<span class="n">func</span> <span class="o">=</span> <span class="n">bpf_jit_load_half</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">common_load_ind</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_LD_B_IND</span>:
				<span class="n">func</span> <span class="o">=</span> <span class="n">bpf_jit_load_byte</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">common_load_ind</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_JMP_JA</span>:
				<span class="n">emit_jump</span><span class="p">(</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">K</span><span class="p">]);</span>
				<span class="n">emit_nop</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>

<span class="cp">#define COND_SEL(CODE, TOP, FOP)	\</span>
<span class="cp">	case CODE:			\</span>
<span class="cp">		t_op = TOP;		\</span>
<span class="cp">		f_op = FOP;		\</span>
<span class="cp">		goto cond_branch</span>

			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JGT_K</span><span class="p">,</span> <span class="n">BGU</span><span class="p">,</span> <span class="n">BLEU</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JGE_K</span><span class="p">,</span> <span class="n">BGEU</span><span class="p">,</span> <span class="n">BLU</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JEQ_K</span><span class="p">,</span> <span class="n">BE</span><span class="p">,</span> <span class="n">BNE</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JSET_K</span><span class="p">,</span> <span class="n">BNE</span><span class="p">,</span> <span class="n">BE</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JGT_X</span><span class="p">,</span> <span class="n">BGU</span><span class="p">,</span> <span class="n">BLEU</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JGE_X</span><span class="p">,</span> <span class="n">BGEU</span><span class="p">,</span> <span class="n">BLU</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JEQ_X</span><span class="p">,</span> <span class="n">BE</span><span class="p">,</span> <span class="n">BNE</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JSET_X</span><span class="p">,</span> <span class="n">BNE</span><span class="p">,</span> <span class="n">BE</span><span class="p">);</span>

<span class="nl">cond_branch:</span>			<span class="n">f_offset</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">];</span>
				<span class="n">t_offset</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span><span class="p">];</span>

				<span class="cm">/* same targets, can avoid doing the test :) */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span> <span class="o">==</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">emit_jump</span><span class="p">(</span><span class="n">t_offset</span><span class="p">);</span>
					<span class="n">emit_nop</span><span class="p">();</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">switch</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">BPF_S_JMP_JGT_X</span>:
				<span class="k">case</span> <span class="n">BPF_S_JMP_JGE_X</span>:
				<span class="k">case</span> <span class="n">BPF_S_JMP_JEQ_X</span>:
					<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
					<span class="n">emit_cmp</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">BPF_S_JMP_JSET_X</span>:
					<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
					<span class="n">emit_btst</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">BPF_S_JMP_JEQ_K</span>:
				<span class="k">case</span> <span class="n">BPF_S_JMP_JGT_K</span>:
				<span class="k">case</span> <span class="n">BPF_S_JMP_JGE_K</span>:
					<span class="k">if</span> <span class="p">(</span><span class="n">is_simm13</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">emit_cmpi</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">emit_loadimm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">r_TMP</span><span class="p">);</span>
						<span class="n">emit_cmp</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_TMP</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">BPF_S_JMP_JSET_K</span>:
					<span class="k">if</span> <span class="p">(</span><span class="n">is_simm13</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">emit_btsti</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">emit_loadimm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">r_TMP</span><span class="p">);</span>
						<span class="n">emit_btst</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_TMP</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">)</span>
						<span class="n">t_offset</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
					<span class="n">emit_branch</span><span class="p">(</span><span class="n">t_op</span><span class="p">,</span> <span class="n">t_offset</span><span class="p">);</span>
					<span class="n">emit_nop</span><span class="p">();</span> <span class="cm">/* delay slot */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">emit_jump</span><span class="p">(</span><span class="n">f_offset</span><span class="p">);</span>
						<span class="n">emit_nop</span><span class="p">();</span>
					<span class="p">}</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">emit_branch</span><span class="p">(</span><span class="n">f_op</span><span class="p">,</span> <span class="n">f_offset</span><span class="p">);</span>
				<span class="n">emit_nop</span><span class="p">();</span> <span class="cm">/* delay slot */</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span>
				<span class="cm">/* hmm, too complex filter, give up with jit compiler */</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ilen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">prog</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">temp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">proglen</span> <span class="o">+</span> <span class="n">ilen</span> <span class="o">&gt;</span> <span class="n">oldproglen</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;bpb_jit_compile fatal error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">addrs</span><span class="p">);</span>
					<span class="n">module_free</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">image</span> <span class="o">+</span> <span class="n">proglen</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ilen</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">proglen</span> <span class="o">+=</span> <span class="n">ilen</span><span class="p">;</span>
			<span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">proglen</span><span class="p">;</span>
			<span class="n">prog</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* last bpf instruction is always a RET :</span>
<span class="cm">		 * use it to give the cleanup instruction(s) addr</span>
<span class="cm">		 */</span>
		<span class="n">cleanup_addr</span> <span class="o">=</span> <span class="n">proglen</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* jmpl; mov r_A,%o0; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seen_or_pass0</span> <span class="o">&amp;</span> <span class="n">SEEN_MEM</span><span class="p">)</span>
			<span class="n">cleanup_addr</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* add %sp, X, %sp; */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">proglen</span> <span class="o">!=</span> <span class="n">oldproglen</span><span class="p">)</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;bpb_jit_compile proglen=%u != oldproglen=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">proglen</span><span class="p">,</span> <span class="n">oldproglen</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proglen</span> <span class="o">==</span> <span class="n">oldproglen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">image</span> <span class="o">=</span> <span class="n">module_alloc</span><span class="p">(</span><span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
						   <span class="n">proglen</span><span class="p">,</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span><span class="p">)));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">oldproglen</span> <span class="o">=</span> <span class="n">proglen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bpf_jit_enable</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;flen=%d proglen=%u pass=%d image=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">flen</span><span class="p">,</span> <span class="n">proglen</span><span class="p">,</span> <span class="n">pass</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bpf_jit_enable</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;JIT code: &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span>
				       <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">proglen</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">bpf_flush_icache</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span> <span class="o">+</span> <span class="n">proglen</span><span class="p">);</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">bpf_func</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">image</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addrs</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jit_free_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">module_free</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* run from softirq, we must use a work_struct to call</span>
<span class="cm"> * module_free() from process context</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bpf_jit_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">bpf_func</span> <span class="o">!=</span> <span class="n">sk_run_filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">bpf_func</span><span class="p">;</span>

		<span class="n">INIT_WORK</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">jit_free_defer</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
