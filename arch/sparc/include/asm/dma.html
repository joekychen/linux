<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › dma.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>dma.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_SPARC_DMA_H</span>
<span class="cp">#define _ASM_SPARC_DMA_H</span>

<span class="cm">/* These are irrelevant for Sparc DMA, but we leave it in so that</span>
<span class="cm"> * things can compile.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_DMA_CHANNELS 8</span>
<span class="cp">#define DMA_MODE_READ    1</span>
<span class="cp">#define DMA_MODE_WRITE   2</span>
<span class="cp">#define MAX_DMA_ADDRESS  (~0UL)</span>

<span class="cm">/* Useful constants */</span>
<span class="cp">#define SIZE_16MB      (16*1024*1024)</span>
<span class="cp">#define SIZE_64K       (64*1024)</span>

<span class="cm">/* SBUS DMA controller reg offsets */</span>
<span class="cp">#define DMA_CSR		0x00UL		</span><span class="cm">/* rw  DMA control/status register    0x00   */</span><span class="cp"></span>
<span class="cp">#define DMA_ADDR	0x04UL		</span><span class="cm">/* rw  DMA transfer address register  0x04   */</span><span class="cp"></span>
<span class="cp">#define DMA_COUNT	0x08UL		</span><span class="cm">/* rw  DMA transfer count register    0x08   */</span><span class="cp"></span>
<span class="cp">#define DMA_TEST	0x0cUL		</span><span class="cm">/* rw  DMA test/debug register        0x0c   */</span><span class="cp"></span>

<span class="cm">/* Fields in the cond_reg register */</span>
<span class="cm">/* First, the version identification bits */</span>
<span class="cp">#define DMA_DEVICE_ID    0xf0000000        </span><span class="cm">/* Device identification bits */</span><span class="cp"></span>
<span class="cp">#define DMA_VERS0        0x00000000        </span><span class="cm">/* Sunray DMA version */</span><span class="cp"></span>
<span class="cp">#define DMA_ESCV1        0x40000000        </span><span class="cm">/* DMA ESC Version 1 */</span><span class="cp"></span>
<span class="cp">#define DMA_VERS1        0x80000000        </span><span class="cm">/* DMA rev 1 */</span><span class="cp"></span>
<span class="cp">#define DMA_VERS2        0xa0000000        </span><span class="cm">/* DMA rev 2 */</span><span class="cp"></span>
<span class="cp">#define DMA_VERHME       0xb0000000        </span><span class="cm">/* DMA hme gate array */</span><span class="cp"></span>
<span class="cp">#define DMA_VERSPLUS     0x90000000        </span><span class="cm">/* DMA rev 1 PLUS */</span><span class="cp"></span>

<span class="cp">#define DMA_HNDL_INTR    0x00000001        </span><span class="cm">/* An IRQ needs to be handled */</span><span class="cp"></span>
<span class="cp">#define DMA_HNDL_ERROR   0x00000002        </span><span class="cm">/* We need to take an error */</span><span class="cp"></span>
<span class="cp">#define DMA_FIFO_ISDRAIN 0x0000000c        </span><span class="cm">/* The DMA FIFO is draining */</span><span class="cp"></span>
<span class="cp">#define DMA_INT_ENAB     0x00000010        </span><span class="cm">/* Turn on interrupts */</span><span class="cp"></span>
<span class="cp">#define DMA_FIFO_INV     0x00000020        </span><span class="cm">/* Invalidate the FIFO */</span><span class="cp"></span>
<span class="cp">#define DMA_ACC_SZ_ERR   0x00000040        </span><span class="cm">/* The access size was bad */</span><span class="cp"></span>
<span class="cp">#define DMA_FIFO_STDRAIN 0x00000040        </span><span class="cm">/* DMA_VERS1 Drain the FIFO */</span><span class="cp"></span>
<span class="cp">#define DMA_RST_SCSI     0x00000080        </span><span class="cm">/* Reset the SCSI controller */</span><span class="cp"></span>
<span class="cp">#define DMA_RST_ENET     DMA_RST_SCSI      </span><span class="cm">/* Reset the ENET controller */</span><span class="cp"></span>
<span class="cp">#define DMA_ST_WRITE     0x00000100        </span><span class="cm">/* write from device to memory */</span><span class="cp"></span>
<span class="cp">#define DMA_ENABLE       0x00000200        </span><span class="cm">/* Fire up DMA, handle requests */</span><span class="cp"></span>
<span class="cp">#define DMA_PEND_READ    0x00000400        </span><span class="cm">/* DMA_VERS1/0/PLUS Pending Read */</span><span class="cp"></span>
<span class="cp">#define DMA_ESC_BURST    0x00000800        </span><span class="cm">/* 1=16byte 0=32byte */</span><span class="cp"></span>
<span class="cp">#define DMA_READ_AHEAD   0x00001800        </span><span class="cm">/* DMA read ahead partial longword */</span><span class="cp"></span>
<span class="cp">#define DMA_DSBL_RD_DRN  0x00001000        </span><span class="cm">/* No EC drain on slave reads */</span><span class="cp"></span>
<span class="cp">#define DMA_BCNT_ENAB    0x00002000        </span><span class="cm">/* If on, use the byte counter */</span><span class="cp"></span>
<span class="cp">#define DMA_TERM_CNTR    0x00004000        </span><span class="cm">/* Terminal counter */</span><span class="cp"></span>
<span class="cp">#define DMA_SCSI_SBUS64  0x00008000        </span><span class="cm">/* HME: Enable 64-bit SBUS mode. */</span><span class="cp"></span>
<span class="cp">#define DMA_CSR_DISAB    0x00010000        </span><span class="cm">/* No FIFO drains during csr */</span><span class="cp"></span>
<span class="cp">#define DMA_SCSI_DISAB   0x00020000        </span><span class="cm">/* No FIFO drains during reg */</span><span class="cp"></span>
<span class="cp">#define DMA_DSBL_WR_INV  0x00020000        </span><span class="cm">/* No EC inval. on slave writes */</span><span class="cp"></span>
<span class="cp">#define DMA_ADD_ENABLE   0x00040000        </span><span class="cm">/* Special ESC DVMA optimization */</span><span class="cp"></span>
<span class="cp">#define DMA_E_BURSTS	 0x000c0000	   </span><span class="cm">/* ENET: SBUS r/w burst mask */</span><span class="cp"></span>
<span class="cp">#define DMA_E_BURST32	 0x00040000	   </span><span class="cm">/* ENET: SBUS 32 byte r/w burst */</span><span class="cp"></span>
<span class="cp">#define DMA_E_BURST16	 0x00000000	   </span><span class="cm">/* ENET: SBUS 16 byte r/w burst */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST_SZ      0x000c0000        </span><span class="cm">/* SCSI: SBUS r/w burst size */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST64       0x000c0000        </span><span class="cm">/* SCSI: 64byte bursts (HME on UltraSparc only) */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST32       0x00040000        </span><span class="cm">/* SCSI: 32byte bursts */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST16       0x00000000        </span><span class="cm">/* SCSI: 16byte bursts */</span><span class="cp"></span>
<span class="cp">#define DMA_BRST0        0x00080000        </span><span class="cm">/* SCSI: no bursts (non-HME gate arrays) */</span><span class="cp"></span>
<span class="cp">#define DMA_ADDR_DISAB   0x00100000        </span><span class="cm">/* No FIFO drains during addr */</span><span class="cp"></span>
<span class="cp">#define DMA_2CLKS        0x00200000        </span><span class="cm">/* Each transfer = 2 clock ticks */</span><span class="cp"></span>
<span class="cp">#define DMA_3CLKS        0x00400000        </span><span class="cm">/* Each transfer = 3 clock ticks */</span><span class="cp"></span>
<span class="cp">#define DMA_EN_ENETAUI   DMA_3CLKS         </span><span class="cm">/* Put lance into AUI-cable mode */</span><span class="cp"></span>
<span class="cp">#define DMA_CNTR_DISAB   0x00800000        </span><span class="cm">/* No IRQ when DMA_TERM_CNTR set */</span><span class="cp"></span>
<span class="cp">#define DMA_AUTO_NADDR   0x01000000        </span><span class="cm">/* Use &quot;auto nxt addr&quot; feature */</span><span class="cp"></span>
<span class="cp">#define DMA_SCSI_ON      0x02000000        </span><span class="cm">/* Enable SCSI dma */</span><span class="cp"></span>
<span class="cp">#define DMA_PARITY_OFF   0x02000000        </span><span class="cm">/* HME: disable parity checking */</span><span class="cp"></span>
<span class="cp">#define DMA_LOADED_ADDR  0x04000000        </span><span class="cm">/* Address has been loaded */</span><span class="cp"></span>
<span class="cp">#define DMA_LOADED_NADDR 0x08000000        </span><span class="cm">/* Next address has been loaded */</span><span class="cp"></span>
<span class="cp">#define DMA_RESET_FAS366 0x08000000        </span><span class="cm">/* HME: Assert RESET to FAS366 */</span><span class="cp"></span>

<span class="cm">/* Values describing the burst-size property from the PROM */</span>
<span class="cp">#define DMA_BURST1       0x01</span>
<span class="cp">#define DMA_BURST2       0x02</span>
<span class="cp">#define DMA_BURST4       0x04</span>
<span class="cp">#define DMA_BURST8       0x08</span>
<span class="cp">#define DMA_BURST16      0x10</span>
<span class="cp">#define DMA_BURST32      0x20</span>
<span class="cp">#define DMA_BURST64      0x40</span>
<span class="cp">#define DMA_BURSTBITS    0x7f</span>

<span class="cm">/* From PCI */</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">isa_dma_bridge_buggy</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define isa_dma_bridge_buggy 	(0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SPARC32</span>

<span class="cm">/* Routines for data transfer buffers. */</span>
<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scatterlist</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">sparc32_dma_ops</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="p">(</span><span class="o">*</span><span class="n">get_scsi_one</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_scsi_sgl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_scsi_one</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">__u32</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_scsi_sgl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SBUS</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">map_dma_area</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unmap_dma_area</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sparc32_dma_ops</span> <span class="o">*</span><span class="n">sparc32_dma_ops</span><span class="p">;</span>

<span class="cp">#define mmu_get_scsi_one(dev,vaddr,len) \</span>
<span class="cp">	sparc32_dma_ops-&gt;get_scsi_one(dev, vaddr, len)</span>
<span class="cp">#define mmu_get_scsi_sgl(dev,sg,sz) \</span>
<span class="cp">	sparc32_dma_ops-&gt;get_scsi_sgl(dev, sg, sz)</span>
<span class="cp">#define mmu_release_scsi_one(dev,vaddr,len) \</span>
<span class="cp">	sparc32_dma_ops-&gt;release_scsi_one(dev, vaddr,len)</span>
<span class="cp">#define mmu_release_scsi_sgl(dev,sg,sz) \</span>
<span class="cp">	sparc32_dma_ops-&gt;release_scsi_sgl(dev, sg, sz)</span>

<span class="cp">#ifdef CONFIG_SBUS</span>
<span class="cm">/*</span>
<span class="cm"> * mmu_map/unmap are provided by iommu/iounit; Invalid to call on IIep.</span>
<span class="cm"> *</span>
<span class="cm"> * The mmu_map_dma_area establishes two mappings in one go.</span>
<span class="cm"> * These mappings point to pages normally mapped at &#39;va&#39; (linear address).</span>
<span class="cm"> * First mapping is for CPU visible address at &#39;a&#39;, uncached.</span>
<span class="cm"> * This is an alias, but it works because it is an uncached mapping.</span>
<span class="cm"> * Second mapping is for device visible address, or &quot;bus&quot; address.</span>
<span class="cm"> * The bus address is returned at &#39;*pba&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * These functions seem distinct, but are hard to split.</span>
<span class="cm"> * On sun4m, page attributes depend on the CPU type, so we have to</span>
<span class="cm"> * know if we are mapping RAM or I/O, so it has to be an additional argument</span>
<span class="cm"> * to a separate mapping function for CPU visible mappings.</span>
<span class="cm"> */</span>
<span class="cp">#define sbus_map_dma_area(dev,pba,va,a,len) \</span>
<span class="cp">	sparc32_dma_ops-&gt;map_dma_area(dev, pba, va, a, len)</span>
<span class="cp">#define sbus_unmap_dma_area(dev,ba,len) \</span>
<span class="cp">	sparc32_dma_ops-&gt;unmap_dma_area(dev, ba, len)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SBUS */</span><span class="cp"></span>

<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* !(_ASM_SPARC_DMA_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
