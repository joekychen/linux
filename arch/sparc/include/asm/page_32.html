<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › page_32.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>page_32.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * page.h:  Various defines and such for MMU operations on the Sparc for</span>
<span class="cm"> *          the Linux kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _SPARC_PAGE_H</span>
<span class="cp">#define _SPARC_PAGE_H</span>

<span class="cp">#include &lt;linux/const.h&gt;</span>

<span class="cp">#define PAGE_SHIFT   12</span>
<span class="cp">#define PAGE_SIZE    (_AC(1, UL) &lt;&lt; PAGE_SHIFT)</span>
<span class="cp">#define PAGE_MASK    (~(PAGE_SIZE-1))</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#define clear_page(page)	 memset((void *)(page), 0, PAGE_SIZE)</span>
<span class="cp">#define copy_page(to,from) 	memcpy((void *)(to), (void *)(from), PAGE_SIZE)</span>
<span class="cp">#define clear_user_page(addr, vaddr, page)	\</span>
<span class="cp">	do { 	clear_page(addr);		\</span>
<span class="cp">		sparc_flush_page_to_ram(page);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define copy_user_page(to, from, vaddr, page)	\</span>
<span class="cp">	do {	copy_page(to, from);		\</span>
<span class="cp">		sparc_flush_page_to_ram(page);	\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/* The following structure is used to hold the physical</span>
<span class="cm"> * memory configuration of the machine.  This is filled in</span>
<span class="cm"> * prom_meminit() and is later used by mem_init() to set up</span>
<span class="cm"> * mem_map[].  We statically allocate SPARC_PHYS_BANKS+1 of</span>
<span class="cm"> * these structs, this is arbitrary.  The entry after the</span>
<span class="cm"> * last valid one has num_bytes==0.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sparc_phys_banks</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_addr</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_bytes</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SPARC_PHYS_BANKS 32</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sparc_phys_banks</span> <span class="n">sp_banks</span><span class="p">[</span><span class="n">SPARC_PHYS_BANKS</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

<span class="cm">/* passing structs on the Sparc slow us down tremendously... */</span>

<span class="cm">/* #define STRICT_MM_TYPECHECKS */</span>

<span class="cp">#ifdef STRICT_MM_TYPECHECKS</span>
<span class="cm">/*</span>
<span class="cm"> * These are used to make use of C type-checking..</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span> <span class="n">pte_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iopte</span><span class="p">;</span> <span class="p">}</span> <span class="n">iopte_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmdv</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="p">}</span> <span class="n">pmd_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgd</span><span class="p">;</span> <span class="p">}</span> <span class="n">pgd_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctxd</span><span class="p">;</span> <span class="p">}</span> <span class="n">ctxd_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgprot</span><span class="p">;</span> <span class="p">}</span> <span class="n">pgprot_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iopgprot</span><span class="p">;</span> <span class="p">}</span> <span class="n">iopgprot_t</span><span class="p">;</span>

<span class="cp">#define pte_val(x)	((x).pte)</span>
<span class="cp">#define iopte_val(x)	((x).iopte)</span>
<span class="cp">#define pmd_val(x)      ((x).pmdv[0])</span>
<span class="cp">#define pgd_val(x)	((x).pgd)</span>
<span class="cp">#define ctxd_val(x)	((x).ctxd)</span>
<span class="cp">#define pgprot_val(x)	((x).pgprot)</span>
<span class="cp">#define iopgprot_val(x)	((x).iopgprot)</span>

<span class="cp">#define __pte(x)	((pte_t) { (x) } )</span>
<span class="cp">#define __iopte(x)	((iopte_t) { (x) } )</span>
<span class="cm">/* #define __pmd(x)        ((pmd_t) { (x) } ) */</span> <span class="cm">/* XXX procedure with loop */</span>
<span class="cp">#define __pgd(x)	((pgd_t) { (x) } )</span>
<span class="cp">#define __ctxd(x)	((ctxd_t) { (x) } )</span>
<span class="cp">#define __pgprot(x)	((pgprot_t) { (x) } )</span>
<span class="cp">#define __iopgprot(x)	((iopgprot_t) { (x) } )</span>

<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * .. while these make it easier on the compiler</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iopte_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmdv</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="p">}</span> <span class="n">pmd_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgd_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctxd_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgprot_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iopgprot_t</span><span class="p">;</span>

<span class="cp">#define pte_val(x)	(x)</span>
<span class="cp">#define iopte_val(x)	(x)</span>
<span class="cp">#define pmd_val(x)      ((x).pmdv[0])</span>
<span class="cp">#define pgd_val(x)	(x)</span>
<span class="cp">#define ctxd_val(x)	(x)</span>
<span class="cp">#define pgprot_val(x)	(x)</span>
<span class="cp">#define iopgprot_val(x)	(x)</span>

<span class="cp">#define __pte(x)	(x)</span>
<span class="cp">#define __iopte(x)	(x)</span>
<span class="cm">/* #define __pmd(x)        (x) */</span> <span class="cm">/* XXX later */</span>
<span class="cp">#define __pgd(x)	(x)</span>
<span class="cp">#define __ctxd(x)	(x)</span>
<span class="cp">#define __pgprot(x)	(x)</span>
<span class="cp">#define __iopgprot(x)	(x)</span>

<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pgtable_t</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sparc_unmapped_base</span><span class="p">;</span>
<span class="cp">#define TASK_UNMAPPED_BASE	sparc_unmapped_base</span>

<span class="cp">#else </span><span class="cm">/* !(__ASSEMBLY__) */</span><span class="cp"></span>

<span class="cp">#define __pgprot(x)	(x)</span>

<span class="cp">#endif </span><span class="cm">/* !(__ASSEMBLY__) */</span><span class="cp"></span>

<span class="cp">#define PAGE_OFFSET	0xf0000000</span>
<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_base</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn_base</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#define __pa(x)			((unsigned long)(x) - PAGE_OFFSET + phys_base)</span>
<span class="cp">#define __va(x)			((void *)((unsigned long) (x) - phys_base + PAGE_OFFSET))</span>

<span class="cp">#define virt_to_phys		__pa</span>
<span class="cp">#define phys_to_virt		__va</span>

<span class="cp">#define ARCH_PFN_OFFSET		(pfn_base)</span>
<span class="cp">#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) &gt;&gt; PAGE_SHIFT)</span>

<span class="cp">#define pfn_valid(pfn)		(((pfn) &gt;= (pfn_base)) &amp;&amp; (((pfn)-(pfn_base)) &lt; max_mapnr))</span>
<span class="cp">#define virt_addr_valid(kaddr)	((((unsigned long)(kaddr)-PAGE_OFFSET)&gt;&gt;PAGE_SHIFT) &lt; max_mapnr)</span>

<span class="cp">#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \</span>
<span class="cp">				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)</span>

<span class="cp">#include &lt;asm-generic/memory_model.h&gt;</span>
<span class="cp">#include &lt;asm-generic/getorder.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* _SPARC_PAGE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
