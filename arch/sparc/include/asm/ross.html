<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › ross.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ross.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * ross.h: Ross module specific definitions and defines.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _SPARC_ROSS_H</span>
<span class="cp">#define _SPARC_ROSS_H</span>

<span class="cp">#include &lt;asm/asi.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cm">/* Ross made Hypersparcs have a %psr &#39;impl&#39; field of &#39;0001&#39;.  The &#39;vers&#39;</span>
<span class="cm"> * field has &#39;1111&#39;.</span>
<span class="cm"> */</span>

<span class="cm">/* The MMU control register fields on the HyperSparc.</span>
<span class="cm"> *</span>
<span class="cm"> * -----------------------------------------------------------------</span>
<span class="cm"> * |implvers| RSV |CWR|SE|WBE| MID |BM| C|CS|MR|CM|RSV|CE|RSV|NF|ME|</span>
<span class="cm"> * -----------------------------------------------------------------</span>
<span class="cm"> *  31    24 23-22 21  20  19 18-15 14 13 12 11 10  9   8 7-2  1  0</span>
<span class="cm"> *</span>
<span class="cm"> * Phew, lots of fields there ;-)</span>
<span class="cm"> *</span>
<span class="cm"> * CWR: Cache Wrapping Enabled, if one cache wrapping is on.</span>
<span class="cm"> * SE: Snoop Enable, turns on bus snooping for cache activity if one.</span>
<span class="cm"> * WBE: Write Buffer Enable, one turns it on.</span>
<span class="cm"> * MID: The ModuleID of the chip for MBus transactions.</span>
<span class="cm"> * BM: Boot-Mode. One indicates the MMU is in boot mode.</span>
<span class="cm"> * C: Indicates whether accesses are cachable while the MMU is</span>
<span class="cm"> *    disabled.</span>
<span class="cm"> * CS: Cache Size -- 0 = 128k, 1 = 256k</span>
<span class="cm"> * MR: Memory Reflection, one indicates that the memory bus connected</span>
<span class="cm"> *     to the MBus supports memory reflection.</span>
<span class="cm"> * CM: Cache Mode -- 0 = write-through, 1 = copy-back</span>
<span class="cm"> * CE: Cache Enable -- 0 = no caching, 1 = cache is on</span>
<span class="cm"> * NF: No Fault -- 0 = faults trap the CPU from supervisor mode</span>
<span class="cm"> *                 1 = faults from supervisor mode do not generate traps</span>
<span class="cm"> * ME: MMU Enable -- 0 = MMU is off, 1 = MMU is on</span>
<span class="cm"> */</span>

<span class="cp">#define HYPERSPARC_CWENABLE   0x00200000</span>
<span class="cp">#define HYPERSPARC_SBENABLE   0x00100000</span>
<span class="cp">#define HYPERSPARC_WBENABLE   0x00080000</span>
<span class="cp">#define HYPERSPARC_MIDMASK    0x00078000</span>
<span class="cp">#define HYPERSPARC_BMODE      0x00004000</span>
<span class="cp">#define HYPERSPARC_ACENABLE   0x00002000</span>
<span class="cp">#define HYPERSPARC_CSIZE      0x00001000</span>
<span class="cp">#define HYPERSPARC_MRFLCT     0x00000800</span>
<span class="cp">#define HYPERSPARC_CMODE      0x00000400</span>
<span class="cp">#define HYPERSPARC_CENABLE    0x00000100</span>
<span class="cp">#define HYPERSPARC_NFAULT     0x00000002</span>
<span class="cp">#define HYPERSPARC_MENABLE    0x00000001</span>


<span class="cm">/* The ICCR instruction cache register on the HyperSparc.</span>
<span class="cm"> *</span>
<span class="cm"> * -----------------------------------------------</span>
<span class="cm"> * |                                 | FTD | ICE |</span>
<span class="cm"> * -----------------------------------------------</span>
<span class="cm"> *  31                                  1     0</span>
<span class="cm"> *</span>
<span class="cm"> * This register is accessed using the V8 &#39;wrasr&#39; and &#39;rdasr&#39;</span>
<span class="cm"> * opcodes, since not all assemblers understand them and those</span>
<span class="cm"> * that do use different semantics I will just hard code the</span>
<span class="cm"> * instruction with a &#39;.word&#39; statement.</span>
<span class="cm"> *</span>
<span class="cm"> * FTD:  If set to one flush instructions executed during an</span>
<span class="cm"> *       instruction cache hit occurs, the corresponding line</span>
<span class="cm"> *       for said cache-hit is invalidated.  If FTD is zero,</span>
<span class="cm"> *       an unimplemented &#39;flush&#39; trap will occur when any</span>
<span class="cm"> *       flush is executed by the processor.</span>
<span class="cm"> *</span>
<span class="cm"> * ICE:  If set to one, the instruction cache is enabled.  If</span>
<span class="cm"> *       zero, the cache will not be used for instruction fetches.</span>
<span class="cm"> *</span>
<span class="cm"> * All other bits are read as zeros, and writes to them have no</span>
<span class="cm"> * effect.</span>
<span class="cm"> *</span>
<span class="cm"> * Wheee, not many assemblers understand the %iccr register nor</span>
<span class="cm"> * the generic asr r/w instructions.</span>
<span class="cm"> *</span>
<span class="cm"> *  1000 0011 0100 0111 1100 0000 0000 0000   ! rd %iccr, %g1</span>
<span class="cm"> *</span>
<span class="cm"> * 0x  8    3    4    7    c    0    0    0   ! 0x8347c000</span>
<span class="cm"> *</span>
<span class="cm"> *  1011 1111 1000 0000 0110 0000 0000 0000   ! wr %g1, 0x0, %iccr</span>
<span class="cm"> *</span>
<span class="cm"> * 0x  b    f    8    0    6    0    0    0   ! 0xbf806000</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define HYPERSPARC_ICCR_FTD     0x00000002</span>
<span class="cp">#define HYPERSPARC_ICCR_ICE     0x00000001</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_ross_icr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">icreg</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;.word 0x8347c000</span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="cm">/* rd %iccr, %g1 */</span>
			     <span class="s">&quot;mov %%g1, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">icreg</span><span class="p">)</span>
			     <span class="o">:</span> <span class="cm">/* no inputs */</span>
			     <span class="o">:</span> <span class="s">&quot;g1&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">icreg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_ross_icr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">icreg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;or %%g0, %0, %%g1</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;.word 0xbf806000</span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="cm">/* wr %g1, 0x0, %iccr */</span>
			     <span class="s">&quot;nop</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;nop</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="s">&quot;nop</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="o">:</span> <span class="cm">/* no outputs */</span>
			     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">icreg</span><span class="p">)</span>
			     <span class="o">:</span> <span class="s">&quot;g1&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* HyperSparc specific cache flushing. */</span>

<span class="cm">/* This is for the on-chip instruction cache. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hyper_flush_whole_icache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;sta %%g0, [%%g0] %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
			     <span class="o">:</span> <span class="cm">/* no outputs */</span>
			     <span class="o">:</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_M_FLUSH_IWHOLE</span><span class="p">)</span>
			     <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vac_cache_size</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vac_line_size</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hyper_clear_all_tags</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">vac_cache_size</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">vac_line_size</span><span class="p">)</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;sta %%g0, [%0] %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
				     <span class="o">:</span> <span class="cm">/* no outputs */</span>
				     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_M_DATAC_TAG</span><span class="p">)</span>
				     <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hyper_flush_unconditional_combined</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">vac_cache_size</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">vac_line_size</span><span class="p">)</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;sta %%g0, [%0] %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
				     <span class="o">:</span> <span class="cm">/* no outputs */</span>
				     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_M_FLUSH_CTX</span><span class="p">)</span>
				     <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hyper_flush_cache_user</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">vac_cache_size</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">vac_line_size</span><span class="p">)</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;sta %%g0, [%0] %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
				     <span class="o">:</span> <span class="cm">/* no outputs */</span>
				     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_M_FLUSH_USER</span><span class="p">)</span>
				     <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hyper_flush_cache_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;sta %%g0, [%0] %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
				     <span class="o">:</span> <span class="cm">/* no outputs */</span>
				     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_M_FLUSH_PAGE</span><span class="p">)</span>
				     <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">+=</span> <span class="n">vac_line_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !(__ASSEMBLY__) */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* !(_SPARC_ROSS_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
