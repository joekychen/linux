<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › barrier_64.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>barrier_64.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __SPARC64_BARRIER_H</span>
<span class="cp">#define __SPARC64_BARRIER_H</span>

<span class="cm">/* These are here in an effort to more fully work around Spitfire Errata</span>
<span class="cm"> * #51.  Essentially, if a memory barrier occurs soon after a mispredicted</span>
<span class="cm"> * branch, the chip can stop executing instructions until a trap occurs.</span>
<span class="cm"> * Therefore, if interrupts are disabled, the chip can hang forever.</span>
<span class="cm"> *</span>
<span class="cm"> * It used to be believed that the memory barrier had to be right in the</span>
<span class="cm"> * delay slot, but a case has been traced recently wherein the memory barrier</span>
<span class="cm"> * was one instruction after the branch delay slot and the chip still hung.</span>
<span class="cm"> * The offending sequence was the following in sym_wakeup_done() of the</span>
<span class="cm"> * sym53c8xx_2 driver:</span>
<span class="cm"> *</span>
<span class="cm"> *	call	sym_ccb_from_dsa, 0</span>
<span class="cm"> *	 movge	%icc, 0, %l0</span>
<span class="cm"> *	brz,pn	%o0, .LL1303</span>
<span class="cm"> *	 mov	%o0, %l2</span>
<span class="cm"> *	membar	#LoadLoad</span>
<span class="cm"> *</span>
<span class="cm"> * The branch has to be mispredicted for the bug to occur.  Therefore, we put</span>
<span class="cm"> * the memory barrier explicitly into a &quot;branch always, predicted taken&quot;</span>
<span class="cm"> * delay slot to avoid the problem case.</span>
<span class="cm"> */</span>
<span class="cp">#define membar_safe(type) \</span>
<span class="cp">do {	__asm__ __volatile__(&quot;ba,pt	%%xcc, 1f\n\t&quot; \</span>
<span class="cp">			     &quot; membar	&quot; type &quot;\n&quot; \</span>
<span class="cp">			     &quot;1:\n&quot; \</span>
<span class="cp">			     : : : &quot;memory&quot;); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* The kernel always executes in TSO memory model these days,</span>
<span class="cm"> * and furthermore most sparc64 chips implement more stringent</span>
<span class="cm"> * memory ordering than required by the specifications.</span>
<span class="cm"> */</span>
<span class="cp">#define mb()	membar_safe(&quot;#StoreLoad&quot;)</span>
<span class="cp">#define rmb()	__asm__ __volatile__(&quot;&quot;:::&quot;memory&quot;)</span>
<span class="cp">#define wmb()	__asm__ __volatile__(&quot;&quot;:::&quot;memory&quot;)</span>

<span class="cp">#define read_barrier_depends()		do { } while(0)</span>
<span class="cp">#define set_mb(__var, __value) \</span>
<span class="cp">	do { __var = __value; membar_safe(&quot;#StoreLoad&quot;); } while(0)</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#define smp_mb()	mb()</span>
<span class="cp">#define smp_rmb()	rmb()</span>
<span class="cp">#define smp_wmb()	wmb()</span>
<span class="cp">#else</span>
<span class="cp">#define smp_mb()	__asm__ __volatile__(&quot;&quot;:::&quot;memory&quot;)</span>
<span class="cp">#define smp_rmb()	__asm__ __volatile__(&quot;&quot;:::&quot;memory&quot;)</span>
<span class="cp">#define smp_wmb()	__asm__ __volatile__(&quot;&quot;:::&quot;memory&quot;)</span>
<span class="cp">#endif</span>

<span class="cp">#define smp_read_barrier_depends()	do { } while(0)</span>

<span class="cp">#endif </span><span class="cm">/* !(__SPARC64_BARRIER_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
