<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › hypervisor.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>hypervisor.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _SPARC64_HYPERVISOR_H</span>
<span class="cp">#define _SPARC64_HYPERVISOR_H</span>

<span class="cm">/* Sun4v hypervisor interfaces and defines.</span>
<span class="cm"> *</span>
<span class="cm"> * Hypervisor calls are made via traps to software traps number 0x80</span>
<span class="cm"> * and above.  Registers %o0 to %o5 serve as argument, status, and</span>
<span class="cm"> * return value registers.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two kinds of these traps.  First there are the normal</span>
<span class="cm"> * &quot;fast traps&quot; which use software trap 0x80 and encode the function</span>
<span class="cm"> * to invoke by number in register %o5.  Argument and return value</span>
<span class="cm"> * handling is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * -----------------------------------------------</span>
<span class="cm"> * |  %o5  | function number |     undefined     |</span>
<span class="cm"> * |  %o0  |   argument 0    |   return status   |</span>
<span class="cm"> * |  %o1  |   argument 1    |   return value 1  |</span>
<span class="cm"> * |  %o2  |   argument 2    |   return value 2  |</span>
<span class="cm"> * |  %o3  |   argument 3    |   return value 3  |</span>
<span class="cm"> * |  %o4  |   argument 4    |   return value 4  |</span>
<span class="cm"> * -----------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * The second type are &quot;hyper-fast traps&quot; which encode the function</span>
<span class="cm"> * number in the software trap number itself.  So these use trap</span>
<span class="cm"> * numbers &gt; 0x80.  The register usage for hyper-fast traps is as</span>
<span class="cm"> * follows:</span>
<span class="cm"> *</span>
<span class="cm"> * -----------------------------------------------</span>
<span class="cm"> * |  %o0  |   argument 0    |   return status   |</span>
<span class="cm"> * |  %o1  |   argument 1    |   return value 1  |</span>
<span class="cm"> * |  %o2  |   argument 2    |   return value 2  |</span>
<span class="cm"> * |  %o3  |   argument 3    |   return value 3  |</span>
<span class="cm"> * |  %o4  |   argument 4    |   return value 4  |</span>
<span class="cm"> * -----------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * Registers providing explicit arguments to the hypervisor calls</span>
<span class="cm"> * are volatile across the call.  Upon return their values are</span>
<span class="cm"> * undefined unless explicitly specified as containing a particular</span>
<span class="cm"> * return value by the specific call.  The return status is always</span>
<span class="cm"> * returned in register %o0, zero indicates a successful execution of</span>
<span class="cm"> * the hypervisor call and other values indicate an error status as</span>
<span class="cm"> * defined below.  So, for example, if a hyper-fast trap takes</span>
<span class="cm"> * arguments 0, 1, and 2, then %o0, %o1, and %o2 are volatile across</span>
<span class="cm"> * the call and %o3, %o4, and %o5 would be preserved.</span>
<span class="cm"> *</span>
<span class="cm"> * If the hypervisor trap is invalid, or the fast trap function number</span>
<span class="cm"> * is invalid, HV_EBADTRAP will be returned in %o0.  Also, all 64-bits</span>
<span class="cm"> * of the argument and return values are significant.</span>
<span class="cm"> */</span>

<span class="cm">/* Trap numbers.  */</span>
<span class="cp">#define HV_FAST_TRAP		0x80</span>
<span class="cp">#define HV_MMU_MAP_ADDR_TRAP	0x83</span>
<span class="cp">#define HV_MMU_UNMAP_ADDR_TRAP	0x84</span>
<span class="cp">#define HV_TTRACE_ADDENTRY_TRAP	0x85</span>
<span class="cp">#define HV_CORE_TRAP		0xff</span>

<span class="cm">/* Error codes.  */</span>
<span class="cp">#define HV_EOK				0  </span><span class="cm">/* Successful return            */</span><span class="cp"></span>
<span class="cp">#define HV_ENOCPU			1  </span><span class="cm">/* Invalid CPU id               */</span><span class="cp"></span>
<span class="cp">#define HV_ENORADDR			2  </span><span class="cm">/* Invalid real address         */</span><span class="cp"></span>
<span class="cp">#define HV_ENOINTR			3  </span><span class="cm">/* Invalid interrupt id         */</span><span class="cp"></span>
<span class="cp">#define HV_EBADPGSZ			4  </span><span class="cm">/* Invalid pagesize encoding    */</span><span class="cp"></span>
<span class="cp">#define HV_EBADTSB			5  </span><span class="cm">/* Invalid TSB description      */</span><span class="cp"></span>
<span class="cp">#define HV_EINVAL			6  </span><span class="cm">/* Invalid argument             */</span><span class="cp"></span>
<span class="cp">#define HV_EBADTRAP			7  </span><span class="cm">/* Invalid function number      */</span><span class="cp"></span>
<span class="cp">#define HV_EBADALIGN			8  </span><span class="cm">/* Invalid address alignment    */</span><span class="cp"></span>
<span class="cp">#define HV_EWOULDBLOCK			9  </span><span class="cm">/* Cannot complete w/o blocking */</span><span class="cp"></span>
<span class="cp">#define HV_ENOACCESS			10 </span><span class="cm">/* No access to resource        */</span><span class="cp"></span>
<span class="cp">#define HV_EIO				11 </span><span class="cm">/* I/O error                    */</span><span class="cp"></span>
<span class="cp">#define HV_ECPUERROR			12 </span><span class="cm">/* CPU in error state           */</span><span class="cp"></span>
<span class="cp">#define HV_ENOTSUPPORTED		13 </span><span class="cm">/* Function not supported       */</span><span class="cp"></span>
<span class="cp">#define HV_ENOMAP			14 </span><span class="cm">/* No mapping found             */</span><span class="cp"></span>
<span class="cp">#define HV_ETOOMANY			15 </span><span class="cm">/* Too many items specified     */</span><span class="cp"></span>
<span class="cp">#define HV_ECHANNEL			16 </span><span class="cm">/* Invalid LDC channel          */</span><span class="cp"></span>
<span class="cp">#define HV_EBUSY			17 </span><span class="cm">/* Resource busy                */</span><span class="cp"></span>

<span class="cm">/* mach_exit()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MACH_EXIT</span>
<span class="cm"> * ARG0:	exit code</span>
<span class="cm"> * ERRORS:	This service does not return.</span>
<span class="cm"> *</span>
<span class="cm"> * Stop all CPUs in the virtual domain and place them into the stopped</span>
<span class="cm"> * state.  The 64-bit exit code may be passed to a service entity as</span>
<span class="cm"> * the domain&#39;s exit status.  On systems without a service entity, the</span>
<span class="cm"> * domain will undergo a reset, and the boot firmware will be</span>
<span class="cm"> * reloaded.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will never return to the guest that invokes it.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: By convention an exit code of zero denotes a successful exit by</span>
<span class="cm"> *       the guest code.  A non-zero exit code denotes a guest specific</span>
<span class="cm"> *       error indication.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MACH_EXIT		0x00</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sun4v_mach_exit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_code</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Domain services.  */</span>

<span class="cm">/* mach_desc()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MACH_DESC</span>
<span class="cm"> * ARG0:	buffer</span>
<span class="cm"> * ARG1:	length</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	length</span>
<span class="cm"> * ERRORS:	HV_EBADALIGN	Buffer is badly aligned</span>
<span class="cm"> *		HV_ENORADDR	Buffer is to an illegal real address.</span>
<span class="cm"> *		HV_EINVAL	Buffer length is too small for complete</span>
<span class="cm"> *				machine description.</span>
<span class="cm"> *</span>
<span class="cm"> * Copy the most current machine description into the buffer indicated</span>
<span class="cm"> * by the real address in ARG0.  The buffer provided must be 16 byte</span>
<span class="cm"> * aligned.  Upon success or HV_EINVAL, this service returns the</span>
<span class="cm"> * actual size of the machine description in the RET1 return value.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: A method of determining the appropriate buffer size for the</span>
<span class="cm"> *       machine description is to first call this service with a buffer</span>
<span class="cm"> *       length of 0 bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MACH_DESC		0x01</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_mach_desc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer_pa</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf_len</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">real_buf_len</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* mach_sir()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MACH_SIR</span>
<span class="cm"> * ERRORS:	This service does not return.</span>
<span class="cm"> *</span>
<span class="cm"> * Perform a software initiated reset of the virtual machine domain.</span>
<span class="cm"> * All CPUs are captured as soon as possible, all hardware devices are</span>
<span class="cm"> * returned to the entry default state, and the domain is restarted at</span>
<span class="cm"> * the SIR (trap type 0x04) real trap table (RTBA) entry point on one</span>
<span class="cm"> * of the CPUs.  The single CPU restarted is selected as determined by</span>
<span class="cm"> * platform specific policy.  Memory is preserved across this</span>
<span class="cm"> * operation.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MACH_SIR		0x02</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sun4v_mach_sir</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* mach_set_watchdog()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MACH_SET_WATCHDOG</span>
<span class="cm"> * ARG0:	timeout in milliseconds</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	time remaining in milliseconds</span>
<span class="cm"> *</span>
<span class="cm"> * A guest uses this API to set a watchdog timer.  Once the gues has set</span>
<span class="cm"> * the timer, it must call the timer service again either to disable or</span>
<span class="cm"> * postpone the expiration.  If the timer expires before being reset or</span>
<span class="cm"> * disabled, then the hypervisor take a platform specific action leading</span>
<span class="cm"> * to guest termination within a bounded time period.  The platform action</span>
<span class="cm"> * may include recovery actions such as reporting the expiration to a</span>
<span class="cm"> * Service Processor, and/or automatically restarting the gues.</span>
<span class="cm"> *</span>
<span class="cm"> * The &#39;timeout&#39; parameter is specified in milliseconds, however the</span>
<span class="cm"> * implementated granularity is given by the &#39;watchdog-resolution&#39;</span>
<span class="cm"> * property in the &#39;platform&#39; node of the guest&#39;s machine description.</span>
<span class="cm"> * The largest allowed timeout value is specified by the</span>
<span class="cm"> * &#39;watchdog-max-timeout&#39; property of the &#39;platform&#39; node.</span>
<span class="cm"> *</span>
<span class="cm"> * If the &#39;timeout&#39; argument is not zero, the watchdog timer is set to</span>
<span class="cm"> * expire after a minimum of &#39;timeout&#39; milliseconds.</span>
<span class="cm"> *</span>
<span class="cm"> * If the &#39;timeout&#39; argument is zero, the watchdog timer is disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * If the &#39;timeout&#39; value exceeds the value of the &#39;max-watchdog-timeout&#39;</span>
<span class="cm"> * property, the hypervisor leaves the watchdog timer state unchanged,</span>
<span class="cm"> * and returns a status of EINVAL.</span>
<span class="cm"> *</span>
<span class="cm"> * The &#39;time remaining&#39; return value is valid regardless of whether the</span>
<span class="cm"> * return status is EOK or EINVAL.  A non-zero return value indicates the</span>
<span class="cm"> * number of milliseconds that were remaining until the timer was to expire.</span>
<span class="cm"> * If less than one millisecond remains, the return value is &#39;1&#39;.  If the</span>
<span class="cm"> * watchdog timer was disabled at the time of the call, the return value is</span>
<span class="cm"> * zero.</span>
<span class="cm"> *</span>
<span class="cm"> * If the hypervisor cannot support the exact timeout value requested, but</span>
<span class="cm"> * can support a larger timeout value, the hypervisor may round the actual</span>
<span class="cm"> * timeout to a value larger than the requested timeout, consequently the</span>
<span class="cm"> * &#39;time remaining&#39; return value may be larger than the previously requested</span>
<span class="cm"> * timeout value.</span>
<span class="cm"> *</span>
<span class="cm"> * Any guest OS debugger should be aware that the watchdog service may be in</span>
<span class="cm"> * use.  Consequently, it is recommended that the watchdog service is</span>
<span class="cm"> * disabled upon debugger entry (e.g. reaching a breakpoint), and then</span>
<span class="cm"> * re-enabled upon returning to normal execution.  The API has been designed</span>
<span class="cm"> * with this in mind, and the &#39;time remaining&#39; result of the disable call may</span>
<span class="cm"> * be used directly as the timeout argument of the re-enable call.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MACH_SET_WATCHDOG	0x05</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_mach_set_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">orig_timeout</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* CPU services.</span>
<span class="cm"> *</span>
<span class="cm"> * CPUs represent devices that can execute software threads.  A single</span>
<span class="cm"> * chip that contains multiple cores or strands is represented as</span>
<span class="cm"> * multiple CPUs with unique CPU identifiers.  CPUs are exported to</span>
<span class="cm"> * OBP via the machine description (and to the OS via the OBP device</span>
<span class="cm"> * tree).  CPUs are always in one of three states: stopped, running,</span>
<span class="cm"> * or error.</span>
<span class="cm"> *</span>
<span class="cm"> * A CPU ID is a pre-assigned 16-bit value that uniquely identifies a</span>
<span class="cm"> * CPU within a logical domain.  Operations that are to be performed</span>
<span class="cm"> * on multiple CPUs specify them via a CPU list.  A CPU list is an</span>
<span class="cm"> * array in real memory, of which each 16-bit word is a CPU ID.  CPU</span>
<span class="cm"> * lists are passed through the API as two arguments.  The first is</span>
<span class="cm"> * the number of entries (16-bit words) in the CPU list, and the</span>
<span class="cm"> * second is the (real address) pointer to the CPU ID list.</span>
<span class="cm"> */</span>

<span class="cm">/* cpu_start()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_START</span>
<span class="cm"> * ARG0:	CPU ID</span>
<span class="cm"> * ARG1:	PC</span>
<span class="cm"> * ARG2:	RTBA</span>
<span class="cm"> * ARG3:	target ARG0</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	ENOCPU		Invalid CPU ID</span>
<span class="cm"> *		EINVAL		Target CPU ID is not in the stopped state</span>
<span class="cm"> *		ENORADDR	Invalid PC or RTBA real address</span>
<span class="cm"> *		EBADALIGN	Unaligned PC or unaligned RTBA</span>
<span class="cm"> *		EWOULDBLOCK	Starting resources are not available</span>
<span class="cm"> *</span>
<span class="cm"> * Start CPU with given CPU ID with PC in %pc and with a real trap</span>
<span class="cm"> * base address value of RTBA.  The indicated CPU must be in the</span>
<span class="cm"> * stopped state.  The supplied RTBA must be aligned on a 256 byte</span>
<span class="cm"> * boundary.  On successful completion, the specified CPU will be in</span>
<span class="cm"> * the running state and will be supplied with &quot;target ARG0&quot; in %o0</span>
<span class="cm"> * and RTBA in %tba.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_START		0x10</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_cpu_start</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpuid</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rtba</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg0</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* cpu_stop()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_STOP</span>
<span class="cm"> * ARG0:	CPU ID</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	ENOCPU		Invalid CPU ID</span>
<span class="cm"> *		EINVAL		Target CPU ID is the current cpu</span>
<span class="cm"> *		EINVAL		Target CPU ID is not in the running state</span>
<span class="cm"> *		EWOULDBLOCK	Stopping resources are not available</span>
<span class="cm"> *		ENOTSUPPORTED	Not supported on this platform</span>
<span class="cm"> *</span>
<span class="cm"> * The specified CPU is stopped.  The indicated CPU must be in the</span>
<span class="cm"> * running state.  On completion, it will be in the stopped state.  It</span>
<span class="cm"> * is not legal to stop the current CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: As this service cannot be used to stop the current cpu, this service</span>
<span class="cm"> *       may not be used to stop the last running CPU in a domain.  To stop</span>
<span class="cm"> *       and exit a running domain, a guest must use the mach_exit() service.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_STOP		0x11</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_cpu_stop</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpuid</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* cpu_yield()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_YIELD</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	No possible error.</span>
<span class="cm"> *</span>
<span class="cm"> * Suspend execution on the current CPU.  Execution will resume when</span>
<span class="cm"> * an interrupt (device, %stick_compare, or cross-call) is targeted to</span>
<span class="cm"> * the CPU.  On some CPUs, this API may be used by the hypervisor to</span>
<span class="cm"> * save power by disabling hardware strands.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_YIELD		0x12</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_cpu_yield</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* cpu_qconf()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_QCONF</span>
<span class="cm"> * ARG0:	queue</span>
<span class="cm"> * ARG1:	base real address</span>
<span class="cm"> * ARG2:	number of entries</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	ENORADDR	Invalid base real address</span>
<span class="cm"> *		EINVAL		Invalid queue or number of entries is less</span>
<span class="cm"> *				than 2 or too large.</span>
<span class="cm"> *		EBADALIGN	Base real address is not correctly aligned</span>
<span class="cm"> *				for size.</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the given queue to be placed at the given base real</span>
<span class="cm"> * address, with the given number of entries.  The number of entries</span>
<span class="cm"> * must be a power of 2.  The base real address must be aligned</span>
<span class="cm"> * exactly to match the queue size.  Each queue entry is 64 bytes</span>
<span class="cm"> * long, so for example a 32 entry queue must be aligned on a 2048</span>
<span class="cm"> * byte real address boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * The specified queue is unconfigured if the number of entries is given</span>
<span class="cm"> * as zero.</span>
<span class="cm"> *</span>
<span class="cm"> * For the current version of this API service, the argument queue is defined</span>
<span class="cm"> * as follows:</span>
<span class="cm"> *</span>
<span class="cm"> *	queue		description</span>
<span class="cm"> *	-----		-------------------------</span>
<span class="cm"> *	0x3c		cpu mondo queue</span>
<span class="cm"> *	0x3d		device mondo queue</span>
<span class="cm"> *	0x3e		resumable error queue</span>
<span class="cm"> *	0x3f		non-resumable error queue</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The maximum number of entries for each queue for a specific cpu may</span>
<span class="cm"> *       be determined from the machine description.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_QCONF		0x14</span>
<span class="cp">#define  HV_CPU_QUEUE_CPU_MONDO		 0x3c</span>
<span class="cp">#define  HV_CPU_QUEUE_DEVICE_MONDO	 0x3d</span>
<span class="cp">#define  HV_CPU_QUEUE_RES_ERROR		 0x3e</span>
<span class="cp">#define  HV_CPU_QUEUE_NONRES_ERROR	 0x3f</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_cpu_qconf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">queue_paddr</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_queue_entries</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* cpu_qinfo()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_QINFO</span>
<span class="cm"> * ARG0:	queue</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	base real address</span>
<span class="cm"> * RET1:	number of entries</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid queue</span>
<span class="cm"> *</span>
<span class="cm"> * Return the configuration info for the given queue.  The base real</span>
<span class="cm"> * address and number of entries of the defined queue are returned.</span>
<span class="cm"> * The queue argument values are the same as for cpu_qconf() above.</span>
<span class="cm"> *</span>
<span class="cm"> * If the specified queue is a valid queue number, but no queue has</span>
<span class="cm"> * been defined, the number of entries will be set to zero and the</span>
<span class="cm"> * base real address returned is undefined.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_QINFO		0x15</span>

<span class="cm">/* cpu_mondo_send()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_MONDO_SEND</span>
<span class="cm"> * ARG0-1:	CPU list</span>
<span class="cm"> * ARG2:	data real address</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EBADALIGN	Mondo data is not 64-byte aligned or CPU list</span>
<span class="cm"> *				is not 2-byte aligned.</span>
<span class="cm"> *		ENORADDR	Invalid data mondo address, or invalid cpu list</span>
<span class="cm"> *				address.</span>
<span class="cm"> *		ENOCPU		Invalid cpu in CPU list</span>
<span class="cm"> *		EWOULDBLOCK	Some or all of the listed CPUs did not receive</span>
<span class="cm"> *				the mondo</span>
<span class="cm"> *		ECPUERROR	One or more of the listed CPUs are in error</span>
<span class="cm"> *				state, use HV_FAST_CPU_STATE to see which ones</span>
<span class="cm"> *		EINVAL		CPU list includes caller&#39;s CPU ID</span>
<span class="cm"> *</span>
<span class="cm"> * Send a mondo interrupt to the CPUs in the given CPU list with the</span>
<span class="cm"> * 64-bytes at the given data real address.  The data must be 64-byte</span>
<span class="cm"> * aligned.  The mondo data will be delivered to the cpu_mondo queues</span>
<span class="cm"> * of the recipient CPUs.</span>
<span class="cm"> *</span>
<span class="cm"> * In all cases, error or not, the CPUs in the CPU list to which the</span>
<span class="cm"> * mondo has been successfully delivered will be indicated by having</span>
<span class="cm"> * their entry in CPU list updated with the value 0xffff.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_MONDO_SEND		0x42</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_cpu_mondo_send</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_list_pa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mondo_block_pa</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* cpu_myid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_MYID</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	CPU ID</span>
<span class="cm"> * ERRORS:	No errors defined.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the hypervisor ID handle for the current CPU.  Use by a</span>
<span class="cm"> * virtual CPU to discover it&#39;s own identity.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_MYID		0x16</span>

<span class="cm">/* cpu_state()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_STATE</span>
<span class="cm"> * ARG0:	CPU ID</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	state</span>
<span class="cm"> * ERRORS:	ENOCPU		Invalid CPU ID</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve the current state of the CPU with the given CPU ID.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_STATE		0x17</span>
<span class="cp">#define  HV_CPU_STATE_STOPPED		 0x01</span>
<span class="cp">#define  HV_CPU_STATE_RUNNING		 0x02</span>
<span class="cp">#define  HV_CPU_STATE_ERROR		 0x03</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">sun4v_cpu_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpuid</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* cpu_set_rtba()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_SET_RTBA</span>
<span class="cm"> * ARG0:	RTBA</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	previous RTBA</span>
<span class="cm"> * ERRORS:	ENORADDR	Invalid RTBA real address</span>
<span class="cm"> *		EBADALIGN	RTBA is incorrectly aligned for a trap table</span>
<span class="cm"> *</span>
<span class="cm"> * Set the real trap base address of the local cpu to the given RTBA.</span>
<span class="cm"> * The supplied RTBA must be aligned on a 256 byte boundary.  Upon</span>
<span class="cm"> * success the previous value of the RTBA is returned in RET1.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This service does not affect %tba</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_SET_RTBA		0x18</span>

<span class="cm">/* cpu_set_rtba()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CPU_GET_RTBA</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	previous RTBA</span>
<span class="cm"> * ERRORS:	No possible error.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the current value of RTBA in RET1.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CPU_GET_RTBA		0x19</span>

<span class="cm">/* MMU services.</span>
<span class="cm"> *</span>
<span class="cm"> * Layout of a TSB description for mmu_tsb_ctx{,non}0() calls.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">hv_tsb_descr</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">pgsz_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">assoc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">num_ttes</span><span class="p">;</span>	<span class="cm">/* in TTEs */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ctx_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pgsz_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tsb_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">resv</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="cp">#define HV_TSB_DESCR_PGSZ_IDX_OFFSET	0x00</span>
<span class="cp">#define HV_TSB_DESCR_ASSOC_OFFSET	0x02</span>
<span class="cp">#define HV_TSB_DESCR_NUM_TTES_OFFSET	0x04</span>
<span class="cp">#define HV_TSB_DESCR_CTX_IDX_OFFSET	0x08</span>
<span class="cp">#define HV_TSB_DESCR_PGSZ_MASK_OFFSET	0x0c</span>
<span class="cp">#define HV_TSB_DESCR_TSB_BASE_OFFSET	0x10</span>
<span class="cp">#define HV_TSB_DESCR_RESV_OFFSET	0x18</span>

<span class="cm">/* Page size bitmask.  */</span>
<span class="cp">#define HV_PGSZ_MASK_8K			(1 &lt;&lt; 0)</span>
<span class="cp">#define HV_PGSZ_MASK_64K		(1 &lt;&lt; 1)</span>
<span class="cp">#define HV_PGSZ_MASK_512K		(1 &lt;&lt; 2)</span>
<span class="cp">#define HV_PGSZ_MASK_4MB		(1 &lt;&lt; 3)</span>
<span class="cp">#define HV_PGSZ_MASK_32MB		(1 &lt;&lt; 4)</span>
<span class="cp">#define HV_PGSZ_MASK_256MB		(1 &lt;&lt; 5)</span>
<span class="cp">#define HV_PGSZ_MASK_2GB		(1 &lt;&lt; 6)</span>
<span class="cp">#define HV_PGSZ_MASK_16GB		(1 &lt;&lt; 7)</span>

<span class="cm">/* Page size index.  The value given in the TSB descriptor must correspond</span>
<span class="cm"> * to the smallest page size specified in the pgsz_mask page size bitmask.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PGSZ_IDX_8K			0</span>
<span class="cp">#define HV_PGSZ_IDX_64K			1</span>
<span class="cp">#define HV_PGSZ_IDX_512K		2</span>
<span class="cp">#define HV_PGSZ_IDX_4MB			3</span>
<span class="cp">#define HV_PGSZ_IDX_32MB		4</span>
<span class="cp">#define HV_PGSZ_IDX_256MB		5</span>
<span class="cp">#define HV_PGSZ_IDX_2GB			6</span>
<span class="cp">#define HV_PGSZ_IDX_16GB		7</span>

<span class="cm">/* MMU fault status area.</span>
<span class="cm"> *</span>
<span class="cm"> * MMU related faults have their status and fault address information</span>
<span class="cm"> * placed into a memory region made available by privileged code.  Each</span>
<span class="cm"> * virtual processor must make a mmu_fault_area_conf() call to tell the</span>
<span class="cm"> * hypervisor where that processor&#39;s fault status should be stored.</span>
<span class="cm"> *</span>
<span class="cm"> * The fault status block is a multiple of 64-bytes and must be aligned</span>
<span class="cm"> * on a 64-byte boundary.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">hv_fault_status</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">i_fault_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">i_fault_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">i_fault_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">i_reserved</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">d_fault_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">d_fault_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">d_fault_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">d_reserved</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="cp">#define HV_FAULT_I_TYPE_OFFSET	0x00</span>
<span class="cp">#define HV_FAULT_I_ADDR_OFFSET	0x08</span>
<span class="cp">#define HV_FAULT_I_CTX_OFFSET	0x10</span>
<span class="cp">#define HV_FAULT_D_TYPE_OFFSET	0x40</span>
<span class="cp">#define HV_FAULT_D_ADDR_OFFSET	0x48</span>
<span class="cp">#define HV_FAULT_D_CTX_OFFSET	0x50</span>

<span class="cp">#define HV_FAULT_TYPE_FAST_MISS	1</span>
<span class="cp">#define HV_FAULT_TYPE_FAST_PROT	2</span>
<span class="cp">#define HV_FAULT_TYPE_MMU_MISS	3</span>
<span class="cp">#define HV_FAULT_TYPE_INV_RA	4</span>
<span class="cp">#define HV_FAULT_TYPE_PRIV_VIOL	5</span>
<span class="cp">#define HV_FAULT_TYPE_PROT_VIOL	6</span>
<span class="cp">#define HV_FAULT_TYPE_NFO	7</span>
<span class="cp">#define HV_FAULT_TYPE_NFO_SEFF	8</span>
<span class="cp">#define HV_FAULT_TYPE_INV_VA	9</span>
<span class="cp">#define HV_FAULT_TYPE_INV_ASI	10</span>
<span class="cp">#define HV_FAULT_TYPE_NC_ATOMIC	11</span>
<span class="cp">#define HV_FAULT_TYPE_PRIV_ACT	12</span>
<span class="cp">#define HV_FAULT_TYPE_RESV1	13</span>
<span class="cp">#define HV_FAULT_TYPE_UNALIGNED	14</span>
<span class="cp">#define HV_FAULT_TYPE_INV_PGSZ	15</span>
<span class="cm">/* Values 16 --&gt; -2 are reserved.  */</span>
<span class="cp">#define HV_FAULT_TYPE_MULTIPLE	-1</span>

<span class="cm">/* Flags argument for mmu_{map,unmap}_addr(), mmu_demap_{page,context,all}(),</span>
<span class="cm"> * and mmu_{map,unmap}_perm_addr().</span>
<span class="cm"> */</span>
<span class="cp">#define HV_MMU_DMMU			0x01</span>
<span class="cp">#define HV_MMU_IMMU			0x02</span>
<span class="cp">#define HV_MMU_ALL			(HV_MMU_DMMU | HV_MMU_IMMU)</span>

<span class="cm">/* mmu_map_addr()</span>
<span class="cm"> * TRAP:	HV_MMU_MAP_ADDR_TRAP</span>
<span class="cm"> * ARG0:	virtual address</span>
<span class="cm"> * ARG1:	mmu context</span>
<span class="cm"> * ARG2:	TTE</span>
<span class="cm"> * ARG3:	flags (HV_MMU_{IMMU,DMMU})</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid virtual address, mmu context, or flags</span>
<span class="cm"> *		EBADPGSZ	Invalid page size value</span>
<span class="cm"> *		ENORADDR	Invalid real address in TTE</span>
<span class="cm"> *</span>
<span class="cm"> * Create a non-permanent mapping using the given TTE, virtual</span>
<span class="cm"> * address, and mmu context.  The flags argument determines which</span>
<span class="cm"> * (data, or instruction, or both) TLB the mapping gets loaded into.</span>
<span class="cm"> *</span>
<span class="cm"> * The behavior is undefined if the valid bit is clear in the TTE.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This API call is for privileged code to specify temporary translation</span>
<span class="cm"> *       mappings without the need to create and manage a TSB.</span>
<span class="cm"> */</span>

<span class="cm">/* mmu_unmap_addr()</span>
<span class="cm"> * TRAP:	HV_MMU_UNMAP_ADDR_TRAP</span>
<span class="cm"> * ARG0:	virtual address</span>
<span class="cm"> * ARG1:	mmu context</span>
<span class="cm"> * ARG2:	flags (HV_MMU_{IMMU,DMMU})</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid virtual address, mmu context, or flags</span>
<span class="cm"> *</span>
<span class="cm"> * Demaps the given virtual address in the given mmu context on this</span>
<span class="cm"> * CPU.  This function is intended to be used to demap pages mapped</span>
<span class="cm"> * with mmu_map_addr.  This service is equivalent to invoking</span>
<span class="cm"> * mmu_demap_page() with only the current CPU in the CPU list. The</span>
<span class="cm"> * flags argument determines which (data, or instruction, or both) TLB</span>
<span class="cm"> * the mapping gets unmapped from.</span>
<span class="cm"> *</span>
<span class="cm"> * Attempting to perform an unmap operation for a previously defined</span>
<span class="cm"> * permanent mapping will have undefined results.</span>
<span class="cm"> */</span>

<span class="cm">/* mmu_tsb_ctx0()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_TSB_CTX0</span>
<span class="cm"> * ARG0:	number of TSB descriptions</span>
<span class="cm"> * ARG1:	TSB descriptions pointer</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	ENORADDR		Invalid TSB descriptions pointer or</span>
<span class="cm"> *					TSB base within a descriptor</span>
<span class="cm"> *		EBADALIGN		TSB descriptions pointer is not aligned</span>
<span class="cm"> *					to an 8-byte boundary, or TSB base</span>
<span class="cm"> *					within a descriptor is not aligned for</span>
<span class="cm"> *					the given TSB size</span>
<span class="cm"> *		EBADPGSZ		Invalid page size in a TSB descriptor</span>
<span class="cm"> *		EBADTSB			Invalid associativity or size in a TSB</span>
<span class="cm"> *					descriptor</span>
<span class="cm"> *		EINVAL			Invalid number of TSB descriptions, or</span>
<span class="cm"> *					invalid context index in a TSB</span>
<span class="cm"> *					descriptor, or index page size not</span>
<span class="cm"> *					equal to smallest page size in page</span>
<span class="cm"> *					size bitmask field.</span>
<span class="cm"> *</span>
<span class="cm"> * Configures the TSBs for the current CPU for virtual addresses with</span>
<span class="cm"> * context zero.  The TSB descriptions pointer is a pointer to an</span>
<span class="cm"> * array of the given number of TSB descriptions.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The maximum number of TSBs available to a virtual CPU is given by the</span>
<span class="cm"> *       mmu-max-#tsbs property of the cpu&#39;s corresponding &quot;cpu&quot; node in the</span>
<span class="cm"> *       machine description.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_TSB_CTX0		0x20</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_mmu_tsb_ctx0</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_descriptions</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tsb_desc_ra</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* mmu_tsb_ctxnon0()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_TSB_CTXNON0</span>
<span class="cm"> * ARG0:	number of TSB descriptions</span>
<span class="cm"> * ARG1:	TSB descriptions pointer</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	Same as for mmu_tsb_ctx0() above.</span>
<span class="cm"> *</span>
<span class="cm"> * Configures the TSBs for the current CPU for virtual addresses with</span>
<span class="cm"> * non-zero contexts.  The TSB descriptions pointer is a pointer to an</span>
<span class="cm"> * array of the given number of TSB descriptions.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: A maximum of 16 TSBs may be specified in the TSB description list.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_TSB_CTXNON0		0x21</span>

<span class="cm">/* mmu_demap_page()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_DEMAP_PAGE</span>
<span class="cm"> * ARG0:	reserved, must be zero</span>
<span class="cm"> * ARG1:	reserved, must be zero</span>
<span class="cm"> * ARG2:	virtual address</span>
<span class="cm"> * ARG3:	mmu context</span>
<span class="cm"> * ARG4:	flags (HV_MMU_{IMMU,DMMU})</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL			Invalid virtual address, context, or</span>
<span class="cm"> *					flags value</span>
<span class="cm"> *		ENOTSUPPORTED		ARG0 or ARG1 is non-zero</span>
<span class="cm"> *</span>
<span class="cm"> * Demaps any page mapping of the given virtual address in the given</span>
<span class="cm"> * mmu context for the current virtual CPU.  Any virtually tagged</span>
<span class="cm"> * caches are guaranteed to be kept consistent.  The flags argument</span>
<span class="cm"> * determines which TLB (instruction, or data, or both) participate in</span>
<span class="cm"> * the operation.</span>
<span class="cm"> *</span>
<span class="cm"> * ARG0 and ARG1 are both reserved and must be set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_DEMAP_PAGE		0x22</span>

<span class="cm">/* mmu_demap_ctx()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_DEMAP_CTX</span>
<span class="cm"> * ARG0:	reserved, must be zero</span>
<span class="cm"> * ARG1:	reserved, must be zero</span>
<span class="cm"> * ARG2:	mmu context</span>
<span class="cm"> * ARG3:	flags (HV_MMU_{IMMU,DMMU})</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL			Invalid context or flags value</span>
<span class="cm"> *		ENOTSUPPORTED		ARG0 or ARG1 is non-zero</span>
<span class="cm"> *</span>
<span class="cm"> * Demaps all non-permanent virtual page mappings previously specified</span>
<span class="cm"> * for the given context for the current virtual CPU.  Any virtual</span>
<span class="cm"> * tagged caches are guaranteed to be kept consistent.  The flags</span>
<span class="cm"> * argument determines which TLB (instruction, or data, or both)</span>
<span class="cm"> * participate in the operation.</span>
<span class="cm"> *</span>
<span class="cm"> * ARG0 and ARG1 are both reserved and must be set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_DEMAP_CTX		0x23</span>

<span class="cm">/* mmu_demap_all()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_DEMAP_ALL</span>
<span class="cm"> * ARG0:	reserved, must be zero</span>
<span class="cm"> * ARG1:	reserved, must be zero</span>
<span class="cm"> * ARG2:	flags (HV_MMU_{IMMU,DMMU})</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL			Invalid flags value</span>
<span class="cm"> *		ENOTSUPPORTED		ARG0 or ARG1 is non-zero</span>
<span class="cm"> *</span>
<span class="cm"> * Demaps all non-permanent virtual page mappings previously specified</span>
<span class="cm"> * for the current virtual CPU.  Any virtual tagged caches are</span>
<span class="cm"> * guaranteed to be kept consistent.  The flags argument determines</span>
<span class="cm"> * which TLB (instruction, or data, or both) participate in the</span>
<span class="cm"> * operation.</span>
<span class="cm"> *</span>
<span class="cm"> * ARG0 and ARG1 are both reserved and must be set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_DEMAP_ALL		0x24</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sun4v_mmu_demap_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* mmu_map_perm_addr()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_MAP_PERM_ADDR</span>
<span class="cm"> * ARG0:	virtual address</span>
<span class="cm"> * ARG1:	reserved, must be zero</span>
<span class="cm"> * ARG2:	TTE</span>
<span class="cm"> * ARG3:	flags (HV_MMU_{IMMU,DMMU})</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL			Invalid virtual address or flags value</span>
<span class="cm"> *		EBADPGSZ		Invalid page size value</span>
<span class="cm"> *		ENORADDR		Invalid real address in TTE</span>
<span class="cm"> *		ETOOMANY		Too many mappings (max of 8 reached)</span>
<span class="cm"> *</span>
<span class="cm"> * Create a permanent mapping using the given TTE and virtual address</span>
<span class="cm"> * for context 0 on the calling virtual CPU.  A maximum of 8 such</span>
<span class="cm"> * permanent mappings may be specified by privileged code.  Mappings</span>
<span class="cm"> * may be removed with mmu_unmap_perm_addr().</span>
<span class="cm"> *</span>
<span class="cm"> * The behavior is undefined if a TTE with the valid bit clear is given.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This call is used to specify address space mappings for which</span>
<span class="cm"> *       privileged code does not expect to receive misses.  For example,</span>
<span class="cm"> *       this mechanism can be used to map kernel nucleus code and data.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_MAP_PERM_ADDR	0x25</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_mmu_map_perm_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">set_to_zero</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tte</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* mmu_fault_area_conf()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_FAULT_AREA_CONF</span>
<span class="cm"> * ARG0:	real address</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	previous mmu fault area real address</span>
<span class="cm"> * ERRORS:	ENORADDR		Invalid real address</span>
<span class="cm"> *		EBADALIGN		Invalid alignment for fault area</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the MMU fault status area for the calling CPU.  A 64-byte</span>
<span class="cm"> * aligned real address specifies where MMU fault status information</span>
<span class="cm"> * is placed.  The return value is the previously specified area, or 0</span>
<span class="cm"> * for the first invocation.  Specifying a fault area at real address</span>
<span class="cm"> * 0 is not allowed.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_FAULT_AREA_CONF	0x26</span>

<span class="cm">/* mmu_enable()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_ENABLE</span>
<span class="cm"> * ARG0:	enable flag</span>
<span class="cm"> * ARG1:	return target address</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	ENORADDR		Invalid real address when disabling</span>
<span class="cm"> *					translation.</span>
<span class="cm"> *		EBADALIGN		The return target address is not</span>
<span class="cm"> *					aligned to an instruction.</span>
<span class="cm"> *		EINVAL			The enable flag request the current</span>
<span class="cm"> *					operating mode (e.g. disable if already</span>
<span class="cm"> *					disabled)</span>
<span class="cm"> *</span>
<span class="cm"> * Enable or disable virtual address translation for the calling CPU</span>
<span class="cm"> * within the virtual machine domain.  If the enable flag is zero,</span>
<span class="cm"> * translation is disabled, any non-zero value will enable</span>
<span class="cm"> * translation.</span>
<span class="cm"> *</span>
<span class="cm"> * When this function returns, the newly selected translation mode</span>
<span class="cm"> * will be active.  If the mmu is being enabled, then the return</span>
<span class="cm"> * target address is a virtual address else it is a real address.</span>
<span class="cm"> *</span>
<span class="cm"> * Upon successful completion, control will be returned to the given</span>
<span class="cm"> * return target address (ie. the cpu will jump to that address).  On</span>
<span class="cm"> * failure, the previous mmu mode remains and the trap simply returns</span>
<span class="cm"> * as normal with the appropriate error code in RET0.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_ENABLE		0x27</span>

<span class="cm">/* mmu_unmap_perm_addr()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_UNMAP_PERM_ADDR</span>
<span class="cm"> * ARG0:	virtual address</span>
<span class="cm"> * ARG1:	reserved, must be zero</span>
<span class="cm"> * ARG2:	flags (HV_MMU_{IMMU,DMMU})</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL			Invalid virtual address or flags value</span>
<span class="cm"> *		ENOMAP			Specified mapping was not found</span>
<span class="cm"> *</span>
<span class="cm"> * Demaps any permanent page mapping (established via</span>
<span class="cm"> * mmu_map_perm_addr()) at the given virtual address for context 0 on</span>
<span class="cm"> * the current virtual CPU.  Any virtual tagged caches are guaranteed</span>
<span class="cm"> * to be kept consistent.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_UNMAP_PERM_ADDR	0x28</span>

<span class="cm">/* mmu_tsb_ctx0_info()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_TSB_CTX0_INFO</span>
<span class="cm"> * ARG0:	max TSBs</span>
<span class="cm"> * ARG1:	buffer pointer</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	number of TSBs</span>
<span class="cm"> * ERRORS:	EINVAL			Supplied buffer is too small</span>
<span class="cm"> *		EBADALIGN		The buffer pointer is badly aligned</span>
<span class="cm"> *		ENORADDR		Invalid real address for buffer pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Return the TSB configuration as previous defined by mmu_tsb_ctx0()</span>
<span class="cm"> * into the provided buffer.  The size of the buffer is given in ARG1</span>
<span class="cm"> * in terms of the number of TSB description entries.</span>
<span class="cm"> *</span>
<span class="cm"> * Upon return, RET1 always contains the number of TSB descriptions</span>
<span class="cm"> * previously configured.  If zero TSBs were configured, EOK is</span>
<span class="cm"> * returned with RET1 containing 0.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_TSB_CTX0_INFO	0x29</span>

<span class="cm">/* mmu_tsb_ctxnon0_info()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_TSB_CTXNON0_INFO</span>
<span class="cm"> * ARG0:	max TSBs</span>
<span class="cm"> * ARG1:	buffer pointer</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	number of TSBs</span>
<span class="cm"> * ERRORS:	EINVAL			Supplied buffer is too small</span>
<span class="cm"> *		EBADALIGN		The buffer pointer is badly aligned</span>
<span class="cm"> *		ENORADDR		Invalid real address for buffer pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Return the TSB configuration as previous defined by</span>
<span class="cm"> * mmu_tsb_ctxnon0() into the provided buffer.  The size of the buffer</span>
<span class="cm"> * is given in ARG1 in terms of the number of TSB description entries.</span>
<span class="cm"> *</span>
<span class="cm"> * Upon return, RET1 always contains the number of TSB descriptions</span>
<span class="cm"> * previously configured.  If zero TSBs were configured, EOK is</span>
<span class="cm"> * returned with RET1 containing 0.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_TSB_CTXNON0_INFO	0x2a</span>

<span class="cm">/* mmu_fault_area_info()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMU_FAULT_AREA_INFO</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	fault area real address</span>
<span class="cm"> * ERRORS:	No errors defined.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the currently defined MMU fault status area for the current</span>
<span class="cm"> * CPU.  The real address of the fault status area is returned in</span>
<span class="cm"> * RET1, or 0 is returned in RET1 if no fault status area is defined.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: mmu_fault_area_conf() may be called with the return value (RET1)</span>
<span class="cm"> *       from this service if there is a need to save and restore the fault</span>
<span class="cm"> *	 area for a cpu.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMU_FAULT_AREA_INFO	0x2b</span>

<span class="cm">/* Cache and Memory services. */</span>

<span class="cm">/* mem_scrub()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MEM_SCRUB</span>
<span class="cm"> * ARG0:	real address</span>
<span class="cm"> * ARG1:	length</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	length scrubbed</span>
<span class="cm"> * ERRORS:	ENORADDR	Invalid real address</span>
<span class="cm"> *		EBADALIGN	Start address or length are not correctly</span>
<span class="cm"> *				aligned</span>
<span class="cm"> *		EINVAL		Length is zero</span>
<span class="cm"> *</span>
<span class="cm"> * Zero the memory contents in the range real address to real address</span>
<span class="cm"> * plus length minus 1.  Also, valid ECC will be generated for that</span>
<span class="cm"> * memory address range.  Scrubbing is started at the given real</span>
<span class="cm"> * address, but may not scrub the entire given length.  The actual</span>
<span class="cm"> * length scrubbed will be returned in RET1.</span>
<span class="cm"> *</span>
<span class="cm"> * The real address and length must be aligned on an 8K boundary, or</span>
<span class="cm"> * contain the start address and length from a sun4v error report.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: There are two uses for this function.  The first use is to block clear</span>
<span class="cm"> *       and initialize memory and the second is to scrub an u ncorrectable</span>
<span class="cm"> *       error reported via a resumable or non-resumable trap.  The second</span>
<span class="cm"> *       use requires the arguments to be equal to the real address and length</span>
<span class="cm"> *       provided in a sun4v memory error report.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MEM_SCRUB		0x31</span>

<span class="cm">/* mem_sync()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MEM_SYNC</span>
<span class="cm"> * ARG0:	real address</span>
<span class="cm"> * ARG1:	length</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	length synced</span>
<span class="cm"> * ERRORS:	ENORADDR	Invalid real address</span>
<span class="cm"> *		EBADALIGN	Start address or length are not correctly</span>
<span class="cm"> *				aligned</span>
<span class="cm"> *		EINVAL		Length is zero</span>
<span class="cm"> *</span>
<span class="cm"> * Force the next access within the real address to real address plus</span>
<span class="cm"> * length minus 1 to be fetches from main system memory.  Less than</span>
<span class="cm"> * the given length may be synced, the actual amount synced is</span>
<span class="cm"> * returned in RET1.  The real address and length must be aligned on</span>
<span class="cm"> * an 8K boundary.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MEM_SYNC		0x32</span>

<span class="cm">/* Time of day services.</span>
<span class="cm"> *</span>
<span class="cm"> * The hypervisor maintains the time of day on a per-domain basis.</span>
<span class="cm"> * Changing the time of day in one domain does not affect the time of</span>
<span class="cm"> * day on any other domain.</span>
<span class="cm"> *</span>
<span class="cm"> * Time is described by a single unsigned 64-bit word which is the</span>
<span class="cm"> * number of seconds since the UNIX Epoch (00:00:00 UTC, January 1,</span>
<span class="cm"> * 1970).</span>
<span class="cm"> */</span>

<span class="cm">/* tod_get()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_TOD_GET</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	TOD</span>
<span class="cm"> * ERRORS:	EWOULDBLOCK	TOD resource is temporarily unavailable</span>
<span class="cm"> *		ENOTSUPPORTED	If TOD not supported on this platform</span>
<span class="cm"> *</span>
<span class="cm"> * Return the current time of day.  May block if TOD access is</span>
<span class="cm"> * temporarily not possible.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_TOD_GET			0x50</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_tod_get</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">time</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* tod_set()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_TOD_SET</span>
<span class="cm"> * ARG0:	TOD</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EWOULDBLOCK	TOD resource is temporarily unavailable</span>
<span class="cm"> *		ENOTSUPPORTED	If TOD not supported on this platform</span>
<span class="cm"> *</span>
<span class="cm"> * The current time of day is set to the value specified in ARG0.  May</span>
<span class="cm"> * block if TOD access is temporarily not possible.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_TOD_SET			0x51</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_tod_set</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Console services */</span>

<span class="cm">/* con_getchar()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CONS_GETCHAR</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	character</span>
<span class="cm"> * ERRORS:	EWOULDBLOCK	No character available.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a character from the console device.  If no character is</span>
<span class="cm"> * available then an EWOULDBLOCK error is returned.  If a character is</span>
<span class="cm"> * available, then the returned status is EOK and the character value</span>
<span class="cm"> * is in RET1.</span>
<span class="cm"> *</span>
<span class="cm"> * A virtual BREAK is represented by the 64-bit value -1.</span>
<span class="cm"> *</span>
<span class="cm"> * A virtual HUP signal is represented by the 64-bit value -2.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CONS_GETCHAR		0x60</span>

<span class="cm">/* con_putchar()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CONS_PUTCHAR</span>
<span class="cm"> * ARG0:	character</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Illegal character</span>
<span class="cm"> *		EWOULDBLOCK	Output buffer currently full, would block</span>
<span class="cm"> *</span>
<span class="cm"> * Send a character to the console device.  Only character values</span>
<span class="cm"> * between 0 and 255 may be used.  Values outside this range are</span>
<span class="cm"> * invalid except for the 64-bit value -1 which is used to send a</span>
<span class="cm"> * virtual BREAK.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CONS_PUTCHAR		0x61</span>

<span class="cm">/* con_read()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CONS_READ</span>
<span class="cm"> * ARG0:	buffer real address</span>
<span class="cm"> * ARG1:	buffer size in bytes</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	bytes read or BREAK or HUP</span>
<span class="cm"> * ERRORS:	EWOULDBLOCK	No character available.</span>
<span class="cm"> *</span>
<span class="cm"> * Reads characters into a buffer from the console device.  If no</span>
<span class="cm"> * character is available then an EWOULDBLOCK error is returned.</span>
<span class="cm"> * If a character is available, then the returned status is EOK</span>
<span class="cm"> * and the number of bytes read into the given buffer is provided</span>
<span class="cm"> * in RET1.</span>
<span class="cm"> *</span>
<span class="cm"> * A virtual BREAK is represented by the 64-bit RET1 value -1.</span>
<span class="cm"> *</span>
<span class="cm"> * A virtual HUP signal is represented by the 64-bit RET1 value -2.</span>
<span class="cm"> *</span>
<span class="cm"> * If BREAK or HUP are indicated, no bytes were read into buffer.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CONS_READ		0x62</span>

<span class="cm">/* con_write()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_CONS_WRITE</span>
<span class="cm"> * ARG0:	buffer real address</span>
<span class="cm"> * ARG1:	buffer size in bytes</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	bytes written</span>
<span class="cm"> * ERRORS:	EWOULDBLOCK	Output buffer currently full, would block</span>
<span class="cm"> *</span>
<span class="cm"> * Send a characters in buffer to the console device.  Breaks must be</span>
<span class="cm"> * sent using con_putchar().</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_CONS_WRITE		0x63</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">sun4v_con_getchar</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="n">status</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">sun4v_con_putchar</span><span class="p">(</span><span class="kt">long</span> <span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">sun4v_con_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bytes_read</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_con_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bytes_written</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* mach_set_soft_state()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MACH_SET_SOFT_STATE</span>
<span class="cm"> * ARG0:	software state</span>
<span class="cm"> * ARG1:	software state description pointer</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		software state not valid or software state</span>
<span class="cm"> *				description is not NULL terminated</span>
<span class="cm"> *		ENORADDR	software state description pointer is not a</span>
<span class="cm"> *				valid real address</span>
<span class="cm"> *		EBADALIGNED	software state description is not correctly</span>
<span class="cm"> *				aligned</span>
<span class="cm"> *</span>
<span class="cm"> * This allows the guest to report it&#39;s soft state to the hypervisor.  There</span>
<span class="cm"> * are two primary components to this state.  The first part states whether</span>
<span class="cm"> * the guest software is running or not.  The second containts optional</span>
<span class="cm"> * details specific to the software.</span>
<span class="cm"> *</span>
<span class="cm"> * The software state argument is defined below in HV_SOFT_STATE_*, and</span>
<span class="cm"> * indicates whether the guest is operating normally or in a transitional</span>
<span class="cm"> * state.</span>
<span class="cm"> *</span>
<span class="cm"> * The software state description argument is a real address of a data buffer</span>
<span class="cm"> * of size 32-bytes aligned on a 32-byte boundary.  It is treated as a NULL</span>
<span class="cm"> * terminated 7-bit ASCII string of up to 31 characters not including the</span>
<span class="cm"> * NULL termination.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MACH_SET_SOFT_STATE	0x70</span>
<span class="cp">#define  HV_SOFT_STATE_NORMAL		 0x01</span>
<span class="cp">#define  HV_SOFT_STATE_TRANSITION	 0x02</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_mach_set_soft_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">soft_state</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msg_string_ra</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* mach_get_soft_state()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MACH_GET_SOFT_STATE</span>
<span class="cm"> * ARG0:	software state description pointer</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	software state</span>
<span class="cm"> * ERRORS:	ENORADDR	software state description pointer is not a</span>
<span class="cm"> *				valid real address</span>
<span class="cm"> *		EBADALIGNED	software state description is not correctly</span>
<span class="cm"> *				aligned</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve the current value of the guest&#39;s software state.  The rules</span>
<span class="cm"> * for the software state pointer are the same as for mach_set_soft_state()</span>
<span class="cm"> * above.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MACH_GET_SOFT_STATE	0x71</span>

<span class="cm">/* svc_send()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_SVC_SEND</span>
<span class="cm"> * ARG0:	service ID</span>
<span class="cm"> * ARG1:	buffer real address</span>
<span class="cm"> * ARG2:	buffer size</span>
<span class="cm"> * RET0:	STATUS</span>
<span class="cm"> * RET1:	sent_bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Be careful, all output registers are clobbered by this operation,</span>
<span class="cm"> * so for example it is not possible to save away a value in %o4</span>
<span class="cm"> * across the trap.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_SVC_SEND		0x80</span>

<span class="cm">/* svc_recv()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_SVC_RECV</span>
<span class="cm"> * ARG0:	service ID</span>
<span class="cm"> * ARG1:	buffer real address</span>
<span class="cm"> * ARG2:	buffer size</span>
<span class="cm"> * RET0:	STATUS</span>
<span class="cm"> * RET1:	recv_bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Be careful, all output registers are clobbered by this operation,</span>
<span class="cm"> * so for example it is not possible to save away a value in %o4</span>
<span class="cm"> * across the trap.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_SVC_RECV		0x81</span>

<span class="cm">/* svc_getstatus()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_SVC_GETSTATUS</span>
<span class="cm"> * ARG0:	service ID</span>
<span class="cm"> * RET0:	STATUS</span>
<span class="cm"> * RET1:	status bits</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_SVC_GETSTATUS		0x82</span>

<span class="cm">/* svc_setstatus()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_SVC_SETSTATUS</span>
<span class="cm"> * ARG0:	service ID</span>
<span class="cm"> * ARG1:	bits to set</span>
<span class="cm"> * RET0:	STATUS</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_SVC_SETSTATUS		0x83</span>

<span class="cm">/* svc_clrstatus()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_SVC_CLRSTATUS</span>
<span class="cm"> * ARG0:	service ID</span>
<span class="cm"> * ARG1:	bits to clear</span>
<span class="cm"> * RET0:	STATUS</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_SVC_CLRSTATUS		0x84</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_svc_send</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">svc_id</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer_size</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sent_bytes</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_svc_recv</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">svc_id</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer_size</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">recv_bytes</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_svc_getstatus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">svc_id</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">status_bits</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_svc_setstatus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">svc_id</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status_bits</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_svc_clrstatus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">svc_id</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status_bits</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Trap trace services.</span>
<span class="cm"> *</span>
<span class="cm"> * The hypervisor provides a trap tracing capability for privileged</span>
<span class="cm"> * code running on each virtual CPU.  Privileged code provides a</span>
<span class="cm"> * round-robin trap trace queue within which the hypervisor writes</span>
<span class="cm"> * 64-byte entries detailing hyperprivileged traps taken n behalf of</span>
<span class="cm"> * privileged code.  This is provided as a debugging capability for</span>
<span class="cm"> * privileged code.</span>
<span class="cm"> *</span>
<span class="cm"> * The trap trace control structure is 64-bytes long and placed at the</span>
<span class="cm"> * start (offset 0) of the trap trace buffer, and is described as</span>
<span class="cm"> * follows:</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">hv_trap_trace_control</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">head_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tail_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">__reserved</span><span class="p">[</span><span class="mh">0x30</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)];</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="cp">#define HV_TRAP_TRACE_CTRL_HEAD_OFFSET	0x00</span>
<span class="cp">#define HV_TRAP_TRACE_CTRL_TAIL_OFFSET	0x08</span>

<span class="cm">/* The head offset is the offset of the most recently completed entry</span>
<span class="cm"> * in the trap-trace buffer.  The tail offset is the offset of the</span>
<span class="cm"> * next entry to be written.  The control structure is owned and</span>
<span class="cm"> * modified by the hypervisor.  A guest may not modify the control</span>
<span class="cm"> * structure contents.  Attempts to do so will result in undefined</span>
<span class="cm"> * behavior for the guest.</span>
<span class="cm"> *</span>
<span class="cm"> * Each trap trace buffer entry is laid out as follows:</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">hv_trap_trace_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">type</span><span class="p">;</span>		<span class="cm">/* Hypervisor or guest entry?	*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">hpstate</span><span class="p">;</span>	<span class="cm">/* Hyper-privileged state	*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tl</span><span class="p">;</span>		<span class="cm">/* Trap level			*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">gl</span><span class="p">;</span>		<span class="cm">/* Global register level	*/</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">tt</span><span class="p">;</span>		<span class="cm">/* Trap type			*/</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">tag</span><span class="p">;</span>		<span class="cm">/* Extended trap identifier	*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tstate</span><span class="p">;</span>		<span class="cm">/* Trap state			*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tick</span><span class="p">;</span>		<span class="cm">/* Tick				*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tpc</span><span class="p">;</span>		<span class="cm">/* Trap PC			*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">f1</span><span class="p">;</span>		<span class="cm">/* Entry specific		*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">f2</span><span class="p">;</span>		<span class="cm">/* Entry specific		*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">f3</span><span class="p">;</span>		<span class="cm">/* Entry specific		*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">f4</span><span class="p">;</span>		<span class="cm">/* Entry specific		*/</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_TYPE	0x00</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_HPSTATE	0x01</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_TL		0x02</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_GL		0x03</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_TT		0x04</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_TAG		0x06</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_TSTATE	0x08</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_TICK	0x10</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_TPC		0x18</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_F1		0x20</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_F2		0x28</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_F3		0x30</span>
<span class="cp">#define HV_TRAP_TRACE_ENTRY_F4		0x38</span>

<span class="cm">/* The type field is encoded as follows.  */</span>
<span class="cp">#define HV_TRAP_TYPE_UNDEF		0x00 </span><span class="cm">/* Entry content undefined     */</span><span class="cp"></span>
<span class="cp">#define HV_TRAP_TYPE_HV			0x01 </span><span class="cm">/* Hypervisor trap entry       */</span><span class="cp"></span>
<span class="cp">#define HV_TRAP_TYPE_GUEST		0xff </span><span class="cm">/* Added via ttrace_addentry() */</span><span class="cp"></span>

<span class="cm">/* ttrace_buf_conf()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_TTRACE_BUF_CONF</span>
<span class="cm"> * ARG0:	real address</span>
<span class="cm"> * ARG1:	number of entries</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	number of entries</span>
<span class="cm"> * ERRORS:	ENORADDR	Invalid real address</span>
<span class="cm"> *		EINVAL		Size is too small</span>
<span class="cm"> *		EBADALIGN	Real address not aligned on 64-byte boundary</span>
<span class="cm"> *</span>
<span class="cm"> * Requests hypervisor trap tracing and declares a virtual CPU&#39;s trap</span>
<span class="cm"> * trace buffer to the hypervisor.  The real address supplies the real</span>
<span class="cm"> * base address of the trap trace queue and must be 64-byte aligned.</span>
<span class="cm"> * Specifying a value of 0 for the number of entries disables trap</span>
<span class="cm"> * tracing for the calling virtual CPU.  The buffer allocated must be</span>
<span class="cm"> * sized for a power of two number of 64-byte trap trace entries plus</span>
<span class="cm"> * an initial 64-byte control structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This may be invoked any number of times so that a virtual CPU may</span>
<span class="cm"> * relocate a trap trace buffer or create &quot;snapshots&quot; of information.</span>
<span class="cm"> *</span>
<span class="cm"> * If the real address is illegal or badly aligned, then trap tracing</span>
<span class="cm"> * is disabled and an error is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Upon failure with EINVAL, this service call returns in RET1 the</span>
<span class="cm"> * minimum number of buffer entries required.  Upon other failures</span>
<span class="cm"> * RET1 is undefined.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_TTRACE_BUF_CONF		0x90</span>

<span class="cm">/* ttrace_buf_info()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_TTRACE_BUF_INFO</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	real address</span>
<span class="cm"> * RET2:	size</span>
<span class="cm"> * ERRORS:	None defined.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the size and location of the previously declared trap-trace</span>
<span class="cm"> * buffer.  In the event that no buffer was previously defined, or the</span>
<span class="cm"> * buffer is disabled, this call will return a size of zero bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_TTRACE_BUF_INFO		0x91</span>

<span class="cm">/* ttrace_enable()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_TTRACE_ENABLE</span>
<span class="cm"> * ARG0:	enable</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	previous enable state</span>
<span class="cm"> * ERRORS:	EINVAL		No trap trace buffer currently defined</span>
<span class="cm"> *</span>
<span class="cm"> * Enable or disable trap tracing, and return the previous enabled</span>
<span class="cm"> * state in RET1.  Future systems may define various flags for the</span>
<span class="cm"> * enable argument (ARG0), for the moment a guest should pass</span>
<span class="cm"> * &quot;(uint64_t) -1&quot; to enable, and &quot;(uint64_t) 0&quot; to disable all</span>
<span class="cm"> * tracing - which will ensure future compatibility.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_TTRACE_ENABLE		0x92</span>

<span class="cm">/* ttrace_freeze()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_TTRACE_FREEZE</span>
<span class="cm"> * ARG0:	freeze</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	previous freeze state</span>
<span class="cm"> * ERRORS:	EINVAL		No trap trace buffer currently defined</span>
<span class="cm"> *</span>
<span class="cm"> * Freeze or unfreeze trap tracing, returning the previous freeze</span>
<span class="cm"> * state in RET1.  A guest should pass a non-zero value to freeze and</span>
<span class="cm"> * a zero value to unfreeze all tracing.  The returned previous state</span>
<span class="cm"> * is 0 for not frozen and 1 for frozen.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_TTRACE_FREEZE		0x93</span>

<span class="cm">/* ttrace_addentry()</span>
<span class="cm"> * TRAP:	HV_TTRACE_ADDENTRY_TRAP</span>
<span class="cm"> * ARG0:	tag (16-bits)</span>
<span class="cm"> * ARG1:	data word 0</span>
<span class="cm"> * ARG2:	data word 1</span>
<span class="cm"> * ARG3:	data word 2</span>
<span class="cm"> * ARG4:	data word 3</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		No trap trace buffer currently defined</span>
<span class="cm"> *</span>
<span class="cm"> * Add an entry to the trap trace buffer.  Upon return only ARG0/RET0</span>
<span class="cm"> * is modified - none of the other registers holding arguments are</span>
<span class="cm"> * volatile across this hypervisor service.</span>
<span class="cm"> */</span>

<span class="cm">/* Core dump services.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the hypervisor viraulizes and thus obscures a lot of the</span>
<span class="cm"> * physical machine layout and state, traditional OS crash dumps can</span>
<span class="cm"> * be difficult to diagnose especially when the problem is a</span>
<span class="cm"> * configuration error of some sort.</span>
<span class="cm"> *</span>
<span class="cm"> * The dump services provide an opaque buffer into which the</span>
<span class="cm"> * hypervisor can place it&#39;s internal state in order to assist in</span>
<span class="cm"> * debugging such situations.  The contents are opaque and extremely</span>
<span class="cm"> * platform and hypervisor implementation specific.  The guest, during</span>
<span class="cm"> * a core dump, requests that the hypervisor update any information in</span>
<span class="cm"> * the dump buffer in preparation to being dumped as part of the</span>
<span class="cm"> * domain&#39;s memory image.</span>
<span class="cm"> */</span>

<span class="cm">/* dump_buf_update()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_DUMP_BUF_UPDATE</span>
<span class="cm"> * ARG0:	real address</span>
<span class="cm"> * ARG1:	size</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	required size of dump buffer</span>
<span class="cm"> * ERRORS:	ENORADDR	Invalid real address</span>
<span class="cm"> *		EBADALIGN	Real address is not aligned on a 64-byte</span>
<span class="cm"> *				boundary</span>
<span class="cm"> *		EINVAL		Size is non-zero but less than minimum size</span>
<span class="cm"> *				required</span>
<span class="cm"> *		ENOTSUPPORTED	Operation not supported on current logical</span>
<span class="cm"> *				domain</span>
<span class="cm"> *</span>
<span class="cm"> * Declare a domain dump buffer to the hypervisor.  The real address</span>
<span class="cm"> * provided for the domain dump buffer must be 64-byte aligned.  The</span>
<span class="cm"> * size specifies the size of the dump buffer and may be larger than</span>
<span class="cm"> * the minimum size specified in the machine description.  The</span>
<span class="cm"> * hypervisor will fill the dump buffer with opaque data.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: A guest may elect to include dump buffer contents as part of a crash</span>
<span class="cm"> *       dump to assist with debugging.  This function may be called any number</span>
<span class="cm"> *       of times so that a guest may relocate a dump buffer, or create</span>
<span class="cm"> *       &quot;snapshots&quot; of any dump-buffer information.  Each call to</span>
<span class="cm"> *       dump_buf_update() atomically declares the new dump buffer to the</span>
<span class="cm"> *       hypervisor.</span>
<span class="cm"> *</span>
<span class="cm"> * A specified size of 0 unconfigures the dump buffer.  If the real</span>
<span class="cm"> * address is illegal or badly aligned, then any currently active dump</span>
<span class="cm"> * buffer is disabled and an error is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * In the event that the call fails with EINVAL, RET1 contains the</span>
<span class="cm"> * minimum size requires by the hypervisor for a valid dump buffer.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_DUMP_BUF_UPDATE		0x94</span>

<span class="cm">/* dump_buf_info()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_DUMP_BUF_INFO</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	real address of current dump buffer</span>
<span class="cm"> * RET2:	size of current dump buffer</span>
<span class="cm"> * ERRORS:	No errors defined.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the currently configures dump buffer description.  A</span>
<span class="cm"> * returned size of 0 bytes indicates an undefined dump buffer.  In</span>
<span class="cm"> * this case the return address in RET1 is undefined.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_DUMP_BUF_INFO		0x95</span>

<span class="cm">/* Device interrupt services.</span>
<span class="cm"> *</span>
<span class="cm"> * Device interrupts are allocated to system bus bridges by the hypervisor,</span>
<span class="cm"> * and described to OBP in the machine description.  OBP then describes</span>
<span class="cm"> * these interrupts to the OS via properties in the device tree.</span>
<span class="cm"> *</span>
<span class="cm"> * Terminology:</span>
<span class="cm"> *</span>
<span class="cm"> *	cpuid		Unique opaque value which represents a target cpu.</span>
<span class="cm"> *</span>
<span class="cm"> *	devhandle	Device handle.  It uniquely identifies a device, and</span>
<span class="cm"> *			consistes of the lower 28-bits of the hi-cell of the</span>
<span class="cm"> *			first entry of the device&#39;s &quot;reg&quot; property in the</span>
<span class="cm"> *			OBP device tree.</span>
<span class="cm"> *</span>
<span class="cm"> *	devino		Device interrupt number.  Specifies the relative</span>
<span class="cm"> *			interrupt number within the device.  The unique</span>
<span class="cm"> *			combination of devhandle and devino are used to</span>
<span class="cm"> *			identify a specific device interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> *			Note: The devino value is the same as the values in the</span>
<span class="cm"> *			      &quot;interrupts&quot; property or &quot;interrupt-map&quot; property</span>
<span class="cm"> *			      in the OBP device tree for that device.</span>
<span class="cm"> *</span>
<span class="cm"> *	sysino		System interrupt number.  A 64-bit unsigned interger</span>
<span class="cm"> *			representing a unique interrupt within a virtual</span>
<span class="cm"> *			machine.</span>
<span class="cm"> *</span>
<span class="cm"> *	intr_state	A flag representing the interrupt state for a given</span>
<span class="cm"> *			sysino.  The state values are defined below.</span>
<span class="cm"> *</span>
<span class="cm"> *	intr_enabled	A flag representing the &#39;enabled&#39; state for a given</span>
<span class="cm"> *			sysino.  The enable values are defined below.</span>
<span class="cm"> */</span>

<span class="cp">#define HV_INTR_STATE_IDLE		0 </span><span class="cm">/* Nothing pending */</span><span class="cp"></span>
<span class="cp">#define HV_INTR_STATE_RECEIVED		1 </span><span class="cm">/* Interrupt received by hardware */</span><span class="cp"></span>
<span class="cp">#define HV_INTR_STATE_DELIVERED		2 </span><span class="cm">/* Interrupt delivered to queue */</span><span class="cp"></span>

<span class="cp">#define HV_INTR_DISABLED		0 </span><span class="cm">/* sysino not enabled */</span><span class="cp"></span>
<span class="cp">#define HV_INTR_ENABLED			1 </span><span class="cm">/* sysino enabled */</span><span class="cp"></span>

<span class="cm">/* intr_devino_to_sysino()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_INTR_DEVINO2SYSINO</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	devino</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	sysino</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle/devino</span>
<span class="cm"> *</span>
<span class="cm"> * Converts a device specific interrupt number of the given</span>
<span class="cm"> * devhandle/devino into a system specific ino (sysino).</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_INTR_DEVINO2SYSINO	0xa0</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_devino_to_sysino</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">devhandle</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">devino</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* intr_getenabled()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_INTR_GETENABLED</span>
<span class="cm"> * ARG0:	sysino</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	intr_enabled (HV_INTR_{DISABLED,ENABLED})</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid sysino</span>
<span class="cm"> *</span>
<span class="cm"> * Returns interrupt enabled state in RET1 for the interrupt defined</span>
<span class="cm"> * by the given sysino.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_INTR_GETENABLED		0xa1</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_intr_getenabled</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysino</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* intr_setenabled()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_INTR_SETENABLED</span>
<span class="cm"> * ARG0:	sysino</span>
<span class="cm"> * ARG1:	intr_enabled (HV_INTR_{DISABLED,ENABLED})</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid sysino or intr_enabled value</span>
<span class="cm"> *</span>
<span class="cm"> * Set the &#39;enabled&#39; state of the interrupt sysino.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_INTR_SETENABLED		0xa2</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_intr_setenabled</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysino</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intr_enabled</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* intr_getstate()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_INTR_GETSTATE</span>
<span class="cm"> * ARG0:	sysino</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	intr_state (HV_INTR_STATE_*)</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid sysino</span>
<span class="cm"> *</span>
<span class="cm"> * Returns current state of the interrupt defined by the given sysino.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_INTR_GETSTATE		0xa3</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_intr_getstate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysino</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* intr_setstate()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_INTR_SETSTATE</span>
<span class="cm"> * ARG0:	sysino</span>
<span class="cm"> * ARG1:	intr_state (HV_INTR_STATE_*)</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid sysino or intr_state value</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the current state of the interrupt described by the given sysino</span>
<span class="cm"> * value.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Setting the state to HV_INTR_STATE_IDLE clears any pending</span>
<span class="cm"> *       interrupt for sysino.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_INTR_SETSTATE		0xa4</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_intr_setstate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysino</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intr_state</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* intr_gettarget()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_INTR_GETTARGET</span>
<span class="cm"> * ARG0:	sysino</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	cpuid</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid sysino</span>
<span class="cm"> *</span>
<span class="cm"> * Returns CPU that is the current target of the interrupt defined by</span>
<span class="cm"> * the given sysino.  The CPU value returned is undefined if the target</span>
<span class="cm"> * has not been set via intr_settarget().</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_INTR_GETTARGET		0xa5</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_intr_gettarget</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysino</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* intr_settarget()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_INTR_SETTARGET</span>
<span class="cm"> * ARG0:	sysino</span>
<span class="cm"> * ARG1:	cpuid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid sysino</span>
<span class="cm"> *		ENOCPU		Invalid cpuid</span>
<span class="cm"> *</span>
<span class="cm"> * Set the target CPU for the interrupt defined by the given sysino.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_INTR_SETTARGET		0xa6</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_intr_settarget</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysino</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpuid</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* vintr_get_cookie()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_VINTR_GET_COOKIE</span>
<span class="cm"> * ARG0:	device handle</span>
<span class="cm"> * ARG1:	device ino</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	cookie</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_VINTR_GET_COOKIE	0xa7</span>

<span class="cm">/* vintr_set_cookie()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_VINTR_SET_COOKIE</span>
<span class="cm"> * ARG0:	device handle</span>
<span class="cm"> * ARG1:	device ino</span>
<span class="cm"> * ARG2:	cookie</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_VINTR_SET_COOKIE	0xa8</span>

<span class="cm">/* vintr_get_valid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_VINTR_GET_VALID</span>
<span class="cm"> * ARG0:	device handle</span>
<span class="cm"> * ARG1:	device ino</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	valid state</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_VINTR_GET_VALID		0xa9</span>

<span class="cm">/* vintr_set_valid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_VINTR_SET_VALID</span>
<span class="cm"> * ARG0:	device handle</span>
<span class="cm"> * ARG1:	device ino</span>
<span class="cm"> * ARG2:	valid state</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_VINTR_SET_VALID		0xaa</span>

<span class="cm">/* vintr_get_state()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_VINTR_GET_STATE</span>
<span class="cm"> * ARG0:	device handle</span>
<span class="cm"> * ARG1:	device ino</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	state</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_VINTR_GET_STATE		0xab</span>

<span class="cm">/* vintr_set_state()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_VINTR_SET_STATE</span>
<span class="cm"> * ARG0:	device handle</span>
<span class="cm"> * ARG1:	device ino</span>
<span class="cm"> * ARG2:	state</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_VINTR_SET_STATE		0xac</span>

<span class="cm">/* vintr_get_target()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_VINTR_GET_TARGET</span>
<span class="cm"> * ARG0:	device handle</span>
<span class="cm"> * ARG1:	device ino</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	cpuid</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_VINTR_GET_TARGET	0xad</span>

<span class="cm">/* vintr_set_target()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_VINTR_SET_TARGET</span>
<span class="cm"> * ARG0:	device handle</span>
<span class="cm"> * ARG1:	device ino</span>
<span class="cm"> * ARG2:	cpuid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_VINTR_SET_TARGET	0xae</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_vintr_get_cookie</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_handle</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_ino</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cookie</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_vintr_set_cookie</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_handle</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_ino</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_vintr_get_valid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_handle</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_ino</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">valid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_vintr_set_valid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_handle</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_ino</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">valid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_vintr_get_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_handle</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_ino</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_vintr_set_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_handle</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_ino</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_vintr_get_target</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_handle</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_ino</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cpuid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_vintr_set_target</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_handle</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_ino</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpuid</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* PCI IO services.</span>
<span class="cm"> *</span>
<span class="cm"> * See the terminology descriptions in the device interrupt services</span>
<span class="cm"> * section above as those apply here too.  Here are terminology</span>
<span class="cm"> * definitions specific to these PCI IO services:</span>
<span class="cm"> *</span>
<span class="cm"> *	tsbnum		TSB number.  Indentifies which io-tsb is used.</span>
<span class="cm"> *			For this version of the specification, tsbnum</span>
<span class="cm"> *			must be zero.</span>
<span class="cm"> *</span>
<span class="cm"> *	tsbindex	TSB index.  Identifies which entry in the TSB</span>
<span class="cm"> *			is used.  The first entry is zero.</span>
<span class="cm"> *</span>
<span class="cm"> *	tsbid		A 64-bit aligned data structure which contains</span>
<span class="cm"> *			a tsbnum and a tsbindex.  Bits 63:32 contain the</span>
<span class="cm"> *			tsbnum and bits 31:00 contain the tsbindex.</span>
<span class="cm"> *</span>
<span class="cm"> *			Use the HV_PCI_TSBID() macro to construct such</span>
<span class="cm"> * 			values.</span>
<span class="cm"> *</span>
<span class="cm"> *	io_attributes	IO attributes for IOMMU mappings.  One of more</span>
<span class="cm"> *			of the attritbute bits are stores in a 64-bit</span>
<span class="cm"> *			value.  The values are defined below.</span>
<span class="cm"> *</span>
<span class="cm"> *	r_addr		64-bit real address</span>
<span class="cm"> *</span>
<span class="cm"> *	pci_device	PCI device address.  A PCI device address identifies</span>
<span class="cm"> *			a specific device on a specific PCI bus segment.</span>
<span class="cm"> *			A PCI device address ia a 32-bit unsigned integer</span>
<span class="cm"> *			with the following format:</span>
<span class="cm"> *</span>
<span class="cm"> *				00000000.bbbbbbbb.dddddfff.00000000</span>
<span class="cm"> *</span>
<span class="cm"> *			Use the HV_PCI_DEVICE_BUILD() macro to construct</span>
<span class="cm"> *			such values.</span>
<span class="cm"> *</span>
<span class="cm"> *	pci_config_offset</span>
<span class="cm"> *			PCI configureation space offset.  For conventional</span>
<span class="cm"> *			PCI a value between 0 and 255.  For extended</span>
<span class="cm"> *			configuration space, a value between 0 and 4095.</span>
<span class="cm"> *</span>
<span class="cm"> *			Note: For PCI configuration space accesses, the offset</span>
<span class="cm"> *			      must be aligned to the access size.</span>
<span class="cm"> *</span>
<span class="cm"> *	error_flag	A return value which specifies if the action succeeded</span>
<span class="cm"> *			or failed.  0 means no error, non-0 means some error</span>
<span class="cm"> *			occurred while performing the service.</span>
<span class="cm"> *</span>
<span class="cm"> *	io_sync_direction</span>
<span class="cm"> *			Direction definition for pci_dma_sync(), defined</span>
<span class="cm"> *			below in HV_PCI_SYNC_*.</span>
<span class="cm"> *</span>
<span class="cm"> *	io_page_list	A list of io_page_addresses, an io_page_address is</span>
<span class="cm"> *			a real address.</span>
<span class="cm"> *</span>
<span class="cm"> *	io_page_list_p	A pointer to an io_page_list.</span>
<span class="cm"> *</span>
<span class="cm"> *	&quot;size based byte swap&quot; - Some functions do size based byte swapping</span>
<span class="cm"> *				 which allows sw to access pointers and</span>
<span class="cm"> *				 counters in native form when the processor</span>
<span class="cm"> *				 operates in a different endianness than the</span>
<span class="cm"> *				 IO bus.  Size-based byte swapping converts a</span>
<span class="cm"> *				 multi-byte field between big-endian and</span>
<span class="cm"> *				 little-endian format.</span>
<span class="cm"> */</span>

<span class="cp">#define HV_PCI_MAP_ATTR_READ		0x01</span>
<span class="cp">#define HV_PCI_MAP_ATTR_WRITE		0x02</span>

<span class="cp">#define HV_PCI_DEVICE_BUILD(b,d,f)	\</span>
<span class="cp">	((((b) &amp; 0xff) &lt;&lt; 16) | \</span>
<span class="cp">	 (((d) &amp; 0x1f) &lt;&lt; 11) | \</span>
<span class="cp">	 (((f) &amp; 0x07) &lt;&lt;  8))</span>

<span class="cp">#define HV_PCI_TSBID(__tsb_num, __tsb_index) \</span>
<span class="cp">	((((u64)(__tsb_num)) &lt;&lt; 32UL) | ((u64)(__tsb_index)))</span>

<span class="cp">#define HV_PCI_SYNC_FOR_DEVICE		0x01</span>
<span class="cp">#define HV_PCI_SYNC_FOR_CPU		0x02</span>

<span class="cm">/* pci_iommu_map()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_IOMMU_MAP</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	tsbid</span>
<span class="cm"> * ARG2:	#ttes</span>
<span class="cm"> * ARG3:	io_attributes</span>
<span class="cm"> * ARG4:	io_page_list_p</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	#ttes mapped</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle/tsbnum/tsbindex/io_attributes</span>
<span class="cm"> *		EBADALIGN	Improperly aligned real address</span>
<span class="cm"> *		ENORADDR	Invalid real address</span>
<span class="cm"> *</span>
<span class="cm"> * Create IOMMU mappings in the sun4v device defined by the given</span>
<span class="cm"> * devhandle.  The mappings are created in the TSB defined by the</span>
<span class="cm"> * tsbnum component of the given tsbid.  The first mapping is created</span>
<span class="cm"> * in the TSB i ndex defined by the tsbindex component of the given tsbid.</span>
<span class="cm"> * The call creates up to #ttes mappings, the first one at tsbnum, tsbindex,</span>
<span class="cm"> * the second at tsbnum, tsbindex + 1, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * All mappings are created with the attributes defined by the io_attributes</span>
<span class="cm"> * argument.  The page mapping addresses are described in the io_page_list</span>
<span class="cm"> * defined by the given io_page_list_p, which is a pointer to the io_page_list.</span>
<span class="cm"> * The first entry in the io_page_list is the address for the first iotte, the</span>
<span class="cm"> * 2nd for the 2nd iotte, and so on.</span>
<span class="cm"> *</span>
<span class="cm"> * Each io_page_address in the io_page_list must be appropriately aligned.</span>
<span class="cm"> * #ttes must be greater than zero.  For this version of the spec, the tsbnum</span>
<span class="cm"> * component of the given tsbid must be zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the actual number of mappings creates, which may be less than</span>
<span class="cm"> * or equal to the argument #ttes.  If the function returns a value which</span>
<span class="cm"> * is less than the #ttes, the caller may continus to call the function with</span>
<span class="cm"> * an updated tsbid, #ttes, io_page_list_p arguments until all pages are</span>
<span class="cm"> * mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This function does not imply an iotte cache flush.  The guest must</span>
<span class="cm"> *       demap an entry before re-mapping it.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_IOMMU_MAP		0xb0</span>

<span class="cm">/* pci_iommu_demap()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_IOMMU_DEMAP</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	tsbid</span>
<span class="cm"> * ARG2:	#ttes</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	#ttes demapped</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle/tsbnum/tsbindex</span>
<span class="cm"> *</span>
<span class="cm"> * Demap and flush IOMMU mappings in the device defined by the given</span>
<span class="cm"> * devhandle.  Demaps up to #ttes entries in the TSB defined by the tsbnum</span>
<span class="cm"> * component of the given tsbid, starting at the TSB index defined by the</span>
<span class="cm"> * tsbindex component of the given tsbid.</span>
<span class="cm"> *</span>
<span class="cm"> * For this version of the spec, the tsbnum of the given tsbid must be zero.</span>
<span class="cm"> * #ttes must be greater than zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the actual number of ttes demapped, which may be less than or equal</span>
<span class="cm"> * to the argument #ttes.  If #ttes demapped is less than #ttes, the caller</span>
<span class="cm"> * may continue to call this function with updated tsbid and #ttes arguments</span>
<span class="cm"> * until all pages are demapped.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Entries do not have to be mapped to be demapped.  A demap of an</span>
<span class="cm"> *       unmapped page will flush the entry from the tte cache.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_IOMMU_DEMAP		0xb1</span>

<span class="cm">/* pci_iommu_getmap()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_IOMMU_GETMAP</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	tsbid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	io_attributes</span>
<span class="cm"> * RET2:	real address</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle/tsbnum/tsbindex</span>
<span class="cm"> *		ENOMAP		Mapping is not valid, no translation exists</span>
<span class="cm"> *</span>
<span class="cm"> * Read and return the mapping in the device described by the given devhandle</span>
<span class="cm"> * and tsbid.  If successful, the io_attributes shall be returned in RET1</span>
<span class="cm"> * and the page address of the mapping shall be returned in RET2.</span>
<span class="cm"> *</span>
<span class="cm"> * For this version of the spec, the tsbnum component of the given tsbid</span>
<span class="cm"> * must be zero.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_IOMMU_GETMAP	0xb2</span>

<span class="cm">/* pci_iommu_getbypass()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_IOMMU_GETBYPASS</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	real address</span>
<span class="cm"> * ARG2:	io_attributes</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	io_addr</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle/io_attributes</span>
<span class="cm"> *		ENORADDR	Invalid real address</span>
<span class="cm"> *		ENOTSUPPORTED	Function not supported in this implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * Create a &quot;special&quot; mapping in the device described by the given devhandle,</span>
<span class="cm"> * for the given real address and attributes.  Return the IO address in RET1</span>
<span class="cm"> * if successful.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_IOMMU_GETBYPASS	0xb3</span>

<span class="cm">/* pci_config_get()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_CONFIG_GET</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	pci_device</span>
<span class="cm"> * ARG2:	pci_config_offset</span>
<span class="cm"> * ARG3:	size</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	error_flag</span>
<span class="cm"> * RET2:	data</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle/pci_device/offset/size</span>
<span class="cm"> *		EBADALIGN	pci_config_offset not size aligned</span>
<span class="cm"> *		ENOACCESS	Access to this offset is not permitted</span>
<span class="cm"> *</span>
<span class="cm"> * Read PCI configuration space for the adapter described by the given</span>
<span class="cm"> * devhandle.  Read size (1, 2, or 4) bytes of data from the given</span>
<span class="cm"> * pci_device, at pci_config_offset from the beginning of the device&#39;s</span>
<span class="cm"> * configuration space.  If there was no error, RET1 is set to zero and</span>
<span class="cm"> * RET2 is set to the data read.  Insignificant bits in RET2 are not</span>
<span class="cm"> * guaranteed to have any specific value and therefore must be ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * The data returned in RET2 is size based byte swapped.</span>
<span class="cm"> *</span>
<span class="cm"> * If an error occurs during the read, set RET1 to a non-zero value.  The</span>
<span class="cm"> * given pci_config_offset must be &#39;size&#39; aligned.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_CONFIG_GET		0xb4</span>

<span class="cm">/* pci_config_put()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_CONFIG_PUT</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	pci_device</span>
<span class="cm"> * ARG2:	pci_config_offset</span>
<span class="cm"> * ARG3:	size</span>
<span class="cm"> * ARG4:	data</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	error_flag</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle/pci_device/offset/size</span>
<span class="cm"> *		EBADALIGN	pci_config_offset not size aligned</span>
<span class="cm"> *		ENOACCESS	Access to this offset is not permitted</span>
<span class="cm"> *</span>
<span class="cm"> * Write PCI configuration space for the adapter described by the given</span>
<span class="cm"> * devhandle.  Write size (1, 2, or 4) bytes of data in a single operation,</span>
<span class="cm"> * at pci_config_offset from the beginning of the device&#39;s configuration</span>
<span class="cm"> * space.  The data argument contains the data to be written to configuration</span>
<span class="cm"> * space.  Prior to writing, the data is size based byte swapped.</span>
<span class="cm"> *</span>
<span class="cm"> * If an error occurs during the write access, do not generate an error</span>
<span class="cm"> * report, do set RET1 to a non-zero value.  Otherwise RET1 is zero.</span>
<span class="cm"> * The given pci_config_offset must be &#39;size&#39; aligned.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is permitted to read from offset zero in the configuration</span>
<span class="cm"> * space described by the given pci_device if necessary to ensure that the</span>
<span class="cm"> * write access to config space completes.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_CONFIG_PUT		0xb5</span>

<span class="cm">/* pci_peek()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_PEEK</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	real address</span>
<span class="cm"> * ARG2:	size</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	error_flag</span>
<span class="cm"> * RET2:	data</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or size</span>
<span class="cm"> *		EBADALIGN	Improperly aligned real address</span>
<span class="cm"> *		ENORADDR	Bad real address</span>
<span class="cm"> *		ENOACCESS	Guest access prohibited</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to read the IO address given by the given devhandle, real address,</span>
<span class="cm"> * and size.  Size must be 1, 2, 4, or 8.  The read is performed as a single</span>
<span class="cm"> * access operation using the given size.  If an error occurs when reading</span>
<span class="cm"> * from the given location, do not generate an error report, but return a</span>
<span class="cm"> * non-zero value in RET1.  If the read was successful, return zero in RET1</span>
<span class="cm"> * and return the actual data read in RET2.  The data returned is size based</span>
<span class="cm"> * byte swapped.</span>
<span class="cm"> *</span>
<span class="cm"> * Non-significant bits in RET2 are not guaranteed to have any specific value</span>
<span class="cm"> * and therefore must be ignored.  If RET1 is returned as non-zero, the data</span>
<span class="cm"> * value is not guaranteed to have any specific value and should be ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have permission to read from the given devhandle, real</span>
<span class="cm"> * address, which must be an IO address.  The argument real address must be a</span>
<span class="cm"> * size aligned address.</span>
<span class="cm"> *</span>
<span class="cm"> * The hypervisor implementation of this function must block access to any</span>
<span class="cm"> * IO address that the guest does not have explicit permission to access.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_PEEK		0xb6</span>

<span class="cm">/* pci_poke()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_POKE</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	real address</span>
<span class="cm"> * ARG2:	size</span>
<span class="cm"> * ARG3:	data</span>
<span class="cm"> * ARG4:	pci_device</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	error_flag</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle, size, or pci_device</span>
<span class="cm"> *		EBADALIGN	Improperly aligned real address</span>
<span class="cm"> *		ENORADDR	Bad real address</span>
<span class="cm"> *		ENOACCESS	Guest access prohibited</span>
<span class="cm"> *		ENOTSUPPORTED	Function is not supported by implementation</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to write data to the IO address given by the given devhandle,</span>
<span class="cm"> * real address, and size.  Size must be 1, 2, 4, or 8.  The write is</span>
<span class="cm"> * performed as a single access operation using the given size. Prior to</span>
<span class="cm"> * writing the data is size based swapped.</span>
<span class="cm"> *</span>
<span class="cm"> * If an error occurs when writing to the given location, do not generate an</span>
<span class="cm"> * error report, but return a non-zero value in RET1.  If the write was</span>
<span class="cm"> * successful, return zero in RET1.</span>
<span class="cm"> *</span>
<span class="cm"> * pci_device describes the configuration address of the device being</span>
<span class="cm"> * written to.  The implementation may safely read from offset 0 with</span>
<span class="cm"> * the configuration space of the device described by devhandle and</span>
<span class="cm"> * pci_device in order to guarantee that the write portion of the operation</span>
<span class="cm"> * completes</span>
<span class="cm"> *</span>
<span class="cm"> * Any error that occurs due to the read shall be reported using the normal</span>
<span class="cm"> * error reporting mechanisms .. the read error is not suppressed.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have permission to write to the given devhandle, real</span>
<span class="cm"> * address, which must be an IO address.  The argument real address must be a</span>
<span class="cm"> * size aligned address.  The caller must have permission to read from</span>
<span class="cm"> * the given devhandle, pci_device cofiguration space offset 0.</span>
<span class="cm"> *</span>
<span class="cm"> * The hypervisor implementation of this function must block access to any</span>
<span class="cm"> * IO address that the guest does not have explicit permission to access.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_POKE		0xb7</span>

<span class="cm">/* pci_dma_sync()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_DMA_SYNC</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	real address</span>
<span class="cm"> * ARG2:	size</span>
<span class="cm"> * ARG3:	io_sync_direction</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	#synced</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or io_sync_direction</span>
<span class="cm"> *		ENORADDR	Bad real address</span>
<span class="cm"> *</span>
<span class="cm"> * Synchronize a memory region described by the given real address and size,</span>
<span class="cm"> * for the device defined by the given devhandle using the direction(s)</span>
<span class="cm"> * defined by the given io_sync_direction.  The argument size is the size of</span>
<span class="cm"> * the memory region in bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the actual number of bytes synchronized in the return value #synced,</span>
<span class="cm"> * which may be less than or equal to the argument size.  If the return</span>
<span class="cm"> * value #synced is less than size, the caller must continue to call this</span>
<span class="cm"> * function with updated real address and size arguments until the entire</span>
<span class="cm"> * memory region is synchronized.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_DMA_SYNC		0xb8</span>

<span class="cm">/* PCI MSI services.  */</span>

<span class="cp">#define HV_MSITYPE_MSI32		0x00</span>
<span class="cp">#define HV_MSITYPE_MSI64		0x01</span>

<span class="cp">#define HV_MSIQSTATE_IDLE		0x00</span>
<span class="cp">#define HV_MSIQSTATE_ERROR		0x01</span>

<span class="cp">#define HV_MSIQ_INVALID			0x00</span>
<span class="cp">#define HV_MSIQ_VALID			0x01</span>

<span class="cp">#define HV_MSISTATE_IDLE		0x00</span>
<span class="cp">#define HV_MSISTATE_DELIVERED		0x01</span>

<span class="cp">#define HV_MSIVALID_INVALID		0x00</span>
<span class="cp">#define HV_MSIVALID_VALID		0x01</span>

<span class="cp">#define HV_PCIE_MSGTYPE_PME_MSG		0x18</span>
<span class="cp">#define HV_PCIE_MSGTYPE_PME_ACK_MSG	0x1b</span>
<span class="cp">#define HV_PCIE_MSGTYPE_CORR_MSG	0x30</span>
<span class="cp">#define HV_PCIE_MSGTYPE_NONFATAL_MSG	0x31</span>
<span class="cp">#define HV_PCIE_MSGTYPE_FATAL_MSG	0x33</span>

<span class="cp">#define HV_MSG_INVALID			0x00</span>
<span class="cp">#define HV_MSG_VALID			0x01</span>

<span class="cm">/* pci_msiq_conf()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSIQ_CONF</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msiqid</span>
<span class="cm"> * ARG2:	real address</span>
<span class="cm"> * ARG3:	number of entries</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle, msiqid or nentries</span>
<span class="cm"> *		EBADALIGN	Improperly aligned real address</span>
<span class="cm"> *		ENORADDR	Bad real address</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the MSI queue given by the devhandle and msiqid arguments,</span>
<span class="cm"> * and to be placed at the given real address and be of the given</span>
<span class="cm"> * number of entries.  The real address must be aligned exactly to match</span>
<span class="cm"> * the queue size.  Each queue entry is 64-bytes long, so f.e. a 32 entry</span>
<span class="cm"> * queue must be aligned on a 2048 byte real address boundary.  The MSI-EQ</span>
<span class="cm"> * Head and Tail are initialized so that the MSI-EQ is &#39;empty&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * Implementation Note: Certain implementations have fixed sized queues.  In</span>
<span class="cm"> *                      that case, number of entries must contain the correct</span>
<span class="cm"> *                      value.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSIQ_CONF		0xc0</span>

<span class="cm">/* pci_msiq_info()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSIQ_INFO</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msiqid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	real address</span>
<span class="cm"> * RET2:	number of entries</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msiqid</span>
<span class="cm"> *</span>
<span class="cm"> * Return the configuration information for the MSI queue described</span>
<span class="cm"> * by the given devhandle and msiqid.  The base address of the queue</span>
<span class="cm"> * is returned in ARG1 and the number of entries is returned in ARG2.</span>
<span class="cm"> * If the queue is unconfigured, the real address is undefined and the</span>
<span class="cm"> * number of entries will be returned as zero.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSIQ_INFO		0xc1</span>

<span class="cm">/* pci_msiq_getvalid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSIQ_GETVALID</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msiqid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	msiqvalid	(HV_MSIQ_VALID or HV_MSIQ_INVALID)</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msiqid</span>
<span class="cm"> *</span>
<span class="cm"> * Get the valid state of the MSI-EQ described by the given devhandle and</span>
<span class="cm"> * msiqid.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSIQ_GETVALID	0xc2</span>

<span class="cm">/* pci_msiq_setvalid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSIQ_SETVALID</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msiqid</span>
<span class="cm"> * ARG2:	msiqvalid	(HV_MSIQ_VALID or HV_MSIQ_INVALID)</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msiqid or msiqvalid</span>
<span class="cm"> *				value or MSI EQ is uninitialized</span>
<span class="cm"> *</span>
<span class="cm"> * Set the valid state of the MSI-EQ described by the given devhandle and</span>
<span class="cm"> * msiqid to the given msiqvalid.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSIQ_SETVALID	0xc3</span>

<span class="cm">/* pci_msiq_getstate()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSIQ_GETSTATE</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msiqid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	msiqstate	(HV_MSIQSTATE_IDLE or HV_MSIQSTATE_ERROR)</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msiqid</span>
<span class="cm"> *</span>
<span class="cm"> * Get the state of the MSI-EQ described by the given devhandle and</span>
<span class="cm"> * msiqid.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSIQ_GETSTATE	0xc4</span>

<span class="cm">/* pci_msiq_getvalid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSIQ_GETVALID</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msiqid</span>
<span class="cm"> * ARG2:	msiqstate	(HV_MSIQSTATE_IDLE or HV_MSIQSTATE_ERROR)</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msiqid or msiqstate</span>
<span class="cm"> *				value or MSI EQ is uninitialized</span>
<span class="cm"> *</span>
<span class="cm"> * Set the state of the MSI-EQ described by the given devhandle and</span>
<span class="cm"> * msiqid to the given msiqvalid.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSIQ_SETSTATE	0xc5</span>

<span class="cm">/* pci_msiq_gethead()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSIQ_GETHEAD</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msiqid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	msiqhead</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msiqid</span>
<span class="cm"> *</span>
<span class="cm"> * Get the current MSI EQ queue head for the MSI-EQ described by the</span>
<span class="cm"> * given devhandle and msiqid.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSIQ_GETHEAD	0xc6</span>

<span class="cm">/* pci_msiq_sethead()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSIQ_SETHEAD</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msiqid</span>
<span class="cm"> * ARG2:	msiqhead</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msiqid or msiqhead,</span>
<span class="cm"> *				or MSI EQ is uninitialized</span>
<span class="cm"> *</span>
<span class="cm"> * Set the current MSI EQ queue head for the MSI-EQ described by the</span>
<span class="cm"> * given devhandle and msiqid.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSIQ_SETHEAD	0xc7</span>

<span class="cm">/* pci_msiq_gettail()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSIQ_GETTAIL</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msiqid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	msiqtail</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msiqid</span>
<span class="cm"> *</span>
<span class="cm"> * Get the current MSI EQ queue tail for the MSI-EQ described by the</span>
<span class="cm"> * given devhandle and msiqid.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSIQ_GETTAIL	0xc8</span>

<span class="cm">/* pci_msi_getvalid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSI_GETVALID</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msinum</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	msivalidstate</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msinum</span>
<span class="cm"> *</span>
<span class="cm"> * Get the current valid/enabled state for the MSI defined by the</span>
<span class="cm"> * given devhandle and msinum.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSI_GETVALID	0xc9</span>

<span class="cm">/* pci_msi_setvalid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSI_SETVALID</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msinum</span>
<span class="cm"> * ARG2:	msivalidstate</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msinum or msivalidstate</span>
<span class="cm"> *</span>
<span class="cm"> * Set the current valid/enabled state for the MSI defined by the</span>
<span class="cm"> * given devhandle and msinum.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSI_SETVALID	0xca</span>

<span class="cm">/* pci_msi_getmsiq()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSI_GETMSIQ</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msinum</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	msiqid</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msinum or MSI is unbound</span>
<span class="cm"> *</span>
<span class="cm"> * Get the MSI EQ that the MSI defined by the given devhandle and</span>
<span class="cm"> * msinum is bound to.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSI_GETMSIQ		0xcb</span>

<span class="cm">/* pci_msi_setmsiq()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSI_SETMSIQ</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msinum</span>
<span class="cm"> * ARG2:	msitype</span>
<span class="cm"> * ARG3:	msiqid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msinum or msiqid</span>
<span class="cm"> *</span>
<span class="cm"> * Set the MSI EQ that the MSI defined by the given devhandle and</span>
<span class="cm"> * msinum is bound to.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSI_SETMSIQ		0xcc</span>

<span class="cm">/* pci_msi_getstate()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSI_GETSTATE</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msinum</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	msistate</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msinum</span>
<span class="cm"> *</span>
<span class="cm"> * Get the state of the MSI defined by the given devhandle and msinum.</span>
<span class="cm"> * If not initialized, return HV_MSISTATE_IDLE.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSI_GETSTATE	0xcd</span>

<span class="cm">/* pci_msi_setstate()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSI_SETSTATE</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msinum</span>
<span class="cm"> * ARG2:	msistate</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msinum or msistate</span>
<span class="cm"> *</span>
<span class="cm"> * Set the state of the MSI defined by the given devhandle and msinum.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSI_SETSTATE	0xce</span>

<span class="cm">/* pci_msg_getmsiq()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSG_GETMSIQ</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msgtype</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	msiqid</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msgtype</span>
<span class="cm"> *</span>
<span class="cm"> * Get the MSI EQ of the MSG defined by the given devhandle and msgtype.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSG_GETMSIQ		0xd0</span>

<span class="cm">/* pci_msg_setmsiq()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSG_SETMSIQ</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msgtype</span>
<span class="cm"> * ARG2:	msiqid</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle, msgtype, or msiqid</span>
<span class="cm"> *</span>
<span class="cm"> * Set the MSI EQ of the MSG defined by the given devhandle and msgtype.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSG_SETMSIQ		0xd1</span>

<span class="cm">/* pci_msg_getvalid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSG_GETVALID</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msgtype</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	msgvalidstate</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msgtype</span>
<span class="cm"> *</span>
<span class="cm"> * Get the valid/enabled state of the MSG defined by the given</span>
<span class="cm"> * devhandle and msgtype.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSG_GETVALID	0xd2</span>

<span class="cm">/* pci_msg_setvalid()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_PCI_MSG_SETVALID</span>
<span class="cm"> * ARG0:	devhandle</span>
<span class="cm"> * ARG1:	msgtype</span>
<span class="cm"> * ARG2:	msgvalidstate</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid devhandle or msgtype or msgvalidstate</span>
<span class="cm"> *</span>
<span class="cm"> * Set the valid/enabled state of the MSG defined by the given</span>
<span class="cm"> * devhandle and msgtype.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_PCI_MSG_SETVALID	0xd3</span>

<span class="cm">/* Logical Domain Channel services.  */</span>

<span class="cp">#define LDC_CHANNEL_DOWN		0</span>
<span class="cp">#define LDC_CHANNEL_UP			1</span>
<span class="cp">#define LDC_CHANNEL_RESETTING		2</span>

<span class="cm">/* ldc_tx_qconf()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_TX_QCONF</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * ARG1:	real address base of queue</span>
<span class="cm"> * ARG2:	num entries in queue</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> *</span>
<span class="cm"> * Configure transmit queue for the LDC endpoint specified by the</span>
<span class="cm"> * given channel ID, to be placed at the given real address, and</span>
<span class="cm"> * be of the given num entries.  Num entries must be a power of two.</span>
<span class="cm"> * The real address base of the queue must be aligned on the queue</span>
<span class="cm"> * size.  Each queue entry is 64-bytes, so for example, a 32 entry</span>
<span class="cm"> * queue must be aligned on a 2048 byte real address boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * Upon configuration of a valid transmit queue the head and tail</span>
<span class="cm"> * pointers are set to a hypervisor specific identical value indicating</span>
<span class="cm"> * that the queue initially is empty.</span>
<span class="cm"> *</span>
<span class="cm"> * The endpoint&#39;s transmit queue is un-configured if num entries is zero.</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum number of entries for each queue for a specific cpu may be</span>
<span class="cm"> * determined from the machine description.  A transmit queue may be</span>
<span class="cm"> * specified even in the event that the LDC is down (peer endpoint has no</span>
<span class="cm"> * receive queue specified).  Transmission will begin as soon as the peer</span>
<span class="cm"> * endpoint defines a receive queue.</span>
<span class="cm"> *</span>
<span class="cm"> * It is recommended that a guest wait for a transmit queue to empty prior</span>
<span class="cm"> * to reconfiguring it, or un-configuring it.  Re or un-configuring of a</span>
<span class="cm"> * non-empty transmit queue behaves exactly as defined above, however it</span>
<span class="cm"> * is undefined as to how many of the pending entries in the original queue</span>
<span class="cm"> * will be delivered prior to the re-configuration taking effect.</span>
<span class="cm"> * Furthermore, as the queue configuration causes a reset of the head and</span>
<span class="cm"> * tail pointers there is no way for a guest to determine how many entries</span>
<span class="cm"> * have been sent after the configuration operation.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_TX_QCONF		0xe0</span>

<span class="cm">/* ldc_tx_qinfo()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_TX_QINFO</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	real address base of queue</span>
<span class="cm"> * RET2:	num entries in queue</span>
<span class="cm"> *</span>
<span class="cm"> * Return the configuration info for the transmit queue of LDC endpoint</span>
<span class="cm"> * defined by the given channel ID.  The real address is the currently</span>
<span class="cm"> * defined real address base of the defined queue, and num entries is the</span>
<span class="cm"> * size of the queue in terms of number of entries.</span>
<span class="cm"> *</span>
<span class="cm"> * If the specified channel ID is a valid endpoint number, but no transmit</span>
<span class="cm"> * queue has been defined this service will return success, but with num</span>
<span class="cm"> * entries set to zero and the real address will have an undefined value.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_TX_QINFO		0xe1</span>

<span class="cm">/* ldc_tx_get_state()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_TX_GET_STATE</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	head offset</span>
<span class="cm"> * RET2:	tail offset</span>
<span class="cm"> * RET3:	channel state</span>
<span class="cm"> *</span>
<span class="cm"> * Return the transmit state, and the head and tail queue pointers, for</span>
<span class="cm"> * the transmit queue of the LDC endpoint defined by the given channel ID.</span>
<span class="cm"> * The head and tail values are the byte offset of the head and tail</span>
<span class="cm"> * positions of the transmit queue for the specified endpoint.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_TX_GET_STATE	0xe2</span>

<span class="cm">/* ldc_tx_set_qtail()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_TX_SET_QTAIL</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * ARG1:	tail offset</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> *</span>
<span class="cm"> * Update the tail pointer for the transmit queue associated with the LDC</span>
<span class="cm"> * endpoint defined by the given channel ID.  The tail offset specified</span>
<span class="cm"> * must be aligned on a 64 byte boundary, and calculated so as to increase</span>
<span class="cm"> * the number of pending entries on the transmit queue.  Any attempt to</span>
<span class="cm"> * decrease the number of pending transmit queue entires is considered</span>
<span class="cm"> * an invalid tail offset and will result in an EINVAL error.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the tail of the transmit queue may not be moved backwards, the</span>
<span class="cm"> * transmit queue may be flushed by configuring a new transmit queue,</span>
<span class="cm"> * whereupon the hypervisor will configure the initial transmit head and</span>
<span class="cm"> * tail pointers to be equal.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_TX_SET_QTAIL	0xe3</span>

<span class="cm">/* ldc_rx_qconf()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_RX_QCONF</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * ARG1:	real address base of queue</span>
<span class="cm"> * ARG2:	num entries in queue</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> *</span>
<span class="cm"> * Configure receive queue for the LDC endpoint specified by the</span>
<span class="cm"> * given channel ID, to be placed at the given real address, and</span>
<span class="cm"> * be of the given num entries.  Num entries must be a power of two.</span>
<span class="cm"> * The real address base of the queue must be aligned on the queue</span>
<span class="cm"> * size.  Each queue entry is 64-bytes, so for example, a 32 entry</span>
<span class="cm"> * queue must be aligned on a 2048 byte real address boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * The endpoint&#39;s transmit queue is un-configured if num entries is zero.</span>
<span class="cm"> *</span>
<span class="cm"> * If a valid receive queue is specified for a local endpoint the LDC is</span>
<span class="cm"> * in the up state for the purpose of transmission to this endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum number of entries for each queue for a specific cpu may be</span>
<span class="cm"> * determined from the machine description.</span>
<span class="cm"> *</span>
<span class="cm"> * As receive queue configuration causes a reset of the queue&#39;s head and</span>
<span class="cm"> * tail pointers there is no way for a gues to determine how many entries</span>
<span class="cm"> * have been received between a preceding ldc_get_rx_state() API call</span>
<span class="cm"> * and the completion of the configuration operation.  It should be noted</span>
<span class="cm"> * that datagram delivery is not guaranteed via domain channels anyway,</span>
<span class="cm"> * and therefore any higher protocol should be resilient to datagram</span>
<span class="cm"> * loss if necessary.  However, to overcome this specific race potential</span>
<span class="cm"> * it is recommended, for example, that a higher level protocol be employed</span>
<span class="cm"> * to ensure either retransmission, or ensure that no datagrams are pending</span>
<span class="cm"> * on the peer endpoint&#39;s transmit queue prior to the configuration process.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_RX_QCONF		0xe4</span>

<span class="cm">/* ldc_rx_qinfo()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_RX_QINFO</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	real address base of queue</span>
<span class="cm"> * RET2:	num entries in queue</span>
<span class="cm"> *</span>
<span class="cm"> * Return the configuration info for the receive queue of LDC endpoint</span>
<span class="cm"> * defined by the given channel ID.  The real address is the currently</span>
<span class="cm"> * defined real address base of the defined queue, and num entries is the</span>
<span class="cm"> * size of the queue in terms of number of entries.</span>
<span class="cm"> *</span>
<span class="cm"> * If the specified channel ID is a valid endpoint number, but no receive</span>
<span class="cm"> * queue has been defined this service will return success, but with num</span>
<span class="cm"> * entries set to zero and the real address will have an undefined value.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_RX_QINFO		0xe5</span>

<span class="cm">/* ldc_rx_get_state()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_RX_GET_STATE</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	head offset</span>
<span class="cm"> * RET2:	tail offset</span>
<span class="cm"> * RET3:	channel state</span>
<span class="cm"> *</span>
<span class="cm"> * Return the receive state, and the head and tail queue pointers, for</span>
<span class="cm"> * the receive queue of the LDC endpoint defined by the given channel ID.</span>
<span class="cm"> * The head and tail values are the byte offset of the head and tail</span>
<span class="cm"> * positions of the receive queue for the specified endpoint.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_RX_GET_STATE	0xe6</span>

<span class="cm">/* ldc_rx_set_qhead()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_RX_SET_QHEAD</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * ARG1:	head offset</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> *</span>
<span class="cm"> * Update the head pointer for the receive queue associated with the LDC</span>
<span class="cm"> * endpoint defined by the given channel ID.  The head offset specified</span>
<span class="cm"> * must be aligned on a 64 byte boundary, and calculated so as to decrease</span>
<span class="cm"> * the number of pending entries on the receive queue.  Any attempt to</span>
<span class="cm"> * increase the number of pending receive queue entires is considered</span>
<span class="cm"> * an invalid head offset and will result in an EINVAL error.</span>
<span class="cm"> *</span>
<span class="cm"> * The receive queue may be flushed by setting the head offset equal</span>
<span class="cm"> * to the current tail offset.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_RX_SET_QHEAD	0xe7</span>

<span class="cm">/* LDC Map Table Entry.  Each slot is defined by a translation table</span>
<span class="cm"> * entry, as specified by the LDC_MTE_* bits below, and a 64-bit</span>
<span class="cm"> * hypervisor invalidation cookie.</span>
<span class="cm"> */</span>
<span class="cp">#define LDC_MTE_PADDR	0x0fffffffffffe000 </span><span class="cm">/* pa[55:13]          */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_COPY_W	0x0000000000000400 </span><span class="cm">/* copy write access  */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_COPY_R	0x0000000000000200 </span><span class="cm">/* copy read access   */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_IOMMU_W	0x0000000000000100 </span><span class="cm">/* IOMMU write access */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_IOMMU_R	0x0000000000000080 </span><span class="cm">/* IOMMU read access  */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_EXEC	0x0000000000000040 </span><span class="cm">/* execute            */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_WRITE	0x0000000000000020 </span><span class="cm">/* read               */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_READ	0x0000000000000010 </span><span class="cm">/* write              */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_SZALL	0x000000000000000f </span><span class="cm">/* page size bits     */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_SZ16GB	0x0000000000000007 </span><span class="cm">/* 16GB page          */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_SZ2GB	0x0000000000000006 </span><span class="cm">/* 2GB page           */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_SZ256MB	0x0000000000000005 </span><span class="cm">/* 256MB page         */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_SZ32MB	0x0000000000000004 </span><span class="cm">/* 32MB page          */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_SZ4MB	0x0000000000000003 </span><span class="cm">/* 4MB page           */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_SZ512K	0x0000000000000002 </span><span class="cm">/* 512K page          */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_SZ64K	0x0000000000000001 </span><span class="cm">/* 64K page           */</span><span class="cp"></span>
<span class="cp">#define LDC_MTE_SZ8K	0x0000000000000000 </span><span class="cm">/* 8K page            */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">ldc_mtable_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">cookie</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* ldc_set_map_table()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_SET_MAP_TABLE</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * ARG1:	table real address</span>
<span class="cm"> * ARG2:	num entries</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> *</span>
<span class="cm"> * Register the MTE table at the given table real address, with the</span>
<span class="cm"> * specified num entries, for the LDC indicated by the given channel</span>
<span class="cm"> * ID.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_SET_MAP_TABLE	0xea</span>

<span class="cm">/* ldc_get_map_table()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_GET_MAP_TABLE</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	table real address</span>
<span class="cm"> * RET2:	num entries</span>
<span class="cm"> *</span>
<span class="cm"> * Return the configuration of the current mapping table registered</span>
<span class="cm"> * for the given channel ID.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_GET_MAP_TABLE	0xeb</span>

<span class="cp">#define LDC_COPY_IN	0</span>
<span class="cp">#define LDC_COPY_OUT	1</span>

<span class="cm">/* ldc_copy()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_COPY</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * ARG1:	LDC_COPY_* direction code</span>
<span class="cm"> * ARG2:	target real address</span>
<span class="cm"> * ARG3:	local real address</span>
<span class="cm"> * ARG4:	length in bytes</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	actual length in bytes</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_COPY		0xec</span>

<span class="cp">#define LDC_MEM_READ	1</span>
<span class="cp">#define LDC_MEM_WRITE	2</span>
<span class="cp">#define LDC_MEM_EXEC	4</span>

<span class="cm">/* ldc_mapin()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_MAPIN</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * ARG1:	cookie</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	real address</span>
<span class="cm"> * RET2:	LDC_MEM_* permissions</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_MAPIN		0xed</span>

<span class="cm">/* ldc_unmap()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_UNMAP</span>
<span class="cm"> * ARG0:	real address</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_UNMAP		0xee</span>

<span class="cm">/* ldc_revoke()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_LDC_REVOKE</span>
<span class="cm"> * ARG0:	channel ID</span>
<span class="cm"> * ARG1:	cookie</span>
<span class="cm"> * ARG2:	ldc_mtable_entry cookie</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_LDC_REVOKE		0xef</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_tx_qconf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_entries</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_tx_qinfo</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">num_entries</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_tx_get_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">head_off</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">tail_off</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">chan_state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_tx_set_qtail</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tail_off</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_rx_qconf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_entries</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_rx_qinfo</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">num_entries</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_rx_get_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">head_off</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">tail_off</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">chan_state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_rx_set_qhead</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">head_off</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_set_map_table</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_entries</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_get_map_table</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">num_entries</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_copy</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dir_code</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tgt_raddr</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lcl_raddr</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">actual_len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_mapin</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">perm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_unmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ldc_revoke</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">channel</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mte_cookie</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Performance counter services.  */</span>

<span class="cp">#define HV_PERF_JBUS_PERF_CTRL_REG	0x00</span>
<span class="cp">#define HV_PERF_JBUS_PERF_CNT_REG	0x01</span>
<span class="cp">#define HV_PERF_DRAM_PERF_CTRL_REG_0	0x02</span>
<span class="cp">#define HV_PERF_DRAM_PERF_CNT_REG_0	0x03</span>
<span class="cp">#define HV_PERF_DRAM_PERF_CTRL_REG_1	0x04</span>
<span class="cp">#define HV_PERF_DRAM_PERF_CNT_REG_1	0x05</span>
<span class="cp">#define HV_PERF_DRAM_PERF_CTRL_REG_2	0x06</span>
<span class="cp">#define HV_PERF_DRAM_PERF_CNT_REG_2	0x07</span>
<span class="cp">#define HV_PERF_DRAM_PERF_CTRL_REG_3	0x08</span>
<span class="cp">#define HV_PERF_DRAM_PERF_CNT_REG_3	0x09</span>

<span class="cm">/* get_perfreg()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_GET_PERFREG</span>
<span class="cm"> * ARG0:	performance reg number</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	performance reg value</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid performance register number</span>
<span class="cm"> *		ENOACCESS	No access allowed to performance counters</span>
<span class="cm"> *</span>
<span class="cm"> * Read the value of the given DRAM/JBUS performance counter/control register.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_GET_PERFREG		0x100</span>

<span class="cm">/* set_perfreg()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_SET_PERFREG</span>
<span class="cm"> * ARG0:	performance reg number</span>
<span class="cm"> * ARG1:	performance reg value</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * ERRORS:	EINVAL		Invalid performance register number</span>
<span class="cm"> *		ENOACCESS	No access allowed to performance counters</span>
<span class="cm"> *</span>
<span class="cm"> * Write the given performance reg value to the given DRAM/JBUS</span>
<span class="cm"> * performance counter/control register.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_SET_PERFREG		0x101</span>

<span class="cp">#define HV_N2_PERF_SPARC_CTL		0x0</span>
<span class="cp">#define HV_N2_PERF_DRAM_CTL0		0x1</span>
<span class="cp">#define HV_N2_PERF_DRAM_CNT0		0x2</span>
<span class="cp">#define HV_N2_PERF_DRAM_CTL1		0x3</span>
<span class="cp">#define HV_N2_PERF_DRAM_CNT1		0x4</span>
<span class="cp">#define HV_N2_PERF_DRAM_CTL2		0x5</span>
<span class="cp">#define HV_N2_PERF_DRAM_CNT2		0x6</span>
<span class="cp">#define HV_N2_PERF_DRAM_CTL3		0x7</span>
<span class="cp">#define HV_N2_PERF_DRAM_CNT3		0x8</span>

<span class="cp">#define HV_FAST_N2_GET_PERFREG		0x104</span>
<span class="cp">#define HV_FAST_N2_SET_PERFREG		0x105</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_niagara_getperf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_niagara_setperf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_niagara2_getperf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_niagara2_setperf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* MMU statistics services.</span>
<span class="cm"> *</span>
<span class="cm"> * The hypervisor maintains MMU statistics and privileged code provides</span>
<span class="cm"> * a buffer where these statistics can be collected.  It is continually</span>
<span class="cm"> * updated once configured.  The layout is as follows:</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">hv_mmu_statistics</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_hits_ctx0_8k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_ticks_ctx0_8k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_hits_ctx0_64k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_ticks_ctx0_64k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_hits_ctx0_4mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_ticks_ctx0_4mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_hits_ctx0_256mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_ticks_ctx0_256mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved3</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_hits_ctxnon0_8k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_ticks_ctxnon0_8k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_hits_ctxnon0_64k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_ticks_ctxnon0_64k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved4</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_hits_ctxnon0_4mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_ticks_ctxnon0_4mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved5</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_hits_ctxnon0_256mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">immu_tsb_ticks_ctxnon0_256mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved6</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_hits_ctx0_8k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_ticks_ctx0_8k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_hits_ctx0_64k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_ticks_ctx0_64k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved7</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_hits_ctx0_4mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_ticks_ctx0_4mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved8</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_hits_ctx0_256mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_ticks_ctx0_256mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved9</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_hits_ctxnon0_8k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_ticks_ctxnon0_8k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_hits_ctxnon0_64k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_ticks_ctxnon0_64k_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved10</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_hits_ctxnon0_4mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_ticks_ctxnon0_4mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved11</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_hits_ctxnon0_256mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dmmu_tsb_ticks_ctxnon0_256mb_tte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__reserved12</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* mmustat_conf()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMUSTAT_CONF</span>
<span class="cm"> * ARG0:	real address</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	real address</span>
<span class="cm"> * ERRORS:	ENORADDR	Invalid real address</span>
<span class="cm"> *		EBADALIGN	Real address not aligned on 64-byte boundary</span>
<span class="cm"> *		EBADTRAP	API not supported on this processor</span>
<span class="cm"> *</span>
<span class="cm"> * Enable MMU statistic gathering using the buffer at the given real</span>
<span class="cm"> * address on the current virtual CPU.  The new buffer real address</span>
<span class="cm"> * is given in ARG1, and the previously specified buffer real address</span>
<span class="cm"> * is returned in RET1, or is returned as zero for the first invocation.</span>
<span class="cm"> *</span>
<span class="cm"> * If the passed in real address argument is zero, this will disable</span>
<span class="cm"> * MMU statistic collection on the current virtual CPU.  If an error is</span>
<span class="cm"> * returned then no statistics are collected.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer contents should be initialized to all zeros before being</span>
<span class="cm"> * given to the hypervisor or else the statistics will be meaningless.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMUSTAT_CONF		0x102</span>

<span class="cm">/* mmustat_info()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_MMUSTAT_INFO</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> * RET1:	real address</span>
<span class="cm"> * ERRORS:	EBADTRAP	API not supported on this processor</span>
<span class="cm"> *</span>
<span class="cm"> * Return the current state and real address of the currently configured</span>
<span class="cm"> * MMU statistics buffer on the current virtual CPU.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_MMUSTAT_INFO		0x103</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_mmustat_conf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">orig_ra</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_mmustat_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ra</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* NCS crypto services  */</span>

<span class="cm">/* ncs_request() sub-function numbers */</span>
<span class="cp">#define HV_NCS_QCONF			0x01</span>
<span class="cp">#define HV_NCS_QTAIL_UPDATE		0x02</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">hv_ncs_queue_entry</span> <span class="p">{</span>
	<span class="cm">/* MAU Control Register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mau_control</span><span class="p">;</span>
<span class="cp">#define MAU_CONTROL_INV_PARITY	0x0000000000002000</span>
<span class="cp">#define MAU_CONTROL_STRAND	0x0000000000001800</span>
<span class="cp">#define MAU_CONTROL_BUSY	0x0000000000000400</span>
<span class="cp">#define MAU_CONTROL_INT		0x0000000000000200</span>
<span class="cp">#define MAU_CONTROL_OP		0x00000000000001c0</span>
<span class="cp">#define MAU_CONTROL_OP_SHIFT	6</span>
<span class="cp">#define MAU_OP_LOAD_MA_MEMORY	0x0</span>
<span class="cp">#define MAU_OP_STORE_MA_MEMORY	0x1</span>
<span class="cp">#define MAU_OP_MODULAR_MULT	0x2</span>
<span class="cp">#define MAU_OP_MODULAR_REDUCE	0x3</span>
<span class="cp">#define MAU_OP_MODULAR_EXP_LOOP	0x4</span>
<span class="cp">#define MAU_CONTROL_LEN		0x000000000000003f</span>
<span class="cp">#define MAU_CONTROL_LEN_SHIFT	0</span>

	<span class="cm">/* Real address of bytes to load or store bytes</span>
<span class="cm">	 * into/out-of the MAU.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mau_mpa</span><span class="p">;</span>

	<span class="cm">/* Modular Arithmetic MA Offset Register.  */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mau_ma</span><span class="p">;</span>

	<span class="cm">/* Modular Arithmetic N Prime Register.  */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mau_np</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hv_ncs_qconf_arg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mid</span><span class="p">;</span>      <span class="cm">/* MAU ID, 1 per core on Niagara */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">base</span><span class="p">;</span>     <span class="cm">/* Real address base of queue */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">end</span><span class="p">;</span>	  <span class="cm">/* Real address end of queue */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">num_ents</span><span class="p">;</span> <span class="cm">/* Number of entries in queue */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hv_ncs_qtail_update_arg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mid</span><span class="p">;</span>      <span class="cm">/* MAU ID, 1 per core on Niagara */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tail</span><span class="p">;</span>     <span class="cm">/* New tail index to use */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">syncflag</span><span class="p">;</span> <span class="cm">/* only SYNCFLAG_SYNC is implemented */</span>
<span class="cp">#define HV_NCS_SYNCFLAG_SYNC	0x00</span>
<span class="cp">#define HV_NCS_SYNCFLAG_ASYNC	0x01</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* ncs_request()</span>
<span class="cm"> * TRAP:	HV_FAST_TRAP</span>
<span class="cm"> * FUNCTION:	HV_FAST_NCS_REQUEST</span>
<span class="cm"> * ARG0:	NCS sub-function</span>
<span class="cm"> * ARG1:	sub-function argument real address</span>
<span class="cm"> * ARG2:	size in bytes of sub-function argument</span>
<span class="cm"> * RET0:	status</span>
<span class="cm"> *</span>
<span class="cm"> * The MAU chip of the Niagara processor is not directly accessible</span>
<span class="cm"> * to privileged code, instead it is programmed indirectly via this</span>
<span class="cm"> * hypervisor API.</span>
<span class="cm"> *</span>
<span class="cm"> * The interfaces defines a queue of MAU operations to perform.</span>
<span class="cm"> * Privileged code registers a queue with the hypervisor by invoking</span>
<span class="cm"> * this HVAPI with the HV_NCS_QCONF sub-function, which defines the</span>
<span class="cm"> * base, end, and number of entries of the queue.  Each queue entry</span>
<span class="cm"> * contains a MAU register struct block.</span>
<span class="cm"> *</span>
<span class="cm"> * The privileged code then proceeds to add entries to the queue and</span>
<span class="cm"> * then invoke the HV_NCS_QTAIL_UPDATE sub-function.  Since only</span>
<span class="cm"> * synchronous operations are supported by the current hypervisor,</span>
<span class="cm"> * HV_NCS_QTAIL_UPDATE will run all the pending queue entries to</span>
<span class="cm"> * completion and return HV_EOK, or return an error code.</span>
<span class="cm"> *</span>
<span class="cm"> * The real address of the sub-function argument must be aligned on at</span>
<span class="cm"> * least an 8-byte boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * The tail argument of HV_NCS_QTAIL_UPDATE is an index, not a byte</span>
<span class="cm"> * offset, into the queue and must be less than or equal the &#39;num_ents&#39;</span>
<span class="cm"> * argument given in the HV_NCS_QCONF call.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FAST_NCS_REQUEST		0x110</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_ncs_request</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">request</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg_ra</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg_size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#define HV_FAST_FIRE_GET_PERFREG	0x120</span>
<span class="cp">#define HV_FAST_FIRE_SET_PERFREG	0x121</span>

<span class="cp">#define HV_FAST_REBOOT_DATA_SET		0x172</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_reboot_data_set</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Function numbers for HV_CORE_TRAP.  */</span>
<span class="cp">#define HV_CORE_SET_VER			0x00</span>
<span class="cp">#define HV_CORE_PUTCHAR			0x01</span>
<span class="cp">#define HV_CORE_EXIT			0x02</span>
<span class="cp">#define HV_CORE_GET_VER			0x03</span>

<span class="cm">/* Hypervisor API groups for use with HV_CORE_SET_VER and</span>
<span class="cm"> * HV_CORE_GET_VER.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_GRP_SUN4V			0x0000</span>
<span class="cp">#define HV_GRP_CORE			0x0001</span>
<span class="cp">#define HV_GRP_INTR			0x0002</span>
<span class="cp">#define HV_GRP_SOFT_STATE		0x0003</span>
<span class="cp">#define HV_GRP_TM			0x0080</span>
<span class="cp">#define HV_GRP_PCI			0x0100</span>
<span class="cp">#define HV_GRP_LDOM			0x0101</span>
<span class="cp">#define HV_GRP_SVC_CHAN			0x0102</span>
<span class="cp">#define HV_GRP_NCS			0x0103</span>
<span class="cp">#define HV_GRP_RNG			0x0104</span>
<span class="cp">#define HV_GRP_PBOOT			0x0105</span>
<span class="cp">#define HV_GRP_TPM			0x0107</span>
<span class="cp">#define HV_GRP_SDIO			0x0108</span>
<span class="cp">#define HV_GRP_SDIO_ERR			0x0109</span>
<span class="cp">#define HV_GRP_REBOOT_DATA		0x0110</span>
<span class="cp">#define HV_GRP_NIAG_PERF		0x0200</span>
<span class="cp">#define HV_GRP_FIRE_PERF		0x0201</span>
<span class="cp">#define HV_GRP_N2_CPU			0x0202</span>
<span class="cp">#define HV_GRP_NIU			0x0204</span>
<span class="cp">#define HV_GRP_VF_CPU			0x0205</span>
<span class="cp">#define HV_GRP_KT_CPU			0x0209</span>
<span class="cp">#define HV_GRP_DIAG			0x0300</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_get_version</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">major</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sun4v_set_version</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">major</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">minor</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">actual_minor</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sun4v_hvapi_register</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">major</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sun4v_hvapi_unregister</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sun4v_hvapi_get</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">major</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sun4v_hvapi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* !(_SPARC64_HYPERVISOR_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
