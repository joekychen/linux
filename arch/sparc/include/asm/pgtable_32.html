<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › pgtable_32.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable_32.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _SPARC_PGTABLE_H</span>
<span class="cp">#define _SPARC_PGTABLE_H</span>

<span class="cm">/*  asm/pgtable.h:  Defines and functions used to work</span>
<span class="cm"> *                        with Sparc page tables.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> *  Copyright (C) 1998 Jakub Jelinek (jj@sunsite.mff.cuni.cz)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/const.h&gt;</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;asm-generic/4level-fixup.h&gt;</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/pgtsrmmu.h&gt;</span>
<span class="cp">#include &lt;asm/vaddrs.h&gt;</span>
<span class="cp">#include &lt;asm/oplib.h&gt;</span>
<span class="cp">#include &lt;asm/cpu_type.h&gt;</span>


<span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">page</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">load_mmu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">calc_highpages</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define pte_ERROR(e)   __builtin_trap()</span>
<span class="cp">#define pmd_ERROR(e)   __builtin_trap()</span>
<span class="cp">#define pgd_ERROR(e)   __builtin_trap()</span>

<span class="cp">#define PMD_SHIFT		22</span>
<span class="cp">#define PMD_SIZE        	(1UL &lt;&lt; PMD_SHIFT)</span>
<span class="cp">#define PMD_MASK        	(~(PMD_SIZE-1))</span>
<span class="cp">#define PMD_ALIGN(__addr) 	(((__addr) + ~PMD_MASK) &amp; PMD_MASK)</span>
<span class="cp">#define PGDIR_SHIFT     	SRMMU_PGDIR_SHIFT</span>
<span class="cp">#define PGDIR_SIZE      	SRMMU_PGDIR_SIZE</span>
<span class="cp">#define PGDIR_MASK      	SRMMU_PGDIR_MASK</span>
<span class="cp">#define PTRS_PER_PTE    	1024</span>
<span class="cp">#define PTRS_PER_PMD    	SRMMU_PTRS_PER_PMD</span>
<span class="cp">#define PTRS_PER_PGD    	SRMMU_PTRS_PER_PGD</span>
<span class="cp">#define USER_PTRS_PER_PGD	PAGE_OFFSET / SRMMU_PGDIR_SIZE</span>
<span class="cp">#define FIRST_USER_ADDRESS	0</span>
<span class="cp">#define PTE_SIZE		(PTRS_PER_PTE*4)</span>

<span class="cp">#define PAGE_NONE	SRMMU_PAGE_NONE</span>
<span class="cp">#define PAGE_SHARED	SRMMU_PAGE_SHARED</span>
<span class="cp">#define PAGE_COPY	SRMMU_PAGE_COPY</span>
<span class="cp">#define PAGE_READONLY	SRMMU_PAGE_RDONLY</span>
<span class="cp">#define PAGE_KERNEL	SRMMU_PAGE_KERNEL</span>

<span class="cm">/* Top-level page directory */</span>
<span class="k">extern</span> <span class="n">pgd_t</span> <span class="n">swapper_pg_dir</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr_in_current_pgd</span><span class="p">;</span>

<span class="cm">/*         xwr */</span>
<span class="cp">#define __P000  PAGE_NONE</span>
<span class="cp">#define __P001  PAGE_READONLY</span>
<span class="cp">#define __P010  PAGE_COPY</span>
<span class="cp">#define __P011  PAGE_COPY</span>
<span class="cp">#define __P100  PAGE_READONLY</span>
<span class="cp">#define __P101  PAGE_READONLY</span>
<span class="cp">#define __P110  PAGE_COPY</span>
<span class="cp">#define __P111  PAGE_COPY</span>

<span class="cp">#define __S000	PAGE_NONE</span>
<span class="cp">#define __S001	PAGE_READONLY</span>
<span class="cp">#define __S010	PAGE_SHARED</span>
<span class="cp">#define __S011	PAGE_SHARED</span>
<span class="cp">#define __S100	PAGE_READONLY</span>
<span class="cp">#define __S101	PAGE_READONLY</span>
<span class="cp">#define __S110	PAGE_SHARED</span>
<span class="cp">#define __S111	PAGE_SHARED</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">num_contexts</span><span class="p">;</span>

<span class="cm">/* First physical page can be anywhere, the following is needed so that</span>
<span class="cm"> * va--&gt;pa and vice versa conversions work properly without performance</span>
<span class="cm"> * hit for all __pa()/__va() operations.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_base</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn_base</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * BAD_PAGETABLE is used when we need a bogus page-table, while</span>
<span class="cm"> * BAD_PAGE is used for a bogus page.</span>
<span class="cm"> *</span>
<span class="cm"> * ZERO_PAGE is a global shared page that is always zero: used</span>
<span class="cm"> * for zero-mapped memory areas etc..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">pte_t</span> <span class="o">*</span> <span class="n">__bad_pagetable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">pte_t</span> <span class="n">__bad_page</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">empty_zero_page</span><span class="p">;</span>

<span class="cp">#define BAD_PAGETABLE __bad_pagetable()</span>
<span class="cp">#define BAD_PAGE __bad_page()</span>
<span class="cp">#define ZERO_PAGE(vaddr) (virt_to_page(&amp;empty_zero_page))</span>

<span class="cm">/*</span>
<span class="cm"> * In general all page table modifications should use the V8 atomic</span>
<span class="cm"> * swap instruction.  This insures the mmu and the cpu are in sync</span>
<span class="cm"> * with respect to ref/mod bits in the page tables.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">srmmu_swap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;swap [%2], %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Certain architectures need to do special things when pte&#39;s</span>
<span class="cm"> * within a page table are directly modified.  Thus, the following</span>
<span class="cm"> * hook is made available.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">srmmu_swap</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pteval</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">srmmu_device_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0xF0000000</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">pmd_page</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srmmu_device_memory</span><span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">pfn_to_page</span><span class="p">((</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_PTD_PMASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pgd_page_vaddr</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srmmu_device_memory</span><span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span> <span class="o">=</span> <span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_PTD_PMASK</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__nocache_va</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_present</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_ET_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SRMMU_ET_PTE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_none</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__pte_clear</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pte_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__pte_clear</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_bad</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_ET_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SRMMU_ET_PTD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_present</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_ET_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SRMMU_ET_PTD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_none</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmd_clear</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="o">/</span><span class="n">SRMMU_REAL_PTRS_PER_PTE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_pte</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pmdp</span><span class="o">-&gt;</span><span class="n">pmdv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">__pte</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_none</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>          
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_bad</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_ET_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SRMMU_ET_PTD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pgd_present</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">pgd_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_ET_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SRMMU_ET_PTD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pgd_clear</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_pte</span><span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pgdp</span><span class="p">,</span> <span class="n">__pte</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following only work if pte_present() is true.</span>
<span class="cm"> * Undefined behaviour if not..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_write</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_WRITE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_dirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_DIRTY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_young</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_REF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following only work if pte_present() is not true.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_file</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_FILE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_special</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_wrprotect</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SRMMU_WRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkclean</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SRMMU_DIRTY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkold</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SRMMU_REF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkwrite</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">SRMMU_WRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkdirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">SRMMU_DIRTY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkyoung</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">SRMMU_REF</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define pte_mkspecial(pte)    (pte)</span>

<span class="cp">#define pfn_pte(pfn, prot)		mk_pte(pfn_to_page(pfn), prot)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pte_pfn</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srmmu_device_memory</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Just return something that will cause</span>
<span class="cm">		 * pfn_valid() to return false.  This makes</span>
<span class="cm">		 * copy_one_pte() to just directly copy to</span>
<span class="cm">		 * PTE over.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_PTE_PMASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define pte_page(pte)	pfn_to_page(pte_pfn(pte))</span>

<span class="cm">/*</span>
<span class="cm"> * Conversion functions: convert a page and protection to a page entry,</span>
<span class="cm"> * and a page entry and page directory to the page they refer to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">mk_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">((</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">4</span><span class="p">))</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">pgprot</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">mk_pte_phys</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(((</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">pgprot</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">mk_pte_io</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(((</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">space</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">pgprot</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define pgprot_noncached pgprot_noncached</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgprot_t</span> <span class="nf">pgprot_noncached</span><span class="p">(</span><span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prot</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__pgprot</span><span class="p">(</span><span class="n">SRMMU_CACHE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">prot</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pte_t</span> <span class="n">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span> <span class="n">__attribute_const__</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_CHG_MASK</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">pgprot_val</span><span class="p">(</span><span class="n">newprot</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define pgd_index(address) ((address) &gt;&gt; PGDIR_SHIFT)</span>

<span class="cm">/* to find an entry in a page-table-directory */</span>
<span class="cp">#define pgd_offset(mm, address) ((mm)-&gt;pgd + pgd_index(address))</span>

<span class="cm">/* to find an entry in a kernel page-table-directory */</span>
<span class="cp">#define pgd_offset_k(address) pgd_offset(&amp;init_mm, address)</span>

<span class="cm">/* Find an entry in the second-level page table.. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="nf">pmd_offset</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pgd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">dir</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">PMD_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTRS_PER_PMD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Find an entry in the third-level page table.. */</span>
<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This shortcut works on sun4m (and sun4d) because the nocache area is static.</span>
<span class="cm"> */</span>
<span class="cp">#define pte_offset_map(d, a)		pte_offset_kernel(d,a)</span>
<span class="cp">#define pte_unmap(pte)		do{}while(0)</span>

<span class="k">struct</span> <span class="n">seq_file</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">mmu_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>

<span class="cm">/* Fault handler stuff... */</span>
<span class="cp">#define FAULT_CODE_PROT     0x1</span>
<span class="cp">#define FAULT_CODE_WRITE    0x2</span>
<span class="cp">#define FAULT_CODE_USER     0x4</span>

<span class="cp">#define update_mmu_cache(vma, address, ptep) do { } while (0)</span>

<span class="kt">void</span> <span class="n">srmmu_mapiorange</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xpa</span><span class="p">,</span>
                      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xva</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">srmmu_unmapiorange</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">virt_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Encode and de-code a swap entry */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__swp_type</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">SRMMU_SWP_TYPE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_SWP_TYPE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__swp_offset</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">SRMMU_SWP_OFF_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SRMMU_SWP_OFF_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">swp_entry_t</span> <span class="nf">__swp_entry</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">swp_entry_t</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SRMMU_SWP_TYPE_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">SRMMU_SWP_TYPE_SHIFT</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">SRMMU_SWP_OFF_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">SRMMU_SWP_OFF_SHIFT</span> <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })</span>
<span class="cp">#define __swp_entry_to_pte(x)		((pte_t) { (x).val })</span>

<span class="cm">/* file-offset-in-pte helpers */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pte_to_pgoff</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SRMMU_PTE_FILE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pgoff_to_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">((</span><span class="n">pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">SRMMU_PTE_FILE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">SRMMU_FILE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is made a constant because mm/fremap.c required a constant.</span>
<span class="cm"> */</span>
<span class="cp">#define PTE_FILE_MAX_BITS 24</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ctx_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ctx_list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ctx_list</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctx_number</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">ctx_mm</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ctx_list</span> <span class="o">*</span><span class="n">ctx_list_pool</span><span class="p">;</span>  <span class="cm">/* Dynamically allocated */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ctx_list</span> <span class="n">ctx_free</span><span class="p">;</span>        <span class="cm">/* Head of free list */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ctx_list</span> <span class="n">ctx_used</span><span class="p">;</span>        <span class="cm">/* Head of used contexts list */</span>

<span class="cp">#define NO_CONTEXT     -1</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_from_ctx_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctx_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_to_ctx_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctx_list</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ctx_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define add_to_free_ctxlist(entry) add_to_ctx_list(&amp;ctx_free, entry)</span>
<span class="cp">#define add_to_used_ctxlist(entry) add_to_ctx_list(&amp;ctx_used, entry)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">__get_phys</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sparc_cpu_model</span><span class="p">){</span>
	<span class="k">case</span> <span class="n">sun4m</span>:
	<span class="k">case</span> <span class="n">sun4d</span>:
		<span class="k">return</span> <span class="p">((</span><span class="n">srmmu_get_pte</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff00</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">__get_iospace</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sparc_cpu_model</span><span class="p">){</span>
	<span class="k">case</span> <span class="n">sun4m</span>:
	<span class="k">case</span> <span class="n">sun4d</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">srmmu_get_pte</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sparc_valid_addr_bitmap</span><span class="p">;</span>

<span class="cm">/* Needs to be defined here and not in linux/mm.h, as it is arch dependent */</span>
<span class="cp">#define kern_addr_valid(addr) \</span>
<span class="cp">	(test_bit(__pa((unsigned long)(addr))&gt;&gt;20, sparc_valid_addr_bitmap))</span>

<span class="cm">/*</span>
<span class="cm"> * For sparc32&amp;64, the pfn in io_remap_pfn_range() carries &lt;iospace&gt; in</span>
<span class="cm"> * its high 4 bits.  These macros/functions put it there or get it from there.</span>
<span class="cm"> */</span>
<span class="cp">#define MK_IOSPACE_PFN(space, pfn)	(pfn | (space &lt;&lt; (BITS_PER_LONG - 4)))</span>
<span class="cp">#define GET_IOSPACE(pfn)		(pfn &gt;&gt; (BITS_PER_LONG - 4))</span>
<span class="cp">#define GET_PFN(pfn)			(pfn &amp; 0x0fffffffUL)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">remap_pfn_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">pgprot_t</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">io_remap_pfn_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">phys_base</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">GET_PFN</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">space</span> <span class="o">=</span> <span class="n">GET_IOSPACE</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">phys_base</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">|</span> <span class="p">(</span><span class="n">space</span> <span class="o">&lt;&lt;</span> <span class="mi">32ULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">remap_pfn_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">phys_base</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS</span>
<span class="cp">#define ptep_set_access_flags(__vma, __address, __ptep, __entry, __dirty) \</span>
<span class="cp">({									  \</span>
<span class="cp">	int __changed = !pte_same(*(__ptep), __entry);			  \</span>
<span class="cp">	if (__changed) {						  \</span>
<span class="cp">		set_pte_at((__vma)-&gt;vm_mm, (__address), __ptep, __entry); \</span>
<span class="cp">		flush_tlb_page(__vma, __address);			  \</span>
<span class="cp">	}								  \</span>
<span class="cp">	__changed;							  \</span>
<span class="cp">})</span>

<span class="cp">#include &lt;asm-generic/pgtable.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* !(__ASSEMBLY__) */</span><span class="cp"></span>

<span class="cp">#define VMALLOC_START           _AC(0xfe600000,UL)</span>
<span class="cp">#define VMALLOC_END             _AC(0xffc00000,UL)</span>

<span class="cm">/* We provide our own get_unmapped_area to cope with VA holes for userland */</span>
<span class="cp">#define HAVE_ARCH_UNMAPPED_AREA</span>

<span class="cm">/*</span>
<span class="cm"> * No page table caches to initialise</span>
<span class="cm"> */</span>
<span class="cp">#define pgtable_cache_init()	do { } while (0)</span>

<span class="cp">#endif </span><span class="cm">/* !(_SPARC_PGTABLE_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
