<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › pgtsrmmu.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtsrmmu.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * pgtsrmmu.h:  SRMMU page table defines and code.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _SPARC_PGTSRMMU_H</span>
<span class="cp">#define _SPARC_PGTSRMMU_H</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cp">#ifdef __ASSEMBLY__</span>
<span class="cp">#include &lt;asm/thread_info.h&gt;	</span><span class="cm">/* TI_UWINMASK for WINDOW_FLUSH */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/* Number of contexts is implementation-dependent; 64k is the most we support */</span>
<span class="cp">#define SRMMU_MAX_CONTEXTS	65536</span>

<span class="cm">/* PMD_SHIFT determines the size of the area a second-level page table entry can map */</span>
<span class="cp">#define SRMMU_REAL_PMD_SHIFT		18</span>
<span class="cp">#define SRMMU_REAL_PMD_SIZE		(1UL &lt;&lt; SRMMU_REAL_PMD_SHIFT)</span>
<span class="cp">#define SRMMU_REAL_PMD_MASK		(~(SRMMU_REAL_PMD_SIZE-1))</span>
<span class="cp">#define SRMMU_REAL_PMD_ALIGN(__addr)	(((__addr)+SRMMU_REAL_PMD_SIZE-1)&amp;SRMMU_REAL_PMD_MASK)</span>

<span class="cm">/* PGDIR_SHIFT determines what a third-level page table entry can map */</span>
<span class="cp">#define SRMMU_PGDIR_SHIFT       24</span>
<span class="cp">#define SRMMU_PGDIR_SIZE        (1UL &lt;&lt; SRMMU_PGDIR_SHIFT)</span>
<span class="cp">#define SRMMU_PGDIR_MASK        (~(SRMMU_PGDIR_SIZE-1))</span>
<span class="cp">#define SRMMU_PGDIR_ALIGN(addr) (((addr)+SRMMU_PGDIR_SIZE-1)&amp;SRMMU_PGDIR_MASK)</span>

<span class="cp">#define SRMMU_REAL_PTRS_PER_PTE	64</span>
<span class="cp">#define SRMMU_REAL_PTRS_PER_PMD	64</span>
<span class="cp">#define SRMMU_PTRS_PER_PGD	256</span>

<span class="cp">#define SRMMU_REAL_PTE_TABLE_SIZE	(SRMMU_REAL_PTRS_PER_PTE*4)</span>
<span class="cp">#define SRMMU_PMD_TABLE_SIZE		(SRMMU_REAL_PTRS_PER_PMD*4)</span>
<span class="cp">#define SRMMU_PGD_TABLE_SIZE		(SRMMU_PTRS_PER_PGD*4)</span>

<span class="cm">/*</span>
<span class="cm"> * To support pagetables in highmem, Linux introduces APIs which</span>
<span class="cm"> * return struct page* and generally manipulate page tables when</span>
<span class="cm"> * they are not mapped into kernel space. Our hardware page tables</span>
<span class="cm"> * are smaller than pages. We lump hardware tabes into big, page sized</span>
<span class="cm"> * software tables.</span>
<span class="cm"> *</span>
<span class="cm"> * PMD_SHIFT determines the size of the area a second-level page table entry</span>
<span class="cm"> * can map, and our pmd_t is 16 times larger than normal.  The values which</span>
<span class="cm"> * were once defined here are now generic for 4c and srmmu, so they&#39;re</span>
<span class="cm"> * found in pgtable.h.</span>
<span class="cm"> */</span>
<span class="cp">#define SRMMU_PTRS_PER_PMD	4</span>

<span class="cm">/* Definition of the values in the ET field of PTD&#39;s and PTE&#39;s */</span>
<span class="cp">#define SRMMU_ET_MASK         0x3</span>
<span class="cp">#define SRMMU_ET_INVALID      0x0</span>
<span class="cp">#define SRMMU_ET_PTD          0x1</span>
<span class="cp">#define SRMMU_ET_PTE          0x2</span>
<span class="cp">#define SRMMU_ET_REPTE        0x3 </span><span class="cm">/* AIEEE, SuperSparc II reverse endian page! */</span><span class="cp"></span>

<span class="cm">/* Physical page extraction from PTP&#39;s and PTE&#39;s. */</span>
<span class="cp">#define SRMMU_CTX_PMASK    0xfffffff0</span>
<span class="cp">#define SRMMU_PTD_PMASK    0xfffffff0</span>
<span class="cp">#define SRMMU_PTE_PMASK    0xffffff00</span>

<span class="cm">/* The pte non-page bits.  Some notes:</span>
<span class="cm"> * 1) cache, dirty, valid, and ref are frobbable</span>
<span class="cm"> *    for both supervisor and user pages.</span>
<span class="cm"> * 2) exec and write will only give the desired effect</span>
<span class="cm"> *    on user pages</span>
<span class="cm"> * 3) use priv and priv_readonly for changing the</span>
<span class="cm"> *    characteristics of supervisor ptes</span>
<span class="cm"> */</span>
<span class="cp">#define SRMMU_CACHE        0x80</span>
<span class="cp">#define SRMMU_DIRTY        0x40</span>
<span class="cp">#define SRMMU_REF          0x20</span>
<span class="cp">#define SRMMU_NOREAD       0x10</span>
<span class="cp">#define SRMMU_EXEC         0x08</span>
<span class="cp">#define SRMMU_WRITE        0x04</span>
<span class="cp">#define SRMMU_VALID        0x02 </span><span class="cm">/* SRMMU_ET_PTE */</span><span class="cp"></span>
<span class="cp">#define SRMMU_PRIV         0x1c</span>
<span class="cp">#define SRMMU_PRIV_RDONLY  0x18</span>

<span class="cp">#define SRMMU_FILE         0x40	</span><span class="cm">/* Implemented in software */</span><span class="cp"></span>

<span class="cp">#define SRMMU_PTE_FILE_SHIFT     8	</span><span class="cm">/* == 32-PTE_FILE_MAX_BITS */</span><span class="cp"></span>

<span class="cp">#define SRMMU_CHG_MASK    (0xffffff00 | SRMMU_REF | SRMMU_DIRTY)</span>

<span class="cm">/* SRMMU swap entry encoding</span>
<span class="cm"> *</span>
<span class="cm"> * We use 5 bits for the type and 19 for the offset.  This gives us</span>
<span class="cm"> * 32 swapfiles of 4GB each.  Encoding looks like:</span>
<span class="cm"> *</span>
<span class="cm"> * oooooooooooooooooootttttRRRRRRRR</span>
<span class="cm"> * fedcba9876543210fedcba9876543210</span>
<span class="cm"> *</span>
<span class="cm"> * The bottom 8 bits are reserved for protection and status bits, especially</span>
<span class="cm"> * FILE and PRESENT.</span>
<span class="cm"> */</span>
<span class="cp">#define SRMMU_SWP_TYPE_MASK	0x1f</span>
<span class="cp">#define SRMMU_SWP_TYPE_SHIFT	SRMMU_PTE_FILE_SHIFT</span>
<span class="cp">#define SRMMU_SWP_OFF_MASK	0x7ffff</span>
<span class="cp">#define SRMMU_SWP_OFF_SHIFT	(SRMMU_PTE_FILE_SHIFT + 5)</span>

<span class="cm">/* Some day I will implement true fine grained access bits for</span>
<span class="cm"> * user pages because the SRMMU gives us the capabilities to</span>
<span class="cm"> * enforce all the protection levels that vma&#39;s can have.</span>
<span class="cm"> * XXX But for now...</span>
<span class="cm"> */</span>
<span class="cp">#define SRMMU_PAGE_NONE    __pgprot(SRMMU_CACHE | \</span>
<span class="cp">				    SRMMU_PRIV | SRMMU_REF)</span>
<span class="cp">#define SRMMU_PAGE_SHARED  __pgprot(SRMMU_VALID | SRMMU_CACHE | \</span>
<span class="cp">				    SRMMU_EXEC | SRMMU_WRITE | SRMMU_REF)</span>
<span class="cp">#define SRMMU_PAGE_COPY    __pgprot(SRMMU_VALID | SRMMU_CACHE | \</span>
<span class="cp">				    SRMMU_EXEC | SRMMU_REF)</span>
<span class="cp">#define SRMMU_PAGE_RDONLY  __pgprot(SRMMU_VALID | SRMMU_CACHE | \</span>
<span class="cp">				    SRMMU_EXEC | SRMMU_REF)</span>
<span class="cp">#define SRMMU_PAGE_KERNEL  __pgprot(SRMMU_VALID | SRMMU_CACHE | SRMMU_PRIV | \</span>
<span class="cp">				    SRMMU_DIRTY | SRMMU_REF)</span>

<span class="cm">/* SRMMU Register addresses in ASI 0x4.  These are valid for all</span>
<span class="cm"> * current SRMMU implementations that exist.</span>
<span class="cm"> */</span>
<span class="cp">#define SRMMU_CTRL_REG           0x00000000</span>
<span class="cp">#define SRMMU_CTXTBL_PTR         0x00000100</span>
<span class="cp">#define SRMMU_CTX_REG            0x00000200</span>
<span class="cp">#define SRMMU_FAULT_STATUS       0x00000300</span>
<span class="cp">#define SRMMU_FAULT_ADDR         0x00000400</span>

<span class="cp">#define WINDOW_FLUSH(tmp1, tmp2)					\</span>
<span class="cp">	mov	0, tmp1;						\</span>
<span class="cp">98:	ld	[%g6 + TI_UWINMASK], tmp2;				\</span>
<span class="cp">	orcc	%g0, tmp2, %g0;						\</span>
<span class="cp">	add	tmp1, 1, tmp1;						\</span>
<span class="cp">	bne	98b;							\</span>
<span class="cp">	 save	%sp, -64, %sp;						\</span>
<span class="cp">99:	subcc	tmp1, 1, tmp1;						\</span>
<span class="cp">	bne	99b;							\</span>
<span class="cp">	 restore %g0, %g0, %g0;</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_valid_pfn</span><span class="p">;</span>

<span class="cm">/* This makes sense. Honest it does - Anton */</span>
<span class="cm">/* XXX Yes but it&#39;s ugly as sin.  FIXME. -KMW */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">srmmu_nocache_pool</span><span class="p">;</span>
<span class="cp">#define __nocache_pa(VADDR) (((unsigned long)VADDR) - SRMMU_NOCACHE_VADDR + __pa((unsigned long)srmmu_nocache_pool))</span>
<span class="cp">#define __nocache_va(PADDR) (__va((unsigned long)PADDR) - (unsigned long)srmmu_nocache_pool + SRMMU_NOCACHE_VADDR)</span>
<span class="cp">#define __nocache_fix(VADDR) __va(__nocache_pa(VADDR))</span>

<span class="cm">/* Accessing the MMU control register. */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">srmmu_get_mmureg</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">srmmu_set_mmureg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regval</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">srmmu_set_ctable_ptr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">srmmu_set_context</span><span class="p">(</span><span class="kt">int</span> <span class="n">context</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">srmmu_get_context</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">srmmu_get_fstatus</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">srmmu_get_faddr</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* This is guaranteed on all SRMMU&#39;s. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">srmmu_flush_whole_tlb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;sta %%g0, [%0] %1</span><span class="se">\n\t</span><span class="s">&quot;</span><span class="o">:</span> <span class="o">:</span>
			     <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="mh">0x400</span><span class="p">),</span>        <span class="cm">/* Flush entire TLB!! */</span>
			     <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_M_FLUSH_PROBE</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">srmmu_get_pte</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">;</span>
        
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">lda [%1] %2,%0</span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="o">:</span>
				<span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span><span class="o">:</span>
				<span class="s">&quot;r&quot;</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xfffff000</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x400</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">ASI_M_FLUSH_PROBE</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !(__ASSEMBLY__) */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* !(_SPARC_PGTSRMMU_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
