<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › oplib_32.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>oplib_32.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * oplib.h:  Describes the interface and available routines in the</span>
<span class="cm"> *           Linux Prom library.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __SPARC_OPLIB_H</span>
<span class="cp">#define __SPARC_OPLIB_H</span>

<span class="cp">#include &lt;asm/openprom.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>

<span class="cm">/* The master romvec pointer... */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">linux_romvec</span> <span class="o">*</span><span class="n">romvec</span><span class="p">;</span>

<span class="cm">/* Enumeration to describe the prom major version we have detected. */</span>
<span class="k">enum</span> <span class="n">prom_major_version</span> <span class="p">{</span>
	<span class="n">PROM_V0</span><span class="p">,</span>      <span class="cm">/* Original sun4c V0 prom */</span>
	<span class="n">PROM_V2</span><span class="p">,</span>      <span class="cm">/* sun4c and early sun4m V2 prom */</span>
	<span class="n">PROM_V3</span><span class="p">,</span>      <span class="cm">/* sun4m and later, up to sun4d/sun4e machines V3 */</span>
	<span class="n">PROM_P1275</span><span class="p">,</span>   <span class="cm">/* IEEE compliant ISA based Sun PROM, only sun4u */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">enum</span> <span class="n">prom_major_version</span> <span class="n">prom_vers</span><span class="p">;</span>
<span class="cm">/* Revision, and firmware revision. */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prom_rev</span><span class="p">,</span> <span class="n">prom_prev</span><span class="p">;</span>

<span class="cm">/* Root node of the prom device tree, this stays constant after</span>
<span class="cm"> * initialization is complete.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_root_node</span><span class="p">;</span>

<span class="cm">/* Pointer to prom structure containing the device tree traversal</span>
<span class="cm"> * and usage utility functions.  Only prom-lib should use these,</span>
<span class="cm"> * users use the interface defined by the library only!</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">linux_nodeops</span> <span class="o">*</span><span class="n">prom_nodeops</span><span class="p">;</span>

<span class="cm">/* The functions... */</span>

<span class="cm">/* You must call prom_init() before using any of the library services,</span>
<span class="cm"> * preferably as early as possible.  Pass it the romvec pointer.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_romvec</span> <span class="o">*</span><span class="n">rom_ptr</span><span class="p">);</span>

<span class="cm">/* Boot argument acquisition, returns the boot command line string. */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_getbootargs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Miscellaneous routines, don&#39;t really fit in any category per se. */</span>

<span class="cm">/* Reboot the machine with the command line passed. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_reboot</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">boot_command</span><span class="p">);</span>

<span class="cm">/* Evaluate the forth string passed. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_feval</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">forth_string</span><span class="p">);</span>

<span class="cm">/* Enter the prom, with possibility of continuation with the &#39;go&#39;</span>
<span class="cm"> * command in newer proms.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_cmdline</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Enter the prom, with no chance of continuation for the stand-alone</span>
<span class="cm"> * which calls this.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__noreturn</span> <span class="n">prom_halt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Set the PROM &#39;sync&#39; callback function to the passed function pointer.</span>
<span class="cm"> * When the user gives the &#39;sync&#39; command at the prom prompt while the</span>
<span class="cm"> * kernel is still active, the prom will call this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX The arguments are different on V0 vs. V2-&gt;higher proms, grrr! XXX</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_func_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_setsync</span><span class="p">(</span><span class="n">sync_func_t</span> <span class="n">func_ptr</span><span class="p">);</span>

<span class="cm">/* Acquire the IDPROM of the root node in the prom device tree.  This</span>
<span class="cm"> * gets passed a buffer where you would like it stuffed.  The return value</span>
<span class="cm"> * is the format type of this idprom or 0xff on error.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">prom_get_idprom</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">idp_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idpbuf_size</span><span class="p">);</span>

<span class="cm">/* Get the prom major version. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_version</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Get the prom plugin revision. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getrev</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Get the prom firmware revision. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getprev</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Write a buffer of characters to the console. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_console_write_buf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Prom&#39;s internal routines, don&#39;t use in kernel/boot code. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_write</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Multiprocessor operations... */</span>

<span class="cm">/* Start the CPU with the given device tree node, context table, and context</span>
<span class="cm"> * at the passed program counter.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_startcpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpunode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">linux_prom_registers</span> <span class="o">*</span><span class="n">context_table</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">context</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">program_counter</span><span class="p">);</span>

<span class="cm">/* Initialize the memory lists based upon the prom version. */</span>
<span class="kt">void</span> <span class="n">prom_meminit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* PROM device tree traversal functions... */</span>

<span class="cm">/* Get the child node of the given node, or zero if no child exists. */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_getchild</span><span class="p">(</span><span class="n">phandle</span> <span class="n">parent_node</span><span class="p">);</span>

<span class="cm">/* Get the next sibling node of the given node, or zero if no further</span>
<span class="cm"> * siblings exist.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_getsibling</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">);</span>

<span class="cm">/* Get the length, at the passed node, of the given property type.</span>
<span class="cm"> * Returns -1 on error (ie. no such property at this node).</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getproplen</span><span class="p">(</span><span class="n">phandle</span> <span class="n">thisnode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">);</span>

<span class="cm">/* Fetch the requested property using the given buffer.  Returns</span>
<span class="cm"> * the number of bytes the prom put into your buffer or -1 on error.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">prom_getproperty</span><span class="p">(</span><span class="n">phandle</span> <span class="n">thisnode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
					 <span class="kt">char</span> <span class="o">*</span><span class="n">prop_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">propbuf_size</span><span class="p">);</span>

<span class="cm">/* Acquire an integer property. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getint</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">);</span>

<span class="cm">/* Acquire an integer property, with a default value. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getintdefault</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span> <span class="kt">int</span> <span class="n">defval</span><span class="p">);</span>

<span class="cm">/* Acquire a boolean property, 0=FALSE 1=TRUE. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getbool</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop</span><span class="p">);</span>

<span class="cm">/* Acquire a string property, null string on error. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_getstring</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">);</span>

<span class="cm">/* Search all siblings starting at the passed node for &quot;name&quot; matching</span>
<span class="cm"> * the given string.  Returns the node on success, zero on failure.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_searchsiblings</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node_start</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* Returns the next property after the passed property for the given</span>
<span class="cm"> * node.  Returns null string on failure.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_nextprop</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prev_property</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>

<span class="cm">/* Returns phandle of the path specified */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_finddevice</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* Set the indicated property at the given node with the passed value.</span>
<span class="cm"> * Returns the number of bytes of your value that the prom took.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_setprop</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop_name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop_value</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">value_size</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_inst2pkg</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* Dorking with Bus ranges... */</span>

<span class="cm">/* Apply promlib probes OBIO ranges to registers. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_apply_obio_ranges</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_prom_registers</span> <span class="o">*</span><span class="n">obioregs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nregs</span><span class="p">);</span>

<span class="cm">/* Apply ranges of any prom node (and optionally parent node as well) to registers. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_apply_generic_ranges</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="n">phandle</span> <span class="n">parent</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">linux_prom_registers</span> <span class="o">*</span><span class="n">sbusregs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nregs</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">prom_ranges_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* CPU probing helpers.  */</span>
<span class="kt">int</span> <span class="n">cpu_find_by_instance</span><span class="p">(</span><span class="kt">int</span> <span class="n">instance</span><span class="p">,</span> <span class="n">phandle</span> <span class="o">*</span><span class="n">prom_node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cpu_find_by_mid</span><span class="p">(</span><span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="n">phandle</span> <span class="o">*</span><span class="n">prom_node</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cpu_get_hwmid</span><span class="p">(</span><span class="n">phandle</span> <span class="n">prom_node</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">prom_lock</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* !(__SPARC_OPLIB_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
