<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › ptrace.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ptrace.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __SPARC_PTRACE_H</span>
<span class="cp">#define __SPARC_PTRACE_H</span>

<span class="cp">#if defined(__sparc__) &amp;&amp; defined(__arch64__)</span>
<span class="cm">/* 64 bit sparc */</span>
<span class="cp">#include &lt;asm/pstate.h&gt;</span>

<span class="cm">/* This struct defines the way the registers are stored on the</span>
<span class="cm"> * stack during a system call and basically all traps.</span>
<span class="cm"> */</span>

<span class="cm">/* This magic value must have the low 9 bits clear,</span>
<span class="cm"> * as that is where we encode the %tt value, see below.</span>
<span class="cm"> */</span>
<span class="cp">#define PT_REGS_MAGIC 0x57ac6c00</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="k">struct</span> <span class="n">pt_regs</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">u_regs</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="cm">/* globals and ins */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tstate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tpc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tnpc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>

	<span class="cm">/* We encode a magic number, PT_REGS_MAGIC, along</span>
<span class="cm">	 * with the %tt (trap type) register value at trap</span>
<span class="cm">	 * entry time.  The magic number allows us to identify</span>
<span class="cm">	 * accurately a trap stack frame in the stack</span>
<span class="cm">	 * unwinder, and the %tt value allows us to test</span>
<span class="cm">	 * things like &quot;in a system call&quot; etc. for an arbitray</span>
<span class="cm">	 * process.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The PT_REGS_MAGIC is chosen such that it can be</span>
<span class="cm">	 * loaded completely using just a sethi instruction.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pt_regs32</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">psr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u_regs</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="cm">/* globals and ins */</span>
<span class="p">};</span>

<span class="cm">/* A V9 register window */</span>
<span class="k">struct</span> <span class="n">reg_window</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locals</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ins</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* A 32-bit register window. */</span>
<span class="k">struct</span> <span class="n">reg_window32</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">locals</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ins</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* A V9 Sparc stack frame */</span>
<span class="k">struct</span> <span class="n">sparc_stackf</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locals</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ins</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sparc_stackf</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">callers_pc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">structptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xargs</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xxargs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* A 32-bit Sparc stack frame */</span>
<span class="k">struct</span> <span class="n">sparc_stackf32</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">locals</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ins</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">callers_pc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">structptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xargs</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xxargs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sparc_trapf</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locals</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ins</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_unused</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* (!__ASSEMBLY__) */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cm">/* 32 bit sparc */</span>

<span class="cp">#include &lt;asm/psr.h&gt;</span>

<span class="cm">/* This struct defines the way the registers are stored on the</span>
<span class="cm"> * stack during a system call and basically all traps.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="k">struct</span> <span class="n">pt_regs</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">y</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">u_regs</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="cm">/* globals and ins */</span>
<span class="p">};</span>

<span class="cm">/* A 32-bit register window. */</span>
<span class="k">struct</span> <span class="n">reg_window32</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locals</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ins</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* A Sparc stack frame */</span>
<span class="k">struct</span> <span class="n">sparc_stackf</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locals</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ins</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sparc_stackf</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">callers_pc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">structptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xargs</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xxargs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* (!__ASSEMBLY__) */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* (defined(__sparc__) &amp;&amp; defined(__arch64__))*/</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#define TRACEREG_SZ	sizeof(struct pt_regs)</span>
<span class="cp">#define STACKFRAME_SZ	sizeof(struct sparc_stackf)</span>

<span class="cp">#define TRACEREG32_SZ	sizeof(struct pt_regs32)</span>
<span class="cp">#define STACKFRAME32_SZ	sizeof(struct sparc_stackf32)</span>

<span class="cp">#endif </span><span class="cm">/* (!__ASSEMBLY__) */</span><span class="cp"></span>

<span class="cp">#define UREG_G0        0</span>
<span class="cp">#define UREG_G1        1</span>
<span class="cp">#define UREG_G2        2</span>
<span class="cp">#define UREG_G3        3</span>
<span class="cp">#define UREG_G4        4</span>
<span class="cp">#define UREG_G5        5</span>
<span class="cp">#define UREG_G6        6</span>
<span class="cp">#define UREG_G7        7</span>
<span class="cp">#define UREG_I0        8</span>
<span class="cp">#define UREG_I1        9</span>
<span class="cp">#define UREG_I2        10</span>
<span class="cp">#define UREG_I3        11</span>
<span class="cp">#define UREG_I4        12</span>
<span class="cp">#define UREG_I5        13</span>
<span class="cp">#define UREG_I6        14</span>
<span class="cp">#define UREG_I7        15</span>
<span class="cp">#define UREG_FP        UREG_I6</span>
<span class="cp">#define UREG_RETPC     UREG_I7</span>

<span class="cp">#if defined(__sparc__) &amp;&amp; defined(__arch64__)</span>
<span class="cm">/* 64 bit sparc */</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;asm/switch_to.h&gt;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pt_regs_trap_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pt_regs_is_syscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tstate</span> <span class="o">&amp;</span> <span class="n">TSTATE_SYSCALL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pt_regs_clear_syscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tstate</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TSTATE_SYSCALL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define arch_ptrace_stop_needed(exit_code, info) \</span>
<span class="cp">({	flush_user_windows(); \</span>
<span class="cp">	get_thread_wsaved() != 0; \</span>
<span class="cp">})</span>

<span class="cp">#define arch_ptrace_stop(exit_code, info) \</span>
<span class="cp">	synchronize_user_stack()</span>

<span class="k">struct</span> <span class="n">global_reg_snapshot</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tstate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tpc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tnpc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">o7</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">i7</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">rpc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_info</span>	<span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pad1</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">global_reg_snapshot</span> <span class="n">global_reg_snapshot</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="cp">#define force_successful_syscall_return()	    \</span>
<span class="cp">do {	current_thread_info()-&gt;syscall_noerror = 1; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define user_mode(regs) (!((regs)-&gt;tstate &amp; TSTATE_PRIV))</span>
<span class="cp">#define instruction_pointer(regs) ((regs)-&gt;tpc)</span>
<span class="cp">#define instruction_pointer_set(regs, val) ((regs)-&gt;tpc = (val))</span>
<span class="cp">#define user_stack_pointer(regs) ((regs)-&gt;u_regs[UREG_FP])</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_syscall_success</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tstate</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TSTATE_XCARRY</span> <span class="o">|</span> <span class="n">TSTATE_ICARRY</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">regs_return_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">u_regs</span><span class="p">[</span><span class="n">UREG_I0</span><span class="p">];</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">profile_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define profile_pc(regs) instruction_pointer(regs)</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* (__KERNEL__) */</span><span class="cp"></span>

<span class="cp">#else </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>
<span class="cm">/* For assembly code. */</span>
<span class="cp">#define TRACEREG_SZ		0xa0</span>
<span class="cp">#define STACKFRAME_SZ		0xc0</span>

<span class="cp">#define TRACEREG32_SZ		0x50</span>
<span class="cp">#define STACKFRAME32_SZ		0x60</span>
<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#else </span><span class="cm">/* (defined(__sparc__) &amp;&amp; defined(__arch64__)) */</span><span class="cp"></span>

<span class="cm">/* 32 bit sparc */</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;asm/switch_to.h&gt;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pt_regs_is_syscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="n">PSR_SYSCALL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pt_regs_clear_syscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">psr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PSR_SYSCALL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define arch_ptrace_stop_needed(exit_code, info) \</span>
<span class="cp">({	flush_user_windows(); \</span>
<span class="cp">	current_thread_info()-&gt;w_saved != 0;	\</span>
<span class="cp">})</span>

<span class="cp">#define arch_ptrace_stop(exit_code, info) \</span>
<span class="cp">	synchronize_user_stack()</span>

<span class="cp">#define user_mode(regs) (!((regs)-&gt;psr &amp; PSR_PS))</span>
<span class="cp">#define instruction_pointer(regs) ((regs)-&gt;pc)</span>
<span class="cp">#define user_stack_pointer(regs) ((regs)-&gt;u_regs[UREG_FP])</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">profile_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* (__KERNEL__) */</span><span class="cp"></span>

<span class="cp">#else </span><span class="cm">/* (!__ASSEMBLY__) */</span><span class="cp"></span>
<span class="cm">/* For assembly code. */</span>
<span class="cp">#define TRACEREG_SZ       0x50</span>
<span class="cp">#define STACKFRAME_SZ     0x60</span>
<span class="cp">#endif </span><span class="cm">/* (!__ASSEMBLY__) */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* (defined(__sparc__) &amp;&amp; defined(__arch64__)) */</span><span class="cp"></span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#define STACK_BIAS		2047</span>
<span class="cp">#endif</span>

<span class="cm">/* These are for pt_regs. */</span>
<span class="cp">#define PT_V9_G0     0x00</span>
<span class="cp">#define PT_V9_G1     0x08</span>
<span class="cp">#define PT_V9_G2     0x10</span>
<span class="cp">#define PT_V9_G3     0x18</span>
<span class="cp">#define PT_V9_G4     0x20</span>
<span class="cp">#define PT_V9_G5     0x28</span>
<span class="cp">#define PT_V9_G6     0x30</span>
<span class="cp">#define PT_V9_G7     0x38</span>
<span class="cp">#define PT_V9_I0     0x40</span>
<span class="cp">#define PT_V9_I1     0x48</span>
<span class="cp">#define PT_V9_I2     0x50</span>
<span class="cp">#define PT_V9_I3     0x58</span>
<span class="cp">#define PT_V9_I4     0x60</span>
<span class="cp">#define PT_V9_I5     0x68</span>
<span class="cp">#define PT_V9_I6     0x70</span>
<span class="cp">#define PT_V9_FP     PT_V9_I6</span>
<span class="cp">#define PT_V9_I7     0x78</span>
<span class="cp">#define PT_V9_TSTATE 0x80</span>
<span class="cp">#define PT_V9_TPC    0x88</span>
<span class="cp">#define PT_V9_TNPC   0x90</span>
<span class="cp">#define PT_V9_Y      0x98</span>
<span class="cp">#define PT_V9_MAGIC  0x9c</span>
<span class="cp">#define PT_TSTATE	PT_V9_TSTATE</span>
<span class="cp">#define PT_TPC		PT_V9_TPC</span>
<span class="cp">#define PT_TNPC		PT_V9_TNPC</span>

<span class="cm">/* These for pt_regs32. */</span>
<span class="cp">#define PT_PSR    0x0</span>
<span class="cp">#define PT_PC     0x4</span>
<span class="cp">#define PT_NPC    0x8</span>
<span class="cp">#define PT_Y      0xc</span>
<span class="cp">#define PT_G0     0x10</span>
<span class="cp">#define PT_WIM    PT_G0</span>
<span class="cp">#define PT_G1     0x14</span>
<span class="cp">#define PT_G2     0x18</span>
<span class="cp">#define PT_G3     0x1c</span>
<span class="cp">#define PT_G4     0x20</span>
<span class="cp">#define PT_G5     0x24</span>
<span class="cp">#define PT_G6     0x28</span>
<span class="cp">#define PT_G7     0x2c</span>
<span class="cp">#define PT_I0     0x30</span>
<span class="cp">#define PT_I1     0x34</span>
<span class="cp">#define PT_I2     0x38</span>
<span class="cp">#define PT_I3     0x3c</span>
<span class="cp">#define PT_I4     0x40</span>
<span class="cp">#define PT_I5     0x44</span>
<span class="cp">#define PT_I6     0x48</span>
<span class="cp">#define PT_FP     PT_I6</span>
<span class="cp">#define PT_I7     0x4c</span>

<span class="cm">/* Reg_window offsets */</span>
<span class="cp">#define RW_V9_L0     0x00</span>
<span class="cp">#define RW_V9_L1     0x08</span>
<span class="cp">#define RW_V9_L2     0x10</span>
<span class="cp">#define RW_V9_L3     0x18</span>
<span class="cp">#define RW_V9_L4     0x20</span>
<span class="cp">#define RW_V9_L5     0x28</span>
<span class="cp">#define RW_V9_L6     0x30</span>
<span class="cp">#define RW_V9_L7     0x38</span>
<span class="cp">#define RW_V9_I0     0x40</span>
<span class="cp">#define RW_V9_I1     0x48</span>
<span class="cp">#define RW_V9_I2     0x50</span>
<span class="cp">#define RW_V9_I3     0x58</span>
<span class="cp">#define RW_V9_I4     0x60</span>
<span class="cp">#define RW_V9_I5     0x68</span>
<span class="cp">#define RW_V9_I6     0x70</span>
<span class="cp">#define RW_V9_I7     0x78</span>

<span class="cp">#define RW_L0     0x00</span>
<span class="cp">#define RW_L1     0x04</span>
<span class="cp">#define RW_L2     0x08</span>
<span class="cp">#define RW_L3     0x0c</span>
<span class="cp">#define RW_L4     0x10</span>
<span class="cp">#define RW_L5     0x14</span>
<span class="cp">#define RW_L6     0x18</span>
<span class="cp">#define RW_L7     0x1c</span>
<span class="cp">#define RW_I0     0x20</span>
<span class="cp">#define RW_I1     0x24</span>
<span class="cp">#define RW_I2     0x28</span>
<span class="cp">#define RW_I3     0x2c</span>
<span class="cp">#define RW_I4     0x30</span>
<span class="cp">#define RW_I5     0x34</span>
<span class="cp">#define RW_I6     0x38</span>
<span class="cp">#define RW_I7     0x3c</span>

<span class="cm">/* Stack_frame offsets */</span>
<span class="cp">#define SF_V9_L0     0x00</span>
<span class="cp">#define SF_V9_L1     0x08</span>
<span class="cp">#define SF_V9_L2     0x10</span>
<span class="cp">#define SF_V9_L3     0x18</span>
<span class="cp">#define SF_V9_L4     0x20</span>
<span class="cp">#define SF_V9_L5     0x28</span>
<span class="cp">#define SF_V9_L6     0x30</span>
<span class="cp">#define SF_V9_L7     0x38</span>
<span class="cp">#define SF_V9_I0     0x40</span>
<span class="cp">#define SF_V9_I1     0x48</span>
<span class="cp">#define SF_V9_I2     0x50</span>
<span class="cp">#define SF_V9_I3     0x58</span>
<span class="cp">#define SF_V9_I4     0x60</span>
<span class="cp">#define SF_V9_I5     0x68</span>
<span class="cp">#define SF_V9_FP     0x70</span>
<span class="cp">#define SF_V9_PC     0x78</span>
<span class="cp">#define SF_V9_RETP   0x80</span>
<span class="cp">#define SF_V9_XARG0  0x88</span>
<span class="cp">#define SF_V9_XARG1  0x90</span>
<span class="cp">#define SF_V9_XARG2  0x98</span>
<span class="cp">#define SF_V9_XARG3  0xa0</span>
<span class="cp">#define SF_V9_XARG4  0xa8</span>
<span class="cp">#define SF_V9_XARG5  0xb0</span>
<span class="cp">#define SF_V9_XXARG  0xb8</span>

<span class="cp">#define SF_L0     0x00</span>
<span class="cp">#define SF_L1     0x04</span>
<span class="cp">#define SF_L2     0x08</span>
<span class="cp">#define SF_L3     0x0c</span>
<span class="cp">#define SF_L4     0x10</span>
<span class="cp">#define SF_L5     0x14</span>
<span class="cp">#define SF_L6     0x18</span>
<span class="cp">#define SF_L7     0x1c</span>
<span class="cp">#define SF_I0     0x20</span>
<span class="cp">#define SF_I1     0x24</span>
<span class="cp">#define SF_I2     0x28</span>
<span class="cp">#define SF_I3     0x2c</span>
<span class="cp">#define SF_I4     0x30</span>
<span class="cp">#define SF_I5     0x34</span>
<span class="cp">#define SF_FP     0x38</span>
<span class="cp">#define SF_PC     0x3c</span>
<span class="cp">#define SF_RETP   0x40</span>
<span class="cp">#define SF_XARG0  0x44</span>
<span class="cp">#define SF_XARG1  0x48</span>
<span class="cp">#define SF_XARG2  0x4c</span>
<span class="cp">#define SF_XARG3  0x50</span>
<span class="cp">#define SF_XARG4  0x54</span>
<span class="cp">#define SF_XARG5  0x58</span>
<span class="cp">#define SF_XXARG  0x5c</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/* global_reg_snapshot offsets */</span>
<span class="cp">#define GR_SNAP_TSTATE	0x00</span>
<span class="cp">#define GR_SNAP_TPC	0x08</span>
<span class="cp">#define GR_SNAP_TNPC	0x10</span>
<span class="cp">#define GR_SNAP_O7	0x18</span>
<span class="cp">#define GR_SNAP_I7	0x20</span>
<span class="cp">#define GR_SNAP_RPC	0x28</span>
<span class="cp">#define GR_SNAP_THREAD	0x30</span>
<span class="cp">#define GR_SNAP_PAD1	0x38</span>

<span class="cp">#endif  </span><span class="cm">/*  __KERNEL__  */</span><span class="cp"></span>

<span class="cm">/* Stuff for the ptrace system call */</span>
<span class="cp">#define PTRACE_SPARC_DETACH       11</span>
<span class="cp">#define PTRACE_GETREGS            12</span>
<span class="cp">#define PTRACE_SETREGS            13</span>
<span class="cp">#define PTRACE_GETFPREGS          14</span>
<span class="cp">#define PTRACE_SETFPREGS          15</span>
<span class="cp">#define PTRACE_READDATA           16</span>
<span class="cp">#define PTRACE_WRITEDATA          17</span>
<span class="cp">#define PTRACE_READTEXT           18</span>
<span class="cp">#define PTRACE_WRITETEXT          19</span>
<span class="cp">#define PTRACE_GETFPAREGS         20</span>
<span class="cp">#define PTRACE_SETFPAREGS         21</span>

<span class="cm">/* There are for debugging 64-bit processes, either from a 32 or 64 bit</span>
<span class="cm"> * parent.  Thus their complements are for debugging 32-bit processes only.</span>
<span class="cm"> */</span>

<span class="cp">#define PTRACE_GETREGS64	  22</span>
<span class="cp">#define PTRACE_SETREGS64	  23</span>
<span class="cm">/* PTRACE_SYSCALL is 24 */</span>
<span class="cp">#define PTRACE_GETFPREGS64	  25</span>
<span class="cp">#define PTRACE_SETFPREGS64	  26</span>

<span class="cp">#endif </span><span class="cm">/* !(__SPARC_PTRACE_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
