<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › sparc › include › asm › oplib_64.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>oplib_64.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* oplib.h:  Describes the interface and available routines in the</span>
<span class="cm"> *           Linux Prom library.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995, 2007 David S. Miller (davem@davemloft.net)</span>
<span class="cm"> * Copyright (C) 1996 Jakub Jelinek (jj@sunsite.mff.cuni.cz)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __SPARC64_OPLIB_H</span>
<span class="cp">#define __SPARC64_OPLIB_H</span>

<span class="cp">#include &lt;asm/openprom.h&gt;</span>

<span class="cm">/* OBP version string. */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">prom_version</span><span class="p">[];</span>

<span class="cm">/* Root node of the prom device tree, this stays constant after</span>
<span class="cm"> * initialization is complete.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_root_node</span><span class="p">;</span>

<span class="cm">/* PROM stdout */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_stdout</span><span class="p">;</span>

<span class="cm">/* /chosen node of the prom device tree, this stays constant after</span>
<span class="cm"> * initialization is complete.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_chosen_node</span><span class="p">;</span>

<span class="cm">/* Helper values and strings in arch/sparc64/kernel/head.S */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_peer_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_compatible_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_root_compatible</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_cpu_compatible</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_finddev_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_chosen_path</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_cpu_path</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_getprop_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_mmu_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_callmethod_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_translate_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_map_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">prom_unmap_name</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_mmu_ihandle_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prom_boot_mapped_pc</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prom_boot_mapping_mode</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prom_boot_mapping_phys_high</span><span class="p">,</span> <span class="n">prom_boot_mapping_phys_low</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">linux_mlist_p1275</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">linux_mlist_p1275</span> <span class="o">*</span><span class="n">theres_more</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_adr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_bytes</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">linux_mem_p1275</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">linux_mlist_p1275</span> <span class="o">**</span><span class="n">p1275_totphys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linux_mlist_p1275</span> <span class="o">**</span><span class="n">p1275_prommap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linux_mlist_p1275</span> <span class="o">**</span><span class="n">p1275_available</span><span class="p">;</span> <span class="cm">/* What we can use */</span>
<span class="p">};</span>

<span class="cm">/* The functions... */</span>

<span class="cm">/* You must call prom_init() before using any of the library services,</span>
<span class="cm"> * preferably as early as possible.  Pass it the romvec pointer.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cif_handler</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cif_stack</span><span class="p">);</span>

<span class="cm">/* Boot argument acquisition, returns the boot command line string. */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_getbootargs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Miscellaneous routines, don&#39;t really fit in any category per se. */</span>

<span class="cm">/* Reboot the machine with the command line passed. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_reboot</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">boot_command</span><span class="p">);</span>

<span class="cm">/* Evaluate the forth string passed. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_feval</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">forth_string</span><span class="p">);</span>

<span class="cm">/* Enter the prom, with possibility of continuation with the &#39;go&#39;</span>
<span class="cm"> * command in newer proms.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_cmdline</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Enter the prom, with no chance of continuation for the stand-alone</span>
<span class="cm"> * which calls this.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_halt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">noreturn</span><span class="p">));</span>

<span class="cm">/* Halt and power-off the machine. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_halt_power_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">noreturn</span><span class="p">));</span>

<span class="cm">/* Acquire the IDPROM of the root node in the prom device tree.  This</span>
<span class="cm"> * gets passed a buffer where you would like it stuffed.  The return value</span>
<span class="cm"> * is the format type of this idprom or 0xff on error.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">prom_get_idprom</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">idp_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idpbuf_size</span><span class="p">);</span>

<span class="cm">/* Write a buffer of characters to the console. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_console_write_buf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Prom&#39;s internal routines, don&#39;t use in kernel/boot code. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_write</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Multiprocessor operations... */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/* Start the CPU with the given device tree node at the passed program</span>
<span class="cm"> * counter with the given arg passed in via register %o0.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_startcpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpunode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/* Start the CPU with the given cpu ID at the passed program</span>
<span class="cm"> * counter with the given arg passed in via register %o0.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_startcpu_cpuid</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpuid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/* Stop the CPU with the given cpu ID.  */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_stopcpu_cpuid</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpuid</span><span class="p">);</span>

<span class="cm">/* Stop the current CPU. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_stopself</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Idle the current CPU. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_idleself</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Resume the CPU with the passed device tree node. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_resumecpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpunode</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Power management interfaces. */</span>

<span class="cm">/* Put the current CPU to sleep. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_sleepself</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Put the entire system to sleep. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_sleepsystem</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Initiate a wakeup event. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_wakeupsystem</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* MMU and memory related OBP interfaces. */</span>

<span class="cm">/* Get unique string identifying SIMM at given physical address. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getunumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">syndrome_code</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">);</span>

<span class="cm">/* Retain physical memory to the caller across soft resets. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_retain</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">paddr</span><span class="p">);</span>

<span class="cm">/* Load explicit I/D TLB entries into the calling processor. */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">prom_itlb_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tte_data</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">prom_dtlb_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tte_data</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">);</span>

<span class="cm">/* Map/Unmap client program address ranges.  First the format of</span>
<span class="cm"> * the mapping mode argument.</span>
<span class="cm"> */</span>
<span class="cp">#define PROM_MAP_WRITE	0x0001 </span><span class="cm">/* Writable */</span><span class="cp"></span>
<span class="cp">#define PROM_MAP_READ	0x0002 </span><span class="cm">/* Readable - sw */</span><span class="cp"></span>
<span class="cp">#define PROM_MAP_EXEC	0x0004 </span><span class="cm">/* Executable - sw */</span><span class="cp"></span>
<span class="cp">#define PROM_MAP_LOCKED	0x0010 </span><span class="cm">/* Locked, use i/dtlb load calls for this instead */</span><span class="cp"></span>
<span class="cp">#define PROM_MAP_CACHED	0x0020 </span><span class="cm">/* Cacheable in both L1 and L2 caches */</span><span class="cp"></span>
<span class="cp">#define PROM_MAP_SE	0x0040 </span><span class="cm">/* Side-Effects */</span><span class="cp"></span>
<span class="cp">#define PROM_MAP_GLOB	0x0080 </span><span class="cm">/* Global */</span><span class="cp"></span>
<span class="cp">#define PROM_MAP_IE	0x0100 </span><span class="cm">/* Invert-Endianness */</span><span class="cp"></span>
<span class="cp">#define PROM_MAP_DEFAULT (PROM_MAP_WRITE | PROM_MAP_READ | PROM_MAP_EXEC | PROM_MAP_CACHED)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_map</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_unmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">);</span>


<span class="cm">/* PROM device tree traversal functions... */</span>

<span class="cm">/* Get the child node of the given node, or zero if no child exists. */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_getchild</span><span class="p">(</span><span class="n">phandle</span> <span class="n">parent_node</span><span class="p">);</span>

<span class="cm">/* Get the next sibling node of the given node, or zero if no further</span>
<span class="cm"> * siblings exist.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_getsibling</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">);</span>

<span class="cm">/* Get the length, at the passed node, of the given property type.</span>
<span class="cm"> * Returns -1 on error (ie. no such property at this node).</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getproplen</span><span class="p">(</span><span class="n">phandle</span> <span class="n">thisnode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">);</span>

<span class="cm">/* Fetch the requested property using the given buffer.  Returns</span>
<span class="cm"> * the number of bytes the prom put into your buffer or -1 on error.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getproperty</span><span class="p">(</span><span class="n">phandle</span> <span class="n">thisnode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">*</span><span class="n">prop_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">propbuf_size</span><span class="p">);</span>

<span class="cm">/* Acquire an integer property. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getint</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">);</span>

<span class="cm">/* Acquire an integer property, with a default value. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getintdefault</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">,</span> <span class="kt">int</span> <span class="n">defval</span><span class="p">);</span>

<span class="cm">/* Acquire a boolean property, 0=FALSE 1=TRUE. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_getbool</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop</span><span class="p">);</span>

<span class="cm">/* Acquire a string property, null string on error. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_getstring</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">bufsize</span><span class="p">);</span>

<span class="cm">/* Does the passed node have the given &quot;name&quot;? YES=1 NO=0 */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_nodematch</span><span class="p">(</span><span class="n">phandle</span> <span class="n">thisnode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* Search all siblings starting at the passed node for &quot;name&quot; matching</span>
<span class="cm"> * the given string.  Returns the node on success, zero on failure.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_searchsiblings</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node_start</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* Return the first property type, as a string, for the given node.</span>
<span class="cm"> * Returns a null string on error. Buffer should be at least 32B long.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_firstprop</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>

<span class="cm">/* Returns the next property after the passed property for the given</span>
<span class="cm"> * node.  Returns null string on failure. Buffer should be at least 32B long.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prom_nextprop</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prev_property</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/* Returns 1 if the specified node has given property. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_node_has_property</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">property</span><span class="p">);</span>

<span class="cm">/* Returns phandle of the path specified */</span>
<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_finddevice</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* Set the indicated property at the given node with the passed value.</span>
<span class="cm"> * Returns the number of bytes of your value that the prom took.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_setprop</span><span class="p">(</span><span class="n">phandle</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop_name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop_value</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">value_size</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">phandle</span> <span class="n">prom_inst2pkg</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prom_sun4v_guest_soft_state</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_ihandle2path</span><span class="p">(</span><span class="kt">int</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">);</span>

<span class="cm">/* Client interface level routines. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">p1275_cmd_direct</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* !(__SPARC64_OPLIB_H) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
