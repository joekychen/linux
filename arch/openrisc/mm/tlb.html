<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › openrisc › mm › tlb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>tlb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * OpenRISC tlb.c</span>
<span class="cm"> *</span>
<span class="cm"> * Linux architectural port borrowing liberally from similar works of</span>
<span class="cm"> * others.  All original copyrights apply as per the original source</span>
<span class="cm"> * declaration.</span>
<span class="cm"> *</span>
<span class="cm"> * Modifications for the OpenRISC architecture:</span>
<span class="cm"> * Copyright (C) 2003 Matjaz Breskvar &lt;phoenix@bsemi.com&gt;</span>
<span class="cm"> * Copyright (C) 2010-2011 Julius Baxter &lt;julius.baxter@orsoc.se&gt;</span>
<span class="cm"> * Copyright (C) 2010-2011 Jonas Bonn &lt;jonas@southpole.se&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      as published by the Free Software Foundation; either version</span>
<span class="cm"> *      2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;asm/segment.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/spr_defs.h&gt;</span>

<span class="cp">#define NO_CONTEXT -1</span>

<span class="cp">#define NUM_DTLB_SETS (1 &lt;&lt; ((mfspr(SPR_IMMUCFGR) &amp; SPR_IMMUCFGR_NTS) &gt;&gt; \</span>
<span class="cp">			    SPR_DMMUCFGR_NTS_OFF))</span>
<span class="cp">#define NUM_ITLB_SETS (1 &lt;&lt; ((mfspr(SPR_IMMUCFGR) &amp; SPR_IMMUCFGR_NTS) &gt;&gt; \</span>
<span class="cp">			    SPR_IMMUCFGR_NTS_OFF))</span>
<span class="cp">#define DTLB_OFFSET(addr) (((addr) &gt;&gt; PAGE_SHIFT) &amp; (NUM_DTLB_SETS-1))</span>
<span class="cp">#define ITLB_OFFSET(addr) (((addr) &gt;&gt; PAGE_SHIFT) &amp; (NUM_ITLB_SETS-1))</span>
<span class="cm">/*</span>
<span class="cm"> * Invalidate all TLB entries.</span>
<span class="cm"> *</span>
<span class="cm"> * This comes down to setting the &#39;valid&#39; bit for all xTLBMR registers to 0.</span>
<span class="cm"> * Easiest way to accomplish this is to just zero out the xTLBMR register</span>
<span class="cm"> * completely.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_tlb_sets</span><span class="p">;</span>

	<span class="cm">/* Determine number of sets for IMMU. */</span>
	<span class="cm">/* FIXME: Assumption is I &amp; D nsets equal. */</span>
	<span class="n">num_tlb_sets</span> <span class="o">=</span> <span class="n">NUM_ITLB_SETS</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_tlb_sets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtspr_off</span><span class="p">(</span><span class="n">SPR_DTLBMR_BASE</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mtspr_off</span><span class="p">(</span><span class="n">SPR_ITLBMR_BASE</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define have_dtlbeir (mfspr(SPR_DMMUCFGR) &amp; SPR_DMMUCFGR_TEIRI)</span>
<span class="cp">#define have_itlbeir (mfspr(SPR_IMMUCFGR) &amp; SPR_IMMUCFGR_TEIRI)</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate a single page.  This is what the xTLBEIR register is for.</span>
<span class="cm"> *</span>
<span class="cm"> * There&#39;s no point in checking the vma for PAGE_EXEC to determine whether it&#39;s</span>
<span class="cm"> * the data or instruction TLB that should be flushed... that would take more</span>
<span class="cm"> * than the few instructions that the following compiles down to!</span>
<span class="cm"> *</span>
<span class="cm"> * The case where we don&#39;t have the xTLBEIR register really only works for</span>
<span class="cm"> * MMU&#39;s with a single way and is hard-coded that way.</span>
<span class="cm"> */</span>

<span class="cp">#define flush_dtlb_page_eir(addr) mtspr(SPR_DTLBEIR, addr)</span>
<span class="cp">#define flush_dtlb_page_no_eir(addr) \</span>
<span class="cp">	mtspr_off(SPR_DTLBMR_BASE(0), DTLB_OFFSET(addr), 0);</span>

<span class="cp">#define flush_itlb_page_eir(addr) mtspr(SPR_ITLBEIR, addr)</span>
<span class="cp">#define flush_itlb_page_no_eir(addr) \</span>
<span class="cp">	mtspr_off(SPR_ITLBMR_BASE(0), ITLB_OFFSET(addr), 0);</span>

<span class="kt">void</span> <span class="nf">flush_tlb_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">have_dtlbeir</span><span class="p">)</span>
		<span class="n">flush_dtlb_page_eir</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">flush_dtlb_page_no_eir</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">have_itlbeir</span><span class="p">)</span>
		<span class="n">flush_itlb_page_eir</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">flush_itlb_page_no_eir</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_tlb_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dtlbeir</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">itlbeir</span><span class="p">;</span>

	<span class="n">dtlbeir</span> <span class="o">=</span> <span class="n">have_dtlbeir</span><span class="p">;</span>
	<span class="n">itlbeir</span> <span class="o">=</span> <span class="n">have_itlbeir</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtlbeir</span><span class="p">)</span>
			<span class="n">flush_dtlb_page_eir</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">flush_dtlb_page_no_eir</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">itlbeir</span><span class="p">)</span>
			<span class="n">flush_itlb_page_eir</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">flush_itlb_page_no_eir</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate the selected mm context only.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: Due to some bug here, we&#39;re flushing everything for now.</span>
<span class="cm"> * This should be changed to loop over over mm and call flush_tlb_range.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">flush_tlb_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* Was seeing bugs with the mm struct passed to us. Scrapped most of</span>
<span class="cm">	   this function. */</span>
	<span class="cm">/* Several architctures do this */</span>
	<span class="n">flush_tlb_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* called in schedule() just before actually doing the switch_to */</span>

<span class="kt">void</span> <span class="nf">switch_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next_tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* remember the pgd for the fault handlers</span>
<span class="cm">	 * this is similar to the pgd register in some other CPU&#39;s.</span>
<span class="cm">	 * we need our own copy of it because current and active_mm</span>
<span class="cm">	 * might be invalid at points where we still need to derefer</span>
<span class="cm">	 * the pgd.</span>
<span class="cm">	 */</span>
	<span class="n">current_pgd</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t have context support implemented, so flush all</span>
<span class="cm">	 * entries belonging to previous map</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">next</span><span class="p">)</span>
		<span class="n">flush_tlb_mm</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the context related info for a new mm_struct</span>
<span class="cm"> * instance.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">init_new_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">NO_CONTEXT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called by __exit_mm to destroy the used MMU context if any before</span>
<span class="cm"> * destroying the mm itself. this is only called when the last user of the mm</span>
<span class="cm"> * drops it.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">destroy_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flush_tlb_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* called once during VM initialization, from init.c */</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">tlb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Do nothing... */</span>
	<span class="cm">/* invalidate the entire TLB */</span>
	<span class="cm">/* flush_tlb_all(); */</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
