<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › blackfin › include › asm › bfin_serial.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>bfin_serial.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * bfin_serial.h - Blackfin UART/Serial definitions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2006-2010 Analog Devices Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the GPL-2 or later.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __BFIN_ASM_SERIAL_H__</span>
<span class="cp">#define __BFIN_ASM_SERIAL_H__</span>

<span class="cp">#include &lt;linux/serial_core.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;mach/anomaly.h&gt;</span>
<span class="cp">#include &lt;mach/bfin_serial.h&gt;</span>

<span class="cp">#if defined(CONFIG_BFIN_UART0_CTSRTS) || \</span>
<span class="cp">    defined(CONFIG_BFIN_UART1_CTSRTS) || \</span>
<span class="cp">    defined(CONFIG_BFIN_UART2_CTSRTS) || \</span>
<span class="cp">    defined(CONFIG_BFIN_UART3_CTSRTS)</span>
<span class="cp"># if defined(BFIN_UART_BF54X_STYLE) || defined(BFIN_UART_BF60X_STYLE)</span>
<span class="cp">#  define CONFIG_SERIAL_BFIN_HARD_CTSRTS</span>
<span class="cp"># else</span>
<span class="cp">#  define CONFIG_SERIAL_BFIN_CTSRTS</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">circ_buf</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">timer_list</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">work_struct</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">bfin_serial_port</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status_irq</span><span class="p">;</span>
<span class="cp">#ifndef BFIN_UART_BF54X_STYLE</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lsr</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SERIAL_BFIN_DMA</span>
	<span class="kt">int</span> <span class="n">tx_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">circ_buf</span> <span class="n">rx_dma_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">rx_dma_timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_dma_nrows</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">rx_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_dma_channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_dma_channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">tx_dma_workqueue</span><span class="p">;</span>
<span class="cp">#elif ANOMALY_05000363</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">anomaly_threshold</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_SERIAL_BFIN_CTSRTS) || \</span>
<span class="cp">	defined(CONFIG_SERIAL_BFIN_HARD_CTSRTS)</span>
	<span class="kt">int</span> <span class="n">cts_pin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rts_pin</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#ifdef BFIN_UART_BF60X_STYLE</span>

<span class="cm">/* UART_CTL Masks */</span>
<span class="cp">#define UCEN                     0x1  </span><span class="cm">/* Enable UARTx Clocks */</span><span class="cp"></span>
<span class="cp">#define LOOP_ENA                 0x2  </span><span class="cm">/* Loopback Mode Enable */</span><span class="cp"></span>
<span class="cp">#define UMOD_MDB                 0x10  </span><span class="cm">/* Enable MDB Mode */</span><span class="cp"></span>
<span class="cp">#define UMOD_IRDA                0x20  </span><span class="cm">/* Enable IrDA Mode */</span><span class="cp"></span>
<span class="cp">#define UMOD_MASK                0x30  </span><span class="cm">/* Uart Mode Mask */</span><span class="cp"></span>
<span class="cp">#define WLS(x)                   (((x-5) &amp; 0x03) &lt;&lt; 8)  </span><span class="cm">/* Word Length Select */</span><span class="cp"></span>
<span class="cp">#define WLS_MASK                 0x300  </span><span class="cm">/* Word length Select Mask */</span><span class="cp"></span>
<span class="cp">#define WLS_OFFSET               8      </span><span class="cm">/* Word length Select Offset */</span><span class="cp"></span>
<span class="cp">#define STB                      0x1000  </span><span class="cm">/* Stop Bits */</span><span class="cp"></span>
<span class="cp">#define STBH                     0x2000  </span><span class="cm">/* Half Stop Bits */</span><span class="cp"></span>
<span class="cp">#define PEN                      0x4000  </span><span class="cm">/* Parity Enable */</span><span class="cp"></span>
<span class="cp">#define EPS                      0x8000  </span><span class="cm">/* Even Parity Select */</span><span class="cp"></span>
<span class="cp">#define STP                      0x10000  </span><span class="cm">/* Stick Parity */</span><span class="cp"></span>
<span class="cp">#define FPE                      0x20000  </span><span class="cm">/* Force Parity Error On Transmit */</span><span class="cp"></span>
<span class="cp">#define FFE                      0x40000  </span><span class="cm">/* Force Framing Error On Transmit */</span><span class="cp"></span>
<span class="cp">#define SB                       0x80000  </span><span class="cm">/* Set Break */</span><span class="cp"></span>
<span class="cp">#define LCR_MASK		 (SB | STP | EPS | PEN | STB | WLS_MASK)</span>
<span class="cp">#define FCPOL                    0x400000  </span><span class="cm">/* Flow Control Pin Polarity */</span><span class="cp"></span>
<span class="cp">#define RPOLC                    0x800000  </span><span class="cm">/* IrDA RX Polarity Change */</span><span class="cp"></span>
<span class="cp">#define TPOLC                    0x1000000  </span><span class="cm">/* IrDA TX Polarity Change */</span><span class="cp"></span>
<span class="cp">#define MRTS                     0x2000000  </span><span class="cm">/* Manual Request To Send */</span><span class="cp"></span>
<span class="cp">#define XOFF                     0x4000000  </span><span class="cm">/* Transmitter Off */</span><span class="cp"></span>
<span class="cp">#define ARTS                     0x8000000  </span><span class="cm">/* Automatic Request To Send */</span><span class="cp"></span>
<span class="cp">#define ACTS                     0x10000000  </span><span class="cm">/* Automatic Clear To Send */</span><span class="cp"></span>
<span class="cp">#define RFIT                     0x20000000  </span><span class="cm">/* Receive FIFO IRQ Threshold */</span><span class="cp"></span>
<span class="cp">#define RFRT                     0x40000000  </span><span class="cm">/* Receive FIFO RTS Threshold */</span><span class="cp"></span>

<span class="cm">/* UART_STAT Masks */</span>
<span class="cp">#define DR                       0x01  </span><span class="cm">/* Data Ready */</span><span class="cp"></span>
<span class="cp">#define OE                       0x02  </span><span class="cm">/* Overrun Error */</span><span class="cp"></span>
<span class="cp">#define PE                       0x04  </span><span class="cm">/* Parity Error */</span><span class="cp"></span>
<span class="cp">#define FE                       0x08  </span><span class="cm">/* Framing Error */</span><span class="cp"></span>
<span class="cp">#define BI                       0x10  </span><span class="cm">/* Break Interrupt */</span><span class="cp"></span>
<span class="cp">#define THRE                     0x20  </span><span class="cm">/* THR Empty */</span><span class="cp"></span>
<span class="cp">#define TEMT                     0x80  </span><span class="cm">/* TSR and UART_THR Empty */</span><span class="cp"></span>
<span class="cp">#define TFI                      0x100  </span><span class="cm">/* Transmission Finished Indicator */</span><span class="cp"></span>

<span class="cp">#define ASTKY                    0x200  </span><span class="cm">/* Address Sticky */</span><span class="cp"></span>
<span class="cp">#define ADDR                     0x400  </span><span class="cm">/* Address bit status */</span><span class="cp"></span>
<span class="cp">#define RO			 0x800  </span><span class="cm">/* Reception Ongoing */</span><span class="cp"></span>
<span class="cp">#define SCTS                     0x1000  </span><span class="cm">/* Sticky CTS */</span><span class="cp"></span>
<span class="cp">#define CTS                      0x10000  </span><span class="cm">/* Clear To Send */</span><span class="cp"></span>
<span class="cp">#define RFCS                     0x20000  </span><span class="cm">/* Receive FIFO Count Status */</span><span class="cp"></span>

<span class="cm">/* UART_CLOCK Masks */</span>
<span class="cp">#define EDBO                     0x80000000 </span><span class="cm">/* Enable Devide by One */</span><span class="cp"></span>

<span class="cp">#else </span><span class="cm">/* BFIN_UART_BF60X_STYLE */</span><span class="cp"></span>

<span class="cm">/* UART_LCR Masks */</span>
<span class="cp">#define WLS(x)                   (((x)-5) &amp; 0x03)  </span><span class="cm">/* Word Length Select */</span><span class="cp"></span>
<span class="cp">#define WLS_MASK                 0x03  </span><span class="cm">/* Word length Select Mask */</span><span class="cp"></span>
<span class="cp">#define WLS_OFFSET               0     </span><span class="cm">/* Word length Select Offset */</span><span class="cp"></span>
<span class="cp">#define STB                      0x04  </span><span class="cm">/* Stop Bits */</span><span class="cp"></span>
<span class="cp">#define PEN                      0x08  </span><span class="cm">/* Parity Enable */</span><span class="cp"></span>
<span class="cp">#define EPS                      0x10  </span><span class="cm">/* Even Parity Select */</span><span class="cp"></span>
<span class="cp">#define STP                      0x20  </span><span class="cm">/* Stick Parity */</span><span class="cp"></span>
<span class="cp">#define SB                       0x40  </span><span class="cm">/* Set Break */</span><span class="cp"></span>
<span class="cp">#define DLAB                     0x80  </span><span class="cm">/* Divisor Latch Access */</span><span class="cp"></span>
<span class="cp">#define LCR_MASK		 (SB | STP | EPS | PEN | STB | WLS_MASK)</span>

<span class="cm">/* UART_LSR Masks */</span>
<span class="cp">#define DR                       0x01  </span><span class="cm">/* Data Ready */</span><span class="cp"></span>
<span class="cp">#define OE                       0x02  </span><span class="cm">/* Overrun Error */</span><span class="cp"></span>
<span class="cp">#define PE                       0x04  </span><span class="cm">/* Parity Error */</span><span class="cp"></span>
<span class="cp">#define FE                       0x08  </span><span class="cm">/* Framing Error */</span><span class="cp"></span>
<span class="cp">#define BI                       0x10  </span><span class="cm">/* Break Interrupt */</span><span class="cp"></span>
<span class="cp">#define THRE                     0x20  </span><span class="cm">/* THR Empty */</span><span class="cp"></span>
<span class="cp">#define TEMT                     0x40  </span><span class="cm">/* TSR and UART_THR Empty */</span><span class="cp"></span>
<span class="cp">#define TFI                      0x80  </span><span class="cm">/* Transmission Finished Indicator */</span><span class="cp"></span>

<span class="cm">/* UART_MCR Masks */</span>
<span class="cp">#define XOFF                     0x01  </span><span class="cm">/* Transmitter Off */</span><span class="cp"></span>
<span class="cp">#define MRTS                     0x02  </span><span class="cm">/* Manual Request To Send */</span><span class="cp"></span>
<span class="cp">#define RFIT                     0x04  </span><span class="cm">/* Receive FIFO IRQ Threshold */</span><span class="cp"></span>
<span class="cp">#define RFRT                     0x08  </span><span class="cm">/* Receive FIFO RTS Threshold */</span><span class="cp"></span>
<span class="cp">#define LOOP_ENA                 0x10  </span><span class="cm">/* Loopback Mode Enable */</span><span class="cp"></span>
<span class="cp">#define FCPOL                    0x20  </span><span class="cm">/* Flow Control Pin Polarity */</span><span class="cp"></span>
<span class="cp">#define ARTS                     0x40  </span><span class="cm">/* Automatic Request To Send */</span><span class="cp"></span>
<span class="cp">#define ACTS                     0x80  </span><span class="cm">/* Automatic Clear To Send */</span><span class="cp"></span>

<span class="cm">/* UART_MSR Masks */</span>
<span class="cp">#define SCTS                     0x01  </span><span class="cm">/* Sticky CTS */</span><span class="cp"></span>
<span class="cp">#define CTS                      0x10  </span><span class="cm">/* Clear To Send */</span><span class="cp"></span>
<span class="cp">#define RFCS                     0x20  </span><span class="cm">/* Receive FIFO Count Status */</span><span class="cp"></span>

<span class="cm">/* UART_GCTL Masks */</span>
<span class="cp">#define UCEN                     0x01  </span><span class="cm">/* Enable UARTx Clocks */</span><span class="cp"></span>
<span class="cp">#define UMOD_IRDA                0x02  </span><span class="cm">/* Enable IrDA Mode */</span><span class="cp"></span>
<span class="cp">#define UMOD_MASK                0x02  </span><span class="cm">/* Uart Mode Mask */</span><span class="cp"></span>
<span class="cp">#define TPOLC                    0x04  </span><span class="cm">/* IrDA TX Polarity Change */</span><span class="cp"></span>
<span class="cp">#define RPOLC                    0x08  </span><span class="cm">/* IrDA RX Polarity Change */</span><span class="cp"></span>
<span class="cp">#define FPE                      0x10  </span><span class="cm">/* Force Parity Error On Transmit */</span><span class="cp"></span>
<span class="cp">#define FFE                      0x20  </span><span class="cm">/* Force Framing Error On Transmit */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* BFIN_UART_BF60X_STYLE */</span><span class="cp"></span>

<span class="cm">/* UART_IER Masks */</span>
<span class="cp">#define ERBFI                    0x01  </span><span class="cm">/* Enable Receive Buffer Full Interrupt */</span><span class="cp"></span>
<span class="cp">#define ETBEI                    0x02  </span><span class="cm">/* Enable Transmit Buffer Empty Interrupt */</span><span class="cp"></span>
<span class="cp">#define ELSI                     0x04  </span><span class="cm">/* Enable RX Status Interrupt */</span><span class="cp"></span>
<span class="cp">#define EDSSI                    0x08  </span><span class="cm">/* Enable Modem Status Interrupt */</span><span class="cp"></span>
<span class="cp">#define EDTPTI                   0x10  </span><span class="cm">/* Enable DMA Transmit PIRQ Interrupt */</span><span class="cp"></span>
<span class="cp">#define ETFI                     0x20  </span><span class="cm">/* Enable Transmission Finished Interrupt */</span><span class="cp"></span>
<span class="cp">#define ERFCI                    0x40  </span><span class="cm">/* Enable Receive FIFO Count Interrupt */</span><span class="cp"></span>

<span class="cp">#if defined(BFIN_UART_BF60X_STYLE)</span>
<span class="cp"># define OFFSET_REDIV            0x00  </span><span class="cm">/* Version ID Register             */</span><span class="cp"></span>
<span class="cp"># define OFFSET_CTL              0x04  </span><span class="cm">/* Control Register                */</span><span class="cp"></span>
<span class="cp"># define OFFSET_STAT             0x08  </span><span class="cm">/* Status Register                 */</span><span class="cp"></span>
<span class="cp"># define OFFSET_SCR              0x0C  </span><span class="cm">/* SCR Scratch Register            */</span><span class="cp"></span>
<span class="cp"># define OFFSET_CLK              0x10  </span><span class="cm">/* Clock Rate Register             */</span><span class="cp"></span>
<span class="cp"># define OFFSET_IER              0x14  </span><span class="cm">/* Interrupt Enable Register       */</span><span class="cp"></span>
<span class="cp"># define OFFSET_IER_SET          0x18  </span><span class="cm">/* Set Interrupt Enable Register   */</span><span class="cp"></span>
<span class="cp"># define OFFSET_IER_CLEAR        0x1C  </span><span class="cm">/* Clear Interrupt Enable Register */</span><span class="cp"></span>
<span class="cp"># define OFFSET_RBR              0x20  </span><span class="cm">/* Receive Buffer register         */</span><span class="cp"></span>
<span class="cp"># define OFFSET_THR              0x24  </span><span class="cm">/* Transmit Holding register       */</span><span class="cp"></span>
<span class="cp">#elif defined(BFIN_UART_BF54X_STYLE)</span>
<span class="cp"># define OFFSET_DLL              0x00  </span><span class="cm">/* Divisor Latch (Low-Byte)        */</span><span class="cp"></span>
<span class="cp"># define OFFSET_DLH              0x04  </span><span class="cm">/* Divisor Latch (High-Byte)       */</span><span class="cp"></span>
<span class="cp"># define OFFSET_GCTL             0x08  </span><span class="cm">/* Global Control Register         */</span><span class="cp"></span>
<span class="cp"># define OFFSET_LCR              0x0C  </span><span class="cm">/* Line Control Register           */</span><span class="cp"></span>
<span class="cp"># define OFFSET_MCR              0x10  </span><span class="cm">/* Modem Control Register          */</span><span class="cp"></span>
<span class="cp"># define OFFSET_LSR              0x14  </span><span class="cm">/* Line Status Register            */</span><span class="cp"></span>
<span class="cp"># define OFFSET_MSR              0x18  </span><span class="cm">/* Modem Status Register           */</span><span class="cp"></span>
<span class="cp"># define OFFSET_SCR              0x1C  </span><span class="cm">/* SCR Scratch Register            */</span><span class="cp"></span>
<span class="cp"># define OFFSET_IER_SET          0x20  </span><span class="cm">/* Set Interrupt Enable Register   */</span><span class="cp"></span>
<span class="cp"># define OFFSET_IER_CLEAR        0x24  </span><span class="cm">/* Clear Interrupt Enable Register */</span><span class="cp"></span>
<span class="cp"># define OFFSET_THR              0x28  </span><span class="cm">/* Transmit Holding register       */</span><span class="cp"></span>
<span class="cp"># define OFFSET_RBR              0x2C  </span><span class="cm">/* Receive Buffer register         */</span><span class="cp"></span>
<span class="cp">#else </span><span class="cm">/* BF533 style */</span><span class="cp"></span>
<span class="cp"># define OFFSET_THR              0x00  </span><span class="cm">/* Transmit Holding register         */</span><span class="cp"></span>
<span class="cp"># define OFFSET_RBR              0x00  </span><span class="cm">/* Receive Buffer register           */</span><span class="cp"></span>
<span class="cp"># define OFFSET_DLL              0x00  </span><span class="cm">/* Divisor Latch (Low-Byte)          */</span><span class="cp"></span>
<span class="cp"># define OFFSET_DLH              0x04  </span><span class="cm">/* Divisor Latch (High-Byte)         */</span><span class="cp"></span>
<span class="cp"># define OFFSET_IER              0x04  </span><span class="cm">/* Interrupt Enable Register         */</span><span class="cp"></span>
<span class="cp"># define OFFSET_IIR              0x08  </span><span class="cm">/* Interrupt Identification Register */</span><span class="cp"></span>
<span class="cp"># define OFFSET_LCR              0x0C  </span><span class="cm">/* Line Control Register             */</span><span class="cp"></span>
<span class="cp"># define OFFSET_MCR              0x10  </span><span class="cm">/* Modem Control Register            */</span><span class="cp"></span>
<span class="cp"># define OFFSET_LSR              0x14  </span><span class="cm">/* Line Status Register              */</span><span class="cp"></span>
<span class="cp"># define OFFSET_MSR              0x18  </span><span class="cm">/* Modem Status Register             */</span><span class="cp"></span>
<span class="cp"># define OFFSET_SCR              0x1C  </span><span class="cm">/* SCR Scratch Register              */</span><span class="cp"></span>
<span class="cp"># define OFFSET_GCTL             0x24  </span><span class="cm">/* Global Control Register           */</span><span class="cp"></span>
<span class="cm">/* code should not need IIR, so force build error if they use it */</span>
<span class="cp"># undef OFFSET_IIR</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * All Blackfin system MMRs are padded to 32bits even if the register</span>
<span class="cm"> * itself is only 16bits.  So use a helper macro to streamline this.</span>
<span class="cm"> */</span>
<span class="cp">#define __BFP(m) u16 m; u16 __pad_##m</span>
<span class="k">struct</span> <span class="n">bfin_uart_regs</span> <span class="p">{</span>
<span class="cp">#if defined(BFIN_UART_BF60X_STYLE)</span>
	<span class="n">u32</span> <span class="n">revid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">stat</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">clk</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ier</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ier_set</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ier_clear</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rbr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">thr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">taip</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tsr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rsr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txdiv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rxdiv</span><span class="p">;</span>
<span class="cp">#elif defined(BFIN_UART_BF54X_STYLE)</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">dll</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">dlh</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">gctl</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">lcr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">mcr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">lsr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">msr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">scr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">ier_set</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">ier_clear</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">rbr</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">dll</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">thr</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">u16</span> <span class="n">rbr</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="n">__pad0</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">dlh</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">ier</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="n">__pad1</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__BFP</span><span class="p">(</span><span class="n">iir</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">lcr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">mcr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">lsr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">msr</span><span class="p">);</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">scr</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">__pad2</span><span class="p">;</span>
	<span class="n">__BFP</span><span class="p">(</span><span class="n">gctl</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="cp">#undef __BFP</span>

<span class="cp">#define port_membase(uart)     (((struct bfin_serial_port *)(uart))-&gt;port.membase)</span>

<span class="cm">/*</span>
<span class="cm">#ifndef port_membase</span>
<span class="cm"># define port_membase(p) 0</span>
<span class="cm">#endif</span>
<span class="cm">*/</span>
<span class="cp">#ifdef BFIN_UART_BF60X_STYLE</span>

<span class="cp">#define UART_GET_CHAR(p)      bfin_read32(port_membase(p) + OFFSET_RBR)</span>
<span class="cp">#define UART_GET_CLK(p)       bfin_read32(port_membase(p) + OFFSET_CLK)</span>
<span class="cp">#define UART_GET_CTL(p)       bfin_read32(port_membase(p) + OFFSET_CTL)</span>
<span class="cp">#define UART_GET_GCTL(p)      UART_GET_CTL(p)</span>
<span class="cp">#define UART_GET_LCR(p)       UART_GET_CTL(p)</span>
<span class="cp">#define UART_GET_MCR(p)       UART_GET_CTL(p)</span>
<span class="cp">#if ANOMALY_05001001</span>
<span class="cp">#define UART_GET_STAT(p) \</span>
<span class="cp">({ \</span>
<span class="cp">	u32 __ret; \</span>
<span class="cp">	unsigned long flags; \</span>
<span class="cp">	flags = hard_local_irq_save(); \</span>
<span class="cp">	__ret = bfin_read32(port_membase(p) + OFFSET_STAT); \</span>
<span class="cp">	hard_local_irq_restore(flags); \</span>
<span class="cp">	__ret; \</span>
<span class="cp">})</span>
<span class="cp">#else</span>
<span class="cp">#define UART_GET_STAT(p)      bfin_read32(port_membase(p) + OFFSET_STAT)</span>
<span class="cp">#endif</span>
<span class="cp">#define UART_GET_MSR(p)       UART_GET_STAT(p)</span>

<span class="cp">#define UART_PUT_CHAR(p, v)   bfin_write32(port_membase(p) + OFFSET_THR, v)</span>
<span class="cp">#define UART_PUT_CLK(p, v)    bfin_write32(port_membase(p) + OFFSET_CLK, v)</span>
<span class="cp">#define UART_PUT_CTL(p, v)    bfin_write32(port_membase(p) + OFFSET_CTL, v)</span>
<span class="cp">#define UART_PUT_GCTL(p, v)   UART_PUT_CTL(p, v)</span>
<span class="cp">#define UART_PUT_LCR(p, v)    UART_PUT_CTL(p, v)</span>
<span class="cp">#define UART_PUT_MCR(p, v)    UART_PUT_CTL(p, v)</span>
<span class="cp">#define UART_PUT_STAT(p, v)   bfin_write32(port_membase(p) + OFFSET_STAT, v)</span>

<span class="cp">#define UART_CLEAR_IER(p, v)  bfin_write32(port_membase(p) + OFFSET_IER_CLEAR, v)</span>
<span class="cp">#define UART_GET_IER(p)       bfin_read32(port_membase(p) + OFFSET_IER)</span>
<span class="cp">#define UART_SET_IER(p, v)    bfin_write32(port_membase(p) + OFFSET_IER_SET, v)</span>

<span class="cp">#define UART_CLEAR_DLAB(p)    </span><span class="cm">/* MMRs not muxed on BF60x */</span><span class="cp"></span>
<span class="cp">#define UART_SET_DLAB(p)      </span><span class="cm">/* MMRs not muxed on BF60x */</span><span class="cp"></span>

<span class="cp">#define UART_CLEAR_LSR(p)     UART_PUT_STAT(p, -1)</span>
<span class="cp">#define UART_GET_LSR(p)       UART_GET_STAT(p)</span>
<span class="cp">#define UART_PUT_LSR(p, v)    UART_PUT_STAT(p, v)</span>

<span class="cm">/* This handles hard CTS/RTS */</span>
<span class="cp">#define BFIN_UART_CTSRTS_HARD</span>
<span class="cp">#define UART_CLEAR_SCTS(p)      UART_PUT_STAT(p, SCTS)</span>
<span class="cp">#define UART_GET_CTS(x)         (UART_GET_MSR(x) &amp; CTS)</span>
<span class="cp">#define UART_DISABLE_RTS(x)     UART_PUT_MCR(x, UART_GET_MCR(x) &amp; ~(ARTS | MRTS))</span>
<span class="cp">#define UART_ENABLE_RTS(x)      UART_PUT_MCR(x, UART_GET_MCR(x) | MRTS | ARTS)</span>
<span class="cp">#define UART_ENABLE_INTS(x, v)  UART_SET_IER(x, v)</span>
<span class="cp">#define UART_DISABLE_INTS(x)    UART_CLEAR_IER(x, 0xF)</span>

<span class="cp">#else </span><span class="cm">/* BFIN_UART_BF60X_STYLE */</span><span class="cp"></span>

<span class="cp">#define UART_GET_CHAR(p)      bfin_read16(port_membase(p) + OFFSET_RBR)</span>
<span class="cp">#define UART_GET_DLL(p)       bfin_read16(port_membase(p) + OFFSET_DLL)</span>
<span class="cp">#define UART_GET_DLH(p)       bfin_read16(port_membase(p) + OFFSET_DLH)</span>
<span class="cp">#define UART_GET_CLK(p)	      ((UART_GET_DLH(p) &lt;&lt; 8) | UART_GET_DLL(p))</span>
<span class="cp">#define UART_GET_GCTL(p)      bfin_read16(port_membase(p) + OFFSET_GCTL)</span>
<span class="cp">#define UART_GET_LCR(p)       bfin_read16(port_membase(p) + OFFSET_LCR)</span>
<span class="cp">#define UART_GET_MCR(p)       bfin_read16(port_membase(p) + OFFSET_MCR)</span>
<span class="cp">#define UART_GET_MSR(p)       bfin_read16(port_membase(p) + OFFSET_MSR)</span>

<span class="cp">#define UART_PUT_CHAR(p, v)   bfin_write16(port_membase(p) + OFFSET_THR, v)</span>
<span class="cp">#define UART_PUT_DLL(p, v)    bfin_write16(port_membase(p) + OFFSET_DLL, v)</span>
<span class="cp">#define UART_PUT_DLH(p, v)    bfin_write16(port_membase(p) + OFFSET_DLH, v)</span>
<span class="cp">#define UART_PUT_CLK(p, v) do \</span>
<span class="cp">{\</span>
<span class="cp">UART_PUT_DLL(p, v &amp; 0xFF); \</span>
<span class="cp">UART_PUT_DLH(p, (v &gt;&gt; 8) &amp; 0xFF); } while (0);</span>

<span class="cp">#define UART_PUT_GCTL(p, v)   bfin_write16(port_membase(p) + OFFSET_GCTL, v)</span>
<span class="cp">#define UART_PUT_LCR(p, v)    bfin_write16(port_membase(p) + OFFSET_LCR, v)</span>
<span class="cp">#define UART_PUT_MCR(p, v)    bfin_write16(port_membase(p) + OFFSET_MCR, v)</span>

<span class="cp">#ifdef BFIN_UART_BF54X_STYLE</span>

<span class="cp">#define UART_CLEAR_IER(p, v)  bfin_write16(port_membase(p) + OFFSET_IER_CLEAR, v)</span>
<span class="cp">#define UART_GET_IER(p)       bfin_read16(port_membase(p) + OFFSET_IER_SET)</span>
<span class="cp">#define UART_SET_IER(p, v)    bfin_write16(port_membase(p) + OFFSET_IER_SET, v)</span>

<span class="cp">#define UART_CLEAR_DLAB(p)    </span><span class="cm">/* MMRs not muxed on BF54x */</span><span class="cp"></span>
<span class="cp">#define UART_SET_DLAB(p)      </span><span class="cm">/* MMRs not muxed on BF54x */</span><span class="cp"></span>

<span class="cp">#define UART_CLEAR_LSR(p)     bfin_write16(port_membase(p) + OFFSET_LSR, -1)</span>
<span class="cp">#define UART_GET_LSR(p)       bfin_read16(port_membase(p) + OFFSET_LSR)</span>
<span class="cp">#define UART_PUT_LSR(p, v)    bfin_write16(port_membase(p) + OFFSET_LSR, v)</span>

<span class="cm">/* This handles hard CTS/RTS */</span>
<span class="cp">#define BFIN_UART_CTSRTS_HARD</span>
<span class="cp">#define UART_CLEAR_SCTS(p)      bfin_write16((port_membase(p) + OFFSET_MSR), SCTS)</span>
<span class="cp">#define UART_GET_CTS(x)         (UART_GET_MSR(x) &amp; CTS)</span>
<span class="cp">#define UART_DISABLE_RTS(x)     UART_PUT_MCR(x, UART_GET_MCR(x) &amp; ~(ARTS | MRTS))</span>
<span class="cp">#define UART_ENABLE_RTS(x)      UART_PUT_MCR(x, UART_GET_MCR(x) | MRTS | ARTS)</span>
<span class="cp">#define UART_ENABLE_INTS(x, v)  UART_SET_IER(x, v)</span>
<span class="cp">#define UART_DISABLE_INTS(x)    UART_CLEAR_IER(x, 0xF)</span>

<span class="cp">#else </span><span class="cm">/* BF533 style */</span><span class="cp"></span>

<span class="cp">#define UART_CLEAR_IER(p, v)  UART_PUT_IER(p, UART_GET_IER(p) &amp; ~(v))</span>
<span class="cp">#define UART_GET_IER(p)       bfin_read16(port_membase(p) + OFFSET_IER)</span>
<span class="cp">#define UART_PUT_IER(p, v)    bfin_write16(port_membase(p) + OFFSET_IER, v)</span>
<span class="cp">#define UART_SET_IER(p, v)    UART_PUT_IER(p, UART_GET_IER(p) | (v))</span>

<span class="cp">#define UART_CLEAR_DLAB(p)    do { UART_PUT_LCR(p, UART_GET_LCR(p) &amp; ~DLAB); SSYNC(); } while (0)</span>
<span class="cp">#define UART_SET_DLAB(p)      do { UART_PUT_LCR(p, UART_GET_LCR(p) | DLAB); SSYNC(); } while (0)</span>

<span class="cp">#define get_lsr_cache(uart)    (((struct bfin_serial_port *)(uart))-&gt;lsr)</span>
<span class="cp">#define put_lsr_cache(uart, v) (((struct bfin_serial_port *)(uart))-&gt;lsr = (v))</span>

<span class="cm">/*</span>
<span class="cm">#ifndef put_lsr_cache</span>
<span class="cm"># define put_lsr_cache(p, v)</span>
<span class="cm">#endif</span>
<span class="cm">#ifndef get_lsr_cache</span>
<span class="cm"># define get_lsr_cache(p) 0</span>
<span class="cm">#endif</span>
<span class="cm">*/</span>

<span class="cm">/* The hardware clears the LSR bits upon read, so we need to cache</span>
<span class="cm"> * some of the more fun bits in software so they don&#39;t get lost</span>
<span class="cm"> * when checking the LSR in other code paths (TX).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">UART_CLEAR_LSR</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_lsr_cache</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bfin_write16</span><span class="p">(</span><span class="n">port_membase</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">OFFSET_LSR</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">UART_GET_LSR</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lsr</span> <span class="o">=</span> <span class="n">bfin_read16</span><span class="p">(</span><span class="n">port_membase</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">OFFSET_LSR</span><span class="p">);</span>
	<span class="n">put_lsr_cache</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">get_lsr_cache</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">lsr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BI</span><span class="o">|</span><span class="n">FE</span><span class="o">|</span><span class="n">PE</span><span class="o">|</span><span class="n">OE</span><span class="p">)));</span>
	<span class="k">return</span> <span class="n">lsr</span> <span class="o">|</span> <span class="n">get_lsr_cache</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">UART_PUT_LSR</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_lsr_cache</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">get_lsr_cache</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This handles soft CTS/RTS */</span>
<span class="cp">#define UART_GET_CTS(x)        gpio_get_value((x)-&gt;cts_pin)</span>
<span class="cp">#define UART_DISABLE_RTS(x)    gpio_set_value((x)-&gt;rts_pin, 1)</span>
<span class="cp">#define UART_ENABLE_RTS(x)     gpio_set_value((x)-&gt;rts_pin, 0)</span>
<span class="cp">#define UART_ENABLE_INTS(x, v) UART_PUT_IER(x, v)</span>
<span class="cp">#define UART_DISABLE_INTS(x)   UART_PUT_IER(x, 0)</span>

<span class="cp">#endif </span><span class="cm">/* BFIN_UART_BF54X_STYLE */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* BFIN_UART_BF60X_STYLE */</span><span class="cp"></span>

<span class="cp">#ifndef BFIN_UART_TX_FIFO_SIZE</span>
<span class="cp"># define BFIN_UART_TX_FIFO_SIZE 2</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __BFIN_ASM_SERIAL_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
