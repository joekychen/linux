<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › blackfin › kernel › setup.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>setup.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2004-2010 Analog Devices Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the GPL-2 or later.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>

<span class="cp">#ifdef CONFIG_MTD_UCLINUX</span>
<span class="cp">#include &lt;linux/mtd/map.h&gt;</span>
<span class="cp">#include &lt;linux/ext2_fs.h&gt;</span>
<span class="cp">#include &lt;linux/cramfs_fs.h&gt;</span>
<span class="cp">#include &lt;linux/romfs_fs.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/cplb.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/blackfin.h&gt;</span>
<span class="cp">#include &lt;asm/cplbinit.h&gt;</span>
<span class="cp">#include &lt;asm/clocks.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/fixed_code.h&gt;</span>
<span class="cp">#include &lt;asm/early_printk.h&gt;</span>
<span class="cp">#include &lt;asm/irq_handler.h&gt;</span>
<span class="cp">#include &lt;asm/pda.h&gt;</span>
<span class="cp">#ifdef CONFIG_BF60x</span>
<span class="cp">#include &lt;mach/pm.h&gt;</span>
<span class="cp">#endif</span>

<span class="n">u16</span> <span class="n">_bfin_swrst</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">_bfin_swrst</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memory_start</span><span class="p">,</span> <span class="n">memory_end</span><span class="p">,</span> <span class="n">physical_mem_end</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_rambase</span><span class="p">,</span> <span class="n">_ramstart</span><span class="p">,</span> <span class="n">_ramend</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserved_mem_dcache_on</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserved_mem_icache_on</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">memory_start</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">memory_end</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">physical_mem_end</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">_ramend</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">reserved_mem_dcache_on</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MTD_UCLINUX</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">map_info</span> <span class="n">uclinux_ram_map</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memory_mtd_end</span><span class="p">,</span> <span class="n">memory_mtd_start</span><span class="p">,</span> <span class="n">mtd_size</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_ebss</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">memory_mtd_end</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">memory_mtd_start</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mtd_size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">char</span> <span class="n">__initdata</span> <span class="n">command_line</span><span class="p">[</span><span class="n">COMMAND_LINE_SIZE</span><span class="p">];</span>
<span class="k">struct</span> <span class="n">blackfin_initial_pda</span> <span class="n">__initdata</span> <span class="n">initial_pda</span><span class="p">;</span>

<span class="cm">/* boot memmap, for parsing &quot;memmap=&quot; */</span>
<span class="cp">#define BFIN_MEMMAP_MAX		128 </span><span class="cm">/* number of entries in bfin_memmap */</span><span class="cp"></span>
<span class="cp">#define BFIN_MEMMAP_RAM		1</span>
<span class="cp">#define BFIN_MEMMAP_RESERVED	2</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bfin_memmap</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bfin_memmap_entry</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span> <span class="cm">/* start of memory segment */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">map</span><span class="p">[</span><span class="n">BFIN_MEMMAP_MAX</span><span class="p">];</span>
<span class="p">}</span> <span class="n">bfin_memmap</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="cm">/* for memmap sanitization */</span>
<span class="k">struct</span> <span class="n">change_member</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bfin_memmap_entry</span> <span class="o">*</span><span class="n">pentry</span><span class="p">;</span> <span class="cm">/* pointer to original entry */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span> <span class="cm">/* address for this change point */</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">change_member</span> <span class="n">change_point_list</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">BFIN_MEMMAP_MAX</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">change_member</span> <span class="o">*</span><span class="n">change_point</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">BFIN_MEMMAP_MAX</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bfin_memmap_entry</span> <span class="o">*</span><span class="n">overlap_list</span><span class="p">[</span><span class="n">BFIN_MEMMAP_MAX</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bfin_memmap_entry</span> <span class="n">new_map</span><span class="p">[</span><span class="n">BFIN_MEMMAP_MAX</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">blackfin_cpudata</span><span class="p">,</span> <span class="n">cpu_data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">early_init_clkin_hz</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_BFIN_DCACHE) || defined(CONFIG_BFIN_ICACHE)</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">generate_cplb_tables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">generate_cplb_tables_all</span><span class="p">();</span>
	<span class="cm">/* Generate per-CPU I&amp;D CPLB tables */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">num_possible_cpus</span><span class="p">();</span> <span class="o">++</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">generate_cplb_tables_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">bfin_setup_caches</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BFIN_ICACHE</span>
	<span class="n">bfin_icache_init</span><span class="p">(</span><span class="n">icplb_tbl</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_BFIN_DCACHE</span>
	<span class="n">bfin_dcache_init</span><span class="p">(</span><span class="n">dcplb_tbl</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
<span class="cp">#endif</span>

	<span class="n">bfin_setup_cpudata</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In cache coherence emulation mode, we need to have the</span>
<span class="cm">	 * D-cache enabled before running any atomic operation which</span>
<span class="cm">	 * might involve cache invalidation (i.e. spinlock, rwlock).</span>
<span class="cm">	 * So printk&#39;s are deferred until then.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_BFIN_ICACHE</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Instruction Cache Enabled for CPU%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  External memory:&quot;</span>
<span class="cp"># ifdef CONFIG_BFIN_EXTMEM_ICACHEABLE</span>
	       <span class="s">&quot; cacheable&quot;</span>
<span class="cp"># else</span>
	       <span class="s">&quot; uncacheable&quot;</span>
<span class="cp"># endif</span>
	       <span class="s">&quot; in instruction cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">L2_LENGTH</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  L2 SRAM        :&quot;</span>
<span class="cp"># ifdef CONFIG_BFIN_L2_ICACHEABLE</span>
		       <span class="s">&quot; cacheable&quot;</span>
<span class="cp"># else</span>
		       <span class="s">&quot; uncacheable&quot;</span>
<span class="cp"># endif</span>
		       <span class="s">&quot; in instruction cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#else</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Instruction Cache Disabled for CPU%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_BFIN_DCACHE</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Data Cache Enabled for CPU%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  External memory:&quot;</span>
<span class="cp"># if defined CONFIG_BFIN_EXTMEM_WRITEBACK</span>
	       <span class="s">&quot; cacheable (write-back)&quot;</span>
<span class="cp"># elif defined CONFIG_BFIN_EXTMEM_WRITETHROUGH</span>
	       <span class="s">&quot; cacheable (write-through)&quot;</span>
<span class="cp"># else</span>
	       <span class="s">&quot; uncacheable&quot;</span>
<span class="cp"># endif</span>
	       <span class="s">&quot; in data cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">L2_LENGTH</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  L2 SRAM        :&quot;</span>
<span class="cp"># if defined CONFIG_BFIN_L2_WRITEBACK</span>
		       <span class="s">&quot; cacheable (write-back)&quot;</span>
<span class="cp"># elif defined CONFIG_BFIN_L2_WRITETHROUGH</span>
		       <span class="s">&quot; cacheable (write-through)&quot;</span>
<span class="cp"># else</span>
		       <span class="s">&quot; uncacheable&quot;</span>
<span class="cp"># endif</span>
		       <span class="s">&quot; in data cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Data Cache Disabled for CPU%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">bfin_setup_cpudata</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blackfin_cpudata</span> <span class="o">*</span><span class="n">cpudata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">cpudata</span><span class="o">-&gt;</span><span class="n">imemctl</span> <span class="o">=</span> <span class="n">bfin_read_IMEM_CONTROL</span><span class="p">();</span>
	<span class="n">cpudata</span><span class="o">-&gt;</span><span class="n">dmemctl</span> <span class="o">=</span> <span class="n">bfin_read_DMEM_CONTROL</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">bfin_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_BFIN_DCACHE) || defined(CONFIG_BFIN_ICACHE)</span>
	<span class="n">generate_cplb_tables</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">bfin_setup_caches</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">bfin_relocate_l1_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_l1_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_text_l1_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_l1_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_data_l1_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_b_l1_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_data_b_l1_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l2_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_l2_len</span><span class="p">;</span>

	<span class="n">early_shadow_stamp</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * due to the ALIGN(4) in the arch/blackfin/kernel/vmlinux.lds.S</span>
<span class="cm">	 * we know that everything about l1 text/data is nice and aligned,</span>
<span class="cm">	 * so copy by 4 byte chunks, and don&#39;t worry about overlapping</span>
<span class="cm">	 * src/dest.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We can&#39;t use the dma_memcpy functions, since they can call</span>
<span class="cm">	 * scheduler functions which might be in L1 :( and core writes</span>
<span class="cm">	 * into L1 instruction cause bad access errors, so we are stuck,</span>
<span class="cm">	 * we are required to use DMA, but can&#39;t use the common dma</span>
<span class="cm">	 * functions. We can&#39;t use memcpy either - since that might be</span>
<span class="cm">	 * going to be in the relocated L1</span>
<span class="cm">	 */</span>

	<span class="n">blackfin_dma_early_init</span><span class="p">();</span>

	<span class="cm">/* if necessary, copy L1 text to L1 instruction SRAM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">L1_CODE_LENGTH</span> <span class="o">&amp;&amp;</span> <span class="n">text_l1_len</span><span class="p">)</span>
		<span class="n">early_dma_memcpy</span><span class="p">(</span><span class="n">_stext_l1</span><span class="p">,</span> <span class="n">_text_l1_lma</span><span class="p">,</span> <span class="n">text_l1_len</span><span class="p">);</span>

	<span class="cm">/* if necessary, copy L1 data to L1 data bank A SRAM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">L1_DATA_A_LENGTH</span> <span class="o">&amp;&amp;</span> <span class="n">data_l1_len</span><span class="p">)</span>
		<span class="n">early_dma_memcpy</span><span class="p">(</span><span class="n">_sdata_l1</span><span class="p">,</span> <span class="n">_data_l1_lma</span><span class="p">,</span> <span class="n">data_l1_len</span><span class="p">);</span>

	<span class="cm">/* if necessary, copy L1 data B to L1 data bank B SRAM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">L1_DATA_B_LENGTH</span> <span class="o">&amp;&amp;</span> <span class="n">data_b_l1_len</span><span class="p">)</span>
		<span class="n">early_dma_memcpy</span><span class="p">(</span><span class="n">_sdata_b_l1</span><span class="p">,</span> <span class="n">_data_b_l1_lma</span><span class="p">,</span> <span class="n">data_b_l1_len</span><span class="p">);</span>

	<span class="n">early_dma_memcpy_done</span><span class="p">();</span>

<span class="cp">#if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_ICACHE_FLUSH_L1)</span>
	<span class="n">blackfin_iflush_l1_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">blackfin_icache_flush_range_l1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* if necessary, copy L2 text/data to L2 SRAM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">L2_LENGTH</span> <span class="o">&amp;&amp;</span> <span class="n">l2_len</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">_stext_l2</span><span class="p">,</span> <span class="n">_l2_lma</span><span class="p">,</span> <span class="n">l2_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">bfin_relocate_coreb_l1_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_l1_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_text_l1_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_l1_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_data_l1_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_b_l1_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_data_b_l1_len</span><span class="p">;</span>

	<span class="n">blackfin_dma_early_init</span><span class="p">();</span>

	<span class="cm">/* if necessary, copy L1 text to L1 instruction SRAM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">L1_CODE_LENGTH</span> <span class="o">&amp;&amp;</span> <span class="n">text_l1_len</span><span class="p">)</span>
		<span class="n">early_dma_memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">COREB_L1_CODE_START</span><span class="p">,</span> <span class="n">_text_l1_lma</span><span class="p">,</span>
				<span class="n">text_l1_len</span><span class="p">);</span>

	<span class="cm">/* if necessary, copy L1 data to L1 data bank A SRAM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">L1_DATA_A_LENGTH</span> <span class="o">&amp;&amp;</span> <span class="n">data_l1_len</span><span class="p">)</span>
		<span class="n">early_dma_memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">COREB_L1_DATA_A_START</span><span class="p">,</span> <span class="n">_data_l1_lma</span><span class="p">,</span>
				<span class="n">data_l1_len</span><span class="p">);</span>

	<span class="cm">/* if necessary, copy L1 data B to L1 data bank B SRAM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">L1_DATA_B_LENGTH</span> <span class="o">&amp;&amp;</span> <span class="n">data_b_l1_len</span><span class="p">)</span>
		<span class="n">early_dma_memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">COREB_L1_DATA_B_START</span><span class="p">,</span> <span class="n">_data_b_l1_lma</span><span class="p">,</span>
				<span class="n">data_b_l1_len</span><span class="p">);</span>

	<span class="n">early_dma_memcpy_done</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_ICACHE_FLUSH_L1</span>
	<span class="n">blackfin_iflush_l1_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">blackfin_icache_flush_range_l1</span> <span class="o">-</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_stext_l1</span> <span class="o">+</span> <span class="n">COREB_L1_CODE_START</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ROMKERNEL</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">bfin_relocate_xip_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">early_shadow_stamp</span><span class="p">();</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">_sdata</span><span class="p">,</span> <span class="n">_data_lma</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_data_len</span> <span class="o">-</span> <span class="n">THREAD_SIZE</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_info</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">_sinitdata</span><span class="p">,</span> <span class="n">_init_data_lma</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_init_data_len</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* add_memory_region to memmap */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">add_memory_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">bfin_memmap</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">BFIN_MEMMAP_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Ooops! Too many entries in the memory map!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">bfin_memmap</span><span class="p">.</span><span class="n">nr_map</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sanitize the boot memmap, removing overlaps.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sanitize_memmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">bfin_memmap_entry</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pnr_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">change_member</span> <span class="o">*</span><span class="n">change_tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">current_type</span><span class="p">,</span> <span class="n">last_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">last_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chgidx</span><span class="p">,</span> <span class="n">still_changing</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">overlap_entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_nr</span><span class="p">,</span> <span class="n">new_nr</span><span class="p">,</span> <span class="n">chg_nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">		Visually we&#39;re performing the following (1,2,3,4 = memory types)</span>

<span class="cm">		Sample memory map (w/overlaps):</span>
<span class="cm">		   ____22__________________</span>
<span class="cm">		   ______________________4_</span>
<span class="cm">		   ____1111________________</span>
<span class="cm">		   _44_____________________</span>
<span class="cm">		   11111111________________</span>
<span class="cm">		   ____________________33__</span>
<span class="cm">		   ___________44___________</span>
<span class="cm">		   __________33333_________</span>
<span class="cm">		   ______________22________</span>
<span class="cm">		   ___________________2222_</span>
<span class="cm">		   _________111111111______</span>
<span class="cm">		   _____________________11_</span>
<span class="cm">		   _________________4______</span>

<span class="cm">		Sanitized equivalent (no overlap):</span>
<span class="cm">		   1_______________________</span>
<span class="cm">		   _44_____________________</span>
<span class="cm">		   ___1____________________</span>
<span class="cm">		   ____22__________________</span>
<span class="cm">		   ______11________________</span>
<span class="cm">		   _________1______________</span>
<span class="cm">		   __________3_____________</span>
<span class="cm">		   ___________44___________</span>
<span class="cm">		   _____________33_________</span>
<span class="cm">		   _______________2________</span>
<span class="cm">		   ________________1_______</span>
<span class="cm">		   _________________4______</span>
<span class="cm">		   ___________________2____</span>
<span class="cm">		   ____________________33__</span>
<span class="cm">		   ______________________4_</span>
<span class="cm">	*/</span>
	<span class="cm">/* if there&#39;s only one memory region, don&#39;t bother */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pnr_map</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">old_nr</span> <span class="o">=</span> <span class="o">*</span><span class="n">pnr_map</span><span class="p">;</span>

	<span class="cm">/* bail out if we find any unreasonable addresses in memmap */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">old_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* create pointers for initial change-point information (for sorting) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">old_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">change_point_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/* record all known change-points (starting and ending addresses),</span>
<span class="cm">	   omitting those that are for empty memory regions */</span>
	<span class="n">chgidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">old_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="o">++</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pentry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
			<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="o">++</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pentry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">chg_nr</span> <span class="o">=</span> <span class="n">chgidx</span><span class="p">;</span>	<span class="cm">/* true number of change-points */</span>

	<span class="cm">/* sort change-point list by memory addresses (low -&gt; high) */</span>
	<span class="n">still_changing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">still_changing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">still_changing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chg_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* if &lt;current_addr&gt; &gt; &lt;last_addr&gt;, swap */</span>
			<span class="cm">/* or, if current=&lt;start_addr&gt; &amp; last=&lt;end_addr&gt;, swap */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">((</span><span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span><span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pentry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span><span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pentry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span>
			   <span class="p">)</span> <span class="p">{</span>
				<span class="n">change_tmp</span> <span class="o">=</span> <span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
				<span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">change_tmp</span><span class="p">;</span>
				<span class="n">still_changing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* create a new memmap, removing overlaps */</span>
	<span class="n">overlap_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* number of entries in the overlap table */</span>
	<span class="n">new_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* index for creating new memmap entries */</span>
	<span class="n">last_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* start with undefined memory type */</span>
	<span class="n">last_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* start with 0 as last starting address */</span>
	<span class="cm">/* loop through change-points, determining affect on the new memmap */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">chgidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chgidx</span> <span class="o">&lt;</span> <span class="n">chg_nr</span><span class="p">;</span> <span class="n">chgidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* keep track of all overlapping memmap entries */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pentry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* add map entry to overlap list (&gt; 1 entry implies an overlap) */</span>
			<span class="n">overlap_list</span><span class="p">[</span><span class="n">overlap_entries</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pentry</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* remove entry from list (order independent, so swap with last) */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">overlap_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">overlap_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pentry</span><span class="p">)</span>
					<span class="n">overlap_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlap_list</span><span class="p">[</span><span class="n">overlap_entries</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">overlap_entries</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* if there are overlapping entries, decide which &quot;type&quot; to use */</span>
		<span class="cm">/* (larger value takes precedence -- 1=usable, 2,3,4,4+=unusable) */</span>
		<span class="n">current_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">overlap_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">overlap_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">current_type</span><span class="p">)</span>
				<span class="n">current_type</span> <span class="o">=</span> <span class="n">overlap_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="cm">/* continue building up new memmap based on this information */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_type</span> <span class="o">!=</span> <span class="n">last_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_map</span><span class="p">[</span><span class="n">new_entry</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span>
					<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">-</span> <span class="n">last_addr</span><span class="p">;</span>
				<span class="cm">/* move forward only if the new size was non-zero */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">new_map</span><span class="p">[</span><span class="n">new_entry</span><span class="p">].</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">new_entry</span> <span class="o">&gt;=</span> <span class="n">BFIN_MEMMAP_MAX</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>	<span class="cm">/* no more space left for new entries */</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current_type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_map</span><span class="p">[</span><span class="n">new_entry</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
				<span class="n">new_map</span><span class="p">[</span><span class="n">new_entry</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">current_type</span><span class="p">;</span>
				<span class="n">last_addr</span> <span class="o">=</span> <span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">last_type</span> <span class="o">=</span> <span class="n">current_type</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">new_nr</span> <span class="o">=</span> <span class="n">new_entry</span><span class="p">;</span>	<span class="cm">/* retain count for new entries */</span>

	<span class="cm">/* copy new mapping into original location */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">new_map</span><span class="p">,</span> <span class="n">new_nr</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bfin_memmap_entry</span><span class="p">));</span>
	<span class="o">*</span><span class="n">pnr_map</span> <span class="o">=</span> <span class="n">new_nr</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">print_memory_map</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">who</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bfin_memmap</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; %s: %016Lx - %016Lx &quot;</span><span class="p">,</span> <span class="n">who</span><span class="p">,</span>
			<span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">,</span>
			<span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BFIN_MEMMAP_RAM</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;(usable)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BFIN_MEMMAP_RESERVED</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;(reserved)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;type %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">parse_memmap</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start_at</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mem_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">arg</span> <span class="o">==</span> <span class="sc">&#39;@&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_at</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">arg</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
		<span class="n">add_memory_region</span><span class="p">(</span><span class="n">start_at</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">BFIN_MEMMAP_RAM</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">arg</span> <span class="o">==</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_at</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">arg</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
		<span class="n">add_memory_region</span><span class="p">(</span><span class="n">start_at</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">BFIN_MEMMAP_RESERVED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initial parsing of the command line.  Currently, we support:</span>
<span class="cm"> *  - Controlling the linux memory size: mem=xxx[KMG]</span>
<span class="cm"> *  - Controlling the physical memory size: max_mem=xxx[KMG][$][#]</span>
<span class="cm"> *       $ -&gt; reserved memory is dcacheable</span>
<span class="cm"> *       # -&gt; reserved memory is icacheable</span>
<span class="cm"> *  - &quot;memmap=XXX[KkmM][@][$]XXX[KkmM]&quot; defines a memory region</span>
<span class="cm"> *       @ from &lt;start&gt; to &lt;start&gt;+&lt;mem&gt;, type RAM</span>
<span class="cm"> *       $ from &lt;start&gt; to &lt;start&gt;+&lt;mem&gt;, type RESERVED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">parse_cmdline_early</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmdline_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">cmdline_p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">memsize</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="s">&quot;mem=&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">to</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">memsize</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">memsize</span><span class="p">)</span>
					<span class="n">_ramend</span> <span class="o">=</span> <span class="n">memsize</span><span class="p">;</span>

			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="s">&quot;max_mem=&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">to</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
				<span class="n">memsize</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">memsize</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">physical_mem_end</span> <span class="o">=</span> <span class="n">memsize</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">to</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">to</span> <span class="o">==</span> <span class="sc">&#39;$&#39;</span>
						    <span class="o">||</span> <span class="o">*</span><span class="p">(</span><span class="n">to</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span>
							<span class="n">reserved_mem_dcache_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">to</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span>
						    <span class="o">||</span> <span class="o">*</span><span class="p">(</span><span class="n">to</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span>
							<span class="n">reserved_mem_icache_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="s">&quot;clkin_hz=&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">to</span> <span class="o">+=</span> <span class="mi">9</span><span class="p">;</span>
				<span class="n">early_init_clkin_hz</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_EARLY_PRINTK</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="s">&quot;earlyprintk=&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">to</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span>
				<span class="n">setup_early_printk</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="s">&quot;memmap=&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">to</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
				<span class="n">parse_memmap</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">to</span><span class="o">++</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup memory defaults from user config.</span>
<span class="cm"> * The physical memory layout looks like:</span>
<span class="cm"> *</span>
<span class="cm"> *  [_rambase, _ramstart]:		kernel image</span>
<span class="cm"> *  [memory_start, memory_end]:		dynamic memory managed by kernel</span>
<span class="cm"> *  [memory_end, _ramend]:		reserved memory</span>
<span class="cm"> *  	[memory_mtd_start(memory_end),</span>
<span class="cm"> *  		memory_mtd_start + mtd_size]:	rootfs (if any)</span>
<span class="cm"> *	[_ramend - DMA_UNCACHED_REGION,</span>
<span class="cm"> *		_ramend]:			uncached DMA region</span>
<span class="cm"> *  [_ramend, physical_mem_end]:	memory not managed by kernel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">memory_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MTD_UCLINUX</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mtd_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_mem</span><span class="p">;</span>

	<span class="n">_rambase</span> <span class="o">=</span> <span class="n">CONFIG_BOOT_LOAD</span><span class="p">;</span>
	<span class="n">_ramstart</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DMA_UNCACHED_REGION</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">_ramend</span> <span class="o">-</span> <span class="n">_ramstart</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">console_init</span><span class="p">();</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;DMA region exceeds memory limit: %lu.&quot;</span><span class="p">,</span>
			<span class="n">_ramend</span> <span class="o">-</span> <span class="n">_ramstart</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">max_mem</span> <span class="o">=</span> <span class="n">memory_end</span> <span class="o">=</span> <span class="n">_ramend</span> <span class="o">-</span> <span class="n">DMA_UNCACHED_REGION</span><span class="p">;</span>

<span class="cp">#if (defined(CONFIG_BFIN_EXTMEM_ICACHEABLE) &amp;&amp; ANOMALY_05000263)</span>
	<span class="cm">/* Due to a Hardware Anomaly we need to limit the size of usable</span>
<span class="cm">	 * instruction memory to max 60MB, 56 if HUNT_FOR_ZERO is on</span>
<span class="cm">	 * 05000263 - Hardware loop corrupted when taking an ICPLB exception</span>
<span class="cm">	 */</span>
<span class="cp"># if (defined(CONFIG_DEBUG_HUNT_FOR_ZERO))</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_mem</span> <span class="o">&gt;=</span> <span class="mi">56</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">max_mem</span> <span class="o">=</span> <span class="mi">56</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="cp"># else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_mem</span> <span class="o">&gt;=</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">max_mem</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="cp"># endif				</span><span class="cm">/* CONFIG_DEBUG_HUNT_FOR_ZERO */</span><span class="cp"></span>
<span class="cp">#endif				</span><span class="cm">/* ANOMALY_05000263 */</span><span class="cp"></span>


<span class="cp">#ifdef CONFIG_MPU</span>
	<span class="cm">/* Round up to multiple of 4MB */</span>
	<span class="n">memory_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ramstart</span> <span class="o">+</span> <span class="mh">0x3fffff</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3fffff</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">memory_start</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">_ramstart</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_MTD_UCLINUX)</span>
	<span class="cm">/* generic memory mapped MTD driver */</span>
	<span class="n">memory_mtd_end</span> <span class="o">=</span> <span class="n">memory_end</span><span class="p">;</span>

	<span class="n">mtd_phys</span> <span class="o">=</span> <span class="n">_ramstart</span><span class="p">;</span>
	<span class="n">mtd_size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">mtd_phys</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)));</span>

<span class="cp"># if defined(CONFIG_EXT2_FS) || defined(CONFIG_EXT3_FS)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)(</span><span class="n">mtd_phys</span> <span class="o">+</span> <span class="mh">0x438</span><span class="p">))</span> <span class="o">==</span> <span class="n">EXT2_SUPER_MAGIC</span><span class="p">)</span>
		<span class="n">mtd_size</span> <span class="o">=</span>
		    <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">mtd_phys</span> <span class="o">+</span> <span class="mh">0x404</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="cp"># endif</span>

<span class="cp"># if defined(CONFIG_CRAMFS)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">mtd_phys</span><span class="p">))</span> <span class="o">==</span> <span class="n">CRAMFS_MAGIC</span><span class="p">)</span>
		<span class="n">mtd_size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">mtd_phys</span> <span class="o">+</span> <span class="mh">0x4</span><span class="p">)));</span>
<span class="cp"># endif</span>

<span class="cp"># if defined(CONFIG_ROMFS_FS)</span>
	<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">mtd_phys</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ROMSB_WORD0</span>
	    <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">mtd_phys</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ROMSB_WORD1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtd_size</span> <span class="o">=</span>
		    <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">mtd_phys</span><span class="p">)[</span><span class="mi">2</span><span class="p">]));</span>

		<span class="cm">/* ROM_FS is XIP, so if we found it, we need to limit memory */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memory_end</span> <span class="o">&gt;</span> <span class="n">max_mem</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Limiting kernel memory to %liMB due to anomaly 05000263</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">max_mem</span> <span class="o">-</span> <span class="n">CONFIG_PHY_RAM_BASE_ADDRESS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
			<span class="n">memory_end</span> <span class="o">=</span> <span class="n">max_mem</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp"># endif				</span><span class="cm">/* CONFIG_ROMFS_FS */</span><span class="cp"></span>

	<span class="cm">/* Since the default MTD_UCLINUX has no magic number, we just blindly</span>
<span class="cm">	 * read 8 past the end of the kernel&#39;s image, and look at it.</span>
<span class="cm">	 * When no image is attached, mtd_size is set to a random number</span>
<span class="cm">	 * Do some basic sanity checks before operating on things</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtd_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">memory_end</span> <span class="o">&lt;=</span> <span class="n">mtd_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Could not find valid ram mtd attached.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memory_end</span> <span class="o">-=</span> <span class="n">mtd_size</span><span class="p">;</span>

		<span class="cm">/* Relocate MTD image to the top of memory after the uncached memory area */</span>
		<span class="n">uclinux_ram_map</span><span class="p">.</span><span class="n">phys</span> <span class="o">=</span> <span class="n">memory_mtd_start</span> <span class="o">=</span> <span class="n">memory_end</span><span class="p">;</span>
		<span class="n">uclinux_ram_map</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">mtd_size</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Found mtd parition at 0x%p, (len=0x%lx), moving to 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">_end</span><span class="p">,</span> <span class="n">mtd_size</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">memory_mtd_start</span><span class="p">);</span>
		<span class="n">dma_memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">uclinux_ram_map</span><span class="p">.</span><span class="n">phys</span><span class="p">,</span> <span class="n">_end</span><span class="p">,</span> <span class="n">uclinux_ram_map</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_MTD_UCLINUX */</span><span class="cp"></span>

	<span class="cm">/* We need lo limit memory, since everything could have a text section</span>
<span class="cm">	 * of userspace in it, and expose anomaly 05000263. If the anomaly</span>
<span class="cm">	 * doesn&#39;t exist, or we don&#39;t need to - then dont.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memory_end</span> <span class="o">&gt;</span> <span class="n">max_mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Limiting kernel memory to %liMB due to anomaly 05000263</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">max_mem</span> <span class="o">-</span> <span class="n">CONFIG_PHY_RAM_BASE_ADDRESS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">memory_end</span> <span class="o">=</span> <span class="n">max_mem</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MPU</span>
<span class="cp">#if defined(CONFIG_ROMFS_ON_MTD) &amp;&amp; defined(CONFIG_MTD_ROM)</span>
	<span class="n">page_mask_nelts</span> <span class="o">=</span> <span class="p">(((</span><span class="n">_ramend</span> <span class="o">+</span> <span class="n">ASYNC_BANK3_BASE</span> <span class="o">+</span> <span class="n">ASYNC_BANK3_SIZE</span> <span class="o">-</span>
					<span class="n">ASYNC_BANK0_BASE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">page_mask_nelts</span> <span class="o">=</span> <span class="p">((</span><span class="n">_ramend</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">page_mask_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">page_mask_nelts</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">init_mm</span><span class="p">.</span><span class="n">start_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_stext</span><span class="p">;</span>
	<span class="n">init_mm</span><span class="p">.</span><span class="n">end_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_etext</span><span class="p">;</span>
	<span class="n">init_mm</span><span class="p">.</span><span class="n">end_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_edata</span><span class="p">;</span>
	<span class="n">init_mm</span><span class="p">.</span><span class="n">brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Board Memory: %ldMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">physical_mem_end</span> <span class="o">-</span> <span class="n">CONFIG_PHY_RAM_BASE_ADDRESS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Kernel Managed Memory: %ldMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">_ramend</span> <span class="o">-</span> <span class="n">CONFIG_PHY_RAM_BASE_ADDRESS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Memory map:</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;  fixedcode = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;  text      = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;  rodata    = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;  bss       = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;  data      = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;    stack   = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;  init      = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;  available = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#ifdef CONFIG_MTD_UCLINUX</span>
	       <span class="s">&quot;  rootfs    = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#if DMA_UNCACHED_REGION &gt; 0</span>
	       <span class="s">&quot;  DMA Zone  = 0x%p-0x%p</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
		<span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FIXED_CODE_START</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FIXED_CODE_END</span><span class="p">,</span>
		<span class="n">_stext</span><span class="p">,</span> <span class="n">_etext</span><span class="p">,</span>
		<span class="n">__start_rodata</span><span class="p">,</span> <span class="n">__end_rodata</span><span class="p">,</span>
		<span class="n">__bss_start</span><span class="p">,</span> <span class="n">__bss_stop</span><span class="p">,</span>
		<span class="n">_sdata</span><span class="p">,</span> <span class="n">_edata</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">init_thread_union</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">init_thread_union</span><span class="p">)</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span><span class="p">),</span>
		<span class="n">__init_begin</span><span class="p">,</span> <span class="n">__init_end</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_ramstart</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">memory_end</span>
<span class="cp">#ifdef CONFIG_MTD_UCLINUX</span>
		<span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">memory_mtd_start</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">memory_mtd_start</span> <span class="o">+</span> <span class="n">mtd_size</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="cp">#if DMA_UNCACHED_REGION &gt; 0</span>
		<span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">_ramend</span> <span class="o">-</span> <span class="n">DMA_UNCACHED_REGION</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">_ramend</span><span class="p">)</span>
<span class="cp">#endif</span>
		<span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the lowest, highest page frame number we have available</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">find_min_max_pfn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">max_pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">memory_end</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bfin_memmap</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
		<span class="cm">/* RAM? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BFIN_MEMMAP_RAM</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span>
				<span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">max_pfn</span><span class="p">)</span>
			<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">min_low_pfn</span><span class="p">)</span>
			<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">setup_bootmem_allocator</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bootmap_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curr_pfn</span><span class="p">,</span> <span class="n">last_pfn</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* mark memory between memory_start and memory_end usable */</span>
	<span class="n">add_memory_region</span><span class="p">(</span><span class="n">memory_start</span><span class="p">,</span>
		<span class="n">memory_end</span> <span class="o">-</span> <span class="n">memory_start</span><span class="p">,</span> <span class="n">BFIN_MEMMAP_RAM</span><span class="p">);</span>
	<span class="cm">/* sanity check for overlap */</span>
	<span class="n">sanitize_memmap</span><span class="p">(</span><span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bfin_memmap</span><span class="p">.</span><span class="n">nr_map</span><span class="p">);</span>
	<span class="n">print_memory_map</span><span class="p">(</span><span class="s">&quot;boot memmap&quot;</span><span class="p">);</span>

	<span class="cm">/* initialize globals in linux/bootmem.h */</span>
	<span class="n">find_min_max_pfn</span><span class="p">();</span>
	<span class="cm">/* pfn of the last usable page frame */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_pfn</span> <span class="o">&gt;</span> <span class="n">memory_end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
		<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">memory_end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="cm">/* pfn of last page frame directly mapped by kernel */</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">max_pfn</span><span class="p">;</span>
	<span class="cm">/* pfn of the first usable page frame after kernel image*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">min_low_pfn</span> <span class="o">&lt;</span> <span class="n">memory_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
		<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="n">memory_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">CONFIG_PHY_RAM_BASE_ADDRESS</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">memory_end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * give all the memory to the bootmap allocator, tell it to put the</span>
<span class="cm">	 * boot mem_map at the start of memory.</span>
<span class="cm">	 */</span>
	<span class="n">bootmap_size</span> <span class="o">=</span> <span class="n">init_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			<span class="n">memory_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>	<span class="cm">/* map goes here */</span>
			<span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>

	<span class="cm">/* register the memmap regions with the bootmem allocator */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bfin_memmap</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reserve usable memory</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BFIN_MEMMAP_RAM</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are rounding up the start address of usable memory:</span>
<span class="cm">		 */</span>
		<span class="n">curr_pfn</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_pfn</span> <span class="o">&gt;=</span> <span class="n">end_pfn</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * ... and at the end of the usable range downwards:</span>
<span class="cm">		 */</span>
		<span class="n">last_pfn</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span>
					 <span class="n">bfin_memmap</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">last_pfn</span> <span class="o">&gt;</span> <span class="n">end_pfn</span><span class="p">)</span>
			<span class="n">last_pfn</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * .. finally, did all the rounding and playing</span>
<span class="cm">		 * around just make the area go away?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_pfn</span> <span class="o">&lt;=</span> <span class="n">curr_pfn</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">last_pfn</span> <span class="o">-</span> <span class="n">curr_pfn</span><span class="p">;</span>
		<span class="n">free_bootmem</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">curr_pfn</span><span class="p">),</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* reserve memory before memory_start, including bootmap */</span>
	<span class="n">reserve_bootmem</span><span class="p">(</span><span class="n">CONFIG_PHY_RAM_BASE_ADDRESS</span><span class="p">,</span>
		<span class="n">memory_start</span> <span class="o">+</span> <span class="n">bootmap_size</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">CONFIG_PHY_RAM_BASE_ADDRESS</span><span class="p">,</span>
		<span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define EBSZ_TO_MEG(ebsz) \</span>
<span class="cp">({ \</span>
<span class="cp">	int meg = 0; \</span>
<span class="cp">	switch (ebsz &amp; 0xf) { \</span>
<span class="cp">		case 0x1: meg =  16; break; \</span>
<span class="cp">		case 0x3: meg =  32; break; \</span>
<span class="cp">		case 0x5: meg =  64; break; \</span>
<span class="cp">		case 0x7: meg = 128; break; \</span>
<span class="cp">		case 0x9: meg = 256; break; \</span>
<span class="cp">		case 0xb: meg = 512; break; \</span>
<span class="cp">	} \</span>
<span class="cp">	meg; \</span>
<span class="cp">})</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">get_mem_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(EBIU_SDBCTL)</span>
<span class="cp"># if defined(BF561_FAMILY)</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sdbctl</span> <span class="o">=</span> <span class="n">bfin_read_EBIU_SDBCTL</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">EBSZ_TO_MEG</span><span class="p">(</span><span class="n">sdbctl</span> <span class="o">&gt;&gt;</span>  <span class="mi">0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">EBSZ_TO_MEG</span><span class="p">(</span><span class="n">sdbctl</span> <span class="o">&gt;&gt;</span>  <span class="mi">8</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">EBSZ_TO_MEG</span><span class="p">(</span><span class="n">sdbctl</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">EBSZ_TO_MEG</span><span class="p">(</span><span class="n">sdbctl</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="cp"># else</span>
	<span class="k">return</span> <span class="n">EBSZ_TO_MEG</span><span class="p">(</span><span class="n">bfin_read_EBIU_SDBCTL</span><span class="p">());</span>
<span class="cp"># endif</span>
<span class="cp">#elif defined(EBIU_DDRCTL1)</span>
	<span class="n">u32</span> <span class="n">ddrctl</span> <span class="o">=</span> <span class="n">bfin_read_EBIU_DDRCTL1</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ddrctl</span> <span class="o">&amp;</span> <span class="mh">0xc0000</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DEVSZ_64</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVSZ_128</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVSZ_256</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVSZ_512</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">512</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ddrctl</span> <span class="o">&amp;</span> <span class="mh">0x30000</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DEVWD_4</span>:
		<span class="n">ret</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVWD_8</span>:
		<span class="n">ret</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVWD_16</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ddrctl</span> <span class="o">&amp;</span> <span class="mh">0xc000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x4000</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="cp">#elif defined(CONFIG_BF60x)</span>
	<span class="n">u32</span> <span class="n">ddrctl</span> <span class="o">=</span> <span class="n">bfin_read_DMC0_CFG</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ddrctl</span> <span class="o">&amp;</span> <span class="mh">0xf00</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DEVSZ_64</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVSZ_128</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVSZ_256</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVSZ_512</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">512</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVSZ_1G</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DEVSZ_2G</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">2048</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="n">native_machine_early_platform_add_devices</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BF60x</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u_long</span> <span class="n">bfin_get_clk</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="n">u_long</span> <span class="n">clk_rate</span><span class="p">;</span>

	<span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">clk</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">clk_rate</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">clk_rate</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">setup_arch</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">cmdline_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mmr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sclk</span><span class="p">,</span> <span class="n">cclk</span><span class="p">;</span>

	<span class="n">native_machine_early_platform_add_devices</span><span class="p">();</span>

	<span class="n">enable_shadow_console</span><span class="p">();</span>

	<span class="cm">/* Check to make sure we are running on the right processor */</span>
	<span class="n">mmr</span> <span class="o">=</span>  <span class="n">bfin_cpuid</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">CPUID</span> <span class="o">!=</span> <span class="n">bfin_cpuid</span><span class="p">()))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: Not running on ADSP-%s: unknown CPUID 0x%04x Rev 0.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">CPU</span><span class="p">,</span> <span class="n">bfin_cpuid</span><span class="p">(),</span> <span class="n">bfin_revid</span><span class="p">());</span>

<span class="cp">#ifdef CONFIG_DUMMY_CONSOLE</span>
	<span class="n">conswitchp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy_con</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_CMDLINE_BOOL)</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command_line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">CONFIG_CMDLINE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">command_line</span><span class="p">));</span>
	<span class="n">command_line</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">command_line</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Keep a copy of command line */</span>
	<span class="o">*</span><span class="n">cmdline_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">command_line</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">,</span> <span class="n">command_line</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
	<span class="n">boot_command_line</span><span class="p">[</span><span class="n">COMMAND_LINE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bfin_memmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bfin_memmap</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_BF60x</span>
	<span class="cm">/* Should init clock device before parse command early */</span>
	<span class="n">clk_init</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="cm">/* If the user does not specify things on the command line, use</span>
<span class="cm">	 * what the bootloader set things up as</span>
<span class="cm">	 */</span>
	<span class="n">physical_mem_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">parse_cmdline_early</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_ramend</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">_ramend</span> <span class="o">=</span> <span class="n">get_mem_size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">physical_mem_end</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">physical_mem_end</span> <span class="o">=</span> <span class="n">_ramend</span><span class="p">;</span>

	<span class="n">memory_setup</span><span class="p">();</span>

<span class="cp">#ifndef CONFIG_BF60x</span>
	<span class="cm">/* Initialize Async memory banks */</span>
	<span class="n">bfin_write_EBIU_AMBCTL0</span><span class="p">(</span><span class="n">AMBCTL0VAL</span><span class="p">);</span>
	<span class="n">bfin_write_EBIU_AMBCTL1</span><span class="p">(</span><span class="n">AMBCTL1VAL</span><span class="p">);</span>
	<span class="n">bfin_write_EBIU_AMGCTL</span><span class="p">(</span><span class="n">AMGCTLVAL</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_EBIU_MBSCTLVAL</span>
	<span class="n">bfin_write_EBIU_MBSCTL</span><span class="p">(</span><span class="n">CONFIG_EBIU_MBSCTLVAL</span><span class="p">);</span>
	<span class="n">bfin_write_EBIU_MODE</span><span class="p">(</span><span class="n">CONFIG_EBIU_MODEVAL</span><span class="p">);</span>
	<span class="n">bfin_write_EBIU_FCTL</span><span class="p">(</span><span class="n">CONFIG_EBIU_FCTLVAL</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BFIN_HYSTERESIS_CONTROL</span>
	<span class="n">bfin_write_PORTF_HYSTERESIS</span><span class="p">(</span><span class="n">HYST_PORTF_0_15</span><span class="p">);</span>
	<span class="n">bfin_write_PORTG_HYSTERESIS</span><span class="p">(</span><span class="n">HYST_PORTG_0_15</span><span class="p">);</span>
	<span class="n">bfin_write_PORTH_HYSTERESIS</span><span class="p">(</span><span class="n">HYST_PORTH_0_15</span><span class="p">);</span>
	<span class="n">bfin_write_MISCPORT_HYSTERESIS</span><span class="p">((</span><span class="n">bfin_read_MISCPORT_HYSTERESIS</span><span class="p">()</span> <span class="o">&amp;</span>
					<span class="o">~</span><span class="n">HYST_NONEGPIO_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">HYST_NONEGPIO</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">cclk</span> <span class="o">=</span> <span class="n">get_cclk</span><span class="p">();</span>
	<span class="n">sclk</span> <span class="o">=</span> <span class="n">get_sclk</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ANOMALY_05000273</span> <span class="o">||</span> <span class="n">ANOMALY_05000274</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cclk</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sclk</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ANOMALY 05000273 or 05000274: CCLK must be &gt;= 2*SCLK&quot;</span><span class="p">);</span>

<span class="cp">#ifdef BF561_FAMILY</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ANOMALY_05000266</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bfin_read_IMDMA_D0_IRQ_STATUS</span><span class="p">();</span>
		<span class="n">bfin_read_IMDMA_D1_IRQ_STATUS</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">mmr</span> <span class="o">=</span> <span class="n">bfin_read_TBUFCTL</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Hardware Trace %s and %sabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">mmr</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;active&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">mmr</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;en&quot;</span> <span class="o">:</span> <span class="s">&quot;dis&quot;</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_BF60x</span>
	<span class="n">mmr</span> <span class="o">=</span> <span class="n">bfin_read_SYSCR</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Boot Mode: %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mmr</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">);</span>

	<span class="cm">/* Newer parts mirror SWRST bits in SYSCR */</span>
<span class="cp">#if defined(CONFIG_BF53x) || defined(CONFIG_BF561) || \</span>
<span class="cp">    defined(CONFIG_BF538) || defined(CONFIG_BF539)</span>
	<span class="n">_bfin_swrst</span> <span class="o">=</span> <span class="n">bfin_read_SWRST</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="cm">/* Clear boot mode field */</span>
	<span class="n">_bfin_swrst</span> <span class="o">=</span> <span class="n">mmr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_DOUBLEFAULT_PRINT</span>
	<span class="n">bfin_write_SWRST</span><span class="p">(</span><span class="n">_bfin_swrst</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DOUBLE_FAULT</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_DEBUG_DOUBLEFAULT_RESET</span>
	<span class="n">bfin_write_SWRST</span><span class="p">(</span><span class="n">_bfin_swrst</span> <span class="o">|</span> <span class="n">DOUBLE_FAULT</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_bfin_swrst</span> <span class="o">&amp;</span> <span class="n">SWRST_DBL_FAULT_A</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_bfin_swrst</span> <span class="o">&amp;</span> <span class="n">RESET_DOUBLE</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#endif</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;Recovering from DOUBLE FAULT event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_DOUBLEFAULT</span>
		<span class="cm">/* We assume the crashing kernel, and the current symbol table match */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot; While handling exception (EXCAUSE = %#x) at %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">initial_pda</span><span class="p">.</span><span class="n">seqstat_doublefault</span> <span class="o">&amp;</span> <span class="n">SEQSTAT_EXCAUSE</span><span class="p">,</span>
			<span class="n">initial_pda</span><span class="p">.</span><span class="n">retx_doublefault</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;   DCPLB_FAULT_ADDR: %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">initial_pda</span><span class="p">.</span><span class="n">dcplb_doublefault_addr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;   ICPLB_FAULT_ADDR: %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">initial_pda</span><span class="p">.</span><span class="n">icplb_doublefault_addr</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot; The instruction at %pF caused a double exception</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">initial_pda</span><span class="p">.</span><span class="n">retx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">_bfin_swrst</span> <span class="o">&amp;</span> <span class="n">RESET_WDOG</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Recovering from Watchdog event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">_bfin_swrst</span> <span class="o">&amp;</span> <span class="n">RESET_SOFTWARE</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Reset caused by Software reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Blackfin support (C) 2004-2010 Analog Devices, Inc.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bfin_compiled_revid</span><span class="p">()</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Compiled for ADSP-%s Rev any, running on 0.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">bfin_revid</span><span class="p">());</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bfin_compiled_revid</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Compiled for ADSP-%s Rev none</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">CPU</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Compiled for ADSP-%s Rev 0.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">bfin_compiled_revid</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">CPUID</span> <span class="o">==</span> <span class="n">bfin_cpuid</span><span class="p">()))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bfin_revid</span><span class="p">()</span> <span class="o">!=</span> <span class="n">bfin_compiled_revid</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bfin_compiled_revid</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Warning: Compiled for Rev none, but running on Rev %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">bfin_revid</span><span class="p">());</span>
			<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">bfin_compiled_revid</span><span class="p">()</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Warning: Compiled for Rev %d, but running on Rev %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">bfin_compiled_revid</span><span class="p">(),</span> <span class="n">bfin_revid</span><span class="p">());</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bfin_compiled_revid</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">bfin_revid</span><span class="p">())</span>
					<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Error: you are missing anomaly workarounds for this rev&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bfin_revid</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">CONFIG_BF_REV_MIN</span> <span class="o">||</span> <span class="n">bfin_revid</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">CONFIG_BF_REV_MAX</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Warning: Unsupported Chip Revision ADSP-%s Rev 0.%d detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">CPU</span><span class="p">,</span> <span class="n">bfin_revid</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Blackfin Linux support by http://blackfin.uclinux.org/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BF60x</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Processor Speed: %lu MHz core clock, %lu MHz SCLk, %lu MHz SCLK0, %lu MHz SCLK1 and %lu MHz DCLK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cclk</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">bfin_get_clk</span><span class="p">(</span><span class="s">&quot;SYSCLK&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">get_sclk0</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">get_sclk1</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">get_dclk</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Processor Speed: %lu MHz core clock and %lu MHz System Clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">cclk</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">sclk</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">setup_bootmem_allocator</span><span class="p">();</span>

	<span class="n">paging_init</span><span class="p">();</span>

	<span class="cm">/* Copy atomic sequences to their fixed location, and sanity check that</span>
<span class="cm">	   these locations are the ones that we advertise to userspace.  */</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FIXED_CODE_START</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fixed_code_start</span><span class="p">,</span>
	       <span class="n">FIXED_CODE_END</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sigreturn_stub</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fixed_code_start</span>
	       <span class="o">!=</span> <span class="n">SIGRETURN_STUB</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">atomic_xchg32</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fixed_code_start</span>
	       <span class="o">!=</span> <span class="n">ATOMIC_XCHG32</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">atomic_cas32</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fixed_code_start</span>
	       <span class="o">!=</span> <span class="n">ATOMIC_CAS32</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">atomic_add32</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fixed_code_start</span>
	       <span class="o">!=</span> <span class="n">ATOMIC_ADD32</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">atomic_sub32</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fixed_code_start</span>
	       <span class="o">!=</span> <span class="n">ATOMIC_SUB32</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">atomic_ior32</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fixed_code_start</span>
	       <span class="o">!=</span> <span class="n">ATOMIC_IOR32</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">atomic_and32</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fixed_code_start</span>
	       <span class="o">!=</span> <span class="n">ATOMIC_AND32</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">atomic_xor32</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fixed_code_start</span>
	       <span class="o">!=</span> <span class="n">ATOMIC_XOR32</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">safe_user_instruction</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fixed_code_start</span>
		<span class="o">!=</span> <span class="n">SAFE_USER_INSTRUCTION</span> <span class="o">-</span> <span class="n">FIXED_CODE_START</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">platform_init_cpus</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">init_exception_vectors</span><span class="p">();</span>
	<span class="n">bfin_cache_init</span><span class="p">();</span>	<span class="cm">/* Initialize caches for the boot CPU */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">topology_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">register_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">topology_init</span><span class="p">);</span>

<span class="cm">/* Get the input clock frequency */</span>
<span class="k">static</span> <span class="n">u_long</span> <span class="n">cached_clkin_hz</span> <span class="o">=</span> <span class="n">CONFIG_CLKIN_HZ</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_BF60x</span>
<span class="k">static</span> <span class="n">u_long</span> <span class="nf">get_clkin_hz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cached_clkin_hz</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_init_clkin_hz</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cached_clkin_hz</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef BFIN_KERNEL_CLOCK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cached_clkin_hz</span> <span class="o">!=</span> <span class="n">CONFIG_CLKIN_HZ</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;cannot change clkin_hz when reprogramming clocks&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;clkin_hz=&quot;</span><span class="p">,</span> <span class="n">early_init_clkin_hz</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_BF60x</span>
<span class="cm">/* Get the voltage input multiplier */</span>
<span class="k">static</span> <span class="n">u_long</span> <span class="nf">get_vco</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">u_long</span> <span class="n">cached_vco</span><span class="p">;</span>
	<span class="n">u_long</span> <span class="n">msel</span><span class="p">,</span> <span class="n">pll_ctl</span><span class="p">;</span>

	<span class="cm">/* The assumption here is that VCO never changes at runtime.</span>
<span class="cm">	 * If, someday, we support that, then we&#39;ll have to change this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cached_vco</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cached_vco</span><span class="p">;</span>

	<span class="n">pll_ctl</span> <span class="o">=</span> <span class="n">bfin_read_PLL_CTL</span><span class="p">();</span>
	<span class="n">msel</span> <span class="o">=</span> <span class="p">(</span><span class="n">pll_ctl</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">msel</span><span class="p">)</span>
		<span class="n">msel</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="n">cached_vco</span> <span class="o">=</span> <span class="n">get_clkin_hz</span><span class="p">();</span>
	<span class="n">cached_vco</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">pll_ctl</span><span class="p">);</span>	<span class="cm">/* DF bit */</span>
	<span class="n">cached_vco</span> <span class="o">*=</span> <span class="n">msel</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cached_vco</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Get the Core clock */</span>
<span class="n">u_long</span> <span class="nf">get_cclk</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BF60x</span>
	<span class="k">return</span> <span class="n">bfin_get_clk</span><span class="p">(</span><span class="s">&quot;CCLK&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">static</span> <span class="n">u_long</span> <span class="n">cached_cclk_pll_div</span><span class="p">,</span> <span class="n">cached_cclk</span><span class="p">;</span>
	<span class="n">u_long</span> <span class="n">csel</span><span class="p">,</span> <span class="n">ssel</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bfin_read_PLL_STAT</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">get_clkin_hz</span><span class="p">();</span>

	<span class="n">ssel</span> <span class="o">=</span> <span class="n">bfin_read_PLL_DIV</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ssel</span> <span class="o">==</span> <span class="n">cached_cclk_pll_div</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cached_cclk</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cached_cclk_pll_div</span> <span class="o">=</span> <span class="n">ssel</span><span class="p">;</span>

	<span class="n">csel</span> <span class="o">=</span> <span class="p">((</span><span class="n">ssel</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">);</span>
	<span class="n">ssel</span> <span class="o">&amp;=</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ssel</span> <span class="o">&amp;&amp;</span> <span class="n">ssel</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">csel</span><span class="p">))</span>	<span class="cm">/* SCLK &gt; CCLK */</span>
		<span class="n">cached_cclk</span> <span class="o">=</span> <span class="n">get_vco</span><span class="p">()</span> <span class="o">/</span> <span class="n">ssel</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cached_cclk</span> <span class="o">=</span> <span class="n">get_vco</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">csel</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cached_cclk</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_cclk</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BF60x</span>
<span class="cm">/* Get the bf60x clock of SCLK0 domain */</span>
<span class="n">u_long</span> <span class="nf">get_sclk0</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bfin_get_clk</span><span class="p">(</span><span class="s">&quot;SCLK0&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_sclk0</span><span class="p">);</span>

<span class="cm">/* Get the bf60x clock of SCLK1 domain */</span>
<span class="n">u_long</span> <span class="nf">get_sclk1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bfin_get_clk</span><span class="p">(</span><span class="s">&quot;SCLK1&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_sclk1</span><span class="p">);</span>

<span class="cm">/* Get the bf60x DRAM clock */</span>
<span class="n">u_long</span> <span class="nf">get_dclk</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bfin_get_clk</span><span class="p">(</span><span class="s">&quot;DCLK&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_dclk</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Get the default system clock */</span>
<span class="n">u_long</span> <span class="nf">get_sclk</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BF60x</span>
	<span class="k">return</span> <span class="n">get_sclk0</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="k">static</span> <span class="n">u_long</span> <span class="n">cached_sclk</span><span class="p">;</span>
	<span class="n">u_long</span> <span class="n">ssel</span><span class="p">;</span>

	<span class="cm">/* The assumption here is that SCLK never changes at runtime.</span>
<span class="cm">	 * If, someday, we support that, then we&#39;ll have to change this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cached_sclk</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cached_sclk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bfin_read_PLL_STAT</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">get_clkin_hz</span><span class="p">();</span>

	<span class="n">ssel</span> <span class="o">=</span> <span class="n">bfin_read_PLL_DIV</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ssel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Invalid System Clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ssel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cached_sclk</span> <span class="o">=</span> <span class="n">get_vco</span><span class="p">()</span> <span class="o">/</span> <span class="n">ssel</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cached_sclk</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_sclk</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sclk_to_usecs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sclk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">USEC_PER_SEC</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">sclk</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">get_sclk</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sclk_to_usecs</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">usecs_to_sclk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">get_sclk</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">usecs</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">USEC_PER_SEC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">usecs_to_sclk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Get CPU information for use by the procfs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_cpuinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cpu</span><span class="p">,</span> <span class="o">*</span><span class="n">mmu</span><span class="p">,</span> <span class="o">*</span><span class="n">fpu</span><span class="p">,</span> <span class="o">*</span><span class="n">vendor</span><span class="p">,</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">revid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu_num</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">v</span><span class="p">;</span>
	<span class="n">u_long</span> <span class="n">sclk</span><span class="p">,</span> <span class="n">cclk</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">icache_size</span> <span class="o">=</span> <span class="n">BFIN_ICACHESIZE</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">dcache_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dsup_banks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blackfin_cpudata</span> <span class="o">*</span><span class="n">cpudata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">,</span> <span class="n">cpu_num</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">CPU</span><span class="p">;</span>
	<span class="n">mmu</span> <span class="o">=</span> <span class="s">&quot;none&quot;</span><span class="p">;</span>
	<span class="n">fpu</span> <span class="o">=</span> <span class="s">&quot;none&quot;</span><span class="p">;</span>
	<span class="n">revid</span> <span class="o">=</span> <span class="n">bfin_revid</span><span class="p">();</span>

	<span class="n">sclk</span> <span class="o">=</span> <span class="n">get_sclk</span><span class="p">();</span>
	<span class="n">cclk</span> <span class="o">=</span> <span class="n">get_cclk</span><span class="p">();</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bfin_read_CHIPID</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">CHIPID_MANUFACTURE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0xca</span>:
		<span class="n">vendor</span> <span class="o">=</span> <span class="s">&quot;Analog Devices&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">vendor</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;processor</span><span class="se">\t</span><span class="s">: %d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="s">&quot;vendor_id</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_num</span><span class="p">,</span> <span class="n">vendor</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CPUID</span> <span class="o">==</span> <span class="n">bfin_cpuid</span><span class="p">())</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;cpu family</span><span class="se">\t</span><span class="s">: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">CPUID</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;cpu family</span><span class="se">\t</span><span class="s">: Compiled for:0x%04x, running on:0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">CPUID</span><span class="p">,</span> <span class="n">bfin_cpuid</span><span class="p">());</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;model name</span><span class="se">\t</span><span class="s">: ADSP-%s %lu(MHz CCLK) %lu(MHz SCLK) (%s)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;stepping</span><span class="se">\t</span><span class="s">: %d &quot;</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">cclk</span><span class="o">/</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">sclk</span><span class="o">/</span><span class="mi">1000000</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_MPU</span>
		<span class="s">&quot;mpu on&quot;</span><span class="p">,</span>
<span class="cp">#else</span>
		<span class="s">&quot;mpu off&quot;</span><span class="p">,</span>
<span class="cp">#endif</span>
		<span class="n">revid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bfin_revid</span><span class="p">()</span> <span class="o">!=</span> <span class="n">bfin_compiled_revid</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bfin_compiled_revid</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;(Compiled for Rev none)&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bfin_compiled_revid</span><span class="p">()</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;(Compiled for Rev any)&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;(Compiled for Rev %d)&quot;</span><span class="p">,</span> <span class="n">bfin_compiled_revid</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">cpu MHz</span><span class="se">\t\t</span><span class="s">: %lu.%03lu/%lu.%03lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cclk</span><span class="o">/</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">cclk</span><span class="o">%</span><span class="mi">1000000</span><span class="p">,</span>
		<span class="n">sclk</span><span class="o">/</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">sclk</span><span class="o">%</span><span class="mi">1000000</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;bogomips</span><span class="se">\t</span><span class="s">: %lu.%02lu</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Calibration</span><span class="se">\t</span><span class="s">: %lu loops</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">loops_per_jiffy</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">/</span> <span class="mi">500000</span><span class="p">,</span>
		<span class="p">((</span><span class="n">loops_per_jiffy</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">%</span> <span class="mi">100</span><span class="p">,</span>
		<span class="p">(</span><span class="n">loops_per_jiffy</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">));</span>

	<span class="cm">/* Check Cache configutation */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cpudata</span><span class="o">-&gt;</span><span class="n">dmemctl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">DMC0_P</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">DMC1_P</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ACACHE_BSRAM</span>:
		<span class="n">cache</span> <span class="o">=</span> <span class="s">&quot;dbank-A/B</span><span class="se">\t</span><span class="s">: cache/sram&quot;</span><span class="p">;</span>
		<span class="n">dcache_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dsup_banks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ACACHE_BCACHE</span>:
		<span class="n">cache</span> <span class="o">=</span> <span class="s">&quot;dbank-A/B</span><span class="se">\t</span><span class="s">: cache/cache&quot;</span><span class="p">;</span>
		<span class="n">dcache_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">dsup_banks</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASRAM_BSRAM</span>:
		<span class="n">cache</span> <span class="o">=</span> <span class="s">&quot;dbank-A/B</span><span class="se">\t</span><span class="s">: sram/sram&quot;</span><span class="p">;</span>
		<span class="n">dcache_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dsup_banks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
		<span class="n">dcache_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dsup_banks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is it turned on? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cpudata</span><span class="o">-&gt;</span><span class="n">dmemctl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ENDCPLB</span> <span class="o">|</span> <span class="n">DMC_ENABLE</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ENDCPLB</span> <span class="o">|</span> <span class="n">DMC_ENABLE</span><span class="p">))</span>
		<span class="n">dcache_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cpudata</span><span class="o">-&gt;</span><span class="n">imemctl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IMC</span> <span class="o">|</span> <span class="n">ENICPLB</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="n">IMC</span> <span class="o">|</span> <span class="n">ENICPLB</span><span class="p">))</span>
		<span class="n">icache_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;cache size</span><span class="se">\t</span><span class="s">: %d KB(L1 icache) &quot;</span>
		<span class="s">&quot;%d KB(L1 dcache) %d KB(L2 cache)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">icache_size</span><span class="p">,</span> <span class="n">dcache_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;external memory</span><span class="se">\t</span><span class="s">: &quot;</span>
<span class="cp">#if defined(CONFIG_BFIN_EXTMEM_ICACHEABLE)</span>
		   <span class="s">&quot;cacheable&quot;</span>
<span class="cp">#else</span>
		   <span class="s">&quot;uncacheable&quot;</span>
<span class="cp">#endif</span>
		   <span class="s">&quot; in instruction cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;external memory</span><span class="se">\t</span><span class="s">: &quot;</span>
<span class="cp">#if defined(CONFIG_BFIN_EXTMEM_WRITEBACK)</span>
		      <span class="s">&quot;cacheable (write-back)&quot;</span>
<span class="cp">#elif defined(CONFIG_BFIN_EXTMEM_WRITETHROUGH)</span>
		      <span class="s">&quot;cacheable (write-through)&quot;</span>
<span class="cp">#else</span>
		      <span class="s">&quot;uncacheable&quot;</span>
<span class="cp">#endif</span>
		      <span class="s">&quot; in data cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icache_size</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;icache setup</span><span class="se">\t</span><span class="s">: %d Sub-banks/%d Ways, %d Lines/Way</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">BFIN_ISUBBANKS</span><span class="p">,</span> <span class="n">BFIN_IWAYS</span><span class="p">,</span> <span class="n">BFIN_ILINES</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;icache setup</span><span class="se">\t</span><span class="s">: off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
		   <span class="s">&quot;dcache setup</span><span class="se">\t</span><span class="s">: %d Super-banks/%d Sub-banks/%d Ways, %d Lines/Way</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">dsup_banks</span><span class="p">,</span> <span class="n">BFIN_DSUBBANKS</span><span class="p">,</span> <span class="n">BFIN_DWAYS</span><span class="p">,</span>
		   <span class="n">BFIN_DLINES</span><span class="p">);</span>
<span class="cp">#ifdef __ARCH_SYNC_CORE_DCACHE</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;dcache flushes</span><span class="se">\t</span><span class="s">: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dcache_invld_count</span><span class="p">[</span><span class="n">cpu_num</span><span class="p">]);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef __ARCH_SYNC_CORE_ICACHE</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;icache flushes</span><span class="se">\t</span><span class="s">: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">icache_invld_count</span><span class="p">[</span><span class="n">cpu_num</span><span class="p">]);</span>
<span class="cp">#endif</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_num</span> <span class="o">!=</span> <span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">L2_LENGTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;L2 SRAM</span><span class="se">\t\t</span><span class="s">: %dKB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">L2_LENGTH</span><span class="o">/</span><span class="mh">0x400</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;L2 SRAM</span><span class="se">\t\t</span><span class="s">: &quot;</span>
<span class="cp">#if defined(CONFIG_BFIN_L2_ICACHEABLE)</span>
			      <span class="s">&quot;cacheable&quot;</span>
<span class="cp">#else</span>
			      <span class="s">&quot;uncacheable&quot;</span>
<span class="cp">#endif</span>
			      <span class="s">&quot; in instruction cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;L2 SRAM</span><span class="se">\t\t</span><span class="s">: &quot;</span>
<span class="cp">#if defined(CONFIG_BFIN_L2_WRITEBACK)</span>
			      <span class="s">&quot;cacheable (write-back)&quot;</span>
<span class="cp">#elif defined(CONFIG_BFIN_L2_WRITETHROUGH)</span>
			      <span class="s">&quot;cacheable (write-through)&quot;</span>
<span class="cp">#else</span>
			      <span class="s">&quot;uncacheable&quot;</span>
<span class="cp">#endif</span>
			      <span class="s">&quot; in data cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;board name</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bfin_board_name</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;board memory</span><span class="se">\t</span><span class="s">: %ld kB (0x%08lx -&gt; 0x%08lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">physical_mem_end</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">,</span> <span class="n">physical_mem_end</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;kernel memory</span><span class="se">\t</span><span class="s">: %d kB (0x%08lx -&gt; 0x%08lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">memory_end</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">_rambase</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">_rambase</span><span class="p">,</span> <span class="n">memory_end</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">c_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">num_online_cpus</span><span class="p">())</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">c_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">cpumask_next</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">c_start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">c_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">cpuinfo_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">c_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">c_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">c_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">show_cpuinfo</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">cmdline_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">r0</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">early_shadow_stamp</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r0</span><span class="p">)</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">command_line</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
