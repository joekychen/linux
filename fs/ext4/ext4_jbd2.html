<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext4 › ext4_jbd2.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ext4_jbd2.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * ext4_jbd2.h</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1999</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1998--1999 Red Hat corp --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Ext4-specific journaling extensions.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _EXT4_JBD2_H</span>
<span class="cp">#define _EXT4_JBD2_H</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/jbd2.h&gt;</span>
<span class="cp">#include &quot;ext4.h&quot;</span>

<span class="cp">#define EXT4_JOURNAL(inode)	(EXT4_SB((inode)-&gt;i_sb)-&gt;s_journal)</span>

<span class="cm">/* Define the number of blocks we need to account to a transaction to</span>
<span class="cm"> * modify one block of data.</span>
<span class="cm"> *</span>
<span class="cm"> * We may have to touch one inode, one bitmap buffer, up to three</span>
<span class="cm"> * indirection blocks, the group and superblock summaries, and the data</span>
<span class="cm"> * block to complete the transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * For extents-enabled fs we may have to allocate and modify up to</span>
<span class="cm"> * 5 levels of tree + root which are stored in the inode. */</span>

<span class="cp">#define EXT4_SINGLEDATA_TRANS_BLOCKS(sb)				\</span>
<span class="cp">	(EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)   \</span>
<span class="cp">	 ? 27U : 8U)</span>

<span class="cm">/* Extended attribute operations touch at most two data buffers,</span>
<span class="cm"> * two bitmap buffers, and two group summaries, in addition to the inode</span>
<span class="cm"> * and the superblock, which are already accounted for. */</span>

<span class="cp">#define EXT4_XATTR_TRANS_BLOCKS		6U</span>

<span class="cm">/* Define the minimum size for a transaction which modifies data.  This</span>
<span class="cm"> * needs to take into account the fact that we may end up modifying two</span>
<span class="cm"> * quota files too (one for the group, one for the user quota).  The</span>
<span class="cm"> * superblock only gets updated once, of course, so don&#39;t bother</span>
<span class="cm"> * counting that again for the quota updates. */</span>

<span class="cp">#define EXT4_DATA_TRANS_BLOCKS(sb)	(EXT4_SINGLEDATA_TRANS_BLOCKS(sb) + \</span>
<span class="cp">					 EXT4_XATTR_TRANS_BLOCKS - 2 + \</span>
<span class="cp">					 EXT4_MAXQUOTAS_TRANS_BLOCKS(sb))</span>

<span class="cm">/*</span>
<span class="cm"> * Define the number of metadata blocks we need to account to modify data.</span>
<span class="cm"> *</span>
<span class="cm"> * This include super block, inode block, quota blocks and xattr blocks</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_META_TRANS_BLOCKS(sb)	(EXT4_XATTR_TRANS_BLOCKS + \</span>
<span class="cp">					EXT4_MAXQUOTAS_TRANS_BLOCKS(sb))</span>

<span class="cm">/* Delete operations potentially hit one directory&#39;s namespace plus an</span>
<span class="cm"> * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be</span>
<span class="cm"> * generous.  We can grow the delete transaction later if necessary. */</span>

<span class="cp">#define EXT4_DELETE_TRANS_BLOCKS(sb)	(2 * EXT4_DATA_TRANS_BLOCKS(sb) + 64)</span>

<span class="cm">/* Define an arbitrary limit for the amount of data we will anticipate</span>
<span class="cm"> * writing to any given transaction.  For unbounded transactions such as</span>
<span class="cm"> * write(2) and truncate(2) we can write more than this, but we always</span>
<span class="cm"> * start off at the maximum transaction size and grow the transaction</span>
<span class="cm"> * optimistically as we go. */</span>

<span class="cp">#define EXT4_MAX_TRANS_DATA		64U</span>

<span class="cm">/* We break up a large truncate or write transaction once the handle&#39;s</span>
<span class="cm"> * buffer credits gets this low, we need either to extend the</span>
<span class="cm"> * transaction or to start a new one.  Reserve enough space here for</span>
<span class="cm"> * inode, bitmap, superblock, group and indirection updates for at least</span>
<span class="cm"> * one block, plus two quota updates.  Quota allocations are not</span>
<span class="cm"> * needed. */</span>

<span class="cp">#define EXT4_RESERVE_TRANS_BLOCKS	12U</span>

<span class="cp">#define EXT4_INDEX_EXTRA_TRANS_BLOCKS	8</span>

<span class="cp">#ifdef CONFIG_QUOTA</span>
<span class="cm">/* Amount of blocks needed for quota update - we know that the structure was</span>
<span class="cm"> * allocated so we need to update only data block */</span>
<span class="cp">#define EXT4_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 1 : 0)</span>
<span class="cm">/* Amount of blocks needed for quota insert/delete - we do some block writes</span>
<span class="cm"> * but inode, sb and group updates are done only once */</span>
<span class="cp">#define EXT4_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\</span>
<span class="cp">		(EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)+3+DQUOT_INIT_REWRITE) : 0)</span>

<span class="cp">#define EXT4_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\</span>
<span class="cp">		(EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)+3+DQUOT_DEL_REWRITE) : 0)</span>
<span class="cp">#else</span>
<span class="cp">#define EXT4_QUOTA_TRANS_BLOCKS(sb) 0</span>
<span class="cp">#define EXT4_QUOTA_INIT_BLOCKS(sb) 0</span>
<span class="cp">#define EXT4_QUOTA_DEL_BLOCKS(sb) 0</span>
<span class="cp">#endif</span>
<span class="cp">#define EXT4_MAXQUOTAS_TRANS_BLOCKS(sb) (MAXQUOTAS*EXT4_QUOTA_TRANS_BLOCKS(sb))</span>
<span class="cp">#define EXT4_MAXQUOTAS_INIT_BLOCKS(sb) (MAXQUOTAS*EXT4_QUOTA_INIT_BLOCKS(sb))</span>
<span class="cp">#define EXT4_MAXQUOTAS_DEL_BLOCKS(sb) (MAXQUOTAS*EXT4_QUOTA_DEL_BLOCKS(sb))</span>

<span class="cm">/**</span>
<span class="cm"> *   struct ext4_journal_cb_entry - Base structure for callback information.</span>
<span class="cm"> *</span>
<span class="cm"> *   This struct is a &#39;seed&#39; structure for a using with your own callback</span>
<span class="cm"> *   structs. If you are using callbacks you must allocate one of these</span>
<span class="cm"> *   or another struct of your own definition which has this struct</span>
<span class="cm"> *   as it&#39;s first element and pass it to ext4_journal_callback_add().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_journal_cb_entry</span> <span class="p">{</span>
	<span class="cm">/* list information for other callbacks attached to the same handle */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">jce_list</span><span class="p">;</span>

	<span class="cm">/*  Function to call with this callback structure */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">jce_func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ext4_journal_cb_entry</span> <span class="o">*</span><span class="n">jce</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>

	<span class="cm">/* user data goes here */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ext4_journal_callback_add: add a function to call after transaction commit</span>
<span class="cm"> * @handle: active journal transaction handle to register callback on</span>
<span class="cm"> * @func: callback function to call after the transaction has committed:</span>
<span class="cm"> *        @sb: superblock of current filesystem for transaction</span>
<span class="cm"> *        @jce: returned journal callback data</span>
<span class="cm"> *        @rc: journal state at commit (0 = transaction committed properly)</span>
<span class="cm"> * @jce: journal callback data (internal and function private data struct)</span>
<span class="cm"> *</span>
<span class="cm"> * The registered function will be called in the context of the journal thread</span>
<span class="cm"> * after the transaction for which the handle was created has completed.</span>
<span class="cm"> *</span>
<span class="cm"> * No locks are held when the callback function is called, so it is safe to</span>
<span class="cm"> * call blocking functions from within the callback, but the callback should</span>
<span class="cm"> * not block or run for too long, or the filesystem will be blocked waiting for</span>
<span class="cm"> * the next transaction to commit. No journaling functions can be used, or</span>
<span class="cm"> * there is a risk of deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> * There is no guaranteed calling order of multiple registered callbacks on</span>
<span class="cm"> * the same transaction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_journal_callback_add</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ext4_journal_cb_entry</span> <span class="o">*</span><span class="n">jce</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">rc</span><span class="p">),</span>
			<span class="k">struct</span> <span class="n">ext4_journal_cb_entry</span> <span class="o">*</span><span class="n">jce</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span>
			<span class="n">EXT4_SB</span><span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="o">-&gt;</span><span class="n">j_private</span><span class="p">);</span>

	<span class="cm">/* Add the jce to transaction&#39;s private list */</span>
	<span class="n">jce</span><span class="o">-&gt;</span><span class="n">jce_func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_md_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jce</span><span class="o">-&gt;</span><span class="n">jce_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_private_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_md_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext4_journal_callback_del: delete a registered callback</span>
<span class="cm"> * @handle: active journal transaction handle on which callback was registered</span>
<span class="cm"> * @jce: registered journal callback entry to unregister</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_journal_callback_del</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">ext4_journal_cb_entry</span> <span class="o">*</span><span class="n">jce</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span>
			<span class="n">EXT4_SB</span><span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="o">-&gt;</span><span class="n">j_private</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_md_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jce</span><span class="o">-&gt;</span><span class="n">jce_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_md_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">ext4_mark_iloc_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * On success, We end up with an outstanding reference count against</span>
<span class="cm"> * iloc-&gt;bh.  This _must_ be cleaned up later.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">ext4_reserve_inode_write</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper functions with which ext4 calls into JBD.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ext4_journal_abort_handle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">caller</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">err_fn</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext4_journal_get_write_access</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
				    <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext4_forget</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">is_metadata</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">blocknr</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext4_journal_get_create_access</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
				<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext4_handle_dirty_metadata</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
				 <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext4_handle_dirty_super</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
			      <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">now</span><span class="p">);</span>

<span class="cp">#define ext4_journal_get_write_access(handle, bh) \</span>
<span class="cp">	__ext4_journal_get_write_access(__func__, __LINE__, (handle), (bh))</span>
<span class="cp">#define ext4_forget(handle, is_metadata, inode, bh, block_nr) \</span>
<span class="cp">	__ext4_forget(__func__, __LINE__, (handle), (is_metadata), (inode), \</span>
<span class="cp">		      (bh), (block_nr))</span>
<span class="cp">#define ext4_journal_get_create_access(handle, bh) \</span>
<span class="cp">	__ext4_journal_get_create_access(__func__, __LINE__, (handle), (bh))</span>
<span class="cp">#define ext4_handle_dirty_metadata(handle, inode, bh) \</span>
<span class="cp">	__ext4_handle_dirty_metadata(__func__, __LINE__, (handle), (inode), \</span>
<span class="cp">				     (bh))</span>
<span class="cp">#define ext4_handle_dirty_super_now(handle, sb) \</span>
<span class="cp">	__ext4_handle_dirty_super(__func__, __LINE__, (handle), (sb), 1)</span>
<span class="cp">#define ext4_handle_dirty_super(handle, sb) \</span>
<span class="cp">	__ext4_handle_dirty_super(__func__, __LINE__, (handle), (sb), 0)</span>

<span class="n">handle_t</span> <span class="o">*</span><span class="n">ext4_journal_start_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__ext4_journal_stop</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>

<span class="cp">#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)</span>

<span class="cm">/* Note:  Do not use this for NULL handles.  This is only to determine if</span>
<span class="cm"> * a properly allocated handle is using a journal or not. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_handle_valid</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">handle</span> <span class="o">&lt;</span> <span class="n">EXT4_NOJOURNAL_MAX_REF_COUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_handle_sync</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_handle_release_buffer</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="n">jbd2_journal_release_buffer</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_handle_is_aborted</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_handle_has_enough_credits</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span> <span class="o">&lt;</span> <span class="n">needed</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">ext4_journal_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ext4_journal_start_sb</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ext4_journal_stop(handle) \</span>
<span class="cp">	__ext4_journal_stop(__func__, __LINE__, (handle))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">ext4_journal_current_handle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">journal_current_handle</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_journal_extend</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">jbd2_journal_extend</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_journal_restart</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">jbd2_journal_restart</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_journal_blocks_per_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">jbd2_journal_blocks_per_page</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_journal_force_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">jbd2_journal_force_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_jbd2_file_inode</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">jbd2_journal_file_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">jinode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_update_inode_fsync_trans</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_sync_tid</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">datasync</span><span class="p">)</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* super.c */</span>
<span class="kt">int</span> <span class="n">ext4_force_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Ext4 inode journal modes</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_INODE_JOURNAL_DATA_MODE	0x01 </span><span class="cm">/* journal data mode */</span><span class="cp"></span>
<span class="cp">#define EXT4_INODE_ORDERED_DATA_MODE	0x02 </span><span class="cm">/* ordered data mode */</span><span class="cp"></span>
<span class="cp">#define EXT4_INODE_WRITEBACK_DATA_MODE	0x04 </span><span class="cm">/* writeback data mode */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_inode_journal_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EXT4_INODE_WRITEBACK_DATA_MODE</span><span class="p">;</span>	<span class="cm">/* writeback */</span>
	<span class="cm">/* We do not support data journalling with delayed allocation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DATA_FLAGS</span><span class="p">)</span> <span class="o">==</span> <span class="n">EXT4_MOUNT_JOURNAL_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EXT4_INODE_JOURNAL_DATA_MODE</span><span class="p">;</span>	<span class="cm">/* journal data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_JOURNAL_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DELALLOC</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">EXT4_INODE_JOURNAL_DATA_MODE</span><span class="p">;</span>	<span class="cm">/* journal data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DATA_FLAGS</span><span class="p">)</span> <span class="o">==</span> <span class="n">EXT4_MOUNT_ORDERED_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EXT4_INODE_ORDERED_DATA_MODE</span><span class="p">;</span>	<span class="cm">/* ordered */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DATA_FLAGS</span><span class="p">)</span> <span class="o">==</span> <span class="n">EXT4_MOUNT_WRITEBACK_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EXT4_INODE_WRITEBACK_DATA_MODE</span><span class="p">;</span>	<span class="cm">/* writeback */</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_should_journal_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ext4_inode_journal_mode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EXT4_INODE_JOURNAL_DATA_MODE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_should_order_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ext4_inode_journal_mode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EXT4_INODE_ORDERED_DATA_MODE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_should_writeback_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ext4_inode_journal_mode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EXT4_INODE_WRITEBACK_DATA_MODE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function controls whether or not we should try to go down the</span>
<span class="cm"> * dioread_nolock code paths, which makes it safe to avoid taking</span>
<span class="cm"> * i_mutex for direct I/O reads.  This only works for extent-based</span>
<span class="cm"> * files, and it doesn&#39;t work if data journaling is enabled, since the</span>
<span class="cm"> * dioread_nolock code uses b_private to pass information back to the</span>
<span class="cm"> * I/O completion handler, and this conflicts with the jbd&#39;s use of</span>
<span class="cm"> * b_private.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_should_dioread_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DIOREAD_NOLOCK</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* _EXT4_JBD2_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
