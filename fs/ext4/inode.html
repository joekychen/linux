<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext4 › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/ext4/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/minix/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  64-bit file support on 64-bit platforms by Jakub Jelinek</span>
<span class="cm"> *	(jj@sunsite.ms.mff.cuni.cz)</span>
<span class="cm"> *</span>
<span class="cm"> *  Assorted race fixes, rewrite of ext4_get_block() by Al Viro, 2000</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/jbd2.h&gt;</span>
<span class="cp">#include &lt;linux/highuid.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/printk.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#include &quot;ext4_jbd2.h&quot;</span>
<span class="cp">#include &quot;xattr.h&quot;</span>
<span class="cp">#include &quot;acl.h&quot;</span>
<span class="cp">#include &quot;truncate.h&quot;</span>

<span class="cp">#include &lt;trace/events/ext4.h&gt;</span>

<span class="cp">#define MPAGE_DA_EXTENT_TAIL 0x01</span>

<span class="k">static</span> <span class="n">__u32</span> <span class="nf">ext4_inode_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">__u16</span> <span class="n">csum_lo</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">csum_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">csum</span><span class="p">;</span>

	<span class="n">csum_lo</span> <span class="o">=</span> <span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_lo</span><span class="p">;</span>
	<span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">EXT4_FITS_IN_INODE</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">i_checksum_hi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">csum_hi</span> <span class="o">=</span> <span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_hi</span><span class="p">;</span>
		<span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">csum</span> <span class="o">=</span> <span class="n">ext4_chksum</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_csum_seed</span><span class="p">,</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">raw</span><span class="p">,</span>
			   <span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>

	<span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_lo</span> <span class="o">=</span> <span class="n">csum_lo</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">EXT4_FITS_IN_INODE</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">i_checksum_hi</span><span class="p">))</span>
		<span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_hi</span> <span class="o">=</span> <span class="n">csum_hi</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">csum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_inode_csum_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">provided</span><span class="p">,</span> <span class="n">calculated</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_creator_os</span> <span class="o">!=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXT4_OS_LINUX</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
		<span class="n">EXT4_FEATURE_RO_COMPAT_METADATA_CSUM</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">provided</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_lo</span><span class="p">);</span>
	<span class="n">calculated</span> <span class="o">=</span> <span class="n">ext4_inode_csum</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">EXT4_FITS_IN_INODE</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">i_checksum_hi</span><span class="p">))</span>
		<span class="n">provided</span> <span class="o">|=</span> <span class="p">((</span><span class="n">__u32</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_hi</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">calculated</span> <span class="o">&amp;=</span> <span class="mh">0xFFFF</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">provided</span> <span class="o">==</span> <span class="n">calculated</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_inode_csum_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">csum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_creator_os</span> <span class="o">!=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXT4_OS_LINUX</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
		<span class="n">EXT4_FEATURE_RO_COMPAT_METADATA_CSUM</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">csum</span> <span class="o">=</span> <span class="n">ext4_inode_csum</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
	<span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_lo</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">csum</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">EXT4_FITS_IN_INODE</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">i_checksum_hi</span><span class="p">))</span>
		<span class="n">raw</span><span class="o">-&gt;</span><span class="n">i_checksum_hi</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">csum</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_begin_ordered_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					      <span class="n">loff_t</span> <span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_ext4_begin_ordered_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If jinode is zero, then we never opened the file for</span>
<span class="cm">	 * writing, so there&#39;s no need to call</span>
<span class="cm">	 * jbd2_journal_begin_ordered_truncate() since there&#39;s no</span>
<span class="cm">	 * outstanding writes we need to flush.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">jinode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">jbd2_journal_begin_ordered_truncate</span><span class="p">(</span><span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
						   <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">jinode</span><span class="p">,</span>
						   <span class="n">new_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ext4_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">noalloc_get_block_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_set_bh_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ext4_end_io_buffer_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__ext4_journalled_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_bh_delay_or_unwritten</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_discard_partial_page_buffers_no_lock</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Test whether an inode is a fast symlink.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_inode_is_fast_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ea_blocks</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">-</span> <span class="n">ea_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Restart the transaction associated with *handle.  This does a commit,</span>
<span class="cm"> * so before we call here everything must be consistently dirtied against</span>
<span class="cm"> * this transaction.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_truncate_restart_trans</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this</span>
<span class="cm">	 * moment, get_block can be called only for blocks inside i_size since</span>
<span class="cm">	 * page cache has been already dropped and writes are blocked by</span>
<span class="cm">	 * i_mutex. So we can safely drop the i_data_sem here.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;restarting handle %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_journal_restart</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
	<span class="n">ext4_discard_preallocations</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called at the last iput() if i_nlink is zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext4_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">trace_ext4_evict_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ext4_ioend_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * When journalling data dirty buffers are tracked only in the</span>
<span class="cm">		 * journal. So although mm thinks everything is clean and</span>
<span class="cm">		 * ready for reaping the inode might still have some pages to</span>
<span class="cm">		 * write in the running transaction or waiting to be</span>
<span class="cm">		 * checkpointed. Thus calling jbd2_journal_invalidatepage()</span>
<span class="cm">		 * (via truncate_inode_pages()) to discard these buffers can</span>
<span class="cm">		 * cause data loss. Also even if we did not discard these</span>
<span class="cm">		 * buffers, we would have no way to find them after the inode</span>
<span class="cm">		 * is reaped and thus user could see stale data if he tries to</span>
<span class="cm">		 * read them before the transaction is checkpointed. So be</span>
<span class="cm">		 * careful and force everything to disk here... We use</span>
<span class="cm">		 * ei-&gt;i_datasync_tid to store the newest transaction</span>
<span class="cm">		 * containing inode&#39;s data.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that directories do not have this problem because they</span>
<span class="cm">		 * don&#39;t use page cache.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_journal</span><span class="p">;</span>
			<span class="n">tid_t</span> <span class="n">commit_tid</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span><span class="p">;</span>

			<span class="n">jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_tid</span><span class="p">);</span>
			<span class="n">jbd2_log_wait_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_tid</span><span class="p">);</span>
			<span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_order_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ext4_begin_ordered_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_blocks_for_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext4_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we&#39;re going to skip the normal cleanup, we still need to</span>
<span class="cm">		 * make sure that the in-core orphan linked list is properly</span>
<span class="cm">		 * cleaned up.</span>
<span class="cm">		 */</span>
		<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ext4_handle_sync</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			     <span class="s">&quot;couldn&#39;t mark inode dirty (err %d)&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">stop_handle</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">)</span>
		<span class="n">ext4_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ext4_ext_truncate() doesn&#39;t reserve any slop when it</span>
<span class="cm">	 * restarts journal transactions; therefore there may not be</span>
<span class="cm">	 * enough credits left in the handle to remove the inode from</span>
<span class="cm">	 * the orphan list and set the dtime field.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_handle_has_enough_credits</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_extend</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_restart</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				     <span class="s">&quot;couldn&#39;t extend journal (err %d)&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="nl">stop_handle:</span>
			<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kill off the orphan record which ext4_truncate created.</span>
<span class="cm">	 * AKPM: I think this can be inside the above `if&#39;.</span>
<span class="cm">	 * Note that ext4_orphan_del() has to be able to cope with the</span>
<span class="cm">	 * deletion of a non-existent orphan - this is because we don&#39;t</span>
<span class="cm">	 * know if ext4_truncate() actually created an orphan record.</span>
<span class="cm">	 * (Well, we could do this if we need to, but heck - it works)</span>
<span class="cm">	 */</span>
	<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_dtime</span>	<span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * One subtle ordering requirement: if anything has gone wrong</span>
<span class="cm">	 * (transaction abort, IO errors, whatever), then we can still</span>
<span class="cm">	 * do these next steps (the fs will already have been marked as</span>
<span class="cm">	 * having errors), but we can&#39;t free the inode if the mark_dirty</span>
<span class="cm">	 * fails.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span>
		<span class="cm">/* If that failed, just do the required in-core inode clear. */</span>
		<span class="n">ext4_clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ext4_free_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">no_delete:</span>
	<span class="n">ext4_clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>	<span class="cm">/* We must guarantee clearing of inode... */</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_QUOTA</span>
<span class="n">qsize_t</span> <span class="o">*</span><span class="nf">ext4_get_reserved_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_reserved_quota</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the number of metadata blocks need to reserve</span>
<span class="cm"> * to allocate a block located at @lblock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_calc_metadata_amount</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">lblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ext4_ext_calc_metadata_amount</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ext4_ind_calc_metadata_amount</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called with i_data_sem down, which is important since we can call</span>
<span class="cm"> * ext4_discard_preallocations() from here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext4_da_update_reserve_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">used</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quota_claim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>
	<span class="n">trace_ext4_da_update_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="n">quota_claim</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">used</span> <span class="o">&gt;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext4_msg</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s: ino %lu, used %d &quot;</span>
			 <span class="s">&quot;with only %d reserved data blocks&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span>
			 <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">used</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update per-inode reservations */</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span> <span class="o">-=</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_meta_blocks</span> <span class="o">-=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_allocated_meta_blocks</span><span class="p">;</span>
	<span class="n">percpu_counter_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dirtyclusters_counter</span><span class="p">,</span>
			   <span class="n">used</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_allocated_meta_blocks</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_allocated_meta_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can release all of the reserved metadata blocks</span>
<span class="cm">		 * only when we have written all of the delayed</span>
<span class="cm">		 * allocation blocks.</span>
<span class="cm">		 */</span>
		<span class="n">percpu_counter_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dirtyclusters_counter</span><span class="p">,</span>
				   <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_meta_blocks</span><span class="p">);</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_meta_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>

	<span class="cm">/* Update quota subsystem for data blocks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quota_claim</span><span class="p">)</span>
		<span class="n">dquot_claim_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">used</span><span class="p">));</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We did fallocate with an offset that is already delayed</span>
<span class="cm">		 * allocated. So on delayed allocated writeback we should</span>
<span class="cm">		 * not re-claim the quota for fallocated blocks.</span>
<span class="cm">		 */</span>
		<span class="n">dquot_release_reservation_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">used</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have done all the pending block allocations and if</span>
<span class="cm">	 * there aren&#39;t any writers on the inode, we can discard the</span>
<span class="cm">	 * inode&#39;s preallocations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">ext4_discard_preallocations</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__check_block_validity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_data_block_valid</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span><span class="p">,</span>
				   <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext4_error_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span><span class="p">,</span>
				 <span class="s">&quot;lblock %lu mapped to illegal pblock &quot;</span>
				 <span class="s">&quot;(length %d)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span>
				 <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define check_block_validity(inode, map)	\</span>
<span class="cp">	__check_block_validity((inode), __func__, __LINE__, (map))</span>

<span class="cm">/*</span>
<span class="cm"> * Return the number of contiguous dirty pages in a given inode</span>
<span class="cm"> * starting at page frame idx.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pgoff_t</span> <span class="nf">ext4_num_dirty_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">idx</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span>	<span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">pagevec_lookup_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span>
					      <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">do</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					    <span class="o">!</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
						<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">num</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">max_pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sets the BH_Da_Mapped bit on the buffer heads corresponding to the given map.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_buffers_da_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		<span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">pagevec_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
					  <span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">do</span> <span class="p">{</span>
					<span class="n">set_buffer_da_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The ext4_map_blocks() function tries to look up the requested blocks,</span>
<span class="cm"> * and returns if the blocks are already mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise it takes the write lock of the i_data_sem and allocate blocks</span>
<span class="cm"> * and store the allocated blocks in the result buffer head and mark it</span>
<span class="cm"> * mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * If file type is extents based, it will call ext4_ext_map_blocks(),</span>
<span class="cm"> * Otherwise, call with ext4_ind_map_blocks() to handle indirect mapping</span>
<span class="cm"> * based files</span>
<span class="cm"> *</span>
<span class="cm"> * On success, it returns the number of blocks being mapped or allocate.</span>
<span class="cm"> * if create==0 and the blocks are pre-allocated and uninitialized block,</span>
<span class="cm"> * the result buffer head is unmapped. If the create ==1, it will make sure</span>
<span class="cm"> * the buffer head is mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * It returns 0 if plain look up failed (blocks have not been allocated), in</span>
<span class="cm"> * that case, buffer head is unmapped</span>
<span class="cm"> *</span>
<span class="cm"> * It returns the error in case of allocation failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_map_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,&quot;</span>
		  <span class="s">&quot;logical block %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Try to see if we can get the block without requesting a new</span>
<span class="cm">	 * file system block.</span>
<span class="cm">	 */</span>
	<span class="n">down_read</span><span class="p">((</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext4_ext_map_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span>
					     <span class="n">EXT4_GET_BLOCKS_KEEP_SIZE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext4_ind_map_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span>
					     <span class="n">EXT4_GET_BLOCKS_KEEP_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">((</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_MAPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">check_block_validity</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If it is only a block(s) look up */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_CREATE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Returns if the blocks have already allocated</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that if blocks have been preallocated</span>
<span class="cm">	 * ext4_ext_get_block() returns the create = 0</span>
<span class="cm">	 * with buffer head unmapped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_MAPPED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When we call get_blocks without the create flag, the</span>
<span class="cm">	 * BH_Unwritten flag could have gotten set if the blocks</span>
<span class="cm">	 * requested were part of a uninitialized extent.  We need to</span>
<span class="cm">	 * clear this flag now that we are committed to convert all or</span>
<span class="cm">	 * part of the uninitialized extent to be an initialized</span>
<span class="cm">	 * extent.  This is because we need to avoid the combination</span>
<span class="cm">	 * of BH_Unwritten and BH_Mapped flags being simultaneously</span>
<span class="cm">	 * set on the buffer_head.</span>
<span class="cm">	 */</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EXT4_MAP_UNWRITTEN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * New blocks allocate and/or writing to uninitialized extent</span>
<span class="cm">	 * will possibly result in updating i_data, so we take</span>
<span class="cm">	 * the write lock of i_data_sem, and call get_blocks()</span>
<span class="cm">	 * with create == 1 flag.</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">((</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the caller is from delayed allocation writeout path</span>
<span class="cm">	 * we have already reserved fs blocks for allocation</span>
<span class="cm">	 * let the underlying get_block() function know to</span>
<span class="cm">	 * avoid double accounting</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_DELALLOC_RESERVE</span><span class="p">)</span>
		<span class="n">ext4_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_DELALLOC_RESERVED</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to check for EXT4 here because migrate</span>
<span class="cm">	 * could have changed the inode type in between</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext4_ext_map_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext4_ind_map_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_NEW</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We allocated new blocks which will result in</span>
<span class="cm">			 * i_data&#39;s format changing.  Force the migrate</span>
<span class="cm">			 * to fail by clearing migrate flags</span>
<span class="cm">			 */</span>
			<span class="n">ext4_clear_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_EXT_MIGRATE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Update reserved blocks/metadata blocks after successful</span>
<span class="cm">		 * block allocation which had been deferred till now. We don&#39;t</span>
<span class="cm">		 * support fallocate for non extent files. So we can update</span>
<span class="cm">		 * reserve space here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_DELALLOC_RESERVE</span><span class="p">))</span>
			<span class="n">ext4_da_update_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_DELALLOC_RESERVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_clear_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_DELALLOC_RESERVED</span><span class="p">);</span>

		<span class="cm">/* If we have successfully mapped the delayed allocated blocks,</span>
<span class="cm">		 * set the BH_Da_Mapped bit on them. Its important to do this</span>
<span class="cm">		 * under the protection of i_data_sem.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_MAPPED</span><span class="p">)</span>
			<span class="n">set_buffers_da_mapped</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">up_write</span><span class="p">((</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_MAPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">check_block_validity</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Maximum number of blocks we map for direct IO at once. */</span>
<span class="cp">#define DIO_MAX_BLOCKS 4096</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_ext4_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_current_handle</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="n">map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">started</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dio_credits</span><span class="p">;</span>

	<span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">iblock</span><span class="p">;</span>
	<span class="n">map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Direct IO write... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">&gt;</span> <span class="n">DIO_MAX_BLOCKS</span><span class="p">)</span>
			<span class="n">map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">DIO_MAX_BLOCKS</span><span class="p">;</span>
		<span class="n">dio_credits</span> <span class="o">=</span> <span class="n">ext4_chunk_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">m_len</span><span class="p">);</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dio_credits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_map_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">m_pblk</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EXT4_MAP_FLAGS</span><span class="p">)</span> <span class="o">|</span> <span class="n">map</span><span class="p">.</span><span class="n">m_flags</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">*</span> <span class="n">map</span><span class="p">.</span><span class="n">m_len</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">started</span><span class="p">)</span>
		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext4_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_ext4_get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span>
			       <span class="n">create</span> <span class="o">?</span> <span class="n">EXT4_GET_BLOCKS_CREATE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * `handle&#39; can be NULL if create is zero</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">ext4_getblk</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fatal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">handle</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">create</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_map_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span>
			      <span class="n">create</span> <span class="o">?</span> <span class="n">EXT4_GET_BLOCKS_CREATE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">m_pblk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_NEW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">create</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">handle</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Now that we do not always journal data, we should</span>
<span class="cm">		 * keep in mind whether this should always journal the</span>
<span class="cm">		 * new buffer as metadata.  For now, regular file</span>
<span class="cm">		 * writes use ext4_get_block instead, so it&#39;s not a</span>
<span class="cm">		 * problem.</span>
<span class="cm">		 */</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call get_create_access&quot;</span><span class="p">);</span>
		<span class="n">fatal</span> <span class="o">=</span> <span class="n">ext4_journal_get_create_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fatal</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext4_handle_dirty_metadata&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fatal</span><span class="p">)</span>
			<span class="n">fatal</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;not a new buffer&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">fatal</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">ext4_bread</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			       <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">ext4_getblk</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">create</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span> <span class="o">|</span> <span class="n">REQ_META</span> <span class="o">|</span> <span class="n">REQ_PRIO</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">walk_page_buffers</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="n">to</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">partial</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">block_start</span><span class="p">);</span>
	     <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&lt;=</span> <span class="n">from</span> <span class="o">||</span> <span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="o">*</span><span class="n">partial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To preserve ordering, it is essential that the hole instantiation and</span>
<span class="cm"> * the data write be encapsulated in a single transaction.  We cannot</span>
<span class="cm"> * close off a transaction and start a new one between the ext4_get_block()</span>
<span class="cm"> * and the commit_write().  So doing the jbd2_journal_start at the start of</span>
<span class="cm"> * prepare_write() is the right place.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, this function can nest inside ext4_writepage() -&gt;</span>
<span class="cm"> * block_write_full_page(). In that case, we *know* that ext4_writepage()</span>
<span class="cm"> * has generated enough buffer credits to do the whole page.  So we won&#39;t</span>
<span class="cm"> * block on the journal in that case, which is good, because the caller may</span>
<span class="cm"> * be PF_MEMALLOC.</span>
<span class="cm"> *</span>
<span class="cm"> * By accident, ext4 can be reentered when a transaction is open via</span>
<span class="cm"> * quota file writes.  If we were to commit the transaction while thus</span>
<span class="cm"> * reentered, there can be a deadlock - we would be holding a quota</span>
<span class="cm"> * lock, and the commit would never complete if another thread had a</span>
<span class="cm"> * transaction open and was blocking on the quota lock - a ranking</span>
<span class="cm"> * violation.</span>
<span class="cm"> *</span>
<span class="cm"> * So what we do is to rely on the fact that jbd2_journal_stop/journal_start</span>
<span class="cm"> * will _not_ run commit under these circumstances because handle-&gt;h_ref</span>
<span class="cm"> * is elevated.  We&#39;ll still have enough credits for the tiny quotafile</span>
<span class="cm"> * write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_journal_get_write_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_freed</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * __block_write_begin() could have dirtied some buffers. Clean</span>
<span class="cm">	 * the dirty bit as jbd2_journal_get_write_access() could complain</span>
<span class="cm">	 * otherwise about fs integrity issues. Setting of the dirty bit</span>
<span class="cm">	 * by __block_write_begin() isn&#39;t a real problem here as we clear</span>
<span class="cm">	 * the bit before releasing a page lock and thus writeback cannot</span>
<span class="cm">	 * ever write the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">dirty</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_get_block_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			    <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">needed_blocks</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>

	<span class="n">trace_ext4_write_begin</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Reserve one block more for addition to orphan list in case</span>
<span class="cm">	 * we allocate blocks but write fails for some reason</span>
<span class="cm">	 */</span>
	<span class="n">needed_blocks</span> <span class="o">=</span> <span class="n">ext4_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">needed_blocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We cannot recurse into the filesystem as the transaction is already</span>
<span class="cm">	 * started */</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">AOP_FLAG_NOFS</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_dioread_nolock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ext4_get_block_write</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ext4_get_block</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
				<span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">do_journal_get_write_access</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * __block_write_begin may have instantiated a few blocks</span>
<span class="cm">		 * outside i_size.  Trim these off again. Don&#39;t need</span>
<span class="cm">		 * i_size_read because we hold i_mutex.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Add inode to orphan list in case we crash before</span>
<span class="cm">		 * truncate finishes</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If truncate failed early the inode might</span>
<span class="cm">			 * still be on the orphan list; we need to</span>
<span class="cm">			 * make sure the inode is removed from the</span>
<span class="cm">			 * orphan list in that case.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
				<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_should_retry_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* For write_end() in data=journal mode */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_end_fn</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_freed</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_generic_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				  <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i_size_changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_current_handle</span><span class="p">();</span>

	<span class="n">copied</span> <span class="o">=</span> <span class="n">block_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to use i_size_read() here, the i_size</span>
<span class="cm">	 * cannot change under us because we hold i_mutex.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But it&#39;s important to update i_size while still holding page lock:</span>
<span class="cm">	 * page writeout could otherwise come in and zero beyond i_size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">);</span>
		<span class="n">i_size_changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span> <span class="o">&gt;</span>  <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We need to mark inode dirty even if</span>
<span class="cm">		 * new_i_size is less that inode-&gt;i_size</span>
<span class="cm">		 * bu greater than i_disksize.(hint delalloc)</span>
<span class="cm">		 */</span>
		<span class="n">ext4_update_i_disksize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">));</span>
		<span class="n">i_size_changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t mark the inode dirty under page lock. First, it unnecessarily</span>
<span class="cm">	 * makes the holding time of page lock longer. Second, it forces lock</span>
<span class="cm">	 * ordering of page lock and transaction start for journaling</span>
<span class="cm">	 * filesystems.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_size_changed</span><span class="p">)</span>
		<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to pick up the new inode size which generic_commit_write gave us</span>
<span class="cm"> * `file&#39; can be NULL - eg, when called from page_symlink().</span>
<span class="cm"> *</span>
<span class="cm"> * ext4 never places buffers on inode-&gt;i_mapping-&gt;private_list.  metadata</span>
<span class="cm"> * buffers are managed internally.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ordered_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				  <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_current_handle</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret2</span><span class="p">;</span>

	<span class="n">trace_ext4_ordered_write_end</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_jbd2_file_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_generic_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span>
							<span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="cm">/* if we have allocated more blocks and copied</span>
<span class="cm">			 * less. We will have blocks allocated outside</span>
<span class="cm">			 * inode-&gt;i_size. So truncate them</span>
<span class="cm">			 */</span>
			<span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If truncate failed early the inode might still be</span>
<span class="cm">		 * on the orphan list; we need to make sure the inode</span>
<span class="cm">		 * is removed from the orphan list in that case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
			<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_writeback_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				    <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_current_handle</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret2</span><span class="p">;</span>

	<span class="n">trace_ext4_writeback_write_end</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_generic_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span>
							<span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="cm">/* if we have allocated more blocks and copied</span>
<span class="cm">		 * less. We will have blocks allocated outside</span>
<span class="cm">		 * inode-&gt;i_size. So truncate them</span>
<span class="cm">		 */</span>
		<span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>

	<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If truncate failed early the inode might still be</span>
<span class="cm">		 * on the orphan list; we need to make sure the inode</span>
<span class="cm">		 * is removed from the orphan list in that case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
			<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_journalled_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				     <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_current_handle</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">partial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">new_i_size</span><span class="p">;</span>

	<span class="n">trace_ext4_journalled_write_end</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">page_zero_new_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">from</span><span class="o">+</span><span class="n">copied</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">from</span><span class="p">,</span>
				<span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">partial</span><span class="p">,</span> <span class="n">write_end_fn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">new_i_size</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_i_size</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="n">copied</span><span class="p">);</span>
	<span class="n">ext4_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_JDATA</span><span class="p">);</span>
	<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_i_size</span> <span class="o">&gt;</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_update_i_disksize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_i_size</span><span class="p">);</span>
		<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="cm">/* if we have allocated more blocks and copied</span>
<span class="cm">		 * less. We will have blocks allocated outside</span>
<span class="cm">		 * inode-&gt;i_size. So truncate them</span>
<span class="cm">		 */</span>
		<span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If truncate failed early the inode might still be</span>
<span class="cm">		 * on the orphan list; we need to make sure the inode</span>
<span class="cm">		 * is removed from the orphan list in that case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
			<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reserve a single cluster located at lblock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_da_reserve_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">lblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">md_needed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * recalculate the amount of metadata blocks to reserve</span>
<span class="cm">	 * in order to allocate nrblocks</span>
<span class="cm">	 * worse case is one extent per block</span>
<span class="cm">	 */</span>
<span class="nl">repeat:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>
	<span class="n">md_needed</span> <span class="o">=</span> <span class="n">EXT4_NUM_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span>
				 <span class="n">ext4_calc_metadata_amount</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblock</span><span class="p">));</span>
	<span class="n">trace_ext4_da_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">md_needed</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We will charge metadata quota at writeout time; this saves</span>
<span class="cm">	 * us from metadata over-estimation, though we may go over by</span>
<span class="cm">	 * a small amount in the end.  Here we just reserve for data.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dquot_reserve_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We do still charge estimated metadata to the sb though;</span>
<span class="cm">	 * we cannot afford to run out of free blocks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_claim_free_clusters</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">md_needed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dquot_release_reservation_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_retry_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">yield</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_meta_blocks</span> <span class="o">+=</span> <span class="n">md_needed</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>       <span class="cm">/* success */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_da_release_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to_free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to_free</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* Nothing to release, exit */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>

	<span class="n">trace_ext4_da_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">to_free</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">to_free</span> <span class="o">&gt;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if there aren&#39;t enough reserved blocks, then the</span>
<span class="cm">		 * counter is messed up somewhere.  Since this</span>
<span class="cm">		 * function is called from invalidate page, it&#39;s</span>
<span class="cm">		 * harmless to return without any action.</span>
<span class="cm">		 */</span>
		<span class="n">ext4_msg</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="s">&quot;ext4_da_release_space: &quot;</span>
			 <span class="s">&quot;ino %lu, to_free %d with only %d reserved &quot;</span>
			 <span class="s">&quot;data blocks&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">to_free</span><span class="p">,</span>
			 <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">to_free</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span> <span class="o">-=</span> <span class="n">to_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can release all of the reserved metadata blocks</span>
<span class="cm">		 * only when we have written all of the delayed</span>
<span class="cm">		 * allocation blocks.</span>
<span class="cm">		 * Note that in case of bigalloc, i_reserved_meta_blocks,</span>
<span class="cm">		 * i_reserved_data_blocks, etc. refer to number of clusters.</span>
<span class="cm">		 */</span>
		<span class="n">percpu_counter_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dirtyclusters_counter</span><span class="p">,</span>
				   <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_meta_blocks</span><span class="p">);</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_meta_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* update fs dirty data blocks counter */</span>
	<span class="n">percpu_counter_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dirtyclusters_counter</span><span class="p">,</span> <span class="n">to_free</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>

	<span class="n">dquot_release_reservation_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">to_free</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_da_page_release_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">to_release</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">curr_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">num_clusters</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_off</span> <span class="o">=</span> <span class="n">curr_off</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">curr_off</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">to_release</span><span class="o">++</span><span class="p">;</span>
			<span class="n">clear_buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_da_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">curr_off</span> <span class="o">=</span> <span class="n">next_off</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="cm">/* If we have released all the blocks belonging to a cluster, then we</span>
<span class="cm">	 * need to release the reserved space for that cluster. */</span>
	<span class="n">num_clusters</span> <span class="o">=</span> <span class="n">EXT4_NUM_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">to_release</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num_clusters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_fsblk_t</span> <span class="n">lblk</span><span class="p">;</span>
		<span class="n">lblk</span> <span class="o">=</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">))</span> <span class="o">+</span>
			<span class="p">((</span><span class="n">num_clusters</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_bits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">ext4_find_delalloc_cluster</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblk</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">ext4_da_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">num_clusters</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Delayed allocation stuff</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * mpage_da_submit_io - walks through extent of pages and try to write</span>
<span class="cm"> * them with writepage() call back</span>
<span class="cm"> *</span>
<span class="cm"> * @mpd-&gt;inode: inode</span>
<span class="cm"> * @mpd-&gt;first_page: first page of the extent</span>
<span class="cm"> * @mpd-&gt;next_page: page after the last page of the extent</span>
<span class="cm"> *</span>
<span class="cm"> * By the time mpage_da_submit_io() is called we expect all blocks</span>
<span class="cm"> * to be allocated. this may be wrong if allocation failed.</span>
<span class="cm"> *</span>
<span class="cm"> * As pages are already locked by write_cache_pages(), we can&#39;t use it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mpage_da_submit_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpage_da_data</span> <span class="o">*</span><span class="n">mpd</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">block_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">page_bufs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">journal_data</span> <span class="o">=</span> <span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">sector_t</span> <span class="n">pblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur_logical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_io_submit</span> <span class="n">io_submit</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">next_page</span> <span class="o">&lt;=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">first_page</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_submit</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">io_submit</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to start from the first_page to the next_page - 1</span>
<span class="cm">	 * to make sure we also write the mapped dirty buffer_heads.</span>
<span class="cm">	 * If we look at mpd-&gt;b_blocknr we would only be looking</span>
<span class="cm">	 * at the currently mapped buffer_heads.</span>
<span class="cm">	 */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">first_page</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">next_page</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">pagevec_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">PAGEVEC_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">commit_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skip_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cur_logical</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span>
							<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
				<span class="n">pblock</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span> <span class="o">+</span> <span class="p">(</span><span class="n">cur_logical</span> <span class="o">-</span>
							<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">index</span><span class="o">++</span><span class="p">;</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the page does not have buffers (for</span>
<span class="cm">			 * whatever reason), try to create them using</span>
<span class="cm">			 * __block_write_begin.  If this fails,</span>
<span class="cm">			 * skip the page and move on.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						<span class="n">noalloc_get_block_write</span><span class="p">))</span> <span class="p">{</span>
				<span class="nl">skip_page:</span>
					<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">commit_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">bh</span> <span class="o">=</span> <span class="n">page_bufs</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">skip_page</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cur_logical</span> <span class="o">&gt;=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">cur_logical</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">+</span>
						     <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">clear_buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
						<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="n">pblock</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">buffer_da_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
						<span class="n">clear_buffer_da_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span>
					    <span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
						<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">!=</span> <span class="n">pblock</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_UNINIT</span><span class="p">)</span>
						<span class="n">set_buffer_uninit</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="n">clear_buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * skip page if block allocation undone and</span>
<span class="cm">				 * block is dirty</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ext4_bh_delay_or_unwritten</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
					<span class="n">skip_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
				<span class="n">block_start</span> <span class="o">+=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
				<span class="n">cur_logical</span><span class="o">++</span><span class="p">;</span>
				<span class="n">pblock</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">page_bufs</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skip_page</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">skip_page</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">commit_write</span><span class="p">)</span>
				<span class="cm">/* mark the buffer_heads as dirty &amp; uptodate */</span>
				<span class="n">block_commit_write</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Delalloc doesn&#39;t support data journalling,</span>
<span class="cm">			 * but eventually maybe we&#39;ll lift this</span>
<span class="cm">			 * restriction.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">journal_data</span> <span class="o">&amp;&amp;</span> <span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">__ext4_journalled_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">MBLK_IO_SUBMIT</span><span class="p">))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_bio_write_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_submit</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
							  <span class="n">len</span><span class="p">,</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">wbc</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer_uninit</span><span class="p">(</span><span class="n">page_bufs</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ext4_set_bh_endio</span><span class="p">(</span><span class="n">page_bufs</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">block_write_full_page_endio</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>
					<span class="n">noalloc_get_block_write</span><span class="p">,</span>
					<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">wbc</span><span class="p">,</span> <span class="n">ext4_end_io_buffer_write</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>
					<span class="n">noalloc_get_block_write</span><span class="p">,</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">wbc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">pages_written</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * In error case, we have to continue because</span>
<span class="cm">			 * remaining pages are still locked</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext4_io_submit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_submit</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_da_block_invalidatepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpage_da_data</span> <span class="o">*</span><span class="n">mpd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">first_page</span><span class="p">;</span>
	<span class="n">end</span>   <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">next_page</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">pagevec_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">PAGEVEC_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">block_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">nr_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_print_free_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="n">ext4_msg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span> <span class="s">&quot;Total free blocks count %lld&quot;</span><span class="p">,</span>
	       <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span>
			<span class="n">ext4_count_free_clusters</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)));</span>
	<span class="n">ext4_msg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span> <span class="s">&quot;Free/Dirty block details&quot;</span><span class="p">);</span>
	<span class="n">ext4_msg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span> <span class="s">&quot;free_blocks=%lld&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span>
		<span class="n">percpu_counter_sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeclusters_counter</span><span class="p">)));</span>
	<span class="n">ext4_msg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span> <span class="s">&quot;dirty_blocks=%lld&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span>
		<span class="n">percpu_counter_sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dirtyclusters_counter</span><span class="p">)));</span>
	<span class="n">ext4_msg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span> <span class="s">&quot;Block reservation details&quot;</span><span class="p">);</span>
	<span class="n">ext4_msg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span> <span class="s">&quot;i_reserved_data_blocks=%u&quot;</span><span class="p">,</span>
		 <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="p">);</span>
	<span class="n">ext4_msg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span> <span class="s">&quot;i_reserved_meta_blocks=%u&quot;</span><span class="p">,</span>
	       <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_reserved_meta_blocks</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mpage_da_map_and_submit - go through given space, map them</span>
<span class="cm"> *       if necessary, and then submit them for I/O</span>
<span class="cm"> *</span>
<span class="cm"> * @mpd - bh describing space</span>
<span class="cm"> *</span>
<span class="cm"> * The function skips space we know is already mapped to disk blocks.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpage_da_map_and_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpage_da_data</span> <span class="o">*</span><span class="n">mpd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">blks</span><span class="p">,</span> <span class="n">get_blocks_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="n">map</span><span class="p">,</span> <span class="o">*</span><span class="n">mapp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">next</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">max_blocks</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">disksize</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the blocks are mapped already, or we couldn&#39;t accumulate</span>
<span class="cm">	 * any blocks, then proceed immediately to the submission stage.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_state</span>  <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Mapped</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Delay</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Unwritten</span><span class="p">))))</span>
		<span class="k">goto</span> <span class="n">submit_io</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_current_handle</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call ext4_map_blocks() to allocate any delayed allocation</span>
<span class="cm">	 * blocks, or to convert an uninitialized extent to be</span>
<span class="cm">	 * initialized (in the case where we have written into</span>
<span class="cm">	 * one or more preallocated blocks).</span>
<span class="cm">	 *</span>
<span class="cm">	 * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE to</span>
<span class="cm">	 * indicate that we are on the delayed allocation path.  This</span>
<span class="cm">	 * affects functions in many different parts of the allocation</span>
<span class="cm">	 * call path.  This flag exists primarily because we don&#39;t</span>
<span class="cm">	 * want to change *many* call functions, so ext4_map_blocks()</span>
<span class="cm">	 * will set the EXT4_STATE_DELALLOC_RESERVED flag once the</span>
<span class="cm">	 * inode&#39;s allocation semaphore is taken.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the blocks in questions were delalloc blocks, set</span>
<span class="cm">	 * EXT4_GET_BLOCKS_DELALLOC_RESERVE so the delalloc accounting</span>
<span class="cm">	 * variables are updated after the blocks have been allocated.</span>
<span class="cm">	 */</span>
	<span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">max_blocks</span><span class="p">;</span>
	<span class="n">get_blocks_flags</span> <span class="o">=</span> <span class="n">EXT4_GET_BLOCKS_CREATE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_dioread_nolock</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">get_blocks_flags</span> <span class="o">|=</span> <span class="n">EXT4_GET_BLOCKS_IO_CREATE_EXT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Delay</span><span class="p">))</span>
		<span class="n">get_blocks_flags</span> <span class="o">|=</span> <span class="n">EXT4_GET_BLOCKS_DELALLOC_RESERVE</span><span class="p">;</span>

	<span class="n">blks</span> <span class="o">=</span> <span class="n">ext4_map_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">get_blocks_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blks</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">blks</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If get block returns EAGAIN or ENOSPC and there</span>
<span class="cm">		 * appears to be free blocks we will just let</span>
<span class="cm">		 * mpage_da_submit_io() unlock all of the pages.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">submit_io</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_count_free_clusters</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">submit_io</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * get block failure will cause us to loop in</span>
<span class="cm">		 * writepages, because a_ops-&gt;writepage won&#39;t be able</span>
<span class="cm">		 * to make progress. The page will be redirtied by</span>
<span class="cm">		 * writepage and writepages will again try to write</span>
<span class="cm">		 * the same.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_mount_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MF_FS_ABORTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext4_msg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span>
				 <span class="s">&quot;delayed block allocation failed for inode %lu &quot;</span>
				 <span class="s">&quot;at logical offset %llu with max blocks %zd &quot;</span>
				 <span class="s">&quot;with error %d&quot;</span><span class="p">,</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">next</span><span class="p">,</span>
				 <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">ext4_msg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span>
				<span class="s">&quot;This should not happen!! Data will be lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
				<span class="n">ext4_print_free_blocks</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* invalidate all the pages */</span>
		<span class="n">ext4_da_block_invalidatepages</span><span class="p">(</span><span class="n">mpd</span><span class="p">);</span>

		<span class="cm">/* Mark this page range as having been completed */</span>
		<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">io_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">blks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mapp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_NEW</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">map</span><span class="p">.</span><span class="n">m_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">m_pblk</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_order_data</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_jbd2_file_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Only if the journal is aborted */</span>
				<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">retval</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">submit_io</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update on-disk size along with block allocation.</span>
<span class="cm">	 */</span>
	<span class="n">disksize</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">next</span> <span class="o">+</span> <span class="n">blks</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disksize</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">disksize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disksize</span> <span class="o">&gt;</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_update_i_disksize</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">disksize</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">ext4_error</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				   <span class="s">&quot;Failed to mark inode %lu dirty&quot;</span><span class="p">,</span>
				   <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">submit_io:</span>
	<span class="n">mpage_da_submit_io</span><span class="p">(</span><span class="n">mpd</span><span class="p">,</span> <span class="n">mapp</span><span class="p">);</span>
	<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">io_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define BH_FLAGS ((1 &lt;&lt; BH_Uptodate) | (1 &lt;&lt; BH_Mapped) | \</span>
<span class="cp">		(1 &lt;&lt; BH_Delay) | (1 &lt;&lt; BH_Unwritten))</span>

<span class="cm">/*</span>
<span class="cm"> * mpage_add_bh_to_extent - try to add one more block to extent of blocks</span>
<span class="cm"> *</span>
<span class="cm"> * @mpd-&gt;lbh - extent of blocks</span>
<span class="cm"> * @logical - logical number of the block in the file</span>
<span class="cm"> * @bh - bh of the block (used to access block&#39;s state)</span>
<span class="cm"> *</span>
<span class="cm"> * the function is used to collect contig. blocks in same state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpage_add_bh_to_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpage_da_data</span> <span class="o">*</span><span class="n">mpd</span><span class="p">,</span>
				   <span class="n">sector_t</span> <span class="n">logical</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">b_size</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nrblocks</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX Don&#39;t go larger than mballoc is willing to allocate</span>
<span class="cm">	 * This is a stopgap solution.  We eventually need to fold</span>
<span class="cm">	 * mpage_da_submit_io() into this function and then call</span>
<span class="cm">	 * ext4_map_blocks() multiple times in a loop</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nrblocks</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">/</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">flush_it</span><span class="p">;</span>

	<span class="cm">/* check if thereserved journal credits might overflow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nrblocks</span> <span class="o">&gt;=</span> <span class="n">EXT4_MAX_TRANS_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * With non-extent format we are limited by the journal</span>
<span class="cm">			 * credit available.  Total credit needed to insert</span>
<span class="cm">			 * nrblocks contiguous blocks is dependent on the</span>
<span class="cm">			 * nrblocks.  So limit nrblocks.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">flush_it</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">nrblocks</span> <span class="o">+</span> <span class="p">(</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">))</span> <span class="o">&gt;</span>
				<span class="n">EXT4_MAX_TRANS_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Adding the new buffer_head would make it cross the</span>
<span class="cm">			 * allowed limit for which we have journal credit</span>
<span class="cm">			 * reserved. So limit the new bh-&gt;b_size</span>
<span class="cm">			 */</span>
			<span class="n">b_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXT4_MAX_TRANS_DATA</span> <span class="o">-</span> <span class="n">nrblocks</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
						<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
			<span class="cm">/* we will do mpage_da_submit_io in the next loop */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * First block in the extent</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
		<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">b_size</span><span class="p">;</span>
		<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="n">b_state</span> <span class="o">&amp;</span> <span class="n">BH_FLAGS</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">+</span> <span class="n">nrblocks</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Can we merge the block to our big extent?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">logical</span> <span class="o">==</span> <span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b_state</span> <span class="o">&amp;</span> <span class="n">BH_FLAGS</span><span class="p">)</span> <span class="o">==</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">+=</span> <span class="n">b_size</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">flush_it:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We couldn&#39;t merge the block to our extent, so we</span>
<span class="cm">	 * need to flush current  extent and start new one</span>
<span class="cm">	 */</span>
	<span class="n">mpage_da_map_and_submit</span><span class="p">(</span><span class="n">mpd</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_bh_delay_or_unwritten</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is grabs code from the very beginning of</span>
<span class="cm"> * ext4_map_blocks, but assumes that the caller is from delayed write</span>
<span class="cm"> * time. This function looks up the requested blocks and sets the</span>
<span class="cm"> * buffer delay bit under the protection of i_data_sem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_da_map_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">invalid_block</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">sector_t</span><span class="p">)</span> <span class="mh">0xffff</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">invalid_block</span> <span class="o">&lt;</span> <span class="n">ext4_blocks_count</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">))</span>
		<span class="n">invalid_block</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;ext4_da_map_blocks(): inode %lu, max_blocks %u,&quot;</span>
		  <span class="s">&quot;logical block %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Try to see if we can get the block without requesting a new</span>
<span class="cm">	 * file system block.</span>
<span class="cm">	 */</span>
	<span class="n">down_read</span><span class="p">((</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext4_ext_map_blocks</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext4_ind_map_blocks</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * XXX: __block_prepare_write() unmaps passed block,</span>
<span class="cm">		 * is it OK?</span>
<span class="cm">		 */</span>
		<span class="cm">/* If the block was allocated from previously allocated cluster,</span>
<span class="cm">		 * then we dont need to reserve it again. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_FROM_CLUSTER</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">ext4_da_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="cm">/* not enough space to reserve */</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Clear EXT4_MAP_FROM_CLUSTER flag since its purpose is served</span>
<span class="cm">		 * and it should not appear on the bh-&gt;b_state.</span>
<span class="cm">		 */</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EXT4_MAP_FROM_CLUSTER</span><span class="p">;</span>

		<span class="n">map_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">invalid_block</span><span class="p">);</span>
		<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">set_buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">up_read</span><span class="p">((</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a special get_blocks_t callback which is used by</span>
<span class="cm"> * ext4_da_write_begin().  It will either return mapped block or</span>
<span class="cm"> * reserve space for a single block.</span>
<span class="cm"> *</span>
<span class="cm"> * For delayed buffer_head we have BH_Mapped, BH_New, BH_Delay set.</span>
<span class="cm"> * We also have b_blocknr = -1 and b_bdev initialized properly</span>
<span class="cm"> *</span>
<span class="cm"> * For unwritten buffer_head we have BH_Mapped, BH_New, BH_Unwritten set.</span>
<span class="cm"> * We also have b_blocknr = physicalblock mapping unwritten extent and b_bdev</span>
<span class="cm"> * initialized properly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_da_get_block_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="n">map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">create</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>

	<span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">iblock</span><span class="p">;</span>
	<span class="n">map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * first, we need to know whether the block is allocated already</span>
<span class="cm">	 * preallocated blocks are unmapped but should treated</span>
<span class="cm">	 * the same as allocated blocks.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_da_map_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">map_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">m_pblk</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EXT4_MAP_FLAGS</span><span class="p">)</span> <span class="o">|</span> <span class="n">map</span><span class="p">.</span><span class="n">m_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* A delayed write to unwritten bh should be marked</span>
<span class="cm">		 * new and mapped.  Mapped ensures that we don&#39;t do</span>
<span class="cm">		 * get_block multiple times when we write to the same</span>
<span class="cm">		 * offset and new ensures that we do proper zero out</span>
<span class="cm">		 * for partial write.</span>
<span class="cm">		 */</span>
		<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">set_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is used as a standard get_block_t calback function</span>
<span class="cm"> * when there is no desire to allocate any blocks.  It is used as a</span>
<span class="cm"> * callback function for block_write_begin() and block_write_full_page().</span>
<span class="cm"> * These functions should only try to map a single block at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * Since this function doesn&#39;t do block allocations even if the caller</span>
<span class="cm"> * requests it by passing in create=1, it is critically important that</span>
<span class="cm"> * any caller checks to make sure that any buffer heads are returned</span>
<span class="cm"> * by this function are either all already mapped or marked for</span>
<span class="cm"> * delayed allocation before calling  block_write_full_page().  Otherwise,</span>
<span class="cm"> * b_blocknr could be left unitialized, and the page write functions will</span>
<span class="cm"> * be taken by surprise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">noalloc_get_block_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">_ext4_get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bget_one</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bput_one</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ext4_journalled_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">page_bufs</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_bufs</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page_bufs</span><span class="p">);</span>
	<span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_bufs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bget_one</span><span class="p">);</span>
	<span class="cm">/* As soon as we unlock the page, it can go away, but we have</span>
<span class="cm">	 * references to buffers so we are safe */</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_bufs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">do_journal_get_write_access</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_bufs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">write_end_fn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_bufs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bput_one</span><span class="p">);</span>
	<span class="n">ext4_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_JDATA</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_set_bh_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ext4_end_io_buffer_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Note that we don&#39;t need to start a transaction unless we&#39;re journaling data</span>
<span class="cm"> * because we should have holes filled from ext4_page_mkwrite(). We even don&#39;t</span>
<span class="cm"> * need to file the inode to the transaction&#39;s list in ordered mode because if</span>
<span class="cm"> * we are writing back data added by write(), the inode is already there and if</span>
<span class="cm"> * we are writing back data modified via mmap(), no one guarantees in which</span>
<span class="cm"> * transaction the data will hit the disk. In case we are journaling data, we</span>
<span class="cm"> * cannot start transaction directly because transaction start ranks above page</span>
<span class="cm"> * lock so we have to do some magic.</span>
<span class="cm"> *</span>
<span class="cm"> * This function can get called via...</span>
<span class="cm"> *   - ext4_da_writepages after taking page lock (have journal handle)</span>
<span class="cm"> *   - journal_submit_inode_data_buffers (no journal handle)</span>
<span class="cm"> *   - shrink_page_list via pdflush (no journal handle)</span>
<span class="cm"> *   - grab_page_cache when doing write_begin (have journal handle)</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t do any block allocation in this function. If we have page with</span>
<span class="cm"> * multiple blocks we need to write those buffer_heads that are mapped. This</span>
<span class="cm"> * is important for mmaped based write. So if we do with blocksize 1K</span>
<span class="cm"> * truncate(f, 1024);</span>
<span class="cm"> * a = mmap(f, 0, 4096);</span>
<span class="cm"> * a[0] = &#39;a&#39;;</span>
<span class="cm"> * truncate(f, 4096);</span>
<span class="cm"> * we have in the page first buffer_head mapped via page_mkwrite call back</span>
<span class="cm"> * but other buffer_heads would be unmapped but dirty (dirty done via the</span>
<span class="cm"> * do_wp_page). So writepage should write the first block. If we modify</span>
<span class="cm"> * the mmap area beyond 1024 we will again get a page_fault and the</span>
<span class="cm"> * page_mkwrite callback will do the block allocation and mark the</span>
<span class="cm"> * buffer_heads mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * We redirty the page if we have any buffer_heads that is either delay or</span>
<span class="cm"> * unwritten in the page.</span>
<span class="cm"> *</span>
<span class="cm"> * We can get recursively called as show below.</span>
<span class="cm"> *</span>
<span class="cm"> *	ext4_writepage() -&gt; kmalloc() -&gt; __alloc_pages() -&gt; page_launder() -&gt;</span>
<span class="cm"> *		ext4_writepage()</span>
<span class="cm"> *</span>
<span class="cm"> * But since we don&#39;t do any block allocation we should not deadlock.</span>
<span class="cm"> * Page also have the dirty flag cleared so we don&#39;t get recurive page_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">commit_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">page_bufs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">trace_ext4_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the page does not have buffers (for whatever reason),</span>
<span class="cm">	 * try to create them using __block_write_begin.  If this</span>
<span class="cm">	 * fails, redirty the page and move on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					<span class="n">noalloc_get_block_write</span><span class="p">))</span> <span class="p">{</span>
		<span class="nl">redirty_page:</span>
			<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">commit_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">page_bufs</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">walk_page_buffers</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">page_bufs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			      <span class="n">ext4_bh_delay_or_unwritten</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t want to do block allocation, so redirty</span>
<span class="cm">		 * the page and return.  We may reach here when we do</span>
<span class="cm">		 * a journal commit via journal_submit_inode_data_buffers.</span>
<span class="cm">		 * We can also reach here via shrink_page_list but it</span>
<span class="cm">		 * should never be for direct reclaim so warn if that</span>
<span class="cm">		 * happens</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PF_MEMALLOC</span><span class="o">|</span><span class="n">PF_KSWAPD</span><span class="p">))</span> <span class="o">==</span>
								<span class="n">PF_MEMALLOC</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">redirty_page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">commit_write</span><span class="p">)</span>
		<span class="cm">/* now mark the buffer_heads as dirty and uptodate */</span>
		<span class="n">block_commit_write</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s mmapped pagecache.  Add buffers and journal it.  There</span>
<span class="cm">		 * doesn&#39;t seem much point in redirtying the page here.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">__ext4_journalled_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uninit</span><span class="p">(</span><span class="n">page_bufs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext4_set_bh_endio</span><span class="p">(</span><span class="n">page_bufs</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">block_write_full_page_endio</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">noalloc_get_block_write</span><span class="p">,</span>
					    <span class="n">wbc</span><span class="p">,</span> <span class="n">ext4_end_io_buffer_write</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">noalloc_get_block_write</span><span class="p">,</span>
					    <span class="n">wbc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called via ext4_da_writepages() to</span>
<span class="cm"> * calculate the total number of credits to reserve to fit</span>
<span class="cm"> * a single extent allocation into a single transaction,</span>
<span class="cm"> * ext4_da_writpeages() will loop calling this before</span>
<span class="cm"> * the block allocation.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_da_writepages_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_blocks</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * With non-extent format the journal credit needed to</span>
<span class="cm">	 * insert nrblocks contiguous block is dependent on</span>
<span class="cm">	 * number of contiguous block. So we will limit</span>
<span class="cm">	 * number of contiguous block to a sane value</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">max_blocks</span> <span class="o">&gt;</span> <span class="n">EXT4_MAX_TRANS_DATA</span><span class="p">))</span>
		<span class="n">max_blocks</span> <span class="o">=</span> <span class="n">EXT4_MAX_TRANS_DATA</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ext4_chunk_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">max_blocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * write_cache_pages_da - walk the list of dirty pages of the given</span>
<span class="cm"> * address space and accumulate pages that need writing, and call</span>
<span class="cm"> * mpage_da_map_and_submit to map a single contiguous memory region</span>
<span class="cm"> * and then write them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_cache_pages_da</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mpage_da_data</span> <span class="o">*</span><span class="n">mpd</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="o">*</span><span class="n">done_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span>		<span class="n">pvec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">sector_t</span>		<span class="n">logical</span><span class="p">;</span>
	<span class="n">pgoff_t</span>			<span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">nr_to_write</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">mpd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpage_da_data</span><span class="p">));</span>
	<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">wbc</span> <span class="o">=</span> <span class="n">wbc</span><span class="p">;</span>
	<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">||</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">)</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">PAGECACHE_TAG_TOWRITE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">;</span>

	<span class="o">*</span><span class="n">done_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">pagevec_lookup_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
			      <span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/*</span>
<span class="cm">			 * At this point, the page may be truncated or</span>
<span class="cm">			 * invalidated (changing page-&gt;mapping to NULL), or</span>
<span class="cm">			 * even swizzled back from swapper_space to tmpfs file</span>
<span class="cm">			 * mapping. However, page-&gt;index will not change</span>
<span class="cm">			 * because we have a reference on the page.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="o">*</span><span class="n">done_index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we can&#39;t merge this page, and we have</span>
<span class="cm">			 * accumulated an contiguous region, write it</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">next_page</span> <span class="o">!=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">next_page</span> <span class="o">!=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">first_page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mpage_da_map_and_submit</span><span class="p">(</span><span class="n">mpd</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">ret_extent_tail</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the page is no longer dirty, or its</span>
<span class="cm">			 * mapping no longer corresponds to inode we</span>
<span class="cm">			 * are writing (which means it has been</span>
<span class="cm">			 * truncated or invalidated), or the page is</span>
<span class="cm">			 * already under writeback and we are not</span>
<span class="cm">			 * doing a data integrity writeback, skip the page</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_NONE</span><span class="p">))</span> <span class="o">||</span>
			    <span class="n">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">next_page</span> <span class="o">!=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
				<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">first_page</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">next_page</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span>
				<span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mpage_add_bh_to_extent</span><span class="p">(</span><span class="n">mpd</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span>
						       <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span>
						       <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Dirty</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Uptodate</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">io_done</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">ret_extent_tail</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Page with regular buffer heads,</span>
<span class="cm">				 * just add all dirty ones</span>
<span class="cm">				 */</span>
				<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
				<span class="k">do</span> <span class="p">{</span>
					<span class="n">BUG_ON</span><span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
					<span class="cm">/*</span>
<span class="cm">					 * We need to try to allocate</span>
<span class="cm">					 * unmapped blocks in the same page.</span>
<span class="cm">					 * Otherwise we won&#39;t make progress</span>
<span class="cm">					 * with the page in ext4_writepage</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ext4_bh_delay_or_unwritten</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">mpage_add_bh_to_extent</span><span class="p">(</span><span class="n">mpd</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span>
								       <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">,</span>
								       <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">io_done</span><span class="p">)</span>
							<span class="k">goto</span> <span class="n">ret_extent_tail</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span> <span class="p">{</span>
						<span class="cm">/*</span>
<span class="cm">						 * mapped dirty buffer. We need</span>
<span class="cm">						 * to update the b_state</span>
<span class="cm">						 * because we look at b_state</span>
<span class="cm">						 * in mpage_da_map_blocks.  We</span>
<span class="cm">						 * don&#39;t update b_size because</span>
<span class="cm">						 * if we find an unmapped</span>
<span class="cm">						 * buffer_head later we need to</span>
<span class="cm">						 * use the b_state flag of that</span>
<span class="cm">						 * buffer_head.</span>
<span class="cm">						 */</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
							<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">&amp;</span> <span class="n">BH_FLAGS</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">logical</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nr_to_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nr_to_write</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nr_to_write</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				    <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span>
					<span class="cm">/*</span>
<span class="cm">					 * We stop writing back only if we are</span>
<span class="cm">					 * not doing integrity sync. In case of</span>
<span class="cm">					 * integrity sync we have to keep going</span>
<span class="cm">					 * because someone may be concurrently</span>
<span class="cm">					 * dirtying pages, and we might have</span>
<span class="cm">					 * synced a lot of newly appeared dirty</span>
<span class="cm">					 * pages, but have not synced all of the</span>
<span class="cm">					 * old dirty pages.</span>
<span class="cm">					 */</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">ret_extent_tail:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">MPAGE_DA_EXTENT_TAIL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_da_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span>	<span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">range_whole</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mpage_da_data</span> <span class="n">mpd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pages_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">range_cyclic</span><span class="p">,</span> <span class="n">cycled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">io_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needed_blocks</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">desired_nr_to_write</span><span class="p">,</span> <span class="n">nr_to_writebump</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">range_start</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">pgoff_t</span> <span class="n">done_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>

	<span class="n">trace_ext4_da_writepages</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * No pages to write? This is mainly a kludge to avoid starting</span>
<span class="cm">	 * a transaction for special inodes like journal inode on last iput()</span>
<span class="cm">	 * because that could violate lock ordering on umount</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">||</span> <span class="o">!</span><span class="n">mapping_tagged</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the filesystem has aborted, it is read-only, so return</span>
<span class="cm">	 * right away instead of dumping stack traces later on that</span>
<span class="cm">	 * will obscure the real source of the problem.  We test</span>
<span class="cm">	 * EXT4_MF_FS_ABORTED instead of sb-&gt;s_flag&#39;s MS_RDONLY because</span>
<span class="cm">	 * the latter could be true if the filesystem is mounted</span>
<span class="cm">	 * read-only, and in that case, ext4_da_writepages should</span>
<span class="cm">	 * *never* be called, so if that ever happens, we would want</span>
<span class="cm">	 * the stack trace.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_mount_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MF_FS_ABORTED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">==</span> <span class="n">LLONG_MAX</span><span class="p">)</span>
		<span class="n">range_whole</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">range_cyclic</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span>
			<span class="n">cycled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span>  <span class="o">=</span> <span class="n">LLONG_MAX</span><span class="p">;</span>
		<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This works around two forms of stupidity.  The first is in</span>
<span class="cm">	 * the writeback code, which caps the maximum number of pages</span>
<span class="cm">	 * written to be 1024 pages.  This is wrong on multiple</span>
<span class="cm">	 * levels; different architectues have a different page size,</span>
<span class="cm">	 * which changes the maximum amount of data which gets</span>
<span class="cm">	 * written.  Secondly, 4 megabytes is way too small.  XFS</span>
<span class="cm">	 * forces this value to be 16 megabytes by multiplying</span>
<span class="cm">	 * nr_to_write parameter by four, and then relies on its</span>
<span class="cm">	 * allocator to allocate larger extents to make them</span>
<span class="cm">	 * contiguous.  Unfortunately this brings us to the second</span>
<span class="cm">	 * stupidity, which is that ext4&#39;s mballoc code only allocates</span>
<span class="cm">	 * at most 2048 blocks.  So we force contiguous writes up to</span>
<span class="cm">	 * the number of dirty blocks in the inode, or</span>
<span class="cm">	 * sbi-&gt;max_writeback_mb_bump whichever is smaller.</span>
<span class="cm">	 */</span>
	<span class="n">max_pages</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_max_writeback_mb_bump</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">range_cyclic</span> <span class="o">&amp;&amp;</span> <span class="n">range_whole</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">==</span> <span class="n">LONG_MAX</span><span class="p">)</span>
			<span class="n">desired_nr_to_write</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">desired_nr_to_write</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">desired_nr_to_write</span> <span class="o">=</span> <span class="n">ext4_num_dirty_pages</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
							   <span class="n">max_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desired_nr_to_write</span> <span class="o">&gt;</span> <span class="n">max_pages</span><span class="p">)</span>
		<span class="n">desired_nr_to_write</span> <span class="o">=</span> <span class="n">max_pages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&lt;</span> <span class="n">desired_nr_to_write</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_to_writebump</span> <span class="o">=</span> <span class="n">desired_nr_to_write</span> <span class="o">-</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span><span class="p">;</span>
		<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="n">desired_nr_to_write</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">||</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">)</span>
		<span class="n">tag_pages_for_writeback</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * we  insert one extent at a time. So we need</span>
<span class="cm">		 * credit needed for single extent allocation.</span>
<span class="cm">		 * journalled mode is currently not supported</span>
<span class="cm">		 * by delalloc</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="n">needed_blocks</span> <span class="o">=</span> <span class="n">ext4_da_writepages_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="cm">/* start a new transaction*/</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">needed_blocks</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="n">ext4_msg</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">,</span> <span class="s">&quot;%s: jbd2_start: &quot;</span>
			       <span class="s">&quot;%ld pages, ino %lu; err %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_writepages</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Now call write_cache_pages_da() to find the next</span>
<span class="cm">		 * contiguous region of logical blocks that need</span>
<span class="cm">		 * blocks to be allocated by ext4 and submit them.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">write_cache_pages_da</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mpd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done_index</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we have a contiguous extent of pages and we</span>
<span class="cm">		 * haven&#39;t done the I/O yet, map the blocks and submit</span>
<span class="cm">		 * them for I/O.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpd</span><span class="p">.</span><span class="n">io_done</span> <span class="o">&amp;&amp;</span> <span class="n">mpd</span><span class="p">.</span><span class="n">next_page</span> <span class="o">!=</span> <span class="n">mpd</span><span class="p">.</span><span class="n">first_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mpage_da_map_and_submit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpd</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">MPAGE_DA_EXTENT_TAIL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">trace_ext4_da_write_pages</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mpd</span><span class="p">);</span>
		<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">-=</span> <span class="n">mpd</span><span class="p">.</span><span class="n">pages_written</span><span class="p">;</span>

		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mpd</span><span class="p">.</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_journal</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* commit the transaction which would</span>
<span class="cm">			 * free blocks released in the transaction</span>
<span class="cm">			 * and try again</span>
<span class="cm">			 */</span>
			<span class="n">jbd2_journal_force_commit_nested</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_journal</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">MPAGE_DA_EXTENT_TAIL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Got one extent now try with rest of the pages.</span>
<span class="cm">			 * If mpd.retval is set -EIO, journal is aborted.</span>
<span class="cm">			 * So we don&#39;t need to write any more.</span>
<span class="cm">			 */</span>
			<span class="n">pages_written</span> <span class="o">+=</span> <span class="n">mpd</span><span class="p">.</span><span class="n">pages_written</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mpd</span><span class="p">.</span><span class="n">retval</span><span class="p">;</span>
			<span class="n">io_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * There is no more writeout needed</span>
<span class="cm">			 * or we requested for a noblocking writeout</span>
<span class="cm">			 * and we found the device congested</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_done</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cycled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cycled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span>  <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update index */</span>
	<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">=</span> <span class="n">range_cyclic</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">||</span> <span class="p">(</span><span class="n">range_whole</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * set the writeback_index so that range_cyclic</span>
<span class="cm">		 * mode will write it back later</span>
<span class="cm">		 */</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span> <span class="o">=</span> <span class="n">done_index</span><span class="p">;</span>

<span class="nl">out_writepages:</span>
	<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">-=</span> <span class="n">nr_to_writebump</span><span class="p">;</span>
	<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">=</span> <span class="n">range_start</span><span class="p">;</span>
	<span class="n">trace_ext4_da_writepages_result</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">pages_written</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define FALL_BACK_TO_NONDELALLOC 1</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_nonda_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">free_blocks</span><span class="p">,</span> <span class="n">dirty_blocks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * switch to non delalloc mode if we are running low</span>
<span class="cm">	 * on free block. The free block accounting via percpu</span>
<span class="cm">	 * counters can get slightly wrong with percpu_counter_batch getting</span>
<span class="cm">	 * accumulated on each CPU without updating global counters</span>
<span class="cm">	 * Delalloc need an accurate free block accounting. So switch</span>
<span class="cm">	 * to non delalloc when we are near to error range.</span>
<span class="cm">	 */</span>
	<span class="n">free_blocks</span>  <span class="o">=</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span>
		<span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeclusters_counter</span><span class="p">));</span>
	<span class="n">dirty_blocks</span> <span class="o">=</span> <span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dirtyclusters_counter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">free_blocks</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dirty_blocks</span> <span class="o">||</span>
		<span class="n">free_blocks</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">dirty_blocks</span> <span class="o">+</span> <span class="n">EXT4_FREECLUSTERS_WATERMARK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * free block count is less than 150% of dirty blocks</span>
<span class="cm">		 * or free blocks is less than watermark</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Even if we don&#39;t switch but are nearing capacity,</span>
<span class="cm">	 * start pushing delalloc when 1/2 of free blocks are dirty.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dirty_blocks</span><span class="p">)</span>
		<span class="n">writeback_inodes_sb_if_idle</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">WB_REASON_FS_FREE_SPACE</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_da_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			       <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_nonda_switch</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">fsdata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">FALL_BACK_TO_NONDELALLOC</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ext4_write_begin</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
					<span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">fsdata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">trace_ext4_da_write_begin</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">retry:</span>
	<span class="cm">/*</span>
<span class="cm">	 * With delayed allocation, we don&#39;t log the i_disksize update</span>
<span class="cm">	 * if there is delayed block allocation. But we still need</span>
<span class="cm">	 * to journalling the i_disksize update if writes to the end</span>
<span class="cm">	 * of file which has an already mapped buffer.</span>
<span class="cm">	 */</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We cannot recurse into the filesystem as the transaction is already</span>
<span class="cm">	 * started */</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">AOP_FLAG_NOFS</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ext4_da_get_block_prep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * block_write_begin may have instantiated a few blocks</span>
<span class="cm">		 * outside i_size.  Trim these off again. Don&#39;t need</span>
<span class="cm">		 * i_size_read because we hold i_mutex.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
			<span class="n">ext4_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_should_retry_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if we should update i_disksize</span>
<span class="cm"> * when write to the end of file but not require block allocation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_da_should_update_i_disksize</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="o">||</span> <span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_da_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			     <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_current_handle</span><span class="p">();</span>
	<span class="n">loff_t</span> <span class="n">new_i_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_mode</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fsdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write_mode</span> <span class="o">==</span> <span class="n">FALL_BACK_TO_NONDELALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ext4_inode_journal_mode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">EXT4_INODE_ORDERED_DATA_MODE</span>:
			<span class="k">return</span> <span class="n">ext4_ordered_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
					<span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">EXT4_INODE_WRITEBACK_DATA_MODE</span>:
			<span class="k">return</span> <span class="n">ext4_writeback_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
					<span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">trace_ext4_da_write_end</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">copied</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * generic_write_end() will run mark_inode_dirty() if i_size</span>
<span class="cm">	 * changes.  So let&#39;s piggyback the i_disksize mark_inode_dirty</span>
<span class="cm">	 * into that.</span>
<span class="cm">	 */</span>

	<span class="n">new_i_size</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&amp;&amp;</span> <span class="n">new_i_size</span> <span class="o">&gt;</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_da_should_update_i_disksize</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_i_size</span> <span class="o">&gt;</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Updating i_disksize when extending file</span>
<span class="cm">				 * without needing block allocation</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_order_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_jbd2_file_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
								   <span class="n">inode</span><span class="p">);</span>

				<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">new_i_size</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
			<span class="cm">/* We need to mark inode dirty even if</span>
<span class="cm">			 * new_i_size is less that inode-&gt;i_size</span>
<span class="cm">			 * bu greater than i_disksize.(hint delalloc)</span>
<span class="cm">			 */</span>
			<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret2</span> <span class="o">=</span> <span class="n">generic_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span>
							<span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_da_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Drop reserved blocks</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ext4_da_page_release_reservation</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">ext4_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Force all delayed allocation blocks to be allocated for a given inode.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_alloc_da_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_ext4_alloc_da_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_reserved_meta_blocks</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do something simple for now.  The filemap_flush() will</span>
<span class="cm">	 * also start triggering a write of the data blocks, which is</span>
<span class="cm">	 * not strictly speaking necessary (and for users of</span>
<span class="cm">	 * laptop_mode, not even desirable).  However, to do otherwise</span>
<span class="cm">	 * would require replicating code paths in:</span>
<span class="cm">	 *</span>
<span class="cm">	 * ext4_da_writepages() -&gt;</span>
<span class="cm">	 *    write_cache_pages() ---&gt; (via passed in callback function)</span>
<span class="cm">	 *        __mpage_da_writepage() --&gt;</span>
<span class="cm">	 *           mpage_add_bh_to_extent()</span>
<span class="cm">	 *           mpage_da_map_blocks()</span>
<span class="cm">	 *</span>
<span class="cm">	 * The problem is that write_cache_pages(), located in</span>
<span class="cm">	 * mm/page-writeback.c, marks pages clean in preparation for</span>
<span class="cm">	 * doing I/O, which is not desirable if we&#39;re not planning on</span>
<span class="cm">	 * doing I/O at all.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We could call write_cache_pages(), and then redirty all of</span>
<span class="cm">	 * the pages by calling redirty_page_for_writepage() but that</span>
<span class="cm">	 * would be ugly in the extreme.  So instead we would need to</span>
<span class="cm">	 * replicate parts of the code in the above functions,</span>
<span class="cm">	 * simplifying them because we wouldn&#39;t actually intend to</span>
<span class="cm">	 * write out the pages, but rather only collect contiguous</span>
<span class="cm">	 * logical block extents, call the multi-block allocator, and</span>
<span class="cm">	 * then update the buffer heads with the block allocations.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For now, though, we&#39;ll cheat by calling filemap_flush(),</span>
<span class="cm">	 * which will map the blocks, and start the I/O, but not</span>
<span class="cm">	 * actually wait for the I/O to complete.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">filemap_flush</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bmap() is special.  It gets used by applications such as lilo and by</span>
<span class="cm"> * the swapper to find the on-disk block of a specific piece of data.</span>
<span class="cm"> *</span>
<span class="cm"> * Naturally, this is dangerous if the block concerned is still in the</span>
<span class="cm"> * journal.  If somebody makes a swapfile on an ext4 data-journaling</span>
<span class="cm"> * filesystem and enables swap, then they may get a nasty shock when the</span>
<span class="cm"> * data getting swapped to that swapfile suddenly gets overwritten by</span>
<span class="cm"> * the original zero&#39;s written out previously to the journal and</span>
<span class="cm"> * awaiting writeback in the kernel&#39;s buffer cache.</span>
<span class="cm"> *</span>
<span class="cm"> * So, if we see any bmap calls here on a modified, data-journaled file,</span>
<span class="cm"> * take extra steps to flush any blocks which might be in the cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">ext4_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping_tagged</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DELALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * With delalloc we want to sync the file</span>
<span class="cm">		 * so that we can make sure we allocate</span>
<span class="cm">		 * blocks for file</span>
<span class="cm">		 */</span>
		<span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ext4_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_JDATA</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is a REALLY heavyweight approach, but the use of</span>
<span class="cm">		 * bmap on dirty files is expected to be extremely rare:</span>
<span class="cm">		 * only if we run lilo or swapon on a freshly made file</span>
<span class="cm">		 * do we expect this to happen.</span>
<span class="cm">		 *</span>
<span class="cm">		 * (bmap requires CAP_SYS_RAWIO so this does not</span>
<span class="cm">		 * represent an unprivileged user DOS attack --- we&#39;d be</span>
<span class="cm">		 * in trouble if mortal users could trigger this path at</span>
<span class="cm">		 * will.)</span>
<span class="cm">		 *</span>
<span class="cm">		 * NB. EXT4_STATE_JDATA is not set on files other than</span>
<span class="cm">		 * regular files.  If somebody wants to bmap a directory</span>
<span class="cm">		 * or symlink and gets confused because the buffer</span>
<span class="cm">		 * hasn&#39;t yet been flushed to disk, they deserve</span>
<span class="cm">		 * everything they get.</span>
<span class="cm">		 */</span>

		<span class="n">ext4_clear_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_JDATA</span><span class="p">);</span>
		<span class="n">journal</span> <span class="o">=</span> <span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">jbd2_journal_lock_updates</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">jbd2_journal_flush</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">jbd2_journal_unlock_updates</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">generic_block_bmap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">ext4_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_ext4_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mpage_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ext4_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ext4_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_readpages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">ext4_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_invalidatepage_free_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">curr_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">curr_off</span> <span class="o">&amp;&amp;</span> <span class="n">test_clear_buffer_uninit</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_free_io_end</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">);</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">curr_off</span> <span class="o">=</span> <span class="n">curr_off</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">trace_ext4_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * free any io_end structure allocated for buffers to be discarded</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_dioread_nolock</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">))</span>
		<span class="n">ext4_invalidatepage_free_endio</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If it&#39;s a full truncate we just forget about the pending dirtying</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="p">)</span>
		<span class="n">jbd2_journal_invalidatepage</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">block_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_releasepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">trace_ext4_releasepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">jbd2_journal_try_to_free_buffers</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_get_block used when preparing for a DIO write or buffer write.</span>
<span class="cm"> * We allocate an uinitialized extent if blocks haven&#39;t been allocated.</span>
<span class="cm"> * The extent will be converted to initialized after the IO is complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_get_block_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_debug</span><span class="p">(</span><span class="s">&quot;ext4_get_block_write: inode %lu, create flag %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">_ext4_get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span>
			       <span class="n">EXT4_GET_BLOCKS_IO_CREATE_EXT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_end_io_dio</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			    <span class="kt">ssize_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="n">is_async</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
        <span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">io_end</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>

	<span class="cm">/* if not async direct IO or dio with 0 bytes write, just return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_end</span> <span class="o">||</span> <span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;ext4_end_io_dio(): io_end 0x%p &quot;</span>
		  <span class="s">&quot;for inode %lu, iocb 0x%p, offset %llu, size %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
 		  <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="n">io_end</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
		  <span class="n">size</span><span class="p">);</span>

	<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* if not aio dio with unwritten extents, just free io and return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">EXT4_IO_END_UNWRITTEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext4_free_io_end</span><span class="p">(</span><span class="n">io_end</span><span class="p">);</span>
<span class="nl">out:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_async</span><span class="p">)</span>
			<span class="n">aio_complete</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">inode_dio_done</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">io_end</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">io_end</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_async</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_end</span><span class="o">-&gt;</span><span class="n">iocb</span> <span class="o">=</span> <span class="n">iocb</span><span class="p">;</span>
		<span class="n">io_end</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dio_unwritten_wq</span><span class="p">;</span>

	<span class="cm">/* Add the io_end to per-inode completed aio dio list*/</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_completed_io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_completed_io_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_completed_io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* queue the work to convert unwritten extents to written */</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_end_io_buffer_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">io_end</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_clear_buffer_uninit</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">io_end</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext4_msg</span><span class="p">(</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span>
			 <span class="s">&quot;sb umounted, discard end_io request for inode %lu&quot;</span><span class="p">,</span>
			 <span class="n">io_end</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">ext4_free_io_end</span><span class="p">(</span><span class="n">io_end</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It may be over-defensive here to check EXT4_IO_END_UNWRITTEN now,</span>
<span class="cm">	 * but being more careful is always safe for the future change.</span>
<span class="cm">	 */</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">io_end</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">ext4_set_io_unwritten_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">io_end</span><span class="p">);</span>

	<span class="cm">/* Add the io_end to per-inode completed io list*/</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_completed_io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_completed_io_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_completed_io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wq</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dio_unwritten_wq</span><span class="p">;</span>
	<span class="cm">/* queue the work to convert unwritten extents to written */</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">clear_buffer_uninit</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">end_buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">uptodate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_set_bh_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">io_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">io_end</span> <span class="o">=</span> <span class="n">ext4_init_io_end</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;%s: allocation fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">io_end</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">io_end</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to hold a reference to the page to make sure it</span>
<span class="cm">	 * doesn&#39;t get evicted before ext4_end_io_work() has a chance</span>
<span class="cm">	 * to convert the extent from written to unwritten.</span>
<span class="cm">	 */</span>
	<span class="n">io_end</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">io_end</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">ext4_end_io_buffer_write</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For ext4 extent files, ext4 will do direct-io write to holes,</span>
<span class="cm"> * preallocated extents, and those write extend the file, no need to</span>
<span class="cm"> * fall back to buffered IO.</span>
<span class="cm"> *</span>
<span class="cm"> * For holes, we fallocate those blocks, mark them as uninitialized</span>
<span class="cm"> * If those blocks were preallocated, we mark sure they are splited, but</span>
<span class="cm"> * still keep the range to write as uninitialized.</span>
<span class="cm"> *</span>
<span class="cm"> * The unwrritten extents will be converted to written when DIO is completed.</span>
<span class="cm"> * For async direct IO, since the IO may still pending when return, we</span>
<span class="cm"> * set up an end_io call back function, which will do the conversion</span>
<span class="cm"> * when async direct IO completed.</span>
<span class="cm"> *</span>
<span class="cm"> * If the O_DIRECT write will extend the file then add this inode to the</span>
<span class="cm"> * orphan list.  So recovery will truncate it back to the original size</span>
<span class="cm"> * if the machine crashes during the write.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ext4_ext_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>

	<span class="n">loff_t</span> <span class="n">final_size</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span> <span class="o">&amp;&amp;</span> <span class="n">final_size</span> <span class="o">&lt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm"> 		 * We could direct write to holes and fallocate.</span>
<span class="cm">		 *</span>
<span class="cm"> 		 * Allocated blocks to fill the hole are marked as uninitialized</span>
<span class="cm"> 		 * to prevent parallel buffered read to expose the stale data</span>
<span class="cm"> 		 * before DIO complete the data IO.</span>
<span class="cm">		 *</span>
<span class="cm"> 		 * As to previously fallocated extents, ext4 get_block</span>
<span class="cm"> 		 * will just simply mark the buffer mapped but still</span>
<span class="cm"> 		 * keep the extents uninitialized.</span>
<span class="cm"> 		 *</span>
<span class="cm">		 * for non AIO case, we will convert those unwritten extents</span>
<span class="cm">		 * to written after return back from blockdev_direct_IO.</span>
<span class="cm">		 *</span>
<span class="cm">		 * for async DIO, the conversion needs to be defered when</span>
<span class="cm">		 * the IO is completed. The ext4 end_io callback function</span>
<span class="cm">		 * will be called to take care of the conversion work.</span>
<span class="cm">		 * Here for async case, we allocate an io_end structure to</span>
<span class="cm">		 * hook to the iocb.</span>
<span class="cm"> 		 */</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_aio_dio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sync_kiocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">io_end</span> <span class="o">=</span>
				<span class="n">ext4_init_io_end</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_end</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">io_end</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">EXT4_IO_END_DIRECT</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">io_end</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * we save the io structure for current async</span>
<span class="cm">			 * direct IO, so that later ext4_map_blocks()</span>
<span class="cm">			 * could flag the io structure whether there</span>
<span class="cm">			 * is a unwritten extents needs to be converted</span>
<span class="cm">			 * when IO is completed.</span>
<span class="cm">			 */</span>
			<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_aio_dio</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">__blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					 <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
					 <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
					 <span class="n">ext4_get_block_write</span><span class="p">,</span>
					 <span class="n">ext4_end_io_dio</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">,</span>
					 <span class="n">DIO_LOCKING</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span>
			<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_aio_dio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The io_end structure takes a reference to the inode,</span>
<span class="cm">		 * that structure needs to be destroyed and the</span>
<span class="cm">		 * reference to the inode need to be dropped, when IO is</span>
<span class="cm">		 * complete, even with 0 byte write, or failed.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In the successful AIO DIO case, the io_end structure will be</span>
<span class="cm">		 * desctroyed and the reference to the inode will be dropped</span>
<span class="cm">		 * after the end_io call back function is called.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In the case there is 0 byte write, or error case, since</span>
<span class="cm">		 * VFS direct IO won&#39;t invoke the end_io call back function,</span>
<span class="cm">		 * we need to free the end_io structure here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_free_io_end</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						<span class="n">EXT4_STATE_DIO_UNWRITTEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * for non AIO case, since the IO is already</span>
<span class="cm">			 * completed, we could do the conversion right here</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_convert_unwritten_extents</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
							     <span class="n">offset</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">ext4_clear_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_DIO_UNWRITTEN</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* for write the the end of file case, we fall back to old way */</span>
	<span class="k">return</span> <span class="n">ext4_ind_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ext4_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are doing data journalling we don&#39;t support O_DIRECT</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_ext4_direct_IO_enter</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">),</span> <span class="n">rw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_ext_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_ind_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
	<span class="n">trace_ext4_direct_IO_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">),</span> <span class="n">rw</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pages can be marked dirty completely asynchronously from ext4&#39;s journalling</span>
<span class="cm"> * activity.  By filemap_sync_pte(), try_to_unmap_one(), etc.  We cannot do</span>
<span class="cm"> * much here because -&gt;set_page_dirty is called under VFS locks.  The page is</span>
<span class="cm"> * not necessarily locked.</span>
<span class="cm"> *</span>
<span class="cm"> * We cannot just dirty the page and leave attached buffers clean, because the</span>
<span class="cm"> * buffers&#39; dirty state is &quot;definitive&quot;.  We cannot just set the buffers dirty</span>
<span class="cm"> * or jbddirty because all the journalling code will explode.</span>
<span class="cm"> *</span>
<span class="cm"> * So what we do is to mark the page &quot;pending dirty&quot; and next time writepage</span>
<span class="cm"> * is called, propagate that into the buffers appropriately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_journalled_set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext4_ordered_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext4_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext4_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">ext4_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">ext4_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">ext4_ordered_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext4_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span>		<span class="o">=</span> <span class="n">ext4_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>		<span class="o">=</span> <span class="n">ext4_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">ext4_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">migratepage</span>		<span class="o">=</span> <span class="n">buffer_migrate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>  <span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext4_writeback_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext4_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext4_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">ext4_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">ext4_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">ext4_writeback_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext4_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span>		<span class="o">=</span> <span class="n">ext4_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>		<span class="o">=</span> <span class="n">ext4_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">ext4_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">migratepage</span>		<span class="o">=</span> <span class="n">buffer_migrate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>  <span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext4_journalled_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext4_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext4_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">ext4_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">ext4_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">ext4_journalled_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_page_dirty</span>		<span class="o">=</span> <span class="n">ext4_journalled_set_page_dirty</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext4_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span>		<span class="o">=</span> <span class="n">ext4_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>		<span class="o">=</span> <span class="n">ext4_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">ext4_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>  <span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext4_da_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext4_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext4_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">ext4_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepages</span>		<span class="o">=</span> <span class="n">ext4_da_writepages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">ext4_da_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">ext4_da_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext4_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span>		<span class="o">=</span> <span class="n">ext4_da_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>		<span class="o">=</span> <span class="n">ext4_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">ext4_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">migratepage</span>		<span class="o">=</span> <span class="n">buffer_migrate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>  <span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">ext4_set_aops</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ext4_inode_journal_mode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EXT4_INODE_ORDERED_DATA_MODE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DELALLOC</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_da_aops</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_ordered_aops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXT4_INODE_WRITEBACK_DATA_MODE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DELALLOC</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_da_aops</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_writeback_aops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXT4_INODE_JOURNAL_DATA_MODE</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_journalled_aops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ext4_discard_partial_page_buffers()</span>
<span class="cm"> * Wrapper function for ext4_discard_partial_page_buffers_no_lock.</span>
<span class="cm"> * This function finds and locks the page containing the offset</span>
<span class="cm"> * &quot;from&quot; and passes it to ext4_discard_partial_page_buffers_no_lock.</span>
<span class="cm"> * Calling functions that already have the page locked should call</span>
<span class="cm"> * ext4_discard_partial_page_buffers_no_lock directly.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_discard_partial_page_buffers</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
				   <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_FS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_discard_partial_page_buffers_no_lock</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
		<span class="n">from</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_discard_partial_page_buffers_no_lock()</span>
<span class="cm"> * Zeros a page range of length &#39;length&#39; starting from offset &#39;from&#39;.</span>
<span class="cm"> * Buffer heads that correspond to the block aligned regions of the</span>
<span class="cm"> * zeroed range will be unmapped.  Unblock aligned regions</span>
<span class="cm"> * will have the corresponding buffer head mapped if needed so that</span>
<span class="cm"> * that region of the page can be updated with the partial zero out.</span>
<span class="cm"> *</span>
<span class="cm"> * This function assumes that the page has already been  locked.  The</span>
<span class="cm"> * The range to be discarded must be contained with in the given page.</span>
<span class="cm"> * If the specified range exceeds the end of the page it will be shortened</span>
<span class="cm"> * to the end of the page that corresponds to &#39;from&#39;.  This function is</span>
<span class="cm"> * appropriate for updating a page and it buffer heads to be unmapped and</span>
<span class="cm"> * zeroed for blocks that have been either released, or are going to be</span>
<span class="cm"> * released.</span>
<span class="cm"> *</span>
<span class="cm"> * handle: The journal handle</span>
<span class="cm"> * inode:  The files inode</span>
<span class="cm"> * page:   A locked page that contains the offset &quot;from&quot;</span>
<span class="cm"> * from:   The starting byte offset (from the begining of the file)</span>
<span class="cm"> *         to begin discarding</span>
<span class="cm"> * len:    The length of bytes to discard</span>
<span class="cm"> * flags:  Optional flags that may be used:</span>
<span class="cm"> *</span>
<span class="cm"> *         EXT4_DISCARD_PARTIAL_PG_ZERO_UNMAPPED</span>
<span class="cm"> *         Only zero the regions of the page whose buffer heads</span>
<span class="cm"> *         have already been unmapped.  This flag is appropriate</span>
<span class="cm"> *         for updateing the contents of a page whose blocks may</span>
<span class="cm"> *         have already been released, and we only want to zero</span>
<span class="cm"> *         out the regions that correspond to those released blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on sucess or negative on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_discard_partial_page_buffers_no_lock</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">iblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * correct length if it does not fall between</span>
<span class="cm">	 * &#39;from&#39; and the end of the page</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

	<span class="n">iblock</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Find the buffer that contains &quot;offset&quot; */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">iblock</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end_of_block</span><span class="p">,</span> <span class="n">range_to_discard</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* The length of space left to zero and unmap */</span>
		<span class="n">range_to_discard</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">length</span> <span class="o">-</span> <span class="n">pos</span><span class="p">;</span>

		<span class="cm">/* The length of space until the end of the block */</span>
		<span class="n">end_of_block</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do not unmap or zero past end of block</span>
<span class="cm">		 * for this buffer head</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range_to_discard</span> <span class="o">&gt;</span> <span class="n">end_of_block</span><span class="p">)</span>
			<span class="n">range_to_discard</span> <span class="o">=</span> <span class="n">end_of_block</span><span class="p">;</span>


		<span class="cm">/*</span>
<span class="cm">		 * Skip this buffer head if we are only zeroing unampped</span>
<span class="cm">		 * regions of the page</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_DISCARD_PARTIAL_PG_ZERO_UNMAPPED</span> <span class="o">&amp;&amp;</span>
			<span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="cm">/* If the range is block aligned, unmap */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range_to_discard</span> <span class="o">==</span> <span class="n">blocksize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">clear_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_req</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">range_to_discard</span><span class="p">);</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;Buffer discarded&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this block is not completely contained in the range</span>
<span class="cm">		 * to be discarded, then it is not going to be released. Because</span>
<span class="cm">		 * we need to keep this block, we need to make sure this part</span>
<span class="cm">		 * of the page is uptodate before we modify it by writeing</span>
<span class="cm">		 * partial zeros on it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Buffer head must be mapped before we can read</span>
<span class="cm">			 * from the block</span>
<span class="cm">			 */</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;unmapped&quot;</span><span class="p">);</span>
			<span class="n">ext4_get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* unmapped? It&#39;s a hole - nothing to do */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;still unmapped&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Ok, it&#39;s mapped. Make sure it&#39;s up-to-date */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="cm">/* Uhhuh. Read error. Complain and punt.*/</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get write access&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">range_to_discard</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;Partial buffer zeroed&quot;</span><span class="p">);</span>
<span class="nl">next:</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">iblock</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">range_to_discard</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext4_can_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">ext4_inode_is_fast_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_punch_hole: punches a hole in a file by releaseing the blocks</span>
<span class="cm"> * associated with the given offset and length</span>
<span class="cm"> *</span>
<span class="cm"> * @inode:  File inode</span>
<span class="cm"> * @offset: The offset where the hole will begin</span>
<span class="cm"> * @len:    The length of the hole</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on sucess or negative on failure</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ext4_punch_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* TODO: Add support for non extent hole punching */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TODO: Add support for bigalloc file systems */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ext4_ext_punch_hole</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_truncate()</span>
<span class="cm"> *</span>
<span class="cm"> * We block out ext4_get_block() block instantiations across the entire</span>
<span class="cm"> * transaction, and VFS/VM ensures that ext4_truncate() cannot run</span>
<span class="cm"> * simultaneously on behalf of the same inode.</span>
<span class="cm"> *</span>
<span class="cm"> * As we work through the truncate and commit bits of it to the journal there</span>
<span class="cm"> * is one core, guiding principle: the file&#39;s tree must always be consistent on</span>
<span class="cm"> * disk.  We must be able to restart the truncate after a crash.</span>
<span class="cm"> *</span>
<span class="cm"> * The file&#39;s tree may be transiently inconsistent in memory (although it</span>
<span class="cm"> * probably isn&#39;t), but whenever we close off and commit a journal transaction,</span>
<span class="cm"> * the contents of (the filesystem + the journal) must be consistent and</span>
<span class="cm"> * restartable.  It&#39;s pretty simple, really: bottom up, right to left (although</span>
<span class="cm"> * left-to-right works OK too).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that at recovery time, journal replay occurs *before* the restart of</span>
<span class="cm"> * truncate against the orphan inode list.</span>
<span class="cm"> *</span>
<span class="cm"> * The committed inode has the new, desired i_size (which is the same as</span>
<span class="cm"> * i_disksize in this case).  After a crash, ext4_orphan_cleanup() will see</span>
<span class="cm"> * that this inode&#39;s truncate did not complete and it will again call</span>
<span class="cm"> * ext4_truncate() to have another go.  So there will be instantiated blocks</span>
<span class="cm"> * to the right of the truncation point in a crashed ext4 filesystem.  But</span>
<span class="cm"> * that&#39;s fine - as long as they are linked from the inode, the post-crash</span>
<span class="cm"> * ext4_truncate() run will find them and release them.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext4_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_ext4_truncate_enter</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ext4_clear_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EOFBLOCKS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NO_AUTO_DA_ALLOC</span><span class="p">))</span>
		<span class="n">ext4_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_DA_ALLOC_CLOSE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">))</span>
		<span class="n">ext4_ext_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ext4_ind_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">trace_ext4_truncate_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_get_inode_loc returns with an extra refcount against the inode&#39;s</span>
<span class="cm"> * underlying buffer_head on success. If &#39;in_mem&#39; is true, we have all</span>
<span class="cm"> * data in memory that is needed to recreate the on-disk version of this</span>
<span class="cm"> * inode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ext4_get_inode_loc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_mem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_group_desc</span>	<span class="o">*</span><span class="n">gdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span>	<span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span>		<span class="n">block</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">inodes_per_block</span><span class="p">,</span> <span class="n">inode_offset</span><span class="p">;</span>

	<span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_valid_inum</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">iloc</span><span class="o">-&gt;</span><span class="n">block_group</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">EXT4_INODES_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext4_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">iloc</span><span class="o">-&gt;</span><span class="n">block_group</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out the offset within the block group inode table</span>
<span class="cm">	 */</span>
	<span class="n">inodes_per_block</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_inodes_per_block</span><span class="p">;</span>
	<span class="n">inode_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
			<span class="n">EXT4_INODES_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">ext4_inode_table</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">gdp</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">inode_offset</span> <span class="o">/</span> <span class="n">inodes_per_block</span><span class="p">);</span>
	<span class="n">iloc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode_offset</span> <span class="o">%</span> <span class="n">inodes_per_block</span><span class="p">)</span> <span class="o">*</span> <span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
				       <span class="s">&quot;unable to read itable block&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the buffer has the write error flag, we have failed</span>
<span class="cm">		 * to write out another inode in the same block.  In this</span>
<span class="cm">		 * case, we don&#39;t have to read the block because we may</span>
<span class="cm">		 * read the old inode data successfully.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* someone brought it uptodate while we waited */</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">has_buffer</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we have all information of the inode in memory and this</span>
<span class="cm">		 * is the only valid inode in the block, we need not read the</span>
<span class="cm">		 * block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_mem</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>

			<span class="n">start</span> <span class="o">=</span> <span class="n">inode_offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">inodes_per_block</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* Is the inode bitmap in cache? */</span>
			<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_inode_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">gdp</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">make_io</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the inode bitmap isn&#39;t in cache then the</span>
<span class="cm">			 * optimisation may end up performing two reads instead</span>
<span class="cm">			 * of one, so skip it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">make_io</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">inodes_per_block</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">inode_offset</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">start</span> <span class="o">+</span> <span class="n">inodes_per_block</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* all other inodes are free, so skip I/O */</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">has_buffer</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

<span class="nl">make_io:</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we need to do any I/O, try to pre-readahead extra</span>
<span class="cm">		 * blocks from the inode table.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_inode_readahead_blks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_fsblk_t</span> <span class="n">b</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">table</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">num</span><span class="p">;</span>

			<span class="n">table</span> <span class="o">=</span> <span class="n">ext4_inode_table</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">gdp</span><span class="p">);</span>
			<span class="cm">/* s_inode_readahead_blks is always a power of 2 */</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_inode_readahead_blks</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
				<span class="n">b</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_inode_readahead_blks</span><span class="p">;</span>
			<span class="n">num</span> <span class="o">=</span> <span class="n">EXT4_INODES_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext4_has_group_desc_csum</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
				<span class="n">num</span> <span class="o">-=</span> <span class="n">ext4_itable_unused_count</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">gdp</span><span class="p">);</span>
			<span class="n">table</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">inodes_per_block</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">table</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span>
				<span class="n">sb_breadahead</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">b</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * There are other valid inodes in the buffer, this inode</span>
<span class="cm">		 * has in-inode xattrs, or we don&#39;t have this inode in memory.</span>
<span class="cm">		 * Read the block from disk.</span>
<span class="cm">		 */</span>
		<span class="n">trace_ext4_load_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_sync</span><span class="p">;</span>
		<span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span> <span class="o">|</span> <span class="n">REQ_META</span> <span class="o">|</span> <span class="n">REQ_PRIO</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
					       <span class="s">&quot;unable to read itable block&quot;</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">has_buffer:</span>
	<span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext4_get_inode_loc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We have all inode data except xattrs in memory here. */</span>
	<span class="k">return</span> <span class="n">__ext4_get_inode_loc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iloc</span><span class="p">,</span>
		<span class="o">!</span><span class="n">ext4_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_XATTR</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ext4_set_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">S_SYNC</span><span class="o">|</span><span class="n">S_APPEND</span><span class="o">|</span><span class="n">S_IMMUTABLE</span><span class="o">|</span><span class="n">S_NOATIME</span><span class="o">|</span><span class="n">S_DIRSYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_SYNC_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_SYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_APPEND_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_APPEND</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_IMMUTABLE_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_IMMUTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_NOATIME_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOATIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_DIRSYNC_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DIRSYNC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Propagate flags from i_flags to EXT4_I(inode)-&gt;i_flags */</span>
<span class="kt">void</span> <span class="nf">ext4_get_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vfs_fl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_fl</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">vfs_fl</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_flags</span><span class="p">;</span>
		<span class="n">old_fl</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">;</span>
		<span class="n">new_fl</span> <span class="o">=</span> <span class="n">old_fl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">EXT4_SYNC_FL</span><span class="o">|</span><span class="n">EXT4_APPEND_FL</span><span class="o">|</span>
				<span class="n">EXT4_IMMUTABLE_FL</span><span class="o">|</span><span class="n">EXT4_NOATIME_FL</span><span class="o">|</span>
				<span class="n">EXT4_DIRSYNC_FL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vfs_fl</span> <span class="o">&amp;</span> <span class="n">S_SYNC</span><span class="p">)</span>
			<span class="n">new_fl</span> <span class="o">|=</span> <span class="n">EXT4_SYNC_FL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vfs_fl</span> <span class="o">&amp;</span> <span class="n">S_APPEND</span><span class="p">)</span>
			<span class="n">new_fl</span> <span class="o">|=</span> <span class="n">EXT4_APPEND_FL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vfs_fl</span> <span class="o">&amp;</span> <span class="n">S_IMMUTABLE</span><span class="p">)</span>
			<span class="n">new_fl</span> <span class="o">|=</span> <span class="n">EXT4_IMMUTABLE_FL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vfs_fl</span> <span class="o">&amp;</span> <span class="n">S_NOATIME</span><span class="p">)</span>
			<span class="n">new_fl</span> <span class="o">|=</span> <span class="n">EXT4_NOATIME_FL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vfs_fl</span> <span class="o">&amp;</span> <span class="n">S_DIRSYNC</span><span class="p">)</span>
			<span class="n">new_fl</span> <span class="o">|=</span> <span class="n">EXT4_DIRSYNC_FL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">,</span> <span class="n">old_fl</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old_fl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">blkcnt_t</span> <span class="nf">ext4_inode_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">blkcnt_t</span> <span class="n">i_blocks</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				<span class="n">EXT4_FEATURE_RO_COMPAT_HUGE_FILE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we are using combined 48 bit field */</span>
		<span class="n">i_blocks</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks_high</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span> <span class="o">|</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks_lo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_HUGE_FILE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* i_blocks represent file system block size */</span>
			<span class="k">return</span> <span class="n">i_blocks</span>  <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">i_blocks</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks_lo</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ext4_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="n">iloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_journal</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">i_uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">i_gid</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">iloc</span><span class="p">.</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__ext4_get_inode_loc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
	<span class="n">raw_inode</span> <span class="o">=</span> <span class="n">ext4_raw_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_GOOD_OLD_INODE_SIZE</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">&gt;</span>
		    <span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;bad extra_isize (%u != %u)&quot;</span><span class="p">,</span>
				<span class="n">EXT4_GOOD_OLD_INODE_SIZE</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">,</span>
				<span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Precompute checksum seed for inode metadata */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
			<span class="n">EXT4_FEATURE_RO_COMPAT_METADATA_CSUM</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">__u32</span> <span class="n">csum</span><span class="p">;</span>
		<span class="n">__le32</span> <span class="n">inum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">__le32</span> <span class="n">gen</span> <span class="o">=</span> <span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">;</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="n">ext4_chksum</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_csum_seed</span><span class="p">,</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">inum</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="n">inum</span><span class="p">));</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_csum_seed</span> <span class="o">=</span> <span class="n">ext4_chksum</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">gen</span><span class="p">,</span>
					      <span class="k">sizeof</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_inode_csum_verify</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">,</span> <span class="n">ei</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;checksum invalid&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">i_uid</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_low</span><span class="p">);</span>
	<span class="n">i_gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_low</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NO_UID32</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">i_uid</span> <span class="o">|=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">i_gid</span> <span class="o">|=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i_uid_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_uid</span><span class="p">);</span>
	<span class="n">i_gid_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_gid</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_links_count</span><span class="p">));</span>

	<span class="n">ext4_clear_state_flags</span><span class="p">(</span><span class="n">ei</span><span class="p">);</span>	<span class="cm">/* Only relevant on 32-bit archs */</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dir_start_lookup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">);</span>
	<span class="cm">/* We now have enough fields to check if the inode was active or not.</span>
<span class="cm">	 * This is needed because nfsd might try to access dead inodes</span>
<span class="cm">	 * the test is that same one that e2fsck uses</span>
<span class="cm">	 * NeilBrown 1999oct15</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_mount_state</span> <span class="o">&amp;</span> <span class="n">EXT4_ORPHAN_FS</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* this inode is deleted */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* The only unlinked inodes we let through here have</span>
<span class="cm">		 * valid i_mode and are being read by the orphan</span>
<span class="cm">		 * recovery code: that&#39;s fine, we&#39;re about to complete</span>
<span class="cm">		 * the process of deleting those. */</span>
	<span class="p">}</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">ext4_inode_blocks</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_file_acl_lo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">EXT4_FEATURE_INCOMPAT_64BIT</span><span class="p">))</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">|=</span>
			<span class="p">((</span><span class="n">__u64</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_file_acl_high</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">ext4_isize</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_quota</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_group</span> <span class="o">=</span> <span class="n">iloc</span><span class="p">.</span><span class="n">block_group</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_last_alloc_group</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * NOTE! The in-memory inode i_data array is in little-endian order</span>
<span class="cm">	 * even on big-endian machines: we do NOT byteswap the block numbers!</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">EXT4_N_BLOCKS</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_orphan</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set transaction id&#39;s of transactions that have to be committed</span>
<span class="cm">	 * to finish f[data]sync. We set them to currently running transaction</span>
<span class="cm">	 * as we cannot be sure that the inode or some of its metadata isn&#39;t</span>
<span class="cm">	 * part of the transaction - the inode could have been reclaimed and</span>
<span class="cm">	 * now it is reread from disk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
		<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>

		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span>
			<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="p">)</span>
			<span class="n">tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tid</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">;</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_sync_tid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The extra space is currently unused. Use it. */</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_inode</span><span class="p">)</span> <span class="o">-</span>
					    <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="o">*</span><span class="n">magic</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_inode</span> <span class="o">+</span>
					<span class="n">EXT4_GOOD_OLD_INODE_SIZE</span> <span class="o">+</span>
					<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXT4_XATTR_MAGIC</span><span class="p">))</span>
				<span class="n">ext4_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_XATTR</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">EXT4_INODE_GET_XTIME</span><span class="p">(</span><span class="n">i_ctime</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
	<span class="n">EXT4_INODE_GET_XTIME</span><span class="p">(</span><span class="n">i_mtime</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
	<span class="n">EXT4_INODE_GET_XTIME</span><span class="p">(</span><span class="n">i_atime</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
	<span class="n">EXT4_EINODE_GET_XTIME</span><span class="p">(</span><span class="n">i_crtime</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_disk_version</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_FITS_IN_INODE</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">i_version_hi</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">|=</span>
			<span class="p">(</span><span class="n">__u64</span><span class="p">)(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_version_hi</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ext4_data_block_valid</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;bad extended attribute block %llu&quot;</span><span class="p">,</span>
				 <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">ext4_inode_is_fast_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
			<span class="cm">/* Validate extent which is part of inode */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_ext_check_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">ext4_inode_is_fast_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Validate block references which are part of inode */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_ind_check_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_file_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_file_operations</span><span class="p">;</span>
		<span class="n">ext4_set_aops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_dir_operations</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_inode_is_fast_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_fast_symlink_inode_operations</span><span class="p">;</span>
			<span class="n">nd_terminate_link</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_symlink_inode_operations</span><span class="p">;</span>
			<span class="n">ext4_set_aops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">S_ISFIFO</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext4_special_inode_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
			   <span class="n">old_decode_dev</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">])));</span>
		<span class="k">else</span>
			<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
			   <span class="n">new_decode_dev</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">1</span><span class="p">])));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;bogus i_mode (%o)&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">ext4_set_inode_flags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

<span class="nl">bad_inode:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">iget_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_inode_blocks_set</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">i_blocks</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_blocks</span> <span class="o">&lt;=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * i_blocks can be represnted in a 32 bit variable</span>
<span class="cm">		 * as multiple of 512 bytes</span>
<span class="cm">		 */</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks_lo</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i_blocks</span><span class="p">);</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ext4_clear_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_HUGE_FILE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">EXT4_FEATURE_RO_COMPAT_HUGE_FILE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_blocks</span> <span class="o">&lt;=</span> <span class="mh">0xffffffffffffULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * i_blocks can be represented in a 48 bit variable</span>
<span class="cm">		 * as multiple of 512 bytes</span>
<span class="cm">		 */</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks_lo</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i_blocks</span><span class="p">);</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks_high</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">i_blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">ext4_clear_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_HUGE_FILE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ext4_set_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_HUGE_FILE</span><span class="p">);</span>
		<span class="cm">/* i_block is stored in file system block size */</span>
		<span class="n">i_blocks</span> <span class="o">=</span> <span class="n">i_blocks</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks_lo</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i_blocks</span><span class="p">);</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks_high</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">i_blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Post the struct inode info into an on-disk inode location in the</span>
<span class="cm"> * buffer-cache.  This gobbles the caller&#39;s reference to the</span>
<span class="cm"> * buffer_head in the inode location struct.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have write access to iloc-&gt;bh.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_do_update_inode</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw_inode</span> <span class="o">=</span> <span class="n">ext4_raw_inode</span><span class="p">(</span><span class="n">iloc</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">i_uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">i_gid</span><span class="p">;</span>

	<span class="cm">/* For fields not not tracking in the in-memory inode,</span>
<span class="cm">	 * initialise them to zero for new inodes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_NEW</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_inode_size</span><span class="p">);</span>

	<span class="n">ext4_get_inode_flags</span><span class="p">(</span><span class="n">ei</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">i_uid</span> <span class="o">=</span> <span class="n">i_uid_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">i_gid</span> <span class="o">=</span> <span class="n">i_gid_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NO_UID32</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">low_16_bits</span><span class="p">(</span><span class="n">i_uid</span><span class="p">));</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">low_16_bits</span><span class="p">(</span><span class="n">i_gid</span><span class="p">));</span>
<span class="cm">/*</span>
<span class="cm"> * Fix up interoperability with old kernels. Otherwise, old inodes get</span>
<span class="cm"> * re-used with the upper 16 bits of the uid/gid intact</span>
<span class="cm"> */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span> <span class="o">=</span>
				<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">high_16_bits</span><span class="p">(</span><span class="n">i_uid</span><span class="p">));</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span> <span class="o">=</span>
				<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">high_16_bits</span><span class="p">(</span><span class="n">i_gid</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">fs_high2lowuid</span><span class="p">(</span><span class="n">i_uid</span><span class="p">));</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">fs_high2lowgid</span><span class="p">(</span><span class="n">i_gid</span><span class="p">));</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_links_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>

	<span class="n">EXT4_INODE_SET_XTIME</span><span class="p">(</span><span class="n">i_ctime</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
	<span class="n">EXT4_INODE_SET_XTIME</span><span class="p">(</span><span class="n">i_mtime</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
	<span class="n">EXT4_INODE_SET_XTIME</span><span class="p">(</span><span class="n">i_atime</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
	<span class="n">EXT4_EINODE_SET_XTIME</span><span class="p">(</span><span class="n">i_crtime</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_inode_blocks_set</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">,</span> <span class="n">ei</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_brelse</span><span class="p">;</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dtime</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_creator_os</span> <span class="o">!=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXT4_OS_HURD</span><span class="p">))</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_file_acl_high</span> <span class="o">=</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_file_acl_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span><span class="p">);</span>
	<span class="n">ext4_isize_set</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">&gt;</span> <span class="mh">0x7fffffffULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				<span class="n">EXT4_FEATURE_RO_COMPAT_LARGE_FILE</span><span class="p">)</span> <span class="o">||</span>
				<span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_rev_level</span> <span class="o">==</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXT4_GOOD_OLD_REV</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* If this is the first large file</span>
<span class="cm">			 * created, add a flag to the superblock.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
					<span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_brelse</span><span class="p">;</span>
			<span class="n">ext4_update_dynamic_rev</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="n">EXT4_SET_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					<span class="n">EXT4_FEATURE_RO_COMPAT_LARGE_FILE</span><span class="p">);</span>
			<span class="n">ext4_handle_sync</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_super_now</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_valid_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">old_encode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">));</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_encode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">));</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">EXT4_N_BLOCKS</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>

	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_disk_version</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_FITS_IN_INODE</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">i_version_hi</span><span class="p">))</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_version_hi</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ext4_inode_csum_set</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext4_handle_dirty_metadata&quot;</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">ext4_clear_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_NEW</span><span class="p">);</span>

	<span class="n">ext4_update_inode_fsync_trans</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out_brelse:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">ext4_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_write_inode()</span>
<span class="cm"> *</span>
<span class="cm"> * We are called from a few places:</span>
<span class="cm"> *</span>
<span class="cm"> * - Within generic_file_write() for O_SYNC files.</span>
<span class="cm"> *   Here, there will be no transaction running. We wait for any running</span>
<span class="cm"> *   trasnaction to commit.</span>
<span class="cm"> *</span>
<span class="cm"> * - Within sys_sync(), kupdate and such.</span>
<span class="cm"> *   We wait on commit, if tol to.</span>
<span class="cm"> *</span>
<span class="cm"> * - Within prune_icache() (PF_MEMALLOC == true)</span>
<span class="cm"> *   Here we simply return.  We can&#39;t afford to block kswapd on the</span>
<span class="cm"> *   journal commit.</span>
<span class="cm"> *</span>
<span class="cm"> * In all cases it is actually safe for us to return without doing anything,</span>
<span class="cm"> * because the inode has been copied into a raw inode buffer in</span>
<span class="cm"> * ext4_mark_inode_dirty().  This is a correctness thing for O_SYNC and for</span>
<span class="cm"> * knfsd.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we are absolutely dependent upon all inode dirtiers doing the</span>
<span class="cm"> * right thing: they *must* call mark_inode_dirty() after dirtying info in</span>
<span class="cm"> * which we are interested.</span>
<span class="cm"> *</span>
<span class="cm"> * It would be a bug for them to not do this.  The code:</span>
<span class="cm"> *</span>
<span class="cm"> *	mark_inode_dirty(inode)</span>
<span class="cm"> *	stuff();</span>
<span class="cm"> *	inode-&gt;i_size = expr;</span>
<span class="cm"> *</span>
<span class="cm"> * is in error because a kswapd-driven write_inode() could occur while</span>
<span class="cm"> * `stuff()&#39; is running, and the new i_size will be lost.  Plus the inode</span>
<span class="cm"> * will no longer be on the superblock&#39;s dirty inode list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_journal</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_journal_current_handle</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;called recursively, non-PF_MEMALLOC!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_force_commit</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="n">iloc</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">__ext4_get_inode_loc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span>
			<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_req</span><span class="p">(</span><span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span>
					 <span class="s">&quot;IO error syncing inode&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_setattr()</span>
<span class="cm"> *</span>
<span class="cm"> * Called from notify_change.</span>
<span class="cm"> *</span>
<span class="cm"> * We want to trap VFS attempts to truncate the file as soon as</span>
<span class="cm"> * possible.  In particular, we want to make sure that when the VFS</span>
<span class="cm"> * shrinks i_size, we put the inode on the orphan list and modify</span>
<span class="cm"> * i_disksize immediately, so that during the subsequent flushing of</span>
<span class="cm"> * dirty pages and freeing of disk blocks, we can guarantee that any</span>
<span class="cm"> * commit will leave the blocks being flushed in an unused state on</span>
<span class="cm"> * disk.  (On recovery, the inode will get truncated and the blocks will</span>
<span class="cm"> * be freed, so we have a strong guarantee that no future commit will</span>
<span class="cm"> * leave these blocks visible to the user.)</span>
<span class="cm"> *</span>
<span class="cm"> * Another thing we have to assure is that if we are in ordered mode</span>
<span class="cm"> * and inode is still attached to the committing transaction, we must</span>
<span class="cm"> * we start writeout of all the dirty pages which are being truncated.</span>
<span class="cm"> * This way we are sure that all the data written in the previous</span>
<span class="cm"> * transaction are already on disk (truncate waits for pages under</span>
<span class="cm"> * writeback).</span>
<span class="cm"> *</span>
<span class="cm"> * Called with inode-&gt;i_mutex down.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orphan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ia_valid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_quota_modification</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
		<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">gid_eq</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

		<span class="cm">/* (user+group)*(old+new) structure, inode write (sb,</span>
<span class="cm">		 * inode block, ? - but truncate inode update has it) */</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="p">(</span><span class="n">EXT4_MAXQUOTAS_INIT_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">+</span>
					<span class="n">EXT4_MAXQUOTAS_DEL_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dquot_transfer</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Update corresponding info in inode so that everything is in</span>
<span class="cm">		 * one transaction */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_bitmap_maxbytes</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">orphan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_order_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ext4_begin_ordered_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
							    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Do as much error cleanup as possible */</span>
				<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="n">orphan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">!=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">truncate_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
		<span class="n">ext4_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">setattr_copy</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the call to ext4_truncate failed to get a transaction handle at</span>
<span class="cm">	 * all, we need to clean up the in-core orphan list manually.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orphan</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ext4_acl_chmod</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

<span class="nl">err_out:</span>
	<span class="n">ext4_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext4_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delalloc_blocks</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">generic_fillattr</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t update i_blocks if the block allocation is delayed</span>
<span class="cm">	 * otherwise in the case of system crash before the real block</span>
<span class="cm">	 * allocation is done, we will have i_blocks inconsistent with</span>
<span class="cm">	 * on-disk file blocks.</span>
<span class="cm">	 * We always keep i_blocks updated together with real</span>
<span class="cm">	 * allocation. But to not confuse with user, stat</span>
<span class="cm">	 * will return the blocks that include the delayed allocation</span>
<span class="cm">	 * blocks for this file.</span>
<span class="cm">	 */</span>
	<span class="n">delalloc_blocks</span> <span class="o">=</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span>
				<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span><span class="p">);</span>

	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">+=</span> <span class="p">(</span><span class="n">delalloc_blocks</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">9</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_index_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ext4_ind_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nrblocks</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ext4_ext_index_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nrblocks</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Account for index blocks, block groups bitmaps and block group</span>
<span class="cm"> * descriptor blocks if modify datablocks and index blocks</span>
<span class="cm"> * worse case, the indexs blocks spread over different block groups</span>
<span class="cm"> *</span>
<span class="cm"> * If datablocks are discontiguous, they are possible to spread over</span>
<span class="cm"> * different block groups too. If they are contiuguous, with flexbg,</span>
<span class="cm"> * they could still across block group boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * Also account for superblock, inode, quota and xattr blocks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_meta_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_group_t</span> <span class="n">groups</span><span class="p">,</span> <span class="n">ngroups</span> <span class="o">=</span> <span class="n">ext4_get_groups_count</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">gdpblocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idxblocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * How many index blocks need to touch to modify nrblocks?</span>
<span class="cm">	 * The &quot;Chunk&quot; flag indicating whether the nrblocks is</span>
<span class="cm">	 * physically contiguous on disk</span>
<span class="cm">	 *</span>
<span class="cm">	 * For Direct IO and fallocate, they calls get_block to allocate</span>
<span class="cm">	 * one single extent at a time, so they could set the &quot;Chunk&quot; flag</span>
<span class="cm">	 */</span>
	<span class="n">idxblocks</span> <span class="o">=</span> <span class="n">ext4_index_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nrblocks</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">idxblocks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now let&#39;s see how many group bitmaps and group descriptors need</span>
<span class="cm">	 * to account</span>
<span class="cm">	 */</span>
	<span class="n">groups</span> <span class="o">=</span> <span class="n">idxblocks</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
		<span class="n">groups</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">groups</span> <span class="o">+=</span> <span class="n">nrblocks</span><span class="p">;</span>

	<span class="n">gdpblocks</span> <span class="o">=</span> <span class="n">groups</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">groups</span> <span class="o">&gt;</span> <span class="n">ngroups</span><span class="p">)</span>
		<span class="n">groups</span> <span class="o">=</span> <span class="n">ngroups</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">groups</span> <span class="o">&gt;</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_gdb_count</span><span class="p">)</span>
		<span class="n">gdpblocks</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_gdb_count</span><span class="p">;</span>

	<span class="cm">/* bitmaps and block group descriptor blocks */</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">groups</span> <span class="o">+</span> <span class="n">gdpblocks</span><span class="p">;</span>

	<span class="cm">/* Blocks for super block, inode, quota and xattr blocks */</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">EXT4_META_TRANS_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the total number of credits to reserve to fit</span>
<span class="cm"> * the modification of a single pages into a single transaction,</span>
<span class="cm"> * which may include multiple chunks of block allocations.</span>
<span class="cm"> *</span>
<span class="cm"> * This could be called via ext4_write_begin()</span>
<span class="cm"> *</span>
<span class="cm"> * We need to consider the worse case, when</span>
<span class="cm"> * one new block per extent.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_writepage_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bpp</span> <span class="o">=</span> <span class="n">ext4_journal_blocks_per_page</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_meta_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Account for data blocks for journalled mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">bpp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the journal credits for a chunk of data modification.</span>
<span class="cm"> *</span>
<span class="cm"> * This is called from DIO, fallocate or whoever calling</span>
<span class="cm"> * ext4_map_blocks() to map/allocate a chunk of contiguous disk blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * journal buffers for data blocks are not included here, as DIO</span>
<span class="cm"> * and fallocate do no need to journal data buffers.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_chunk_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ext4_meta_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nrblocks</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The caller must have previously called ext4_reserve_inode_write().</span>
<span class="cm"> * Give this, we know that the caller already has write access to iloc-&gt;bh.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_mark_iloc_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_I_VERSION</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/* the do_update_inode consumes one bh-&gt;b_count */</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_do_update_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iloc</span><span class="p">);</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On success, We end up with an outstanding reference count against</span>
<span class="cm"> * iloc-&gt;bh.  This _must_ be cleaned up later.</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">ext4_reserve_inode_write</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_get_inode_loc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ext4_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Expand an inode by new_extra_isize bytes.</span>
<span class="cm"> * Returns 0 on success or negative error number on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_expand_extra_isize</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_extra_isize</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="n">iloc</span><span class="p">,</span>
				   <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_xattr_ibody_header</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">&gt;=</span> <span class="n">new_extra_isize</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">raw_inode</span> <span class="o">=</span> <span class="n">ext4_raw_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>

	<span class="n">header</span> <span class="o">=</span> <span class="n">IHDR</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>

	<span class="cm">/* No extended attributes present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_XATTR</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">header</span><span class="o">-&gt;</span><span class="n">h_magic</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXT4_XATTR_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_inode</span> <span class="o">+</span> <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">new_extra_isize</span><span class="p">);</span>
		<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">=</span> <span class="n">new_extra_isize</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* try to expand with EAs present */</span>
	<span class="k">return</span> <span class="n">ext4_expand_extra_isize_ea</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_extra_isize</span><span class="p">,</span>
					  <span class="n">raw_inode</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * What we do here is to mark the in-core inode as clean with respect to inode</span>
<span class="cm"> * dirtiness (it may still be data-dirty).</span>
<span class="cm"> * This means that the in-core inode may be reaped by prune_icache</span>
<span class="cm"> * without having to perform any I/O.  This is a very good thing,</span>
<span class="cm"> * because *any* task may call prune_icache - even ones which</span>
<span class="cm"> * have a transaction open against a different journal.</span>
<span class="cm"> *</span>
<span class="cm"> * Is this cheating?  Not really.  Sure, we haven&#39;t written the</span>
<span class="cm"> * inode out, but prune_icache isn&#39;t a user-visible syncing function.</span>
<span class="cm"> * Whenever the user wants stuff synced (sys_sync, sys_msync, sys_fsync)</span>
<span class="cm"> * we start and wait on commits.</span>
<span class="cm"> *</span>
<span class="cm"> * Is this efficient/effective?  Well, we&#39;re being nice to the system</span>
<span class="cm"> * by cleaning up our inodes proactively so they can be reaped</span>
<span class="cm"> * without I/O.  But we are potentially leaving up to five seconds&#39;</span>
<span class="cm"> * worth of inodes floating about which prune_icache wants us to</span>
<span class="cm"> * write out.  One way to fix that would be to get prune_icache()</span>
<span class="cm"> * to do a write_super() to free up some memory.  It has the desired</span>
<span class="cm"> * effect.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="n">iloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mnt_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="n">trace_ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_reserve_inode_write</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_want_extra_isize</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ext4_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_NO_EXPAND</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need extra buffer credits since we may write into EA block</span>
<span class="cm">		 * with this same handle. If journal_extend fails, then it will</span>
<span class="cm">		 * only result in a minor loss of functionality for that inode.</span>
<span class="cm">		 * If this is felt to be critical, then e2fsck should be run to</span>
<span class="cm">		 * force a large enough s_min_extra_isize.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">jbd2_journal_extend</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
			     <span class="n">EXT4_DATA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_expand_extra_isize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						      <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_want_extra_isize</span><span class="p">,</span>
						      <span class="n">iloc</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ext4_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						     <span class="n">EXT4_STATE_NO_EXPAND</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mnt_count</span> <span class="o">!=</span>
					<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_mnt_count</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ext4_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					<span class="s">&quot;Unable to expand inode %lu. Delete&quot;</span>
					<span class="s">&quot; some EAs or run e2fsck.&quot;</span><span class="p">,</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
					<span class="n">mnt_count</span> <span class="o">=</span>
					  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_mnt_count</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_mark_iloc_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_dirty_inode() is called from __mark_inode_dirty()</span>
<span class="cm"> *</span>
<span class="cm"> * We&#39;re really interested in the case where a file is being extended.</span>
<span class="cm"> * i_size has been changed by generic_commit_write() and we thus need</span>
<span class="cm"> * to include the updated inode in the current transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, dquot_alloc_block() will always dirty the inode when blocks</span>
<span class="cm"> * are allocated to the file.</span>
<span class="cm"> *</span>
<span class="cm"> * If the inode is marked synchronous, we don&#39;t honour that here - doing</span>
<span class="cm"> * so would cause a commit on atime updates, which we don&#39;t bother doing.</span>
<span class="cm"> * We handle synchronous inodes at the highest possible level.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext4_dirty_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * Bind an inode&#39;s backing buffer_head into this transaction, to prevent</span>
<span class="c"> * it from being flushed to disk early.  Unlike</span>
<span class="c"> * ext4_reserve_inode_write, this leaves behind no bh reference and</span>
<span class="c"> * returns no iloc structure, so the caller needs to repeat the iloc</span>
<span class="c"> * lookup to mark the inode dirty later.</span>
<span class="c"> */</span>
<span class="c">static int ext4_pin_inode(handle_t *handle, struct inode *inode)</span>
<span class="c">{</span>
<span class="c">	struct ext4_iloc iloc;</span>

<span class="c">	int err = 0;</span>
<span class="c">	if (handle) {</span>
<span class="c">		err = ext4_get_inode_loc(inode, &amp;iloc);</span>
<span class="c">		if (!err) {</span>
<span class="c">			BUFFER_TRACE(iloc.bh, &quot;get_write_access&quot;);</span>
<span class="c">			err = jbd2_journal_get_write_access(handle, iloc.bh);</span>
<span class="c">			if (!err)</span>
<span class="c">				err = ext4_handle_dirty_metadata(handle,</span>
<span class="c">								 NULL,</span>
<span class="c">								 iloc.bh);</span>
<span class="c">			brelse(iloc.bh);</span>
<span class="c">		}</span>
<span class="c">	}</span>
<span class="c">	ext4_std_error(inode-&gt;i_sb, err);</span>
<span class="c">	return err;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">ext4_change_inode_journal_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to be very careful here: changing a data block&#39;s</span>
<span class="cm">	 * journaling status dynamically is dangerous.  If we write a</span>
<span class="cm">	 * data block to the journal, change the status and then delete</span>
<span class="cm">	 * that block, we risk forgetting to revoke the old log record</span>
<span class="cm">	 * from the journal and so a subsequent replay can corrupt data.</span>
<span class="cm">	 * So, first we make sure that the journal is empty and that</span>
<span class="cm">	 * nobody is changing anything.</span>
<span class="cm">	 */</span>

	<span class="n">journal</span> <span class="o">=</span> <span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="cm">/* We have to allocate physical blocks for delalloc blocks</span>
<span class="cm">	 * before flushing journal. otherwise delalloc blocks can not</span>
<span class="cm">	 * be allocated any more. even more truncate on delalloc blocks</span>
<span class="cm">	 * could trigger BUG by flushing delalloc blocks in journal.</span>
<span class="cm">	 * There is no delalloc block in non-journal data mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DELALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_alloc_da_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">jbd2_journal_lock_updates</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, there are no updates running now, and all cached data is</span>
<span class="cm">	 * synced to disk.  We are now in a completely consistent state</span>
<span class="cm">	 * which doesn&#39;t have anything in the journal, and we know that</span>
<span class="cm">	 * no filesystem updates are running, so it is safe to modify</span>
<span class="cm">	 * the inode&#39;s in-core data-journaling state flag now.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">ext4_set_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_JOURNAL_DATA</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">jbd2_journal_flush</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">ext4_clear_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_JOURNAL_DATA</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext4_set_aops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">jbd2_journal_unlock_updates</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="cm">/* Finally we can mark the inode as dirty. */</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_handle_sync</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">ext4_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_bh_unmapped</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext4_page_mkwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This check is racy but catches the common case. We rely on</span>
<span class="cm">	 * __block_page_mkwrite() to do a reliable check.</span>
<span class="cm">	 */</span>
	<span class="n">vfs_check_frozen</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">SB_FREEZE_WRITE</span><span class="p">);</span>
	<span class="cm">/* Delalloc case is easy... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DELALLOC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ext4_nonda_switch</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_page_mkwrite</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span>
						   <span class="n">ext4_da_get_block_prep</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span>
		       <span class="n">ext4_should_retry_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out_ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* Page got truncated from under us? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span> <span class="o">||</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Return if we have all the buffers mapped. This avoids the need to do</span>
<span class="cm">	 * journal_start/journal_stop which can block and take a long time</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">walk_page_buffers</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">ext4_bh_unmapped</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Wait so that we don&#39;t change page under IO */</span>
			<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/* OK, we need to fill the hole... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_dioread_nolock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">get_block</span> <span class="o">=</span> <span class="n">ext4_get_block_write</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">get_block</span> <span class="o">=</span> <span class="n">ext4_get_block</span><span class="p">;</span>
<span class="nl">retry_alloc:</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_page_mkwrite</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">do_journal_get_write_access</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
			<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ext4_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_JDATA</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_should_retry_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry_alloc</span><span class="p">;</span>
<span class="nl">out_ret:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">block_page_mkwrite_return</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
