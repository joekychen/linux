<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext4 › indirect.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>indirect.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/ext4/indirect.c</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/ext4/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/minix/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  Goal-directed block allocation by Stephen Tweedie</span>
<span class="cm"> *	(sct@redhat.com), 1993, 1998</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ext4_jbd2.h&quot;</span>
<span class="cp">#include &quot;truncate.h&quot;</span>

<span class="cp">#include &lt;trace/events/ext4.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Indirect</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_chain</span><span class="p">(</span><span class="n">Indirect</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext4_block_to_path - parse the block number into array of offsets</span>
<span class="cm"> *	@inode: inode in question (we are only interested in its superblock)</span>
<span class="cm"> *	@i_block: block number to be parsed</span>
<span class="cm"> *	@offsets: array to store the offsets in</span>
<span class="cm"> *	@boundary: set this non-zero if the referred-to block is likely to be</span>
<span class="cm"> *	       followed (on disk) by an indirect block.</span>
<span class="cm"> *</span>
<span class="cm"> *	To store the locations of file&#39;s data ext4 uses a data structure common</span>
<span class="cm"> *	for UNIX filesystems - tree of pointers anchored in the inode, with</span>
<span class="cm"> *	data blocks at leaves and indirect blocks in intermediate nodes.</span>
<span class="cm"> *	This function translates the block number into path in that tree -</span>
<span class="cm"> *	return value is the path length and @offsets[n] is the offset of</span>
<span class="cm"> *	pointer to (n+1)th node in the nth one. If @block is out of range</span>
<span class="cm"> *	(negative or too large) warning is printed and zero returned.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: function doesn&#39;t find node addresses, so no IO is needed. All</span>
<span class="cm"> *	we need to know is the capacity of indirect blocks (taken from the</span>
<span class="cm"> *	inode-&gt;i_sb).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Portability note: the last comparison (check that we fit into triple</span>
<span class="cm"> * indirect block) is spelled differently, because otherwise on an</span>
<span class="cm"> * architecture with 32-bit longs and 8Kb pages we might get into trouble</span>
<span class="cm"> * if our filesystem had 8Kb blocks. We might use long long, but that would</span>
<span class="cm"> * kill us on x86. Oh, well, at least the sign propagation does not matter -</span>
<span class="cm"> * i_block would have to be negative in the very beginning, so we would not</span>
<span class="cm"> * get there at all.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_block_to_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="n">ext4_lblk_t</span> <span class="n">i_block</span><span class="p">,</span>
			      <span class="n">ext4_lblk_t</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">boundary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="n">EXT4_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ptrs_bits</span> <span class="o">=</span> <span class="n">EXT4_ADDR_PER_BLOCK_BITS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">long</span> <span class="n">direct_blocks</span> <span class="o">=</span> <span class="n">EXT4_NDIR_BLOCKS</span><span class="p">,</span>
		<span class="n">indirect_blocks</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">,</span>
		<span class="n">double_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">final</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&lt;</span> <span class="n">direct_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="p">;</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">direct_blocks</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">direct_blocks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">indirect_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXT4_IND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="p">;</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">indirect_blocks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">double_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXT4_DIND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="n">ptrs_bits</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">double_blocks</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">ptrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXT4_TIND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="n">ptrs_bits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ext4_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;block %lu &gt; max in inode %lu&quot;</span><span class="p">,</span>
			     <span class="n">i_block</span> <span class="o">+</span> <span class="n">direct_blocks</span> <span class="o">+</span>
			     <span class="n">indirect_blocks</span> <span class="o">+</span> <span class="n">double_blocks</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
		<span class="o">*</span><span class="n">boundary</span> <span class="o">=</span> <span class="n">final</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext4_get_branch - read the chain of indirect blocks leading to data</span>
<span class="cm"> *	@inode: inode in question</span>
<span class="cm"> *	@depth: depth of the chain (1 - direct pointer, etc.)</span>
<span class="cm"> *	@offsets: offsets of pointers in inode/indirect blocks</span>
<span class="cm"> *	@chain: place to store the result</span>
<span class="cm"> *	@err: here we store the error value</span>
<span class="cm"> *</span>
<span class="cm"> *	Function fills the array of triples &lt;key, p, bh&gt; and returns %NULL</span>
<span class="cm"> *	if everything went OK or the pointer to the last filled triple</span>
<span class="cm"> *	(incomplete one) otherwise. Upon the return chain[i].key contains</span>
<span class="cm"> *	the number of (i+1)-th block in the chain (as it is stored in memory,</span>
<span class="cm"> *	i.e. little-endian 32-bit), chain[i].p contains the address of that</span>
<span class="cm"> *	number (it points into struct inode for i==0 and into the bh-&gt;b_data</span>
<span class="cm"> *	for i&gt;0) and chain[i].bh points to the buffer_head of i-th indirect</span>
<span class="cm"> *	block for i&gt;0 and NULL for i==0. In other words, it holds the block</span>
<span class="cm"> *	numbers of the chain, addresses they were taken from (and where we can</span>
<span class="cm"> *	verify that chain did not change) and buffer_heads hosting these</span>
<span class="cm"> *	numbers.</span>
<span class="cm"> *</span>
<span class="cm"> *	Function stops when it stumbles upon zero pointer (absent block)</span>
<span class="cm"> *		(pointer to last triple returned, *@err == 0)</span>
<span class="cm"> *	or when it gets an IO error reading an indirect block</span>
<span class="cm"> *		(ditto, *@err == -EIO)</span>
<span class="cm"> *	or when it reads all @depth-1 indirect blocks successfully and finds</span>
<span class="cm"> *	the whole chain, all way to the data (returns %NULL, *err == 0).</span>
<span class="cm"> *</span>
<span class="cm"> *      Need to be called with</span>
<span class="cm"> *      down_read(&amp;EXT4_I(inode)-&gt;i_data_sem)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">Indirect</span> <span class="o">*</span><span class="nf">ext4_get_branch</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
				 <span class="n">ext4_lblk_t</span>  <span class="o">*</span><span class="n">offsets</span><span class="p">,</span>
				 <span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* i_data is not going away, no lock needed */</span>
	<span class="n">add_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data</span> <span class="o">+</span> <span class="o">*</span><span class="n">offsets</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_block</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh_uptodate_or_lock</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh_submit_read</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* validate block references */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext4_check_indirect_blockref</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">add_chain</span><span class="p">(</span><span class="o">++</span><span class="n">p</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="o">*++</span><span class="n">offsets</span><span class="p">);</span>
		<span class="cm">/* Reader: end */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_block</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">failure:</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">no_block:</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext4_find_near - find a place for allocation with sufficient locality</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@ind: descriptor of indirect block.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function returns the preferred place for block allocation.</span>
<span class="cm"> *	It is used when heuristic for sequential allocation fails.</span>
<span class="cm"> *	Rules are:</span>
<span class="cm"> *	  + if there is a block to the left of our position - allocate near it.</span>
<span class="cm"> *	  + if pointer will live in indirect block - allocate near that block.</span>
<span class="cm"> *	  + if pointer will live in inode - allocate in the same</span>
<span class="cm"> *	    cylinder group.</span>
<span class="cm"> *</span>
<span class="cm"> * In the latter case we colour the starting block by the callers PID to</span>
<span class="cm"> * prevent it from clashing with concurrent allocations for a different inode</span>
<span class="cm"> * in the same block group.   The PID is used here so that functionally related</span>
<span class="cm"> * files will be close-by on-disk.</span>
<span class="cm"> *</span>
<span class="cm"> *	Caller must make sure that @ind is valid and will stay that way.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext4_fsblk_t</span> <span class="nf">ext4_find_near</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">ind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">?</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">:</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* Try to find previous block */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">;</span> <span class="n">p</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* No such thing, so let&#39;s try location of indirect block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is going to be referred to from the inode itself? OK, just put it</span>
<span class="cm">	 * into the same cylinder group then.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ext4_inode_to_goal_block</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext4_find_goal - find a preferred place for allocation.</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@block:  block we want</span>
<span class="cm"> *	@partial: pointer to the last triple within a chain</span>
<span class="cm"> *</span>
<span class="cm"> *	Normally this function find the preferred place for block allocation,</span>
<span class="cm"> *	returns it.</span>
<span class="cm"> *	Because this is only used for non-extent files, we limit the block nr</span>
<span class="cm"> *	to 32 bits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext4_fsblk_t</span> <span class="nf">ext4_find_goal</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">,</span>
				   <span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">goal</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX need to get goal block from mballoc&#39;s data structures</span>
<span class="cm">	 */</span>

	<span class="n">goal</span> <span class="o">=</span> <span class="n">ext4_find_near</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">partial</span><span class="p">);</span>
	<span class="n">goal</span> <span class="o">=</span> <span class="n">goal</span> <span class="o">&amp;</span> <span class="n">EXT4_MAX_BLOCK_FILE_PHYS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">goal</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext4_blks_to_allocate - Look up the block map and count the number</span>
<span class="cm"> *	of direct blocks need to be allocated for the given branch.</span>
<span class="cm"> *</span>
<span class="cm"> *	@branch: chain of indirect blocks</span>
<span class="cm"> *	@k: number of blocks need for indirect blocks</span>
<span class="cm"> *	@blks: number of data blocks to be mapped.</span>
<span class="cm"> *	@blocks_to_boundary:  the offset in the indirect block</span>
<span class="cm"> *</span>
<span class="cm"> *	return the total number of blocks to be allocate, including the</span>
<span class="cm"> *	direct and indirect blocks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_blks_to_allocate</span><span class="p">(</span><span class="n">Indirect</span> <span class="o">*</span><span class="n">branch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blks</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">blocks_to_boundary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Simple case, [t,d]Indirect block(s) has not allocated yet</span>
<span class="cm">	 * then it&#39;s clear blocks on that path have not allocated</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* right now we don&#39;t handle cross boundary allocation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blks</span> <span class="o">&lt;</span> <span class="n">blocks_to_boundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">blks</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">blocks_to_boundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">blks</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">blocks_to_boundary</span> <span class="o">&amp;&amp;</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">branch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">p</span> <span class="o">+</span> <span class="n">count</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext4_alloc_blocks: multiple allocate blocks needed for a branch</span>
<span class="cm"> *	@handle: handle for this transaction</span>
<span class="cm"> *	@inode: inode which needs allocated blocks</span>
<span class="cm"> *	@iblock: the logical block to start allocated at</span>
<span class="cm"> *	@goal: preferred physical block of allocation</span>
<span class="cm"> *	@indirect_blks: the number of blocks need to allocate for indirect</span>
<span class="cm"> *			blocks</span>
<span class="cm"> *	@blks: number of desired blocks</span>
<span class="cm"> *	@new_blocks: on return it will store the new block numbers for</span>
<span class="cm"> *	the indirect blocks(if needed) and the first direct block,</span>
<span class="cm"> *	@err: on return it will store the error code</span>
<span class="cm"> *</span>
<span class="cm"> *	This function will return the number of blocks allocated as</span>
<span class="cm"> *	requested by the passed-in parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_alloc_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="n">ext4_lblk_t</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">goal</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blks</span><span class="p">,</span>
			     <span class="n">ext4_fsblk_t</span> <span class="n">new_blocks</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_allocation_request</span> <span class="n">ar</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blk_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">current_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here we try to allocate the requested multiple blocks at once,</span>
<span class="cm">	 * on a best-effort basis.</span>
<span class="cm">	 * To build a branch, we should allocate blocks for</span>
<span class="cm">	 * the indirect blocks(if not allocated yet), and at least</span>
<span class="cm">	 * the first direct block of this branch.  That&#39;s the</span>
<span class="cm">	 * minimum number of blocks need to allocate(required)</span>
<span class="cm">	 */</span>
	<span class="cm">/* first we try to allocate the indirect blocks */</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">indirect_blks</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
		<span class="cm">/* allocating blocks for indirect blocks and direct blocks */</span>
		<span class="n">current_block</span> <span class="o">=</span> <span class="n">ext4_new_meta_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span>
						     <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed_out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current_block</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">EXT4_MAX_BLOCK_FILE_PHYS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					 <span class="s">&quot;current_block %llu + count %lu &gt; %d!&quot;</span><span class="p">,</span>
					 <span class="n">current_block</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
					 <span class="n">EXT4_MAX_BLOCK_FILE_PHYS</span><span class="p">);</span>
			<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failed_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">target</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
		<span class="cm">/* allocate blocks for indirect blocks */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">indirect_blks</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_blocks</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_block</span><span class="o">++</span><span class="p">;</span>
			<span class="n">count</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * save the new block number</span>
<span class="cm">			 * for the first direct block</span>
<span class="cm">			 */</span>
			<span class="n">new_blocks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_block</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s returned more blocks than &quot;</span>
						<span class="s">&quot;requested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">blks</span> <span class="o">-</span> <span class="n">count</span> <span class="p">;</span>
	<span class="n">blk_allocated</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="cm">/* Now allocate data blocks */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ar</span><span class="p">));</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">goal</span> <span class="o">=</span> <span class="n">goal</span><span class="p">;</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">logical</span> <span class="o">=</span> <span class="n">iblock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="cm">/* enable in-core preallocation only for regular files */</span>
		<span class="n">ar</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">EXT4_MB_HINT_DATA</span><span class="p">;</span>

	<span class="n">current_block</span> <span class="o">=</span> <span class="n">ext4_mb_new_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current_block</span> <span class="o">+</span> <span class="n">ar</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">EXT4_MAX_BLOCK_FILE_PHYS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				 <span class="s">&quot;current_block %llu + ar.len %d &gt; %d!&quot;</span><span class="p">,</span>
				 <span class="n">current_block</span><span class="p">,</span> <span class="n">ar</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
				 <span class="n">EXT4_MAX_BLOCK_FILE_PHYS</span><span class="p">);</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">blks</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if the allocation failed and we didn&#39;t allocate</span>
<span class="cm">		 * any blocks before</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">failed_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">blks</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * save the new block number</span>
<span class="cm">			 * for the first direct block</span>
<span class="cm">			 */</span>
			<span class="n">new_blocks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_block</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">blk_allocated</span> <span class="o">+=</span> <span class="n">ar</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">allocated:</span>
	<span class="cm">/* total number of blocks allocated for direct blocks */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">blk_allocated</span><span class="p">;</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">failed_out:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext4_alloc_branch - allocate and set up a chain of blocks.</span>
<span class="cm"> *	@handle: handle for this transaction</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@indirect_blks: number of allocated indirect blocks</span>
<span class="cm"> *	@blks: number of allocated direct blocks</span>
<span class="cm"> *	@goal: preferred place for allocation</span>
<span class="cm"> *	@offsets: offsets (in the blocks) to store the pointers to next.</span>
<span class="cm"> *	@branch: place to store the chain in.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function allocates blocks, zeroes out all but the last one,</span>
<span class="cm"> *	links them into chain and (if we are synchronous) writes them to disk.</span>
<span class="cm"> *	In other words, it prepares a branch that can be spliced onto the</span>
<span class="cm"> *	inode. It stores the information about that chain in the branch[], in</span>
<span class="cm"> *	the same format as ext4_get_branch() would do. We are calling it after</span>
<span class="cm"> *	we had read the existing part of chain and partial points to the last</span>
<span class="cm"> *	triple of that (one with zero -&gt;key). Upon the exit we have the same</span>
<span class="cm"> *	picture as after the successful ext4_get_block(), except that in one</span>
<span class="cm"> *	place chain is disconnected - *branch-&gt;p is still zero (we did not</span>
<span class="cm"> *	set the last link), but branch-&gt;key contains the number that should</span>
<span class="cm"> *	be placed into *branch-&gt;p to fill that gap.</span>
<span class="cm"> *</span>
<span class="cm"> *	If allocation fails we free all blocks we&#39;ve allocated (and forget</span>
<span class="cm"> *	their buffer_heads) and return the error value the from failed</span>
<span class="cm"> *	ext4_alloc_block() (normally -ENOSPC). Otherwise we set the chain</span>
<span class="cm"> *	as described above and return 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_alloc_branch</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="n">ext4_lblk_t</span> <span class="n">iblock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">indirect_blks</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">blks</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">goal</span><span class="p">,</span>
			     <span class="n">ext4_lblk_t</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">branch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">new_blocks</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">current_block</span><span class="p">;</span>

	<span class="n">num</span> <span class="o">=</span> <span class="n">ext4_alloc_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span>
				<span class="o">*</span><span class="n">blks</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">branch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * metadata blocks and data blocks are allocated.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">indirect_blks</span><span class="p">;</span>  <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get buffer_head for parent block, zero it out</span>
<span class="cm">		 * and set the pointer to new one, then send</span>
<span class="cm">		 * parent to disk.</span>
<span class="cm">		 */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call get_create_access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_create_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t brelse(bh) here; it&#39;s done in</span>
<span class="cm">			 * ext4_journal_forget() below */</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_blocks</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">p</span> <span class="o">=</span> <span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">indirect_blks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">current_block</span> <span class="o">=</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
			<span class="cm">/*</span>
<span class="cm">			 * End of chain, update the last new metablock of</span>
<span class="cm">			 * the chain to point to the new allocated</span>
<span class="cm">			 * data blocks numbers</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="o">*</span><span class="p">(</span><span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">++</span><span class="n">current_block</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;marking uptodate&quot;</span><span class="p">);</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext4_handle_dirty_metadata&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">blks</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">failed:</span>
	<span class="cm">/* Allocation failed, free what we already allocated */</span>
	<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * branch[i].bh is newly allocated, so there is no</span>
<span class="cm">		 * need to revoke the block, which is why we don&#39;t</span>
<span class="cm">		 * need to set EXT4_FREE_BLOCKS_METADATA.</span>
<span class="cm">		 */</span>
		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span>
				 <span class="n">EXT4_FREE_BLOCKS_FORGET</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indirect_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext4_splice_branch - splice the allocated branch onto inode.</span>
<span class="cm"> * @handle: handle for this transaction</span>
<span class="cm"> * @inode: owner</span>
<span class="cm"> * @block: (logical) number of block we are adding</span>
<span class="cm"> * @chain: chain of indirect blocks (with a missing link - see</span>
<span class="cm"> *	ext4_alloc_branch)</span>
<span class="cm"> * @where: location of missing link</span>
<span class="cm"> * @num:   number of indirect blocks we are adding</span>
<span class="cm"> * @blks:  number of direct blocks we are adding</span>
<span class="cm"> *</span>
<span class="cm"> * This function fills the missing link and does all housekeeping needed in</span>
<span class="cm"> * inode (-&gt;i_blocks, etc.). In case of success we end up with the full</span>
<span class="cm"> * chain to new block and return 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_splice_branch</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">blks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">current_block</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re splicing into a [td]indirect block (as opposed to the</span>
<span class="cm">	 * inode) then we need to get write access to the [td]indirect block</span>
<span class="cm">	 * before the splice.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* That&#39;s it */</span>

	<span class="o">*</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">where</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the host buffer_head or inode to point to more just allocated</span>
<span class="cm">	 * direct blocks blocks</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">blks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">current_block</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We are done with atomic stuff, now do the rest of housekeeping */</span>
	<span class="cm">/* had we spliced it onto indirect block? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we spliced it onto an indirect block, we haven&#39;t</span>
<span class="cm">		 * altered the inode.  Note however that if it is being spliced</span>
<span class="cm">		 * onto an indirect block at the very end of the file (the</span>
<span class="cm">		 * file is growing) then we *will* alter the inode to reflect</span>
<span class="cm">		 * the new i_size.  But that is not done here - it is done in</span>
<span class="cm">		 * generic_commit_write-&gt;__mark_inode_dirty-&gt;ext4_dirty_inode.</span>
<span class="cm">		 */</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;splicing indirect only</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext4_handle_dirty_metadata&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * OK, we spliced it into the inode itself on a direct block.</span>
<span class="cm">		 */</span>
		<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;splicing direct</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * branch[i].bh is newly allocated, so there is no</span>
<span class="cm">		 * need to revoke the block, which is why we don&#39;t</span>
<span class="cm">		 * need to set EXT4_FREE_BLOCKS_METADATA.</span>
<span class="cm">		 */</span>
		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">where</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				 <span class="n">EXT4_FREE_BLOCKS_FORGET</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">key</span><span class="p">),</span>
			 <span class="n">blks</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The ext4_ind_map_blocks() function handles non-extents inodes</span>
<span class="cm"> * (i.e., using the traditional indirect/double-indirect i_blocks</span>
<span class="cm"> * scheme) for ext4_map_blocks().</span>
<span class="cm"> *</span>
<span class="cm"> * Allocation strategy is simple: if we have to allocate something, we will</span>
<span class="cm"> * have to go the whole way to leaf. So let&#39;s do it before attaching anything</span>
<span class="cm"> * to tree, set linkage between the newborn blocks, write them if sync is</span>
<span class="cm"> * required, recheck the path, free and repeat if check fails, otherwise</span>
<span class="cm"> * set the last missing link (that will protect us from any truncate-generated</span>
<span class="cm"> * removals - all blocks on the path are immune now) and possibly force the</span>
<span class="cm"> * write on the parent block.</span>
<span class="cm"> * That has a nice additional property: no special recovery from the failed</span>
<span class="cm"> * allocations is needed - we simply release blocks and do not touch anything</span>
<span class="cm"> * reachable from inode.</span>
<span class="cm"> *</span>
<span class="cm"> * `handle&#39; can be NULL if create == 0.</span>
<span class="cm"> *</span>
<span class="cm"> * return &gt; 0, # of blocks mapped or allocated.</span>
<span class="cm"> * return = 0, if plain lookup failed.</span>
<span class="cm"> * return &lt; 0, error case.</span>
<span class="cm"> *</span>
<span class="cm"> * The ext4_ind_get_blocks() function should be called with</span>
<span class="cm"> * down_write(&amp;EXT4_I(inode)-&gt;i_data_sem) if allocating filesystem</span>
<span class="cm"> * blocks (i.e., flags has EXT4_GET_BLOCKS_CREATE set) or</span>
<span class="cm"> * down_read(&amp;EXT4_I(inode)-&gt;i_data_sem) if not allocating file system</span>
<span class="cm"> * blocks.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_ind_map_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">goal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">indirect_blks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blocks_to_boundary</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">first_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_ext4_ind_map_blocks_enter</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">)));</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">handle</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_CREATE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext4_block_to_path</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">blocks_to_boundary</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">partial</span> <span class="o">=</span> <span class="n">ext4_get_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>

	<span class="cm">/* Simplest case - block found, no allocation needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/*map more blocks*/</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">blocks_to_boundary</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_fsblk_t</span> <span class="n">blk</span><span class="p">;</span>

			<span class="n">blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">p</span> <span class="o">+</span> <span class="n">count</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">blk</span> <span class="o">==</span> <span class="n">first_block</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">got_it</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Next simple case - plain lookup or failed read of indirect block */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_CREATE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Okay, we need to do block allocation.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				       <span class="n">EXT4_FEATURE_RO_COMPAT_BIGALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;Can&#39;t allocate blocks for &quot;</span>
				 <span class="s">&quot;non-extent mapped inodes with bigalloc&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">goal</span> <span class="o">=</span> <span class="n">ext4_find_goal</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">partial</span><span class="p">);</span>

	<span class="cm">/* the number of blocks need to allocate for [d,t]indirect blocks */</span>
	<span class="n">indirect_blks</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain</span> <span class="o">+</span> <span class="n">depth</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Next look up the indirect map to count the totoal number of</span>
<span class="cm">	 * direct blocks to allocate for this branch.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">ext4_blks_to_allocate</span><span class="p">(</span><span class="n">partial</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span>
				      <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span> <span class="n">blocks_to_boundary</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Block out ext4_truncate while we alter the tree</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_alloc_branch</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span>
				<span class="n">offsets</span> <span class="o">+</span> <span class="p">(</span><span class="n">partial</span> <span class="o">-</span> <span class="n">chain</span><span class="p">),</span> <span class="n">partial</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The ext4_splice_branch call will free and forget any buffers</span>
<span class="cm">	 * on the new chain if there is a failure, but that risks using</span>
<span class="cm">	 * up transaction credits, especially for bitmaps where the</span>
<span class="cm">	 * credits cannot be returned.  Can we handle this somehow?  We</span>
<span class="cm">	 * may need to return -EAGAIN upwards in the worst case.  --sct</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_splice_branch</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span>
					 <span class="n">partial</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_NEW</span><span class="p">;</span>

	<span class="n">ext4_update_inode_fsync_trans</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">got_it:</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_MAPPED</span><span class="p">;</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">blocks_to_boundary</span><span class="p">)</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_BOUNDARY</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/* Clean up and exit */</span>
	<span class="n">partial</span> <span class="o">=</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* the whole chain */</span>
<span class="nl">cleanup:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call brelse&quot;</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">trace_ext4_ind_map_blocks_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * O_DIRECT for ext3 (or indirect map) based files</span>
<span class="cm"> *</span>
<span class="cm"> * If the O_DIRECT write will extend the file then add this inode to the</span>
<span class="cm"> * orphan list.  So recovery will truncate it back to the original size</span>
<span class="cm"> * if the machine crashes during the write.</span>
<span class="cm"> *</span>
<span class="cm"> * If the O_DIRECT write is intantiating holes inside i_size and the machine</span>
<span class="cm"> * crashes then stale disk data _may_ be exposed inside the file. But current</span>
<span class="cm"> * VFS code falls back into buffered path in that case so we are safe.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">ext4_ind_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orphan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">final_size</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">final_size</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Credits for sb + inode write */</span>
			<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">orphan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
			<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_should_dioread_nolock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_completed_io_list</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="n">ext4_flush_completed_IO</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
				 <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
				 <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
				 <span class="n">ext4_get_block</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
				 <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">ext4_get_block</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">loff_t</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span>
				<span class="n">ext4_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_should_retry_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">orphan</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="cm">/* Credits for sb + inode write */</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This is really bad luck. We&#39;ve written the data</span>
<span class="cm">			 * but cannot extend i_size. Bail out and pretend</span>
<span class="cm">			 * the write failed... */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
				<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
			<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
				<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * We&#39;re going to return a positive `ret&#39;</span>
<span class="cm">				 * here due to non-zero-length I/O, so there&#39;s</span>
<span class="cm">				 * no way of reporting error returns from</span>
<span class="cm">				 * ext4_mark_inode_dirty() to userspace.  So</span>
<span class="cm">				 * ignore it.</span>
<span class="cm">				 */</span>
				<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the number of metadata blocks need to reserve</span>
<span class="cm"> * to allocate a new block at @lblocks for non extent file based file</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_ind_calc_metadata_amount</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">lblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">sector_t</span> <span class="n">dind_mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">sector_t</span><span class="p">)</span><span class="n">EXT4_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">blk_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lblock</span> <span class="o">&lt;</span> <span class="n">EXT4_NDIR_BLOCKS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lblock</span> <span class="o">-=</span> <span class="n">EXT4_NDIR_BLOCKS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">lblock</span> <span class="o">&amp;</span> <span class="n">dind_mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_last_lblock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_last_lblock</span> <span class="o">=</span> <span class="n">lblock</span> <span class="o">&amp;</span> <span class="n">dind_mask</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">blk_bits</span> <span class="o">=</span> <span class="n">order_base_2</span><span class="p">(</span><span class="n">lblock</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">blk_bits</span> <span class="o">/</span> <span class="n">EXT4_ADDR_PER_BLOCK_BITS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext4_ind_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">indirects</span><span class="p">;</span>

	<span class="cm">/* if nrblocks are contiguous */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * With N contiguous data blocks, we need at most</span>
<span class="cm">		 * N/EXT4_ADDR_PER_BLOCK(inode-&gt;i_sb) + 1 indirect blocks,</span>
<span class="cm">		 * 2 dindirect blocks, and 1 tindirect block</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">nrblocks</span><span class="p">,</span>
				    <span class="n">EXT4_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if nrblocks are not contiguous, worse case, each block touch</span>
<span class="cm">	 * a indirect block, and each indirect block touch a double indirect</span>
<span class="cm">	 * block, plus a triple indirect block</span>
<span class="cm">	 */</span>
	<span class="n">indirects</span> <span class="o">=</span> <span class="n">nrblocks</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">indirects</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Truncate transactions can be complex and absolutely huge.  So we need to</span>
<span class="cm"> * be able to restart the transaction at a conventient checkpoint to make</span>
<span class="cm"> * sure we don&#39;t overflow the journal.</span>
<span class="cm"> *</span>
<span class="cm"> * start_transaction gets us a new handle for a truncate transaction,</span>
<span class="cm"> * and extend_transaction tries to extend the existing one a bit.  If</span>
<span class="cm"> * extend fails, we need to propagate the failure up and restart the</span>
<span class="cm"> * transaction in the top-level truncate loop. --sct</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">start_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_blocks_for_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">ext4_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to extend this transaction for the purposes of truncation.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if we managed to create more room.  If we can&#39;t create more</span>
<span class="cm"> * room, and the transaction must be restarted we return 1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_extend_transaction</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_has_enough_credits</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">EXT4_RESERVE_TRANS_BLOCKS</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_journal_extend</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">ext4_blocks_for_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Probably it should be a library function... search for first non-zero word</span>
<span class="cm"> * or memcmp with zero_page, whatever is better for particular architecture.</span>
<span class="cm"> * Linus?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">all_zeroes</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext4_find_shared - find the indirect blocks for partial truncation.</span>
<span class="cm"> *	@inode:	  inode in question</span>
<span class="cm"> *	@depth:	  depth of the affected branch</span>
<span class="cm"> *	@offsets: offsets of pointers in that branch (see ext4_block_to_path)</span>
<span class="cm"> *	@chain:	  place to store the pointers to partial indirect blocks</span>
<span class="cm"> *	@top:	  place to the (detached) top of branch</span>
<span class="cm"> *</span>
<span class="cm"> *	This is a helper function used by ext4_truncate().</span>
<span class="cm"> *</span>
<span class="cm"> *	When we do truncate() we may have to clean the ends of several</span>
<span class="cm"> *	indirect blocks but leave the blocks themselves alive. Block is</span>
<span class="cm"> *	partially truncated if some data below the new i_size is referred</span>
<span class="cm"> *	from it (and it is on the path to the first completely truncated</span>
<span class="cm"> *	data block, indeed).  We have to free the top of that path along</span>
<span class="cm"> *	with everything to the right of the path. Since no allocation</span>
<span class="cm"> *	past the truncation point is possible until ext4_truncate()</span>
<span class="cm"> *	finishes, we may safely do the latter, but top of branch may</span>
<span class="cm"> *	require special attention - pageout below the truncation point</span>
<span class="cm"> *	might try to populate it.</span>
<span class="cm"> *</span>
<span class="cm"> *	We atomically detach the top of branch from the tree, store the</span>
<span class="cm"> *	block number of its root in *@top, pointers to buffer_heads of</span>
<span class="cm"> *	partially truncated blocks - in @chain[].bh and pointers to</span>
<span class="cm"> *	their last elements that should not be removed - in</span>
<span class="cm"> *	@chain[].p. Return value is the pointer to last filled element</span>
<span class="cm"> *	of @chain.</span>
<span class="cm"> *</span>
<span class="cm"> *	The work left to caller to do the actual freeing of subtrees:</span>
<span class="cm"> *		a) free the subtree starting from *@top</span>
<span class="cm"> *		b) free the subtrees whose roots are stored in</span>
<span class="cm"> *			(@chain[i].p+1 .. end of @chain[i].bh-&gt;b_data)</span>
<span class="cm"> *		c) free the subtrees growing from the inode past the @chain[0].</span>
<span class="cm"> *			(no partially truncated stuff there).  */</span>

<span class="k">static</span> <span class="n">Indirect</span> <span class="o">*</span><span class="nf">ext4_find_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
				  <span class="n">ext4_lblk_t</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				  <span class="n">__le32</span> <span class="o">*</span><span class="n">top</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Make k index the deepest non-null offset + 1 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="n">partial</span> <span class="o">=</span> <span class="n">ext4_get_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="cm">/* Writer: pointers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span>
		<span class="n">partial</span> <span class="o">=</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the branch acquired continuation since we&#39;ve looked at it -</span>
<span class="cm">	 * fine, it should all survive and (new) top doesn&#39;t belong to us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span>
		<span class="cm">/* Writer: end */</span>
		<span class="k">goto</span> <span class="n">no_top</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">partial</span><span class="p">;</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">all_zeroes</span><span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span> <span class="n">p</span><span class="o">--</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * OK, we&#39;ve found the last block that must survive. The rest of our</span>
<span class="cm">	 * branch should be detached before unlocking. However, if that rest</span>
<span class="cm">	 * of branch is all ours and does not grow immediately from the inode</span>
<span class="cm">	 * it&#39;s easier to cheat and just decrement partial-&gt;p.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
		<span class="cm">/* Nope, don&#39;t do this in ext4.  Must leave the tree intact */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		*p-&gt;p = 0;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="cm">/* Writer: end */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">no_top:</span>
	<span class="k">return</span> <span class="n">partial</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Zero a number of block pointers in either an inode or an indirect block.</span>
<span class="cm"> * If we restart the transaction we must again get write access to the</span>
<span class="cm"> * indirect block for further modification.</span>
<span class="cm"> *</span>
<span class="cm"> * We release `count&#39; blocks on disk, but (last - first) may be greater</span>
<span class="cm"> * than `count&#39; because there can be holes in there.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, 1 on invalid block range</span>
<span class="cm"> * and &lt; 0 on fatal error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_clear_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
			     <span class="n">ext4_fsblk_t</span> <span class="n">block_to_free</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span>
			     <span class="n">__le32</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">flags</span> <span class="o">=</span> <span class="n">EXT4_FREE_BLOCKS_FORGET</span> <span class="o">|</span> <span class="n">EXT4_FREE_BLOCKS_VALIDATED</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">EXT4_FREE_BLOCKS_METADATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_data_block_valid</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span> <span class="n">block_to_free</span><span class="p">,</span>
				   <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;attempt to clear invalid &quot;</span>
				 <span class="s">&quot;blocks %llu len %lu&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">block_to_free</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">try_to_extend_transaction</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext4_handle_dirty_metadata&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_truncate_restart_trans</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					<span class="n">ext4_blocks_for_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;retaking write access&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">block_to_free</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">ext4_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext4_free_data - free a list of data blocks</span>
<span class="cm"> * @handle:	handle for this transaction</span>
<span class="cm"> * @inode:	inode we are dealing with</span>
<span class="cm"> * @this_bh:	indirect buffer_head which contains *@first and *@last</span>
<span class="cm"> * @first:	array of block numbers</span>
<span class="cm"> * @last:	points immediately past the end of array</span>
<span class="cm"> *</span>
<span class="cm"> * We are freeing all blocks referred from that array (numbers are stored as</span>
<span class="cm"> * little-endian 32-bit) and updating @inode-&gt;i_blocks appropriately.</span>
<span class="cm"> *</span>
<span class="cm"> * We accumulate contiguous runs of blocks to free.  Conveniently, if these</span>
<span class="cm"> * blocks are contiguous then releasing them at one time will only affect one</span>
<span class="cm"> * or two bitmap blocks (+ group descriptor(s) and superblock) and we won&#39;t</span>
<span class="cm"> * actually use a lot of journal space.</span>
<span class="cm"> *</span>
<span class="cm"> * @this_bh will be %NULL if @first and @last point into the inode&#39;s direct</span>
<span class="cm"> * block pointers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_free_data</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">this_bh</span><span class="p">,</span>
			   <span class="n">__le32</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">block_to_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="cm">/* Starting block # of a run */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	    <span class="cm">/* Number of blocks in the run */</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">block_to_free_p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	    <span class="cm">/* Pointer into inode/ind</span>
<span class="cm">					       corresponding to</span>
<span class="cm">					       block_to_free */</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">nr</span><span class="p">;</span>		    <span class="cm">/* Current block # */</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>			    <span class="cm">/* Pointer into inode/ind</span>
<span class="cm">					       for current block */</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_bh</span><span class="p">)</span> <span class="p">{</span>				<span class="cm">/* For indirect block */</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">this_bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">this_bh</span><span class="p">);</span>
		<span class="cm">/* Important: if we can&#39;t update the indirect pointers</span>
<span class="cm">		 * to the blocks, we can&#39;t free them. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* accumulate blocks to free if they&#39;re contiguous */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">block_to_free</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
				<span class="n">block_to_free_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="n">block_to_free</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_clear_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">this_bh</span><span class="p">,</span>
						        <span class="n">block_to_free</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
						        <span class="n">block_to_free_p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">block_to_free</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
				<span class="n">block_to_free_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_clear_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">this_bh</span><span class="p">,</span> <span class="n">block_to_free</span><span class="p">,</span>
					<span class="n">count</span><span class="p">,</span> <span class="n">block_to_free_p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* fatal error */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">this_bh</span><span class="p">,</span> <span class="s">&quot;call ext4_handle_dirty_metadata&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The buffer head should have an attached journal head at this</span>
<span class="cm">		 * point. However, if the data is corrupted and an indirect</span>
<span class="cm">		 * block pointed to itself, it would have been detached when</span>
<span class="cm">		 * the block was cleared. Check for this instead of OOPSing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">EXT4_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">this_bh</span><span class="p">))</span>
			<span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">this_bh</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					 <span class="s">&quot;circular indirect block detected at &quot;</span>
					 <span class="s">&quot;block %llu&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">this_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext4_free_branches - free an array of branches</span>
<span class="cm"> *	@handle: JBD handle for this transaction</span>
<span class="cm"> *	@inode:	inode we are dealing with</span>
<span class="cm"> *	@parent_bh: the buffer_head which contains *@first and *@last</span>
<span class="cm"> *	@first:	array of block numbers</span>
<span class="cm"> *	@last:	pointer immediately past the end of array</span>
<span class="cm"> *	@depth:	depth of the branches to free</span>
<span class="cm"> *</span>
<span class="cm"> *	We are freeing all blocks referred from these branches (numbers are</span>
<span class="cm"> *	stored as little-endian 32-bit) and updating @inode-&gt;i_blocks</span>
<span class="cm"> *	appropriately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_free_branches</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">parent_bh</span><span class="p">,</span>
			       <span class="n">__le32</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_is_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">addr_per_block</span> <span class="o">=</span> <span class="n">EXT4_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">first</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>		<span class="cm">/* A hole */</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_data_block_valid</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span>
						   <span class="n">nr</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						 <span class="s">&quot;invalid indirect mapped &quot;</span>
						 <span class="s">&quot;block %lu (level %d)&quot;</span><span class="p">,</span>
						 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">nr</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Go read the buffer for the next level down */</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * A read failure? Report error and clear slot</span>
<span class="cm">			 * (should be rare).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">EXT4_ERROR_INODE_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span>
						       <span class="s">&quot;Read failure&quot;</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* This zaps the entire block.  Bottom up. */</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;free child branches&quot;</span><span class="p">);</span>
			<span class="n">ext4_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span>
					<span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
					<span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">addr_per_block</span><span class="p">,</span>
					<span class="n">depth</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Everything below this this pointer has been</span>
<span class="cm">			 * released.  Now let this top-of-subtree go.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We want the freeing of this indirect block to be</span>
<span class="cm">			 * atomic in the journal with the updating of the</span>
<span class="cm">			 * bitmap block which owns it.  So make some room in</span>
<span class="cm">			 * the journal.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We zero the parent pointer *after* freeing its</span>
<span class="cm">			 * pointee in the bitmaps, so if extend_transaction()</span>
<span class="cm">			 * for some reason fails to put the bitmap changes and</span>
<span class="cm">			 * the release into the same transaction, recovery</span>
<span class="cm">			 * will merely complain about releasing a free block,</span>
<span class="cm">			 * rather than leaking blocks.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext4_handle_is_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">try_to_extend_transaction</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="n">ext4_truncate_restart_trans</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					    <span class="n">ext4_blocks_for_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * The forget flag here is critical because if</span>
<span class="cm">			 * we are journaling (and not doing data</span>
<span class="cm">			 * journaling), we have to make sure a revoke</span>
<span class="cm">			 * record is written to prevent the journal</span>
<span class="cm">			 * replay from overwriting the (former)</span>
<span class="cm">			 * indirect block if it gets reallocated as a</span>
<span class="cm">			 * data block.  This must happen in the same</span>
<span class="cm">			 * transaction where the data blocks are</span>
<span class="cm">			 * actually freed.</span>
<span class="cm">			 */</span>
			<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					 <span class="n">EXT4_FREE_BLOCKS_METADATA</span><span class="o">|</span>
					 <span class="n">EXT4_FREE_BLOCKS_FORGET</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">parent_bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The block which we have just freed is</span>
<span class="cm">				 * pointed to by an indirect block: journal it</span>
<span class="cm">				 */</span>
				<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">parent_bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
								   <span class="n">parent_bh</span><span class="p">)){</span>
					<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">parent_bh</span><span class="p">,</span>
					<span class="s">&quot;call ext4_handle_dirty_metadata&quot;</span><span class="p">);</span>
					<span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
								   <span class="n">inode</span><span class="p">,</span>
								   <span class="n">parent_bh</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We have reached the bottom of the tree. */</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">parent_bh</span><span class="p">,</span> <span class="s">&quot;free data blocks&quot;</span><span class="p">);</span>
		<span class="n">ext4_free_data</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">parent_bh</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ext4_ind_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">i_data</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr_per_block</span> <span class="o">=</span> <span class="n">EXT4_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">last_block</span><span class="p">,</span> <span class="n">max_block</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">page_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">start_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* AKPM: return what? */</span>

	<span class="n">last_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
					<span class="o">&gt;&gt;</span> <span class="n">EXT4_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">max_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_bitmap_maxbytes</span> <span class="o">+</span> <span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
					<span class="o">&gt;&gt;</span> <span class="n">EXT4_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">%</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_discard_partial_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
			<span class="n">mapping</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">page_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">!=</span> <span class="n">max_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">ext4_block_to_path</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">last_block</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>	<span class="cm">/* error */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK.  This truncate is going to happen.  We add the inode to the</span>
<span class="cm">	 * orphan list, so that if this truncate spans multiple transactions,</span>
<span class="cm">	 * and we crash, we will resume the truncate when the filesystem</span>
<span class="cm">	 * recovers.  It also marks the inode dirty, to catch the new size.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Implication: the file must always be in a sane, consistent</span>
<span class="cm">	 * truncatable state while each transaction commits.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * From here we block out all ext4_get_block() callers who want to</span>
<span class="cm">	 * modify the block allocation tree.</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>

	<span class="n">ext4_discard_preallocations</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The orphan list entry will now protect us from any crash which</span>
<span class="cm">	 * occurs before the truncate completes, so it is now safe to propagate</span>
<span class="cm">	 * the new, shorter inode size (held for now in i_size) into the</span>
<span class="cm">	 * on-disk inode. We do this via i_disksize, which is the value which</span>
<span class="cm">	 * ext4 *really* writes onto the disk inode.</span>
<span class="cm">	 */</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">==</span> <span class="n">max_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It is unnecessary to free any data blocks if last_block is</span>
<span class="cm">		 * equal to the indirect block limit.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* direct blocks */</span>
		<span class="n">ext4_free_data</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i_data</span><span class="o">+</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">i_data</span> <span class="o">+</span> <span class="n">EXT4_NDIR_BLOCKS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">do_indirects</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">partial</span> <span class="o">=</span> <span class="n">ext4_find_shared</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">);</span>
	<span class="cm">/* Kill the top of shared branch (not detached) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">partial</span> <span class="o">==</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Shared branch grows from the inode */</span>
			<span class="n">ext4_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">chain</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span><span class="p">);</span>
			<span class="o">*</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * We mark the inode dirty prior to restart,</span>
<span class="cm">			 * and prior to stop.  No need for it here.</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Shared branch grows from an indirect block */</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
			<span class="n">ext4_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span>
					<span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">,</span>
					<span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">chain</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Clear the ends of indirect blocks on the shared branch */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="o">+</span><span class="n">addr_per_block</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">chain</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call brelse&quot;</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">do_indirects:</span>
	<span class="cm">/* Kill the remaining (whole) subtrees */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">i_data</span><span class="p">[</span><span class="n">EXT4_IND_BLOCK</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">i_data</span><span class="p">[</span><span class="n">EXT4_IND_BLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">EXT4_IND_BLOCK</span>:
		<span class="n">nr</span> <span class="o">=</span> <span class="n">i_data</span><span class="p">[</span><span class="n">EXT4_DIND_BLOCK</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">i_data</span><span class="p">[</span><span class="n">EXT4_DIND_BLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">EXT4_DIND_BLOCK</span>:
		<span class="n">nr</span> <span class="o">=</span> <span class="n">i_data</span><span class="p">[</span><span class="n">EXT4_TIND_BLOCK</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="n">i_data</span><span class="p">[</span><span class="n">EXT4_TIND_BLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">EXT4_TIND_BLOCK</span>:
		<span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ext4_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In a multi-transaction truncate, we only make the final transaction</span>
<span class="cm">	 * synchronous</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ext4_handle_sync</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="nl">out_stop:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this was a simple ftruncate(), and the file will remain alive</span>
<span class="cm">	 * then we need to clear up the orphan record which we created above.</span>
<span class="cm">	 * However, if this was a real unlink then we were called by</span>
<span class="cm">	 * ext4_delete_inode(), and we allow that function to clean up the</span>
<span class="cm">	 * orphan info for us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">trace_ext4_truncate_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
